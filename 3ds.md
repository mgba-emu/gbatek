<a name="contents"></a><a name="gbatek"></a>
Gameboy Advance / Nintendo DS / DSi / 3DS - Technical Info - Extracted from no$gba version 3.04

[About this Document](#aboutthisdocument)


# CPU Reference


## General ARM7TDMI Information

- [ARM CPU Overview](#armcpuoverview)
- [ARM CPU Register Set](#armcpuregisterset)
- [ARM CPU Flags & Condition Field (cond)](#armcpuflagsconditionfieldcond)
- [ARM CPU 26bit Memory Interface](#armcpu26bitmemoryinterface)
- [ARM CPU Exceptions](#armcpuexceptions)
- [ARM CPU Memory Alignments](#armcpumemoryalignments)

## Further Information

- [ARM Pseudo Instructions and Directives](#armpseudoinstructionsanddirectives)
- [ARM CP15 System Control Coprocessor](#armcp15systemcontrolcoprocessor)
- [ARM CPU Instruction Cycle Times](#armcpuinstructioncycletimes)
- [ARM CPU Versions](#armcpuversions)
- [ARM CPU Data Sheet](#armcpudatasheet)

# CPU 32bit ARM Mode


## ARM 32bit Opcodes (ARM Code)

- [ARM Instruction Summary](#arminstructionsummary)
- [ARM Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)](#armopcodesbranchandbranchwithlinkbblbxblxswibkpt)
- [ARM Data Processing (ALU)](#armopcodesdataprocessingalu)
- [ARM Multiply and Multiply-Accumulate (MUL, MLA)](#armopcodesmultiplyandmultiplyaccumulatemulmla)
- [ARM Special ARM9 Instructions (CLZ, QADD/QSUB)](#armopcodesspecialarm9instructionsclzqaddqsub)
- [ARM PSR Transfer (MRS, MSR)](#armopcodespsrtransfermrsmsr)
- [ARM Memory: Single Data Transfer (LDR, STR, PLD)](#armopcodesmemorysingledatatransferldrstrpld)
- [ARM Memory: Halfword, Doubleword, and Signed Data Transfer](#armopcodesmemoryhalfworddoublewordandsigneddatatransfer)
- [ARM Memory: Block Data Transfer (LDM, STM)](#armopcodesmemoryblockdatatransferldmstm)
- [ARM Memory: Single Data Swap (SWP)](#armopcodesmemorysingledataswapswp)
- [ARM Coprocessor (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)](#armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc)

# CPU 16bit THUMB Mode


## ARM 16bit Opcodes (THUMB Code)

- When operating in THUMB state, cut-down 16bit opcodes are used.
- THUMB is supported on T-variants of ARMv4 and up, ie. ARMv4T, ARMv5T, etc.
- [THUMB Instruction Summary](#thumbinstructionsummary)
- [THUMB Register Operations (ALU, BX)](#thumbopcodesregisteroperationsalubx)
- [THUMB Memory Load/Store (LDR/STR)](#thumbopcodesmemoryloadstoreldrstr)
- [THUMB Memory Addressing (ADD PC/SP)](#thumbopcodesmemoryaddressingaddpcsp)
- [THUMB Memory Multiple Load/Store (PUSH/POP and LDM/STM)](#thumbopcodesmemorymultipleloadstorepushpopandldmstm)
- [THUMB Jumps and Calls](#thumbopcodesjumpsandcalls)


# <a name="3dsreference"></a>3DS Reference




## 3DS Summary


- [3DS Memory and I/O Map](#3dsmemoryandiomap)


## 3DS Hardware Registers


- [3DS MISC Registers](#3dsmiscregisters)
- [3DS GPIO Registers](#3dsgpioregisters)
- [3DS Crypto Registers](#3dscryptoregisters)
- [3DS DMA Registers](#3dsdmaregisters)
- [3DS Config Registers](#3dsconfigregisters)
- [3DS SPI and I2C Bus](#3dsspiandi2cbus)
- [3DS Video](#3dsvideo)
- [3DS Sound and Microphone](#3dssoundandmicrophone)
- [3DS Cartridge Registers](#3dscartridgeregisters)
- [3DS Interrupts and Timers](#3dsinterruptsandtimers)
- [ARM Vector Floating-point Unit (VFP)](#armvectorfloatingpointunitvfp)


## 3DS File Formats


- [3DS Files - eMMC Partitions](#3dsfilesemmcpartitions)
- [3DS Files - NCSD Format](#3dsfilesncsdformat)
- [3DS Files - FIRM Format](#3dsfilesfirmformat)
- [3DS Files - FIRM Encryption](#3dsfilesfirmencryption)
- [3DS Files - FIRM Versions](#3dsfilesfirmversions)
- [3DS Files - FIRM Launch Parameters](#3dsfilesfirmlaunchparameters)
- [3DS Files - NCCH Format](#3dsfilesncchformat)
- [3DS Files - NCCH Extended Header](#3dsfilesncchextendedheader)
- [3DS Files - NCCH ExeFS](#3dsfilesncchexefs)
- [3DS Files - NCCH RomFS](#3dsfilesncchromfs)
- [3DS Files - NCCH Encryption](#3dsfilesncchencryption)
- [3DS Files - Title Content Metadata (CMD)](#3dsfilestitlecontentmetadatacmd)
- [3DS Files - Title Metadata (TMD)](#3dsfilestitlemetadatatmd)
- [3DS Files - Title Ticket (ticket.db)](#3dsfilestitleticketticketdb)
- [3DS Files - Title Certificates (certs.db)](#3dsfilestitlecertificatescertsdb)
- [3DS Files - Title Database Files (title.db, import.db, etc.)](#3dsfilestitledatabasefilestitledbimportdbetc)
- [3DS Files - Title Installation Archive (CIA)](#3dsfilestitleinstallationarchivecia)
- [3DS Files - Title Homebrew Executables (3DSX)](#3dsfilestitlehomebrewexecutables3dsx)
- [3DS Files - Client Cert/Key (ClCertA)](#3dsfilesclientcertkeyclcerta)
- [3DS Files - CTCert](#3dsfilesctcert)
- [3DS Files - Dictionary (NJDC)](#3dsfilesdictionarynjdc)
- [3DS Files - Guide (GBIN)](#3dsfilesguidegbin)
- [3DS Files - Version (CVer and NVer)](#3dsfilesversioncverandnver)
- [3DS Files - CRR0 and CRO0 Files](#3dsfilescrr0andcro0files)
- [3DS Files - Archive DARC](#3dsfilesarchivedarc)
- [3DS Files - Archive SARC](#3dsfilesarchivesarc)
- [3DS Files - Archive arcless](#3dsfilesarchivearcless)
- [3DS Files - Archive ZAR](#3dsfilesarchivezar)
- [3DS Files - CCAL Format (Hardware calibration, HWCAL)](#3dsfilesccalformathardwarecalibrationhwcal)
- [3DS Files - Config Savegame](#3dsfilesconfigsavegame)
- [3DS Files - Title IDs](#3dsfilestitleids)
- [3DS Files - Title NS](#3dsfilestitlens)
- [3DS Files - Savedata Extdata](#3dsfilessavedataextdata)
- [3DS Files - Savedata SAVE/BDRI/VSXE Formats](#3dsfilessavedatasavebdrivsxeformats)
- [3DS Files - Savedata DISA and DIFF](#3dsfilessavedatadisaanddiff)
- [3DS Files - Savedata DISA and DIFF - Data Pairs](#3dsfilessavedatadisaanddiffdatapairs)
- [3DS Files - Savedata DISA and DIFF - Checksums](#3dsfilessavedatadisaanddiffchecksums)
- [3DS Files - Savedata Gamecard FLASH Encryption and Wear Leveling](#3dsfilessavedatagamecardflashencryptionandwearleveling)
- [3DS Files - Messages (MsgStdBn)](#3dsfilesmessagesmsgstdbn)
- [3DS Files - Video Icons (SMDH)](#3dsfilesvideoiconssmdh)
- [3DS Files - Video Banner (CBMD)](#3dsfilesvideobannercbmd)
- [3DS Files - Video Banner (Extended Banner)](#3dsfilesvideobannerextendedbanner)
- [3DS Files - Video Layout (CLYT/FLYT)](#3dsfilesvideolayoutclytflyt)
- [3DS Files - Video Layout Animation (CLAN/FLAN)](#3dsfilesvideolayoutanimationclanflan)
- [3DS Files - Video Layout Images (CLIM/FLIM)](#3dsfilesvideolayoutimagesclimflim)
- [3DS Files - Video Archive (CGFX)](#3dsfilesvideoarchivecgfx)
- [3DS Files - Video Shaders (DVLB and DVOB Format)](#3dsfilesvideoshadersdvlbanddvobformat)
- [3DS Files - Video Fonts (CFNT and FFNT Format)](#3dsfilesvideofontscfntandffntformat)
- [3DS Files - Video Texture Package (CTPK)](#3dsfilesvideotexturepackagectpk)
- [3DS Files - Video Bitmap (BMP)](#3dsfilesvideobitmapbmp)
- [3DS Files - Sound Archive (CSAR Format)](#3dsfilessoundarchivecsarformat)
- [3DS Files - Sound SEQ (CSEQ Format)](#3dsfilessoundseqcseqformat)
- [3DS Files - Sound WSD (CWSD Format)](#3dsfilessoundwsdcwsdformat)
- [3DS Files - Sound Bank (CBNK Format)](#3dsfilessoundbankcbnkformat)
- [3DS Files - Sound Wave Archive (CWAR Format)](#3dsfilessoundwavearchivecwarformat)
- [3DS Files - Sound Wave Data (CWAV Format)](#3dsfilessoundwavedatacwavformat)
- [3DS Files - Sound Wave Streams (CSTM Format)](#3dsfilessoundwavestreamscstmformat)
- [3DS Files - Sound Group (CGRP Format)](#3dsfilessoundgroupcgrpformat)
- [3DS Files - Sound IDs (CSID Format)](#3dsfilessoundidscsidformat)
- [3DS Files - Sound DSP Binary (DSP1 aka .cdc)](#3dsfilessounddspbinarydsp1akacdc)
- [3DS Files - BASE64 Encoding](#3dsfilesbase64encoding)
- [3DS Files - Video 3D Photos (MPO)](#3dsfilesvideo3dphotosmpo)
- [3DS Files - Module NWM (Wifi Driver)](#3dsfilesmodulenwmwifidriver)
- [3DS Console IDs](#3dsconsoleids)


## Misc


- [3DS eMMC and MCU Images](#3dsemmcandmcuimages)
- [3DS Component Lists](#3dscomponentlists)
- [3DS Chipset Pinouts](#3dschipsetpinouts)


## Operating System


- [http://forums.nesdev.com/viewtopic.php?f=23&t=18490&p=242531#p242456](http://forums.nesdev.com/viewtopic.php?f=23&t=18490&p=242531#p242456)
- [http://www.3dbrew.org/wiki/Services](http://www.3dbrew.org/wiki/Services)
- [http://www.3dbrew.org/wiki/Services\_API](http://www.3dbrew.org/wiki/Services_API)


## 3DS Reverse Engineering


- [http://forums.nesdev.com/viewtopic.php?f=23&t=18490](http://forums.nesdev.com/viewtopic.php?f=23&t=18490)


## Credits


- [http://www.3dbrew.org/wiki/IO\_Registers](http://www.3dbrew.org/wiki/IO_Registers)



# <a name="3dsmemoryandiomap"></a>3DS Memory and I/O Map




## ARM11 Memory Map


```
  Old3DS Address   Size          Description
  Yes   00000000h  10000h        ARM11 Bootrom mirror  ;also ITCM in ARM11 ?
  Yes   00010000h  10000h    64K ARM11 Bootrom
  Yes   10000000h  ?             IO "memory"
  Yes   17E00000h  2000h      8K MPCore private memory region (aka... IRQ ???)
  No    17E10000h  1000h      4K New3DS: L2C-310 Level 2 Cache Controller (2MB)
  Yes   18000000h  600000h  6M   VRAM (two 3Mbyte banks, VRAM_A and VRAM_B)
  No    1F000000h  400000h  4M   New3DS: extra memory (maybe VRAM and/or QTM?)
  Yes   1FF00000h  40000h   256K Teak DSP Code memory (aka Shared WRAM)
  Yes   1FF40000h  40000h   256K Teak DSP Data memory (aka Shared WRAM)
  Yes   1FF80000h  80000h   512K AXI WRAM
  Yes   20000000h  8000000h 128M FCRAM
  No    28000000h  8000000h 128M New3DS: FCRAM extension
  Yes   FFFF0000h  10000h        ARM11 Bootrom mirror
```

Note: ARM11 MMU supports virtual memory addresses (so above physical addresses
may appear elsewhere in virtual memory).



## ARM9 Memory Map


```
  Old3DS Address   Size          Description
  Yes   00000000h  "8000000h"    Instruction TCM, mirrored each 8000h bytes
  Yes   01FF8000h  8000h     32K Instruction TCM (used here by kernel & titles)
  Yes   07FF8000h  8000h         Instruction TCM (used here by bootrom)
  Yes   08000000h  100000h   1M  ARM9-only internal memory (and ARM7 regions)
  No    08100000h  80000h   512K New3DS:ARM9-only extension (if any/if enabled)
  Yes   10000000h  8000000h      IO "memory"
  Yes   18000000h  600000h   6M  VRAM (two 3Mbyte banks, VRAM_A and VRAM_B)
  Yes   1FF00000h  40000h   256K Teak DSP Code memory (aka Shared WRAM)
  Yes   1FF40000h  40000h   256K Teak DSP Data memory (aka Shared WRAM)
  Yes   1FF80000h  80000h   512K AXI WRAM
  Yes   20000000h  8000000h 128M FCRAM
  No    28000000h  8000000h 128M New3DS: FCRAM extension
  Yes   FFF00000h  4000h     16K Data TCM (mapped here during bootrom)
  Yes   FFFF0000h  10000h    64K ARM9 Bootrom
```


```
 __________________________________ I/O Maps __________________________________
```



## ARM9-only Registers


```
  Physaddr   Old3DS  A9/A11  Category
  10000000h  Yes     A9      CONFIG9 Registers
  10001000h  Yes     A9      IRQ Registers
  10002000h  Yes     A9      NDMA Registers     DMA (alike DSi's NDMA)
  10003000h  Yes     A9      TIMER Registers    Timers (alike GBA/NDS/DSi)
  10004000h  Yes     A9      CTRCARD Registers  ROM cart in 3DS mode
  10005000h          A9      CTRCARD?           2nd ROM cart slot?
  10006000h  Yes     A9      SDMMC Registers    For eMMC and SD Card slot
  10007000h          A9      SDxx?              ?
  10008000h  Yes     A9      PXI Registers      aka IPC
  10009000h  Yes     A9      AES Registers      Crypto
  1000A000h  Yes     A9      SHA Registers      Crypto
  1000B000h  Yes     A9      RSA Registers      Crypto
  1000C000h  Yes     A9      XDMA Registers     DMA
  1000D000h  Yes     A9      SPI_CARD Registers Savedata in ROM carts
  10010000h  Yes     A9      CONFIG Registers   More CONFIG9 registers
  10011000h  Yes     A9      PRNG Registers     Pseudo Random Generator
  10012000h  Yes     A9      OTP Registers      Console IDs
  10018000h  Yes     A9      ARM7 Registers     GBA/NDS/DSi mode config
```



## ARM11/ARM9 Registers


Below registers can be accessed by both ARM11 and ARM9. However, most of them
are working best on ARM11 side (because IRQ and DMA startup modes are
implemented on ARM11 side only; and, in some cases, even FIFOs are in a
separate ARM11-only area at 10300000h and up).

One exception is NTRCARD (this does have IRQ/DMA on both ARM9 and ARM11 side).

```
  10100000h  Yes     A11/A9  Debug WIFI SDIO Regs?  ;uh, actually zerofilled
  10101000h  Yes     A11/A9  HASH Registers     Crypto (same as SHA)
  10102000h  Yes     A11/A9  Y2R_0 Registers    First YUV-to-RGBA
  10103000h  Yes     A11/A9  CSND Registers     Sound channels and capture
  10110000h  Yes     A11/A9  LGYFB_0            Legacy GBA/NDS Video
  10111000h  Yes     A11/A9  LGYFB_1            Legacy GBA/NDS Video
  10120000h  Yes     A11/A9  Camera Registers   Camera Bus 0 (DSi cameras)
  10121000h  Yes     A11/A9  Camera Registers   Camera Bus 1 (left-eye)
  10122000h  Yes     A11/A9  WIFI Registers     SDIO Wifi
  10123000h  Yes     A11/A9  ?                  SDIO?   ;uh, actually data.abt
  10130000h  No      A11/A9  L2B_0              New3DS: First RGB-to-RGBA
  10131000h  No      A11/A9  L2B_1              New3DS: Second RGB-to-RGBA
  10132000h  No      A11/A9  Y2R_1              New3DS: Second YUV-to-RGBA
  10140000h  Yes     A11/A9  CONFIG11 Registers
  10141000h  Yes     A11/A9  CONFIG11 Registers
  10142000h  Yes     A11/A9  SPI Registers      SPI Bus1 (Tsc)
  10143000h  Yes     A11/A9  SPI Registers      SPI Bus2 (unused)
  10144000h  Yes     A11/A9  I2C Registers      I2C Bus1 (for 3DS devices)
  10145000h  Yes     A11/A9  CODEC Registers    ?
  10146000h  Yes     A11/A9  HID Registers      Keypad
  10147000h  Yes     A11/A9  GPIO Registers
  10148000h  Yes     A11/A9  I2C Registers      I2C Bus2 (for 3DS gimmicks)
  10160000h  Yes     A11/A9  SPI Registers      SPI Bus0 (Pwrman,WifiFlash,Tsc)
  10161000h  Yes     A11/A9  I2C Registers      I2C Bus0 (for DSi devices)
  10162000h  Yes     A11/A9  MIC Registers      Microphone
  10163000h  Yes     A11/A9  PXI Registers      aka IPC
  10164000h  Yes     A9/A11  NTRCARD Registers  ROM Cart in NDS/DSi mode
  10165000h  Yes     A11/A9  MP Registers       NDS-Wifi WIFIWAITCNT(10165206h)
  10170000h  Yes     A11/A9  MP Registers       NDS-Wifi WS0 Area (8000h bytes)
  10178000h  Yes     A11/A9  MP Registers       NDS-Wifi WS1 Area (8000h bytes)
  10180000h                                     (end of above area)
```



## ARM11-only Registers


```
  10200000h  Yes     A11     CDMA               DMA
  10201000h  Yes     A11     FCRAM Registers    FCRAM Control
  10202000h  Yes     A11     LCD Registers      LCD
  10203000h  Yes     A11     DSP Registers      Teak DSP (if enabled)
  10204000h  Yes     A11     UNKNOWN            ?
  10205000h  ?       -       N/A ?              ?
  10206000h  No      A11     CDMA               New3DS: DMA
  10207000h  No      A11     MVD Registers      New3DS: Movie Decoder or so?
  1020F000h  Yes     A11     AXI                ?
  10300000h  Yes     A11     FIFO? debug?  Maybe debug wifi FIFOs or so?
  10301000h  Yes     A11     FIFO HASH (SHA)          contains FIFO
  10302000h  Yes     A11     FIFO Y2R_0
  10310000h  Yes     A11     FIFO LGYFB_0
  10311000h  Yes     A11     FIFO LGYFB_1
  10320000h  Yes     A11     FIFO Camera Bus 0 (20h-word window FIFO)
  10321000h  Yes     A11     FIFO Camera Bus 1 (20h-word window FIFO)
  10322000h  Yes     A11     FIFO? wifi??  Maybe contains DATA32 FIFOs or so?
  10323000h  ?       ?       data abort (maybe SDIO FIFO for 10123000h, if any)
  10330000h  No      A11     FIFO L2B_0     New3DS: L2B_0 FIFO (empty=data_abt)
  10331000h  No      A11     FIFO L2B_1     New3DS: L2B_1 FIFO (empty=data_abt)
  10332000h  No      A11     FIFO MVD Y2R_1 New3DS: MVD Y2R FIFO
  10400000h  Yes     A11     GPU External Registers
  10401000h  Yes     A11     GPU Internal Registers
  17E00000h 100h     A11     MPCore SCU (Snoop Control Unit)
  17E00100h 100h     A11     MPCore CPU Interrupt Interface
  17E00200h 100h     A11     MPCore CPU0 Interrupt Interface ;\
  17E00300h 100h     A11     MPCore CPU1 Interrupt Interface ; (aliased for
  17E00400h 100h     A11     MPCore CPU2 Interrupt Interface ; debug purposes)
  17E00500h 100h     A11     MPCore CPU3 Interrupt Interface ;/
  17E00600h 100h     A11     MPCore CPU Timer and Watchdog
  17E00700h 100h     A11     MPCore CPU0 Timer and Watchdog  ;\
  17E00800h 100h     A11     MPCore CPU1 Timer and Watchdog  ; (aliased, too?)
  17E00900h 100h     A11     MPCore CPU2 Timer and Watchdog  ;  <-- N/A in 3DS?
  17E00A00h 100h     A11     MPCore CPU3 Timer and Watchdog  ;/ <-- N/A in 3DS?
  17E00B00h 500h     A11     MPCore Reserved (access causes a DECERR abort)
  17E01000h 1000h    A11     MPCore Global Interrupt Distributor
  17E10000h  No      A11     New3DS: L2C-310 Level 2 Cache Controller
```

IO registers starting at physical address 10200000h are not accessible from the
ARM9 (which includes all LCD/GPU registers). It seems IO registers below
physical address 10100000h are not accessible from the ARM11 bus (=trigger data
abort, as so on all unused 1000h-byte areas).


ARM11 kernel virtual address mappings for these registers varies for different
builds. For ARM11 user mode applications you have:

```
  physaddr = virtaddr-1EC00000h+10100000h
```

That is:

```
  Physical   Virtual
  101xxxxxh  1ECxxxxxh
  102xxxxxh  1EDxxxxxh
```




# <a name="3dsmiscregisters"></a>3DS MISC Registers



```
 _____________________________ UNKNOWN Registers  _____________________________
```



## Unknown Registers at 10204000h (ARM11 only)


```
  10204000h 4    Unknown R/W=000000F1h (res=00000000h)
  10204004h 4    Unknown, readonly (00000001h) (R)
  10204008h 08h  Unused (0) ?
  10204010h 4    Unknown, readonly (00000202h) (R)
  10204014h 4    Unknown, readonly (12000802h) (R) (or data abort!)
  10204018h 08h  Unused (0) ?
  10204020h 4    Unknown, readonly (00000020h) (R) ;or res=00000000h?
  10204024h FDCh Unused (0) ?
```


```
 ______________________________ FCRAM Registers  ______________________________
```



## FCRAM Control Registers (ARM11 only)


```
  10201000h 4    FCRAM_MODE (R/W)
  10201004h 0Ch  Unused (0)
  10201010h 4    FCRAM_DELAY (R/W)
  10201014h 0Ch  Unused (0)
  10201020h 4    FCRAM_OR_WHATEVER (R/W)
  10201024h FDCh Unused (0)
```



## 10201000h - FCRAM\_MODE (R/W)


```
  0     FCRAM Mode (burst enable or so)  (0=GBA, 1=3DS/Fast)              (R/W)
  1-4   Unknown... (00h..0Fh, usually 0)                                  (R/W)
  5-31  Unused (0)
```

Bit0 must be cleared in GBA mode (where FCRAM is used to emulate the GBA
cartridge ROM), when not clearing bit0, only about 1% of GBA ROM reads will
correctly read from "addr", and the other 99% will accidentally read from
"addr+20h" (wrapped within 800h-byte pages).

Changes to this register have no effect until applying them via
CFG11\_FCRAM\_CNT.



## 10201010h - FCRAM\_DELAY (R/W)


```
  0-1   Unknown...  (0..3, usually 0)                                     (R/W)
  2-15  Unused (0)
  16-18 FCRAM Delay (0..7 = Fast..Slow, usually 2)                        (R/W)
  19-31 Unused (0)
```

Changes to this register have no effect until applying them via
CFG11\_FCRAM\_CNT.



## 10201020h - FCRAM\_OR\_WHATEVER (R/W)


```
  0-3   Unknown... (00h..0Fh, usually 8)                                  (R/W)
  4-7   Unused (0)
  8-11  Unknown... (00h..0Fh, usually 8)                                  (R/W)
  12-30 Unused (0)
  31    Unknown... (0..1, usually 0)                                      (R/W)
```

Changes to this register have no effect until applying them via CFG11\_FCRAM\_CNT
(probably so... assuming that it works similar as the registers above, and that
changes do have some yet unknown effect at all).



## Internal FCRAM Configuration Registers


The 3DS uses the following FCRAM chips:

```
  Old3DS: Fujitsu MB82M8080-07L (128Mbyte)
  New3DS: Fujitsu 82MK9A9A, 7L (256Mbyte)
```

The chip in Old3DS does reportedly internally contain 2 dies:

```
  MB81EDS516545 (4x2Mx64bit, aka 64Mbyte)
  MB82DBS08645 (unknown, supposedly contains the missing 64Mbyte)
```

The MB81EDS516545 datasheet says that there are some internal config registers,
which must be initialized after power up, the initialization requires changing
/RAS and /CAS and some other pins. Unknown if/how the 3DS hardware or software
can/may/must initialize those registers.


```
 ______________________________ SD/MMC Registers ______________________________
```



## SD/MMC Registers


```
  10006000h A9      SD/MMC (for SD/MMC Slot and internal eMMC)
  10006200h A9      mirrors of above (each 200h bytes)
  10007000h A9      SDxx (unused? or maybe SDIO wifi on ARM9 side?)
  10007200h A9      mirrors of above (each 200h bytes)
  10100000h A11/A9  Debug SDIO Regs? (actually just zerofilled?)
  10122000h A11/A9  SDIO WIFI? this is wifi?
  10123000h A11/A9  Reportedly SDIO? (actually just data abort?)
```

These registers are used to access the system NAND and the inserted SD card.
Both devices use the same interface.

HCLK of the SDMMC controller is 67.027964 MHz (double of the DSi HCLK).

Unknown if eMMC and Wifi are fast enough to support HCLK/2 on 3DS.

Standard SD cards may require HCLK/4 on 3DS (unless the card was detected to
support HCLK/2; don't know if it requires further card initialization to enable
fast mode?).

- [DSi SD/MMC Protocol and I/O Ports](ds.html#dsisdmmcprotocolandioports)
- [DSi SD/MMC Filesystem](ds.html#dsisdmmcfilesystem)
- [DSi Atheros Wifi SDIO Interface](ds.html#dsiatheroswifisdiointerface)
- [DSi Atheros Wifi Internal Hardware](ds.html#dsiatheroswifiinternalhardware)


## IRQ\_STAT


```
  3     SD card removal flag     (Set to 1 when SD card is removed)
  4     SD card insertion flag   (Set to 1 when SD card is inserted)
  5     SD card insertion status (0=Missing, 1=Inserted)
```

SD card insertion status

Assertion happens around 250 ms after SD card insertion and/or enabling the
EMMC hardware (delay could possibly be due to an SD bus timeout?).



## Wifi Registers


These registers are used to control the Wifi card via the SDIO protocol.

```
  Address  Width  Name
  10122000h 2  WIFI_CMD
  10006002h 2  uh, at 10006002h?
  10122004h 2  WIFI_CMDARG0
  10122006h 2  WIFI_CMDARG1
  1012200ah 2  WIFI_BLKCOUNT
  10122024h 2  WIFI_CLKCTL
  10122026h 2  WIFI_BLKLEN
```

XXX DATA32 FIFO might be at 10322000h (instead of 1012210Ch)... ?


```
 _______________________________ IPC Registers ________________________________
```



## PXI Registers


```
  Address Width Old3DS Name         Used by
  10008000h 4   Yes   PXI_SYNC9     Boot9, Process9     ;-SYNC
  10008004h 2   Yes   PXI_CNT9      Boot9, Process9     ;\
  10008008h 4   Yes   PXI_SEND9                         ; FIFO
  1000800Ch 4   Yes   PXI_RECV9                         ;/
  10163000h 4   Yes   PXI_SYNC11    Boot11              ;-SYNC
  10163004h 2   Yes   PXI_CNT11     Boot11              ;\
  10163008h 4   Yes   PXI_SEND11                        ; FIFO
  1016300Ch 4   Yes   PXI_RECV11                        ;/
```

The PXI registers are similar to those on DS. Uh, aka what is known as IPC.

But, except, SYNC is 8bit (instead 4bit)!

The FIFO registers seem to be exactly same as on NDS.



## 10008000h - ARM9 - PXI\_SYNC9



## 10163000h - ARM11 - PXI\_SYNC11


```
  0-7   R    Data received from remote SYNC bit8-15
  8-15  W    Data sent to remote SYNC bit0-7 (CAUTION: write-only, unlike NDS!)
  16-22 -    Unused (0)
  23    -    Unused (0)   ;<-- reportedly "?" whatever that means, if anything?
  24-28 -    Unused (0)
  29    -    PXI_SYNC11: Unused (0)
  30    W    PXI_SYNC11: Send IRQ to ARM9 IF.bit12 (0=No change, 1=Yes)
  29    W    PXI_SYNC9: Send IRQ to ARM11 IRQ 50h  (0=No change, 1=Yes)
  30    W    PXI_SYNC9: Send IRQ to ARM11 IRQ 51h  (0=No change, 1=Yes)
  31    R/W  Enable IRQ from remote CPU            (0=Disable, 1=Enable)
```

Caution: The send-value (in bit8-15) is write-only on 3DS (reads as zero), this
is different as on NDS/DSi. As workaround: Use 8bit LDRB/STRB instead of 32bit
LDR/STR when changing the IRQ bits.



## 10008004h - ARM9 - PXI\_CNT



## 10163004h - ARM11 - PXI\_CNT


```
  0     R    Send Fifo Empty Status      (0=Not Empty, 1=Empty)
  1     R    Send Fifo Full Status       (0=Not Full, 1=Full)
  2     R/W  Send Fifo Empty IRQ         (0=Disable, 1=Enable)
  3     W    Send Fifo Clear             (0=Nothing, 1=Flush Send Fifo)
  4-7        unknown/unspecified
  8     R    Receive Fifo Empty          (0=Not Empty, 1=Empty)
  9     R    Receive Fifo Full           (0=Not Full, 1=Full)
  10    R/W  Receive Fifo Not Empty IRQ  (0=Disable, 1=Enable)
  11-13      unknown/unspecified
  14    R/W  Error, Read Empty/Send Full (0=No Error, 1=Error/Acknowledge)
  15    R/W  Enable Send/Receive Fifo    (0=Disable, 1=Enable)
```



## 10008008h - ARM9 - PXI\_SEND



## 10163008h - ARM11 - PXI\_SEND



## 1000800Ch - ARM9 - PXI\_RECV



## 1016300Ch - ARM11 - PXI\_RECV


FIFO

- [DS Inter Process Communication (IPC)](ds.html#dsinterprocesscommunicationipc)


## ARM11-to-ARM11 Messages


ARM11 cores can use the Software Interrupt Register, Port 17E01F00h (and data
in AXI memory or other RAM locations) to communicate with each other.


```
 ________________________________ HID Registers _______________________________
```



## HID Registers (aka Keypad)


```
  10146000h 2  HID_PAD
  10146002h 2  HID_PAD_IRQ
```



## 10146000h - HID\_PAD (R)


Same as NDS/DSi, but with X/Y buttons included right in this register.

```
  0     Button A        (0=Pressed, 1=Released)
  1     Button B
  2     Select
  3     Start
  4     DPAD Right
  5     DPAD Left
  6     DPAD Up
  7     DPAD Down
  8     Button R
  9     Button L
  10    Button X
  11    Button Y
  12-15 Unused (0)
```



## 10146002h - HID\_PAD\_IRQ (R/W)


```
  0-11  IRQ Buttons     (0=Ignore, 1=Select)
  12-13 Unused (0)
  14    IRQ Enable Flag (0=Disable, 1=Enable, Interrupt 5Bh)
  15    IRQ Condition   (0=Logical OR, 1=Logical AND)
```

Similar as Port 4000132h on GBA/NDS, used as wake-up source in sleep mode.



## Other Inputs


```
  Circle Pad: Connected to Touchscreen/Sound controller
  Power/Home buttons: see I2C MCU
  Wifi button: see I2C MCU (older 3DS only?)
  Volume/3D Sliders: see I2C MCU
  Accelerometer: see I2C MCU (also includes pedometer step counter)
  Gyroscope: see I2C Gyroscope
  Hinge/Shell: see GPIO (and/or reportedly also I2C MCU)
  DebugPad: See I2C (whatever that is)
  MIC, Cameras, IR, QTM, Charge, SD slot, ROM slot
  Old3DS: NFC reader/writer (external adaptor, instead of New3DS built-in)
  Old3DS: Circle Pad Pro (2nd Circle Pad and R/ZL/ZR buttons, on IR port)
  New3DS: C-stick and ZL/ZR: see I2C (instead of Old3DS's circle pad pro)
  New3DS: NFC built-in (instead of Old3DS's external adaptor)
  New3DS: Head-tracking (whatever that is, probably just camera with IR-LED..?)
  New3DS: Invisible camera IR-LED (unknown how to control/test that)
```


```
 ________________________________ MP? Registers _______________________________
```



## MP Registers (local wifi multiplayer?)


```
  10165206h 2      NDS-Wifi WIFIWAITCNT
  10170000h 8000h  NDS-Wifi WS0 region
  10178000h 8000h  NDS-Wifi WS1 region
```

These registers are used by MP-module. MP-module seems to be used for
3DS\<>DSi local-WLAN communications?


```
 ______________________________ PARODY Registers ______________________________
```



## Parody Register summary


After reading through many official datasheets and homebrew wiki pages, some of
the more amazing 3DS hardware related information goes into 1020B000h...

```
  1020B000h 4   Certain Register
  1020B014h 4   Assert Register
  1020B034h 4   This Register
  1020B096h 2   Figure Register
  1020B1BFh 1   Byte Register
  1020B2E4h ??  Broken Register
  1020B3D0h 4   Snakish Register
```



## 1020B000h - Certain Register


This is the Certain register. The register contains certain bits that are used
to enable certain functions, each bit must be set to a certain value. The
entire system will hang if used with a certain setting.



## 1020B014h - Assert Register


Bits in the Assert register get asserted when asserting events are asserted and
de-asserted. You are asserted to assert what the asserted information does
assert. Assert your dictionary if you can't assert that.



## 1020B034h - This Register


This register can be used to change the value of this register by writing to
this register.



## 1020B096h - Figure Register


Figure 128 contains information about the Figure register. These register
specifications are outlined in Figure 128. See Figure 128 for details about the
Figure Register in Figure 128.

Figure 128: Figure 128 is left blank intentionally.


1020B0DCh - ?



## 1020B1BFh - Byte Register


8-bit Byte value 0,1: 1-ish enable 2:31 must be \<this&0x3\<=2'b010 +!
Pdn SoC value>.



## 1020B2E4h - Broken Register


This works exactly as described in the broken link on the hardware page.



## 1020B3D0h - Snakish Register


With Native\_firm as of 8.1.0.192 three additional unsigned flags have been
introduced to the old(6.5.0.0+) specification which did have specific bits at a
certain virtual address and that were not formerly asserted in 1.0.2.30 with
\*ANY\* firm these values must be accumulated with strict binary point
comparisions(in the same format as the other bits) prohibitvely permitting
abstractions of the reorganized architecture in the \*actual\* snakish sentences
used to describe the entire register space(that CAN be changed in future).




# <a name="3dsgpioregisters"></a>3DS GPIO Registers



```
 _______________________________ GPIO Registers _______________________________
```



## GPIO Registers


```
  Address  Width Name
  10147000h 2   GPIO_DATA0
  10147010h 4x1 GPIO_DATA1
  10147014h 2   GPIO_DATA2
  10147020h 4x2 GPIO_DATA3
  10147028h 2   GPIO_DATA4_WIFI
  10147100h ..  Legacy RTC ?
```



## 10147000h - GPIO\_DATA0\_DATA\_IN (R?)


```
  0      Unknown (0=?, 1=Normal) HID-sysmodule, HID PAD state  ;\GPIO services
  1      Touchscreen (0=Pen Down, 1=No)        (IRQ:63h)       ; bitmask 7h
  2      Hinge (0=Shell Open, 1=Shell Closed)  (IRQ:60h/62h?)  ;/
  3      Unused (0)?
  4      Unused (0)?  ;"Only used by Boot11" (uh, but bootrom tests only bit2)
  5-15   Unused (0)?
```



## 10147010h - GPIO\_DATA1\_DATA\_IN (R)



## 10147010h - GPIO\_DATA1\_DATA\_OUT (W)



## 10147011h - GPIO\_DATA1\_DIRECTION (R/W)



## 10147012h - GPIO\_DATA1\_IRQ\_EDGE (R/W)    ?



## 10147013h - GPIO\_DATA1\_IRQ\_ENABLE (R/W)


```
  0      Headphone (0=None, 1=Connected) gpio:CDC (IRQ:64h) ;\GPIO services
  1      Unknown   (0=?, 1=Normal)                (IRQ:66h) ;/bitmask 18h
  2-7    Unused (0)
```



## 10147014h - GPIO\_DATA2\_DATA\_OUT (R/W)


```
  0      gpio:MCU, gpio:NWM: Wifi?     ;-GPIO services bitmask 20h
  1-15   Unused (0)
```



## 10147020h - GPIO\_DATA3\_DATA\_IN (0=Low, 1=High) (R)



## 10147020h - GPIO\_DATA3\_DATA\_OUT (0=Low, 1=High) (W)



## 10147022h - GPIO\_DATA3\_DIRECTION (0=Normal/Input, 1=Output) (R/W)



## 10147024h - GPIO\_DATA3\_IRQ\_EDGE (0=Falling, 1=Rising) (R/W)    ?



## 10147026h - GPIO\_DATA3\_IRQ\_ENABLE (0=Disable, 1=Enable) (R/W)


Most of these might be IRQ signals from I2C peripherals?

Stuff like QTM, NFC, ir:rst is New3DS only, so Old3DS is probably different
here?

```
  0      C-stick! gpio:CDC, gpio:IR <-- 1 after ir:rst read(IRQ:68h?);\
  1      IrDA IRQ gpio:IR   (0=IRQ)   Boot11(uh, really?)  (IRQ:69h) ;
  2      Gyro IRQ gpio:HID  (1=IRQ, in default cfg)        (IRQ:6Ah?); GPIO
  3      ?        gpio:HID, gpio:IR   used with ir:rst.    (IRQ:6Bh) ; services
  4      ?        gpio:IR send? 1=IR LED enable, 0=disable (IRQ:6Ch) ; bitmask
  5      ?        gpio:IR receive?                         (IRQ:6Dh) ; 3FFC0h
  6      ?        gpio:NFC                                 (IRQ:6Eh) ;
  7      ?        gpio:NFC                                 (IRQ:6Fh) ;
  8      TSC?     gpio:HID  HID-sysmodule, HID PAD state   (IRQ:70h?);
  9      MCU IRQ  gpio:MCU  MCU[10h-1Fh]                   (IRQ:71h) ;
  10     NFC?     gpio:NFC  <-- cleared after NFC read     (IRQ:72h) ;
  11     ?        gpio:QTM   (Twlbg? and/or New3DS?)       (IRQ:73h?);/
  12-15  Unused (0)
```



## 10147028h - GPIO\_DATA4\_DATA\_OUT\_WIFI (R/W)


```
  0      Wifi Enable (1=On) ;gpio:MCU, gpio:NWM ;-GPIO services bitmask 40000h
  1-15   Unused (0)
```



## Default GPIO values


After bootrom initialization, these are the values of the registers:

```
  Address    Value
  10147000h  0003h
  10147010h  00000002h
  10147014h  0000h
  10147020h  00000DFBh
  10147024h  00000000h
  10147028h  0000h
```



## 10147100h - Legacy RTC ?


Normally only 10147100h.bit15 is R/W, and the other bits/registers at 101471xxh
are all zero. But reportedly they can contain this...

```
  10147100h 2      RTC_CNT          Control register
 Below are all bytewise bitswapped...
  10147110h 1      RTC_REG_STAT1    Rtc status register 1                  0
  10147111h 1      RTC_REG_STAT2    Rtc status register 2                  1
  10147112h 1      RTC_REG_CLKADJ   Rtc clock adjustment register          6
  10147113h 1      RTC_REG_FREE     The free general purpose rtc register  7
  10147120h 4      RTC_REG_TIME1    Seconds, minutes, hours, day of week
  10147124h 4 (3?) RTC_REG_TIME2    Day, month and year
  10147130h 4 (3?) RTC_REG_ALRMTIM1 Rtc alarm time register 1              4
  10147134h 4 (3?) RTC_REG_ALRMTIM2 Rtc alarm time register 2              5
 Below are for DSi, unknown if they are used/enabled for NDS, too...
  10147140h 4 (3?) RTC_REG_COUNT    Rtc DSi counter register               ex0
  10147150h 1      RTC_REG_FOUT1    Rtc DSi fout register 1                ex1
  10147151h 1      RTC_REG_FOUT2    Rtc DSi fout register 2                ex2
  10147160h 4 (3?) RTC_REG_ALRMDAT1 Rtc DSi alarm date register 1          ex4
  10147164h 4 (3?) RTC_REG_ALRMDAT2 Rtc DSi alarm date register 2          ex5
 In single bytes...
  10147110h 1      RTC_REG_STAT1          Rtc status register 1
  10147111h 1      RTC_REG_STAT2          Rtc status register 2
  10147112h 1      RTC_REG_CLKADJ         Rtc clock adjustment register
  10147113h 1      RTC_REG_FREE           Free general purpose register
  10147114h 0Ch    Unused
  10147120h 1      RTC_REG_TIME_SECOND    Second
  10147121h 1      RTC_REG_TIME_MINUTE    Minute
  10147122h 1      RTC_REG_TIME_HOUR      Hour
  10147123h 1      RTC_REG_TIME_DOW       Day of week
  10147124h 1      RTC_REG_TIME_DAY       Day
  10147125h 1      RTC_REG_TIME_MONTH     Month
  10147126h 1      RTC_REG_TIME_YEAR      Year
  10147127h 09h    Unused
  10147130h 4 (3?) RTC_REG_ALARM1_MINUTE  Alarm 1 Minute
  10147131h        RTC_REG_ALARM1_HOUR    Alarm 1 Hour
  10147132h        RTC_REG_ALARM1_DOW     Alarm 1 Day of week
  10147133h 01h    Unused
  10147134h 4 (3?) RTC_REG_ALARM2_MINUTE  Alarm 2 Minute
  10147135h        RTC_REG_ALARM2_HOUR    Alarm 2 Hour
  10147136h        RTC_REG_ALARM2_DOW     Alarm 2 Day of week
  10147137h 09h    Unused
  10147140h 4 (3?) RTC_REG_COUNT_LSB      Rtc DSi Counter LSB?
  10147141h        RTC_REG_COUNT_MID      Rtc DSi Counter MID
  10147142h        RTC_REG_COUNT_MSB      Rtc DSi Counter MSB?
  10147143h 0Dh    Unused
  10147150h 1      RTC_REG_FOUT1          Rtc DSi Fout register 1
  10147151h 1      RTC_REG_FOUT2          Rtc DSi Fout register 2
  10147152h 0Eh    Unused
  10147160h 4 (3?) RTC_REG_ALARM1_DAY     Rtc DSi Alarm 1 Day
  10147161h        RTC_REG_ALARM1_MONTH   Rtc DSi Alarm 1 Month
  10147162h        RTC_REG_ALARM1_YEAR    Rtc DSi Alarm 1 Year
  10147163h 01h    Unused
  10147164h 4 (3?) RTC_REG_ALARM2_DAY     Rtc DSi Alarm 2 Day
  10147165h        RTC_REG_ALARM2_MONTH   Rtc DSi Alarm 2 Month
  10147166h        RTC_REG_ALARM2_YEAR    Rtc DSi Alarm 2 Year
  10147167h ..     Unused
```

That is probably for NDS/DSi RTC (4000138h). For GBA Cart RTC see
"ARM7\_RTC\_xxx" registers at 100181xxh.



## 10147100h - RTC\_CNT


```
  0     Latch STAT1                                                 (W)
  1     Latch STAT2                                                 (W)
  2     Latch CLKADJ                                                (W)
  3     Latch FREE                                                  (W)
  4     Latch TIME                                                  (W)
  5     Latch ALRMTIM1                                              (W)
  6     Latch ALRMTIM2                                              (W)
  7     Latch COUNT                                                 (W)
  8     Latch FOUT1                                                 (W)
  9     Latch FOUT2                                                 (W)
  10    Latch ALRMDAT1                                              (W)
  11    Latch ALRMDAT2                                              (W)
  12    ARM7 Busy? This may be chipselect                           (R)
  13    ARM7 write command received? (writing 1 clears it seems)    (R/ack)
  14    ARM7 read command received? (writing 1 clears it seems)     (R/ack)
  15    DS SIO SI pin (rtc irq pin)                                 (R/W)
```

Unknown if "Latch" means writing or reading the registers, or if both is
somehow supported.

Unknown why RTC IRQ pin is write-able, maybe ARM11 must manually trigger it?
But if the ALARM registers are write-only then ARM11 couldn't know their
current value (except, by assuming that the written value wasn't changed from
NDS side).




# <a name="3dscryptoregisters"></a>3DS Crypto Registers



- [3DS Crypto - AES Registers](#3dscryptoaesregisters)
- [3DS Crypto - SHA Registers](#3dscryptosharegisters)
- [3DS Crypto - RSA Registers](#3dscryptorsaregisters)
- [3DS Crypto - PRNG and OTP Registers](#3dscryptoprngandotpregisters)
- [3DS Crypto - AES Keyslots](#3dscryptoaeskeyslots)
- [3DS Crypto - AES Key Generator](#3dscryptoaeskeygenerator)
- [3DS Crypto - RSA sighax](#3dscryptorsasighax)



# <a name="3dscryptoaesregisters"></a>3DS Crypto - AES Registers




## AES Registers (ARM9)


```
  Address           Name          Byte order  Word order
  10009000h 4   R/W AES_CNT       Little      -          ;-bit22-29 unlike DSi
  10009004h 4   W   AES_BLKCNT    Little      -
  10009008h 4   W   AES_WRFIFO    WordWrite   FifoWrite
  1000900Ch 4   R   AES_RDFIFO    WordRead    FifoRead
  10009010h 1   R/W AES_KEYSEL    -           -          ;\new, unlike DSi
  10009011h 1   R/W AES_KEYCNT    -           -          ;/
  10009020h 16  W   AES_IV        WordWrite   Little
  10009030h 16  W   AES_MAC       WordWrite   Little
  10009040h 48  W   AES_KEY0      WordWrite   Little
  10009070h 48  W   AES_KEY1      WordWrite   Little
  100090A0h 48  W   AES_KEY2      WordWrite   Little
  100090D0h 48  W   AES_KEY3      WordWrite   Little
  10009100h 4   W   AES_KEYFIFO   WordWrite   FifoWrite  ;\
  10009104h 4   W   AES_KEYXFIFO  WordWrite   FifoWrite  ; new, unlike DSi
  10009108h 4   W   AES_KEYYFIFO  WordWrite   FifoWrite  ;/
```

Most of these registers are same as on DSi:

- [DSi AES I/O Ports](ds.html#dsiaesioports)
New features are more keyslots, CBC/ECB modes, optional big-endian mode, and a
new Key X/Y scrambler.



## 10009000h - ARM9 - AES\_CNT (R/W)


```
  0-4   Write FIFO Count    (00h..10h words) (00h=Empty, 10h=Full)          (R)
  5-9   Read FIFO Count     (00h..10h words) (00h=Empty, 10h=Full)          (R)
  10    Write FIFO Flush    (0=No change, 1=Flush)                   (N/A or W)
  11    Read FIFO Flush     (0=No change, 1=Flush)                   (N/A or W)
  12-13 Write FIFO DMA Size (0..3 = 16,12,8,4 words) (2=Normal=8)    (R or R/W)
  14-15 Read FIFO DMA Size  (0..3 = 4,8,12,16 words) (1=Normal=8)    (R or R/W)
  16-18 CCM MAC Size, max(4,(N*2+2)) bytes, usually 7=16 bytes       (R or R/W)
  19    CCM Pass Associated Data to RDFIFO (0=No/Normal, 1=Yes)      (R or R/W)
  20    CCM MAC Verify Source (0=From AES_WRFIFO, 1=From AES_MAC)    (R or R/W)
  21    CCM MAC Verify Result (0=Invalid/Busy, 1=Verified/Okay)             (R)
 Below bits (bit22-29) are other than DSi
  22    Byte order for Word Read  (0=Little endian, 1=Big endian)   (R? or R/W)
  23    Byte order for Word Write (0=Little endian, 1=Big endian)   (R? or R/W)
  24    Word order per Fifo Read  (0=Little first, 1=Big first)     (R? or R/W)
  25    Word order per Fifo Write (0=Little first, 1=Big first)     (R? or R/W)
  26    Key Select        (0=No change, 1=Apply key selected in AES_KEYSEL) (W)
  27-29 Mode (0=CCM decrypt, 1=CCM encrypt, 2=CTR, 3=CTR,
              4=CBC decrypt, 5=CBC encrypt, 6=ECB decrypt, 7=ECB encrypt)
  30    Interrupt Enable  (0=Disable, 1=Enable IRQ on Transfer End)  (R or R/W)
  31    Start/Enable      (0=Disable/Ready, 1=Enable/Busy)                (R/W)
```



## 10009010h - ARM9 - AES\_KEYSEL (R/W)


```
  0-5   Keyslot for encrypt/decrypt, apply via AES_CNT.bit26 (00h..3Fh)   (R/W)
  6-7   Unused (0)
```



## 10009011h - ARM9 - AES\_KEYCNT (R/W)


```
  0-5   Keyslot for writes via AES_KEYxyFIFO (04h..3Fh, or 0..3=None)     (R/W)
  6     Key X/Y Scrambler for key 4-3Fh      (0=3DS, 1=DSi)               (R/W)
  7     Flush AES_KEYxyFIFO                  (0=No change, 1=Flush)         (W)
```

"The hardware key generator is triggered by writing the keyY, which is the only
way to trigger it with the 3DS keyslots. The algorithm for generating the
normal-key from keyX and keyY is as follows":

```
  KeyDSi = (((KeyX)       XOR KeyY) + FFFEFB4E295902582A680F5F1A4F3E79h) ROL 42
  Key3DS = (((KeyX ROL 2) XOR KeyY) + 1FF9E9AAC5FE0408024591DC5D52768Ah) ROL 87
```

Key 0-3 are writeable only via the old DSi-style AES\_KEY0..3 registers (not via
AES\_KEYxyFIFO), and key0-3 are always using the old DSi-style Key scrambler.



## 10009100h - ARM9 - AES\_KEYFIFO - Normal Key (four words)



## 10009104h - ARM9 - AES\_KEYXFIFO - Key X (four words)



## 10009108h - ARM9 - AES\_KEYYFIFO - Key Y (four words)


Whatever, new (unlike DSi).

The Key FIFO's are automatically flushed after each 4 words, and after setting
AES\_KEYCNT.bit7, and reportedly also when changing the AES\_CNT word order.


```
 __________________________ Notes and DSi Registers __________________________
```



## Notes


When AES\_CNT.bit31 is set, then AES\_CNT essentially becomes locked and doesn't
change when written to. However if AES\_CNT.bit26 is "set", keyslot-selection is
cued to be handled when AES\_CNT.bit31 is cleared.

Clearing AES\_CNT.bit31 while the AES engine is doing crypto will result in the
AES engine stopping crypto, once it finishes processing the current block.



## 10009004h - ARM9 - AES\_MACEXTRABLKCNT


(CCM-MAC extra data length)>>4, ie. the number of block of CCM-MAC extra
data.



## 10009006h - ARM9 - AES\_BLKCNT


(Data length)>>4, ie. the number of blocks to process



## 10009008h - ARM9 - AES\_WRFIFO



## 1000900Ch - ARM9 - AES\_RDFIFO


Reading from AES\_RDFIFO when there's no data available in the RDFIFO will
result in reading the last word that was in the RDFIFO.

When triggering either RDFIFO or WRFIFO to be flushed, the AES Engine does not
clear either buffer.

Word order and endianness can be changed between each read/write to these
FIFOs. However changing the word order when writing to WRFIFO can cause the
word to be written outside the current block, leaving uninitialized data in its
place. Attempts to change endianness or word order are not honored when reading
from RDFIFO when no more data is available.



## 10009020h - ARM9 - AES\_IV (16 bytes)


This register specifies the counter (CTR mode), nonce (CCM mode) or the
initialization vector (CBC mode) depending on the mode of operation. For CBC
and CTR mode this register takes up the full 16 bytes, but for CCM mode the
nonce is only the first 12 bytes. The AES engine will automatically increment
the counter up to the maximum BLKCNT, after which point it must be manually
incremented and set again.



## 10009030h - ARM9 - AES\_MAC (16 bytes)


This register specifies the message authentication code (MAC) for use in CCM
mode.



## 10009040h/10009070h/100090A0h/100090D0h - AES\_KEY0/1/2/3


These registers are the same as they were on TWL, and are likely preserved for
compatibility reasons. The keyslot is updated immediately after \*any\*
data(u8/u32/...) is written here, which was used on DSi to break the
key-generator.



## CCM mode pitfall


Non-standard AES-CCM behaviour is observed on Wrap/Unwrap function. According
to RFC 3610, the first block B\_0 for authentication should be generated from
the message length and some other parameters. Using these function, it seems
that the message length is aligned up to 16 when generating B\_0. This makes the
generated MAC not compliant with the standard when (inputsize-noncesize)%16!=0.
It is very likely that this non-standard behaviour happens on the hardware
level, but not confirmed yet.

```
  uh, or does it just OMIT that, as on DSi?
  instead of that "aligned" thing?
```




# <a name="3dscryptosharegisters"></a>3DS Crypto - SHA Registers




## SHA Registers


```
  1000A000h 4     ARM9        SHA_CNT           ;\
  1000A004h 4     ARM9        SHA_BLKCNT        ; for ARM9
  1000A040h 20h   ARM9        SHA_HASH          ;
  1000A080h 40h   ARM9        SHA_FIFO          ;/
  10101000h 4     ARM11/ARM9  SHA_CNT           ;\for ARM11 (some registers
  10101004h 4     ARM11/ARM9  SHA_BLKCNT        ; can be also accessed by ARM9,
  10101040h 20h   ARM11/ARM9  SHA_HASH          ; but FIFO and DMA DRQs are
  10301000h 40h   ARM11       SHA_FIFO          ;/working for ARM11 only)
```



## 1000A000h/10101000h - SHA\_CNT - SHA Control (R/W)


```
  0     Read: IN_FIFO full   (0=No/ready, 1=Full/Busy) (10h words)          (R)
        Write: First round   (0=No change, 1=Reset BLKCNT and HASH)         (W)
  1     Final round          (0=No/ready, 1=Enable/Busy)                  (R/W)
  2     IN_FIFO DMA Enable   (0=Disable, 1=Enable CDMA DRQ 0Bh)           (R/W)
  3     Byte order of Result (0=Little endian, 1=Big endian/Standard)     (R/W)
  4-5   Mode                 (0=SHA256, 1=SHA224, 2=3=SHA1)               (R/W)
  6-7   Unused (0)  ;reportedly "?" (but actually: always 0)                (?)
  8     OUT_FIFO Enable      (0=No, 1=Readback Mode)           ;\optional (R/W)
  9     OUT_FIFO Status      (0=Empty, 1=Non-empty)            ; readback   (R)
  10    OUT_FIFO DMA Enable  (0=Disable, 1=Enable CDMA DRQ 0Ch);/         (R/W)
  11-15 Unused (0)                                                          (-)
  16-17 Unused (0)  ;reportedly "?" (but actually: always 0)                (?)
  18-31 Unused (0)                                                          (-)
```

The optional readback mode allows to readback each 40h-byte block from the
FIFO, this can reduce memory reads (and temporary memory writes), for example:

```
  EMMC --> SHA --> AES --> Memory        ;saves 1xMemWrite and 2xMemRead
  EMMC --> AES --> SHA --> Memory        ;saves 1xMemRead
```

The SHA\_IN writing speed is about 62Mbyte/s for SHA256 and SHA224, and
50Mbyte/s for SHA1. Reading source data, and optional forwarding to SHA\_OUT may
cause extra slowdown.



## 1000A004h/10101004h - SHA\_BLKCNT - SHA Input Length (R/W)


```
  0-31  Length in bytes (0..FFFFFFFFh)
```

The length is automatically updated by hardware:

```
  Length is reset to zero when setting SHA_CNT.bit0 (start).
  Length increments by 40h after each 40h-byte FIFO block.
  Length increments by remaining FIFO size after setting SHA_CNT.bit1 (final).
```

The hardware does automatically append the length value (and some padding bits)
to the data stream before computing the final result.



## 1000A040h/10101040h - SHA\_HASH - State/Result (20h bytes) (R/W)


Contains the SHA state/result. The word order is fixed, the byte order (per
32bit word) depends on SHA\_CNT.bit3.

Setting SHA\_CNT.bit0 does automatically apply the following initial values:

- SHA256 6A09E667,BB67AE85,3C6EF372,A54FF53A,510E527F,9B05688C,1F83D9AB,5BE0CD19
- SHA224 C1059ED8,367CD507,3070DD17,F70E5939,FFC00B31,68581511,64F98FA7,BEFA4FA4
- SHA1   67452301,EFCDAB89,98BADCFE,10325476,C3D2E1F0,0       ,0       ,0

The values are updated after each 40h-byte FIFO block, and updated once more
after final round.

SHA1 leaves the last 3 words unused (set to zero). SHA224 and SHA256 do
internally use all 8 words (but the last word is usually omitted when reading
the SHA224 result).



## 1000A080h/10301000h - SHA\_FIFO (40h bytes) - SHA\_IN (W) and SHA\_OUT (R)


```
  0-7   1st byte        ;\
  8-15  2nd byte        ; data to be checksummed
  16-23 3rd byte        ;
  24-31 4th byte        ;/
```

The FIFO is mapped to a 40h-byte area at FIFO+0..3Fh. The word address is don't
care (one can write all words to FIFO+0, or to FIFO+0,4,8,..,3Ch).

However, 8bit/16bit writes do REQUIRE the lower two addresss bits to match up
with the number of previously written bytes (eg. byte writes must go to
FIFO+0,1,2,3,4,5,..,3Fh or FIFO+0,1,2,3,0,1,.,3). Writing 8bit/16bit is
normally needed only for the last block before setting final flag (and only if
the length isn't a multiple of 40h). Writing 8bit/16bit may be also needed if
the data comes from an odd source address (but that would slowdown everything).



## Invalid Operations with/without Data Abort


```
  Reading FIFO when CNT.bit8=0 returns ZERO (readback disabled)
  Reading FIFO when CNT.bit8=1 and FIFO empty causes Data Abort (enabled+empty)
```

Untested...

```
  Writing FIFO when FIFO full... is ignored? or data abort?
  Writing 32bit to FIFO content is odd (not N*4 bytes)... causes what?
  Writing 32bit to FIFO already contains 3Dh..3Fh bytes... causes what?
```




# <a name="3dscryptorsaregisters"></a>3DS Crypto - RSA Registers




## RSA Registers (ARM9)


```
  1000B000h 4    R/W RSA_CNT        Control/status and keyslot select
  1000B0F0h 4    ?   RSA_UNKNOWN    Unknown
  1000B1x0h 4    R/W RSA_SLOTCNT_x  Keyslot 0..3 control/status (x=0..3)
  1000B1x4h 4    R   RSA_SLOTSIZE_x Keyslot 0..3 size/status    (x=0..3)
  1000B200h 4    W   RSA_EXPFIFO    Exponent (10001h, or private key) ;\for
  1000B204h FCh  W   RSA_EXPFIFO    Mirrors of above                  ; current
  1000B400h 100h R/W RSA_MOD        Modulus (public key)              ;/keyslot
  1000B800h 100h R/W RSA_DATA       Incoming Data and Result
```



## 1000B000h - ARM9 - RSA\_CNT (R/W)


```
  0     Start/Busy (0=Idle/Ready, 1=Enable/Busy)
  1     IRQ Enable (0=Disable, 1=Enable, set ARM9 IF.bit22 when Ready)
  2-3   Unused (0)
  4-5   Keyslot    (0..3=Key 0-3)   ;for Start/Busy and RSA_MOD,EXPFIFO
  6-7   Unused (0)
  8     Byte order (0=Little endian, 1=Big Endian) ;for RSA_MOD,DATA,EXPFIFO
  9     Word order (0=Little endian, 1=Big Endian) ;for RSA_MOD,DATA
  10-31 Unused (0)
```



## 1000B0F0h - ARM9 - RSA\_UNKNOWN (R and/or W)


```
  0-28  Unknown/unused?   (always zero)
  29    Unknown/readonly? (always set)
  30-31 Unknown/unused?   (always zero)
```

The bootroms writes zero in RSA IRQ init, so some bits might be write-only?
Writing seems to have no effect on anything though.



## 1000B100h+(0..3)\*10h - ARM9 - RSA\_SLOTCNT\_0..3 (R/W)


```
  0     Read: Exponent Status (0=Bad=LessThan4orOdd, 1=Good=4orMoreAndEven) (R)
        Write: Clear RSA_SLOTSIZE/EXPFIFO (0=Clear, 1=No Change)            (W)
  1     Disable RSA_EXPFIFO Writes        (0=Normal, 1=DataAbort)         (R/W)
  2     Disable RSA_MOD Reads             (0=Normal, 1=DataAbort)         (R/W)
  3-30  Unused (0)
  31    Disable RSA_SLOTCNT_x Writes      (0=Normal, 1=Disable/permanent) (R/w)
```

Bit1,2 can be changed only if Status Bit0 was set (Good=4orMoreAndEven).



## 1000B104h+(0..3)\*10h - ARM9 - RSA\_SLOTSIZE\_0..3 (R)


```
  0-31  Number of words written to EXPFIFO (range 0..40h)
```

Indicates the EXP size (and implied: the MOD and DATA sizes). Whilst that
number is important, programmers should usually know how many words they had
used, without needing to use the SLOTSIZE register.



## 1000B200h - ARM9 - RSA\_EXPFIFO - Exponent; usually 10001h, or Private Key (W)



## 1000B204h..1000B2FFh - ARM9 - RSA\_EXPFIFO mirrors (W)


```
  0-31  FIFO, in current byte-order, to be written MSW first (max 40h words)
```

The number of words written to EXPFIFO does imply the size of the MOD and DATA
values (that makes sense for private exponents, but the public exponent 10001h
must be padded with leading zeroes, and then followed by 10001h in last word
(aka 01000100h for big-endian).

The RSA hardware wants the number of words to be an even number in range of
4..40h, aka a multiple of 8 bytes in range 10h..100h (and if so, sets
SLOTCNT.bit0).



## 1000B400h..1000B4FFh - ARM9 - RSA\_MOD - Modulus; Public Key (R/W)


```
  100h-byte area, in currently selected byte/word-order, for current keyslot
```

The upper bits are unused/don't care when SLOTSIZE\<40h.



## 1000B800h..1000B8FFh - ARM9 - RSA\_DATA (100h bytes) (R/W)


```
  100h-byte area, in currently selected byte/word-order
```

Contains the data that is to be encrypted/decrypted, and contains the result
after completion.

The upper bits are unused/don't care when SLOTSIZE\<40h.



## RSA Timing Examples (versus 67MHz timer)


```
  0.9ms (E475h clks)   Public key, 80h-bytes (DSi-style)
  3.3ms (3571Dh clks)  Public key, 80h-bytes zeropadded to 100h-bytes size
  3.3ms (3574Ah clks)  Public key, 100h-bytes (3DS-style)
  200ms (CE59A5h clks) Private key, 100h-bytes (3DS-style)
```



## Invalid Operations with/without Data Abort


```
  Reading MOD or DATA when busy (and maybe also on writing?)  --> Data Abort
  Reading MOD when disabled in SLOTCNT                        --> Data Abort
  Writing EXPFIFO when disabled in SLOTCNT                    --> Data Abort
  Writing more than 40h words to EXPFIFO                      --> Data Abort
  Reading EXPFIFO or reading unused registers like 1000B5xxh  --> Returns Zero
```



## Keyslot 0..3 usage


During boot, the bootrom uses the following PUBLIC keys (100h byte modulus,
with exponent 10001h):

```
  Slot 0 uninitialized                     (unused)
  Slot 1 retail=FFFFB1E0h, debug=FFFFC4E0h (for FIRM from eMMC)
  Slot 2 retail=FFFFB2E0h, debug=FFFFC5E0h (for FIRM from Wifi-Flash/NDS-Cart)
  Slot 3 retail=FFFFB0E0h, debug=FFFFC3E0h (for NCSD from eMMC)
```

After boot, the bootrom does replace the above keys by four PRIVATE keys (with
100h byte modulus, and 100h byte exponent):

```
  Slot 0 retail=FFFFB3E0h, debug=FFFFC6E0h ;\Hardware slots (modulus+exponent)
  Slot 1 retail=FFFFB5E0h, debug=FFFFC8E0h ; (the modulus are also stored in
  Slot 2 retail=FFFFB7E0h, debug=FFFFCAE0h ; RAM at ITCM+3D00h+(0..3)*100h)
  Slot 3 retail=FFFFB9E0h, debug=FFFFCCE0h ;/
  Slot 4 retail=FFFFBBE0h, debug=FFFFCEE0h ;\
  Slot 5 retail=FFFFBDE0h, debug=FFFFD0E0h ; RAM slots (modulus+exponent are
  Slot 6 retail=FFFFBFE0h, debug=FFFFD2E0h ; stored at ITCM+4100h+(0..3)*200h)
  Slot 7 retail=FFFFC1E0h, debug=FFFFD4E0h ;/
```

Later on, the firmware does replace some slots by other keys:

```
  Slot 0 Arbitrary (uh?)
  Slot 1 CXI access desc (following the exheader, uh?)
  Slot 2 Unused (contains the private key from bootrom)
  Slot 3 Unused (contains the private key from bootrom)
```



## RSA Basics and Differences to DSi


The 3DS RSA hardware is more or less same as the DSi RSA BIOS functions, see
there for general info about RSA maths and RSA padding:

- [BIOS RSA Functions (DSi only)](#biosrsafunctionsdsionly)
Apart from being hardware-implemented, the 3DS is usually using 100h-bytes
(instead 80h), with SHA256 signatures (instead SHA1), and with OpenPGP headers
(instead raw padding).



## Blurb


Writing to RSA\_MOD does not change the exponent written with RSA\_EXPFIFO. An
attack based on the Pohlig-Hellman algorithm exists to "read" the contents of
RSA\_EXPFIFO as a result (see 3DS System Flaws).



## RSA Overview


The RSA module is essentially a hardware-accelerated modular exponentiation
engine. It is specially optimized for RSA applications, so its behavior can be
incoherent when RSA's invariants are broken.

The PKCS (Public-Key Cryptography Standards) message padding must be manually
checked by software, as hardware will only do raw RSA operations.



## Observed edge cases


```
  "if 2 divides mod, output == 0"
```

uh, how to "divide" a "mod" ?

uh, for mod2, remainder SHOULD be 0 or 1 (or is it ALWAYS 0 here?)

uh, also, MOD may be required to be bigger than DATA?




# <a name="3dscryptoprngandotpregisters"></a>3DS Crypto - PRNG and OTP Registers



```
 _______________________________ PRNG Registers _______________________________
```



## PRNG Registers ... Pseudo Random Generator?   Boot9, Process9


```
  10011000h 4  Random (changes on each read)
  10011010h 4  Random (changes on each read)
  10011020h 4  Random (constant)
```

Used as entropy-source for seeding random number generators.


```
 _______________________________ OTP Registers ________________________________
```



## OTP Registers


```
  10012000h 100h  Encrypted 3DS OTP  (R)
  10012100h 8     DSi OTP Console ID (R/W?)
```

Access to this region is disabled once the ARM9 writes 02h to CFG9\_SYSPROT9.



## 10012000h - 100h bytes - Encrypted 3DS OTP (R)


Console-unique data encrypted with AES-CBC. The normalkey and IV are stored in
Boot9 (retail/devunit have seperate normalkey+IV for this).



## 10012100h - 8 bytes - DSi OTP Console ID (R/W?)


Before writing CFG9\_SYSPROT9 bit1, the ARM9 copies the 8-byte TWL Console ID
here. This sets the registers at 4004D00h for ARM7.

```
  [10012100h] = DecryptedOTP[008h] xor B358A6AFh or 80000000h
  [10012104h] = DecryptedOTP[00Ch] xor 08C267B7h
```



## Decrypted OTP


```
  000h 90h   Copied into ITCM. The encrypted version of this is what
                New3DS-arm9loader hashes for key-generation.
  000h 4     Always DEADB00Fh
  004h 4     DeviceId (aka Console ID, used in tickets)
  008h 10h   Fall-back keyY used for movable.sed keyY when
                movable.sed doesn't exist in NAND (the last(???) two words
                here are used on retail for generating console-unique TWL
                keydata/etc).
                This is also used for "LocalFriendCodeSeed", etc.
  018h 1     CTCert byte order? (usually 05h)
  019h 1     CTCert issuer type:
               zero = retail  ("Nintendo CA - G3_NintendoCTR2prod")
               non-zero = dev ("Nintendo CA - G3_NintendoCTR2dev")
  01Ah 6     Manufacturing date (year-1900, month, day, hour, minute, second)
  020h 4     CTCert ECDSA exponent (byte-swapped when OTP[018h]>=5)
  024h 2     Zero?
  026h 1Eh   CTCert ECDSA private key
  044h 3Ch   CTCert ECDSA signature
  080h 10h   Zerofilled
  090h 1Ch   Seed 1 for AES keys ;<-- used for console-unique AES keys
  0ACh 1Ch   Seed 2 for AES keys ;\
  0C8h 1Ch   Seed 3 for AES keys ; not actually used  ;\overlaps SHA256
  0E4h 1Ch   Seed 4 for AES keys ;/                   ;/(see below)
  0E0h 20h   SHA256 hash across [000h..0DFh]
```



## OTP Blurp


After decryption, the first 90h-bytes of plaintext are copied to ITCM+3800h at
01FFB800h aka 07FFB800h if hash verification passes.


On FIRM versions prior to 3.0.0-X, this region was left unprotected. On
versions since 3.0.0-X, this has been fixed, and the region disable is now done
by Kernel9 after doing console-unique TWL keyinit, by setting bit1 of
CFG9\_SYSPROT9. However, with the New3DS FIRM ARM9 binary this is now done in
the FIRM ARM9 binary loader, which also uses the 10012000h region for New 3DS
key generation.


On development units (UNITINFO != 0) ARM9 uses the first 8-bytes from 10012000h
for the TWL Console ID. This region doesn't seem to be used by NATIVE\_FIRM on
retail at all, besides New3DS key-generation in the ARM9-loader.




# <a name="3dscryptoaeskeyslots"></a>3DS Crypto - AES Keyslots




## AES Keyslot Usage


```
  00h      DSi                                       ;\
  01h      DSi                                       ; DSi keys (little-endian,
  02h      DSi                                       ; with DSi key X/Y)
  03h      eMMC key for DSi MBR and FAT filesystems  ;/
  04h      eMMC key for Old3DS MBR and FAT filesystem
  05h      eMMC key for New3DS MBR and FAT filesystem (keyY from FIRM)
  06h      eMMC key for FIRM partitions
  07h      eMMC key for GBA savegame partition
  08h-09h  Unused
  0Ah      DSiWare export (encrypted 10h-byte zeroes in DSiWare_Exports header)
  0Bh      AES-CMAC key (for emmc:\dbs images, and emmc:\private\movable.sed)
  0Ch      Unused
  0Dh      SSL-certificate key (see ClCertA)
  0Eh-10h  Unused
  11h      Temporary keyslot (used by FIRM)
  12h-13h  Unused
  14h      Unknown (initialized by v5.0.0-11 and up)
  15h      New3DS arm9 FIRM binary loader
  16h      New3DS arm9 FIRM binary loader (v9.5.0 and up)
  17h      Unused
  18h      New3DS Second NCCH key (when NCCH[18Bh]=0Ah)
  19h      New3DS Gamecard savedata AES-CMAC key (when [ROM?-]NCSD=what?)
  1Ah      New3DS Gamecard savedata Actual key   (when [ROM?-]NCSD=what?)
  1Bh      New3DS Second NCCH key (when NCCH[18Bh]=0Bh)
  1Ch-1Fh  New3DS Unused keys (initialized, but not used yet)
  20h-23h  Unused
  24h      GBA savegame AES-CMAC key
  25h      Second NCCH key (when NCCH[18Bh]=01h)
  26h-2Bh  Unused
  2Ch      First NCCH key (also 2nd key, when NCCH[18Bh]=00h)
  2Dh      UDS local-WLAN CCMP key
  2Eh      Streetpass key
  2Fh      v6.0 save key
  30h      AES-CMAC key (for emmc:\data\ and sd:\Nintendo 3DS\...)
  31h      APT wrap key
  32h      Unknown
  33h      Gamecard savedata AES-CMAC (New3DS alternately uses keyslot 19h)
  34h      SD key (for all data in "sd:\Nintendo 3DS\<ID0>\<ID1>\")
  35h      Movable.sed key (movable.sed & AES-CBC MAC with import/export cmds)
  36h      Used by friends module
  37h      Gamecard savedata Actual key (New3DS alternately uses keyslot 1Ah)
  38h      BOSS key
  39h      Temporary keys (Download Play & NFC key for generating Amiibo keys)
  3Ah      DSiWare export (for calculating AES-CMACs for SD DSiWare_Exports)
  3Bh      CTRCARD key (for decrypting seed via AES-CCM)
  3Ch      Unused
  3Dh      Common key (used to decrypt title keys in Ticket)
  3Eh      Unused
  3Fh      Temporary keyslot (used by bootrom)
```



## Random notes


After writing to a keyslot, the keyslot must be selected again (write
AES\_KEYSEL + set AES\_CNT bit26), even when writing to the same keyslot. Writing
the last word to a key FIFO immediately after selecting a keyslot will not
affect the keyslot keydata that gets used at that time, the new keydata will
not get used until the keyslot gets selected again.


Writing to the key FIFOs with byte writes results in the AES engine converting
the byte to a word (word=byte\*01010101h). The result is the same regardless of
which FIFO register byte was written to.


The key FIFOs can be written simultaneously. For example, executing the
following will result in the keyX and keyY being set to all-zero (unknown for
normalkey): memset(0x10009100, 0, 0x100); uh, does that mean there are mirrors
at 1000910Ch and up?


Each key FIFO has a 10h-byte tmp-buffer for storing the words written to that
FIFO. Once the last word is written to a key FIFO, the filled tmp-buffer is
then written to the key-data for the keyslot selected by AES\_KEYCNT at the time
the last word was written.



## FIRM-launch key clearing


Starting with 9.0.0-20 the Process9 FIRM-launch code now "clears" the following
AES keyslots, with certain keydata by writing the normal-key: 0x15 and
0x18-0x20. These are the keyslots used by the New3DS FIRM arm9bin loader (minus
keyslot 0x11), the New3DS Process9 does this too.




# <a name="3dscryptoaeskeygenerator"></a>3DS Crypto - AES Key Generator




## Decrypt OTP and get otp\_seed (and rom\_seed for retail/debug)


```
  if [10010010h]=00h then otp_keyiv=FFFFD6E0h else otp_keyiv=FFFFD700h
  if [10010010h]=00h then rom_seed=FFFFD860h  else rom_seed=FFFFDC60h
  aes_setkey_normal(key=otp_keyiv+00h)
  aes_CBC_decrypt(iv=otp_keyiv+10h, src=10012000h, dst=decrypted_otp, len=100h)
  sha256(src=decrypted_otp, dst=temp, len=E0h)
  if [temp+0..1Fh]=[decrypted_otp+E0h..FFh] then otp_okay=1 else otp_okay=0
  if otp_okay=1 then otp_seed=decrypted_otp+90h else otp_seed=10012000h
  if otp_okay=1 then copy [decrypted_otp+0..8Fh] to [ITCM+3800h..388Fh]
```



## Generate bootrom keys (using above otp\_seed and rom\_seed)


```
  sha256(src=otp_seed(00h..1Bh)+rom_seed(00h..23h), dst=temp, len=40h=1Ch+24h)
  aes_setkey_xy(key_x=temp+00h, key_y=temp+10h)
  aes_CBC_encrypt(iv=rom_seed+24h, src=rom_seed+34h, dst=temp, len=40h)
  key_x.00h-03h = uninitialized
  key_x.04h-07h = temp+00h
  key_x.08h-0Bh = temp+10h
  key_x.0Ch-0Fh = temp+20h
  key_x.10h     = temp+30h
  key_x.11h-13h = uninitialized
 ;sha256(src=otp_seed(1Ch..37h)+rom_seed(74h..97h), dst=temp, len=40h=1Ch+24h)
 ;DO NOT: aes_setkey_xy(key_x=temp+00h, key_y=temp+10h)
  aes_CBC_encrypt(iv=rom_seed+98h, src=rom_seed+A8h, dst=temp, len=40h)
  key_x.14h     = temp+00h
  key_x.15h     = temp+10h
  key_x.16h     = temp+20h
  key_x.17h     = temp+30h
 ;sha256(src=otp_seed(38h..53h)+rom_seed(B8h..DBh), dst=temp, len=40h=1Ch+24h)
 ;DO NOT: aes_setkey_xy(key_x=temp+00h, key_y=temp+10h)
  aes_CBC_encrypt(iv=rom_seed+DCh, src=rom_seed+ECh, dst=temp, len=40h)
  key_x.18h-1Bh = temp+00h
  key_x.1Ch-1Fh = temp+10h
  key_x.20h-23h = temp+20h
  key_x.24h     = temp+30h
  key_x.25h-27h = uninitialized
 ;sha256(src=otp_seed(54h..6Fh)+rom_seed(12Ch..14Fh),dst=temp, len=40h=1Ch+24h)
 ;DO NOT: aes_setkey_xy(key_x=temp+00h, key_y=temp+10h)
  aes_CBC_encrypt(iv=rom_seed+150h, src=rom_seed+160h, dst=temp, len=40h)
  key_x.28h     = temp+00h
  key_x.29h     = temp+10h
  key_x.2Ah     = temp+20h
  key_x.2Bh     = temp+30h
  key_x.2Ch-2Fh = rom_seed+170h         ;\
  key_x.30h-33h = rom_seed+180h         ;
  key_x.34h-37h = rom_seed+190h         ;
  key_x.38h-3Bh = rom_seed+1A0h         ; fixed key X values
  key_x.3Ch     = rom_seed+1B0h         ;
  key_x.3Dh     = rom_seed+1C0h         ;
  key_x.3Eh     = rom_seed+1D0h         ;
  key_x.3Fh     = rom_seed+1E0h         ;/
  key_y.00h-03h = uninitialized
  key_y.04h     = rom_seed+1F0h         ;\
  key_y.05h     = rom_seed+200h         ;
  key_y.06h     = rom_seed+210h         ;
  key_y.07h     = rom_seed+220h         ; fixed key Y values
  key_y.08h     = rom_seed+230h         ;
  key_y.09h     = rom_seed+240h         ;
  key_y.0Ah     = rom_seed+250h         ;
  key_y.0Bh     = rom_seed+260h         ;/
  key_y.0Ch-3Eh = uninitialized
  key_y.3Fh     = as set for above CBC encrypt
  key.00h-03h   = uninitialized
  key.04h-0Bh   = uninitialized (or are they set via above key X/Y combo?)
  key.0Ch-0Fh   = rom_seed+270h         ;\
  key.10h       = rom_seed+280h         ;
  key.11h-13h   = uninitialized         ;
  key.14h       = rom_seed+290h         ;
  key.15h       = rom_seed+2A0h         ;
  key.16h       = rom_seed+2B0h         ;
  key.17h       = rom_seed+2C0h         ;
  key.18h-1Bh   = rom_seed+2D0h         ; fixed normal key values
  key.1Ch-1Fh   = rom_seed+2E0h         ;
  key.20h-23h   = rom_seed+2F0h         ;
  key.24h       = rom_seed+300h         ;
  key.25h-27h   = uninitialized         ;
  key.28h       = rom_seed+300h, too    ;
  key.29h       = rom_seed+310h         ;
  key.2Ah       = rom_seed+320h         ;
  key.2Bh       = rom_seed+330h         ;
  key.2Ch-2Fh   = rom_seed+340h         ;
  key.30h-33h   = rom_seed+350h         ;
  key.34h-37h   = rom_seed+360h         ;
  key.38h       = rom_seed+370h         ;
  key.39h-3Bh   = uninitialized         ;
  key.3Ch       = rom_seed+370h, too    ;
  key.3Dh       = rom_seed+380h         ;
  key.3Eh       = rom_seed+390h         ;
  key.3Fh       = rom_seed+3A0h         ;/
  [FFF00618h]   = rom_seed+3A0h, too    ;-copy of normal key 3Fh
  [temp] = fillword(rom_seed+3B0h)      ;-dummy/fill temp buffer on stack
```


```
 ___________ Further important keys (changed after init by bootrom) ___________
```


Misc keys:

```
  key_y.05h = 4D,80,4F,4E,99,90,19,46,13,A2,04,AC,58,44,60,BE  ;by New3DS FIRM
  key_y.30h = movable.sed[110h..11Fh]
  key_y.34h = movable.sed[110h..11Fh]
  key_y.3Ah = movable.sed[110h..11Fh]
```

NCCH retail keys:

```
  key_x.25h = CE,E7,D8,AB,30,C0,0D,AE,85,0E,F5,E3,82,AC,5A,F3 ;NCCH firm 7.0
  key_x.18h = 82,E9,C9,BE,BF,B8,BD,B8,75,EC,C0,A0,7D,47,43,74 ;NCCH firm 9.3
  key_x.1Bh = 45,ad,04,95,39,92,c7,c8,93,72,4a,9a,7b,ce,61,82 ;NCCH firm 9.6
```

NCCH debug keys:

```
  fix_sys   = 52,7C,E6,30,A9,CA,30,5F,36,96,F3,CD,E9,54,19,4B ;fixed system key
  fix_zero  = 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ;fixed zero key
  key_x.25h = 81,90,7A,4B,6F,1B,47,32,3A,67,79,74,CE,4A,D7,1B ;NCCH firm 7.0
  key_x.18h = 30,4B,F1,46,83,72,EE,64,11,5E,BD,40,93,D8,42,76 ;NCCH firm 9.3
  key_x.1Bh = 6C,8B,29,44,A0,72,60,35,F9,41,DF,C0,18,52,4F,B6 ;NCCH firm 9.6
```



## Ticket Keys (aka "Common" keys)


The ticket keys in FIRM are as so:

```
  55,A3,F8,72,BD,C8,0C,55,5A,65,43,81,13,9E,15,3B  ;key_3Dh.normal.0 (debug)
  D0,7B,33,7F,9C,A4,38,59,32,A2,E2,57,23,23,2E,B9  ;key_3Dh.y.0 (retail)
  0C,76,72,30,F0,99,8F,1C,46,82,82,02,FA,AC,BE,4C  ;key_3Dh.y.1 (retail+debug)
  C4,75,CB,3A,B8,C7,88,BB,57,5E,12,A1,09,07,B8,A4  ;key_3Dh.y.2 (retail+debug)
  E4,86,EE,E3,D0,C0,9C,90,2F,66,86,D4,C0,6F,64,9F  ;key_3Dh.y.3 (retail+debug)
  ED,31,BA,9C,04,B0,67,50,6C,44,97,A3,5B,78,04,FC  ;key_3Dh.y.4 (retail+debug)
  5E,66,99,8A,B4,E8,93,16,06,85,0F,D7,A1,6D,D7,55  ;key_3Dh.y.5 (retail+debug)
```

Retail Normal Keys (after mangling above with bootrom's retail Key\_3Dh.X):

```
  64,C5,FD,55,DD,3A,D9,88,32,5B,AA,EC,52,43,DB,98  ;key_3Dh.0.retail (app)
  4A,AA,3D,0E,27,D4,D7,28,D0,B1,B4,33,F0,F9,CB,C8  ;key_3Dh.1.retail (sys)
  FB,B0,EF,8C,DB,B0,D8,E4,53,CD,99,34,43,71,69,7F  ;key_3Dh.2.retail
  25,95,9B,7A,D0,40,9F,72,68,41,98,BA,2E,CD,7D,C6  ;key_3Dh.3.retail
  7A,DA,22,CA,FF,C4,76,CC,82,97,A0,C7,CE,EE,EE,BE  ;key_3Dh.4.retail
  A5,05,1C,A1,B3,7D,CF,3A,FB,CF,8C,C1,ED,D9,CE,02  ;key_3Dh.5.retail
```

Debug Normal Keys (after mangling above with bootrom's debug Key\_3Dh.X):

```
  55,A3,F8,72,BD,C8,0C,55,5A,65,43,81,13,9E,15,3B  ;key_3Dh.0.debug
  44,34,ED,14,82,0C,A1,EB,AB,82,C1,6E,7B,EF,0C,25  ;key_3Dh.1.debug
  F6,2E,3F,95,8E,28,A2,1F,28,9E,EC,71,A8,66,29,DC  ;key_3Dh.2.debug
  2B,49,CB,6F,99,98,D9,AD,94,F2,ED,E7,B5,DA,3E,27  ;key_3Dh.3.debug
  75,05,52,BF,AA,1C,04,07,55,C8,D5,9A,55,F9,AD,1F  ;key_3Dh.4.debug
  AA,DA,4C,A8,F6,E5,A9,77,E0,A0,F9,E4,76,CF,0D,63  ;key_3Dh.5.debug
```




# <a name="3dscryptorsasighax"></a>3DS Crypto - RSA sighax



sighax is a set of fake RSA signatures which are causing the bootrom to always
pass RSA checks.



## How it works


derrek's sighax relies on some bugs in the bootrom RSA signature verification.
RSA doesn't throw errors when decrypting a wrong signature with wrong key
(instead, it does just output "random" gibberish). The decrypted signature
should normally consist of leading FFh-padding bytes, a header, and a SHA
checksum.

However, the 3DS bootrom doesn't insist on the padding bytes, and it does
ignore most of the header bytes. Finally, it does allow the header size to be
as large as occupying the whole 100h-byte signature area, which results in the
SHA value being read from next higher address AFTER the signature area - and
the bootrom happens to store the computed SHA at that location (causing the
bootrom to compare the computed SHA against itself, instead of against of what
should have been the decrypted SHA value).

Alltogether, brute-forcing requires only 6 specific bytes in the decrypted
signature (and the remaining 250 bytes are don't care).


The bootrom uses three RSA keys for different retail signatures, and another
three RSA keys for debug version.



## NCSD Signature (in eMMC)


The eMMC's NCSD Header is unencrypted, and can be changed without needing any
AES keys (however, booting custom code requires to change FIRM, not NCSD).

```
  6CF52F89F378120BFA4E1061D7361634D9A254A4F57AA5BD9F2C30934F0E68CB ;\
  E6611D90D74CAAACB6A995565647333DC17092D320131089CCCD6331CB3A595D ;
  1BA299A32FF4D8E5DD1EB46A2A57935F6FE637322D3BC4F67CFED6C2254C089C ; retail
  62FA11D0824A844C79EE5A4F273D46C23BBBF0A2AF6ACADBE646F46B86D1289C ; version
  7FF7E816CFDA4BC33DFF9D175AC69F72406C071B51F45A1ACB87F168C177CB9B ;
  E6C392F0341849AE5D510D26EEC1097BEBFB9D144A1647301BEAF9520D22C55A ;
  F46D49284CC7F9FBBA371A6D6E4C55F1E536D6237FFF54B3E9C11A20CFCCAC0C ;
  6B06F695766ACEB18BE33299A94CFCA7E258818652F7526B306B52E0AED04218 ;/
  53CB0E4EB1A6FF84284BE0E7385AB4A686A8BBCBC16102479280E0583655D271 ;\
  3FE506FAEE74F8D10F1220441CC2FF5D6DDE99BE79C19B386CAF68D5EB8CED1A ;
  AB4D243C5F398680D31CD2E3C9DD5670F2A88D563B8F65F5B234FD2EBB3BE44A ; debug
  3B6C302722A2ADFB56AE3E1F6417BDEC1E5A86AABBAFBE9419ACA8FDCD45E2CD ; version
  F1EB695F6EA87816122D7BE98EEF92C0814B16B215B31D8C813BB355CEA8138F ;
  B3BF2374246842CD91E1F9AAFF76878617CE02064777AEA0876A2C245C784341 ;
  CDEE90D691745908A6FF9CE781166796F9F1238F884C84D6F1EEBB2E40B4BCA0 ;
  0A7B1E913E0980D29FF6061D8AA944C663F2638127F7CCAB6FC71538471A5138 ;/
```



## FIRM Signature (in eMMC)


The eMMC's FIRM Header is encrypted via console-specific AES keys. Patching
this area requires access to the corresponding AES keyslot (or knowing the OTP
seed value that was used to generate that key). Alternately, knowing the
decrypted content of the currently installed firmware version will also help
(then one can simply XOR the encrypted bytes by old & new unencrypted
bytes).

```
  B6724531C448657A2A2EE306457E350A10D544B42859B0E5B0BED27534CCCC2A ;\
  4D47EDEA60A7DD99939950A6357B1E35DFC7FAC773B7E12E7C1481234AF141B3 ;
  1CF08E9F62293AA6BAAE246C15095F8B78402A684D852C680549FA5B3F14D9E8 ; retail
  38A2FB9C09A15ABB40DCA25E40A3DDC1F58E79CEC901974363A946E99B4346E8 ; version
  A372B6CD55A707E1EAB9BEC0200B5BA0B661236A8708D704517F43C6C38EE956 ;
  0111E1405E5E8ED356C49C4FF6823D1219AFAEEB3DF3C36B62BBA88FC15BA864 ;
  8F9333FD9FC092B8146C3D908F73155D48BE89D72612E18E4AA8EB9B7FD2A5F7 ;
  328C4ECBFB0083833CBD5C983A25CEB8B941CC68EB017CE87F5D793ACA09ACF7 ;/
  88697CDCA9D1EA318256FCD9CED42964C1E98ABC6486B2F128EC02E71C5AE35D ;\
  63D3BF1246134081AF68754787FCB922571D7F61A30DE4FCFA8293A9DA512396 ;
  F1319A364968464CA9806E0A52567486754CDDD4C3A62BDCE255E0DEEC230129 ; debug
  C1BAE1AE95D786865637C1E65FAE83EDF8E7B07D17C0AADA8F055B640D45AB0B ; version
  AC76FF7B3439F5A4BFE8F7E0E103BCE995FAD913FB729D3D030B2644EC483964 ;
  24E0563A1B3E6A1F680B39FC1461886FA7A60B6B56C5A846554AE648FC46E30E ;
  24678FAF1DC3CEB10C2A950F4FFA2083234ED8DCC3587A6D751A7E9AFA061569 ;
  55084FF2725B698EB17454D9B02B6B76BE47ABBE206294366987A4CAB42CBD0B ;/
```



## FIRM Signature (in WifiFlash or NtrCard)


These FIRM Headers are encrypted via fixed AES keys, and can be thus generated
without knowing console-specific keys. However, there are some hardware
requirements:

WifiFlash must have the write-protect pin disabled, and offset 400h must be
writeable (this does require a SPI flash chip with 128Kbyte or more; and won't
work with the normal built-in 4Kbyte chip). And, the eMMC firm sections must be
'destroyed' to trigger WifiFlash booting.

NtrCard requires a NDS flashcart, and support for rewriting its "bootmenu"
memory region. And, key combination Start+Select+X with shell closed is needed
to trigger NtrCard booting.

```
  37E96B10BAF28C74A710EF35824C93F5FBB341CEE4FB446CE4D290ABFCEFACB0 ;\
  63A9B55B3E8A65511D900C5A6E9403AAB5943CEF3A1E882B77D2347942B9E9EB ;
  0D7566370F0CB7310C38CB4AC940D1A6BB476BCC2C487D1C532120F1D2A37DDB ; retail
  3E36F8A2945BD8B16FB354980384998ECC380CD5CF8530F1DAD2FD74BA35ACB9 ; version
  C9DA2C131CB295736AE7EFA0D268EE01872EF033058ABA07B5C684EAD60D76EA ;
  84A18D866307AAAAB764786E396F2F8B630E60E30E3F1CD8A67D02F0A88152DE ;
  7A9E0DD5E64AB7593A3701E4846B6F338D22FD455D45DF212C5577266AA8C367 ;
  AE6E4CE89DF41691BF1F7FE58F2261F5D251DF36DE9F5AF1F368E650D576810B ;/
  18722BC76DC3602E2C0171F3BCA12AB40EA6D112AEFBECF4BE7A2A58FF759058 ;\
  A93C95CDA9B3B676D09A4E4C9E842E5C68229A6A9D77FAC76445E78EB5B363F8 ;
  C66B166BE65AFAE40A1485A364C2C13B855CEEDE3DFEACEC68DD6B8687DD6DF8 ; debug
  B6D3213F72252E7C03C027EE6079F9C5E0290E5DB8CA0BBCF30FCAD72EB637A1 ; version
  70C4A2F41D96BF7D517A2F4F335930DC5E9792D78EDFB51DC79AD9D7A4E7F1ED ;
  4D5A5C621B6245A7F1652256011DC32C49B955304A423009E2B78072CEBC12B3 ;
  85B72F926F19318D64075F09278FBA8448FD2484B82654A55D064542A8F5D9F9 ;
  828CDA5E60D31A40CF8EF18D027310DA4F807988BC753C1EB3B3FC06207E84DE ;/
```



## SIGHAX.BIN


This signature is for unknown purpose (probably Retail eMMC FIRM, too):

```
  6EFF209C8F4AF61F062413D602CA6B4DA1EB5AB9B6F1A2AB226A711DA2CCC27C
  74DE1741143BF69058284CAF444F92A45AAFD5A068043323D48AF1D0EC05564E
  BC79B55134E91A86C3788C97BC29D5A58A8A45255843B89122C7804542F72677
  C8DA5EB7429BAF18F7A8B02E8BB940FE990E9DC97EDCF49DDB18092C28206E74
  6753CC7C6E92362AA8D546B38D9E8D4311A6B1930DA14897807E304B5E1EC085
  6EEFD62CEAEEF28B08BD80397A181560AE6FCE39D09C39DC3DED8C870AB6ABCE
  2894940C0E9C4174F0131A0DA0747C4A7A42C9EC3487F109E252B7A9B865AE47
  7895E8D6A42A0717C40BCCC7A735F33B1E3766AB0E4B5D681BAB410734AB62B0
```



## Links & Credits


- [http://www.sighax.com/](http://www.sighax.com/) ;one signature, and some general info

- [http://gist.github.com/SciresM/cdd2266efb80175d37eabbe86f9d8c52](http://gist.github.com/SciresM/cdd2266efb80175d37eabbe86f9d8c52) ;six signatures




# <a name="3dsdmaregisters"></a>3DS DMA Registers




## ARM9 NDMA


- [3DS DMA - NDMA Registers](#3dsdmandmaregisters)


## ARM9 XDMA and ARM11 CDMA


- [3DS DMA - Corelink DMA Peripheral IDs](#3dsdmacorelinkdmaperipheralids)
- [3DS DMA - Corelink DMA Register Summary](#3dsdmacorelinkdmaregistersummary)
- [3DS DMA - Corelink DMA - Interrupt and Fault Status Registers](#3dsdmacorelinkdmainterruptandfaultstatusregisters)
- [3DS DMA - Corelink DMA - Internal State Status Registers](#3dsdmacorelinkdmainternalstatestatusregisters)
- [3DS DMA - Corelink DMA - Transfer Start (aka "Debug" Registers)](#3dsdmacorelinkdmatransferstartakadebugregisters)
- [3DS DMA - Corelink DMA - Fixed Configuration and ID Registers](#3dsdmacorelinkdmafixedconfigurationandidregisters)
- [3DS DMA - Corelink DMA Opcode Summary](#3dsdmacorelinkdmaopcodesummary)
The ARM Corelink DMA hardware is documented in

```
  DDI0424D_dma330_r1p2_trm        - DMA controller (also covers r0p0 and r1p1)
  IHI0022D amba axi_specification - Memory (ARCACHE, ARPROT etc.)
```



## ARM11 GPU DMA


- [3DS GPU External Registers - Memfill and Memcopy](#3dsgpuexternalregistersmemfillandmemcopy)
The GPU does probably also have DMA(s) for reading things like command lists,
and texture data, and for rendering to framebuffer.




# <a name="3dsdmandmaregisters"></a>3DS DMA - NDMA Registers




## NDMA (ARM9 only)


10002000h ARM9

Same as DSi, except, there seem to be 8 channels (instead of 4).

- [DSi New DMA (NDMA)](ds.html#dsinewdmandma)
And with new bit in NDMAGCNT register:

```
  0        SAD/DAD/TCNT/WCNT register read (0=Written value, 1=Current value)
```

And with new bits in NDMAxCNT registers:

```
  0-4      New extra startup mode bits (used if startup=0Fh)
  5-9      Unknown (unused on DSi, seem to be always 0 on 3DS, too)
```

And with changed startup modes:

```
  00h      TIMER0                                       (Port 10003000h)
  01h      TIMER1                                       (Port 10003004h)
  02h      TIMER2                                       (Port 10003008h)
  03h      TIMER3                                       (Port 1000300Ch)
  04h      CTRCARD0                                    (maybe 10004000h)
  05h      CTRCARD1                                    (maybe 10005000h)
  06h      SDMMC controller (eMMC and SD/MMC slot)      (Port 10006000h)
  07h      SDxx ?     ... apparently not SDIO wifi?    (maybe 10007000h)
  08h      AES IN (WRFIFO)                              (Port 10009008h)
  09h      AES OUT (RDFIFO)                             (Port 1000900Ch)
  0Ah      SHA IN (WRFIFO)                              (Port 1000A000h)
  0Bh      SHA OUT (RDFIFO) (optional readback)         (Port 1000A000h)
  0Ch      NTRCARD      (used so by bootrom)           (maybe 10164000h)
  0Dh      ?
  0Eh      ?
  0Fh      See below (subclassed)
  10h-1Fh  Start immediately (without repeat)
```

Mode 0Fh is subclassed by new bits from NDMAxCNT.bit0-4:

```
  0Fh.00h     exists, related to SPI_CARD and AES IN     ;guess:
  0Fh.01h     exists, related to SPI_CARD and AES IN     ;maybe these also
  0Fh.02h     exists, related to SPI_CARD and AES OUT    ;work with CTRCARD0/1
  0Fh.03h     exists, related to SPI_CARD and AES OUT
  0Fh.04h     exists, related to SPI_CARD and SHA IN
  0Fh.05h     exists, related to SPI_CARD and SHA IN
  0Fh.06h     exists, related to SPI_CARD and SHA OUT
  0Fh.07h     exists, related to SPI_CARD and SHA OUT
  0Fh.08h     SDMMC DATA32 to AES IN  ?    ;used by bootrom
  0Fh.09h     ?   <-- maybe as above for 2nd SDxx controller?
  0Fh.0Ah     exists related to SDMMC and AES OUT
  0Fh.0Bh     ?
  0Fh.0Ch     exists related to SDMMC and SHA IN  ;(SHA at time of SDMMC!)
  0Fh.0Dh     ?
  0Fh.0Eh     exists related to SDMMC and SHA OUT
  0Fh.0Fh     ?
  0Fh.10h     AES OUT to SHA IN       ?    ;used by bootrom
  0Fh.11h     exists related AES IN and SHA OUT
  0Fh.12h-1Fh ?
```

Obviously still missing is MIC microphone (which should be supported by either
NDMA, XDMA, or CDMA) (but maybe needs to be enabled somewhere, maybe selecting
ARM/TEAK as target?).

Also nice would be having SDIO-Wifi on ARM9 side somewhere. Old NDS-Wifi might
exist somewhere, too?




# <a name="3dsdmacorelinkdmaperipheralids"></a>3DS DMA - Corelink DMA Peripheral IDs




## CDMA Peripheral IDs (ARM11)


```
  00h                   Microphone (requires 1014010Ch.bit0=1)
  01h                   NTRCARD    (requires 1014010Ch.bit1=1)
  02h   camera (cam)    Camera Bus 0 (DSi cameras)     (Port 10120000h)
  03h   camera (cam)    Camera Bus 1 (left-eye camera) (Port 10121000h)
  04h   nwm             maybe wifi controller?
  05h   nwm             maybe debug wifi?
  06h   camera (y2r)    Y2R_0 INPUT_Y      ;\      (Port 10302000h)
  07h   camera (y2r)    Y2R_0 INPUT_U      ;       (Port 10302080h)
  08h   camera (y2r)    Y2R_0 INPUT_V      ; Y2R   (Port 10302100h)
  09h   camera (y2r)    Y2R_0 INPUT_YUV    ;       (Port 10302180h)
  0Ah   camera (y2r)    Y2R_0 OUTPUT_RGBA  ;/      (Port 10302200h)
  0Bh   fs              HASH (SHA FIFO IN) ;\SHA   (Port 10101000h)
  0Ch                   HASH (SHA FIFO OUT);/      (Port 10101000h)
  0Dh   TwlBg           LGYFB_0            ;\GBA   (Port 10110000h)
  0Eh   TwlBg           LGYFB_1            ;/NDS   (Port 10111000h)
  0Fh                   SPI_BUS0 (FIFO)    ;\      (Port 10160000h)
  10h                   SPI_BUS1 (FIFO)    ; SPIs  (Port 10142000h)
  11h                   SPI_BUS2 (FIFO)    ;/      (Port 10143000h)
  12h   mvd (y2r2)      Y2R_1 INPUT_Y      ;\    ;\
  13h   mvd (y2r2)      Y2R_1 INPUT_U      ;     ;
  14h   mvd (y2r2)      Y2R_1 INPUT_V      ; Y2R ; new CDMA controller
  15h   mvd (y2r2)      Y2R_1 INPUT_YUV    ;     ; in New3DS only
  16h   mvd (y2r2)      Y2R_1 OUTPUT_RGBA  ;/    ;
  17h   mvd             L2B_0 INPUT        ;\L2B ;
  18h   mvd             L2B_0 OUTPUT       ;/    ;
  19h   mvd             L2B_1 INPUT        ;\L2B ;
  1Ah   mvd             L2B_1 OUTPUT       ;/    ;
  1Bh                                            ;
  1Ch                                            ;
  1Dh                                            ;
  1Eh                                            ;
  1Fh                                            ;/
```

New3DS can use both Old CDMA and NewDMA, however, the peripheral data requests
are sent only to either one (as selected in Port 10140410h).

Apart from peripherals, concerning ROM/RAM memory:

- CDMA can probably access whatever ARM11 memory (maybe whatever or so?)

- CDMA might maybe use Virtual memory addresses instead of physical addresses?



## XDMA Peripheral IDs (ARM9)


```
  00h   Process9        "CTRCARD"(CARD0?) or SPI_CARD (FIFO) (Port 1000D000h)
  01h                   ?  (maybe CARD1?) or SPI_CARD (FIFO) (Port 1000D000h)
  02h                   ?
  03h                   ?
  04h                   AES IN (WRFIFO)                      (Port 10009008h)
  05h                   AES OUT (RDFIFO)                     (Port 1000900Ch)
  06h   unused???       SHA FIFO IN                          (Port 1000A000h)
  07h   Process9        SHA FIFO OUT (optional readback)     (Port 1000A000h)
```

Apart from peripherals, concerning ROM/RAM memory:

- XDMA can access ARM9 memory (probably Main RAM, and AXI, and maybe others?)

- XDMA reportedly cannot access the ARM9 bootrom at all




# <a name="3dsdmacorelinkdmaregistersummary"></a>3DS DMA - Corelink DMA Register Summary




## Corelink DMA Engines


```
  1000C000h ARM9  XDMA CoreLink DMA-330 r0p0 (four channels)
  10200000h ARM11 CDMA CoreLink DMA-330 r0p0 (eight channels)
  10206000h ARM11 CDMA CoreLink DMA-330 r1p1 (eight channels) (New3DS only)
  10300000h ARM11 DMA region (aka FIFOs are here?)
```

The New3DS has two DMA controllers on ARM11 side (the r0p0 is used by bootrom,
and, after bootrom, everything is usually done by r1p1).



## DMAC Control Registers


```
  10xxx000h       DSR           DMA Manager Status Register (R)
  10xxx004h       DPC           DMA Manager Program Counter (R)
  10xxx008h-01Ch  -             Reserved
  10xxx020h       INTEN         Interrupt Enable Register (R/W)
  10xxx024h       INT_EVENT_RIS Event-Interrupt Raw Status Register (R)
  10xxx028h       INTMIS        Interrupt Status Register (R)
  10xxx02Ch       INTCLR        Interrupt Clear Register (W)
  10xxx030h       FSRD          DMA Manager Fault Status Register (R)
  10xxx034h       FSRC          DMA Channel(s) Fault Status Register (R)
  10xxx038h       FTRD          DMA Manager Fault Type Register (R)
  10xxx03Ch       -             Reserved
  10xxx040h+n*4   FTRn          DMA channel n Fault type (R)
  10xxx060h-0FCh  -             Reserved
```


## DMAC Channel Thread Status Registers


```
  10xxx100h+n*8   CSRn          DMA channel n Channel status (R)
  10xxx104h+n*8   CPCn          DMA channel n Channel PC (R)
  10xxx140h-3FCh  -             Reserved
```


## DMAC AXI Status and Loop Counter Registers


```
  10xxx400h+n*20h SARn          DMA channel n Source address (R)
  10xxx404h+n*20h DARn          DMA channel n Destination address (R)
  10xxx408h+n*20h CCRn          DMA channel n Channel control (R)
  10xxx40Ch+n*20h LC0_n         DMA channel n Loop counter 0 (R)
  10xxx410h+n*20h LC1_n         DMA channel n Loop counter 1 (R)
  10xxx414h+n*20h -             Reserved
  10xxx418h+n*20h -             Reserved
  10xxx41Ch+n*20h -             Reserved
  10xxx500h-CFCh  -             Reserved
```


## DMAC Debug Registers (debugging is meant to be synonym for "start execution")


```
  10xxxD00h       DBGSTATUS     Debug Status Register (R)
  10xxxD04h       DBGCMD        Debug Command Register (W) (start INST code)
  10xxxD08h       DBGINST0      Debug Instruction-0 (W) (code[2]+ch+thread)
  10xxxD0Ch       DBGINST1      Debug Instruction-1 (W) (byte[4])
  10xxxD10h-DFCh  -             Reserved
```


## DMAC Configuration Registers


```
  10xxxE00h       CR0           Config Register 0, Misc Info (R)
  10xxxE04h       CR1           Config Register 1, Cache Info (R)
  10xxxE08h       CR2           Config Register 2, Boot Address (R)
  10xxxE0Ch       CR3           Config Register 3, Boot Event/Irq Security (R)
  10xxxE10h       CR4           Config Register 4, Boot Peripheral Security (R)
  10xxxE14h       CRD           DMA Configuration Register (R)
  10xxxE18h-E7Ch  -             Reserved
  10xxxE80h       WD            Watchdog Register (R/W) (rev1 only)
  10xxxE84h-FDCh  -             Reserved
```


## Peripheral and component identification register


```
  10xxxFE0h-FECh  periph_id_n   Peripheral Identification Registers 0-3 (R)
  10xxxFF0h-FFCh  pcell_id_n    Component Identification Registers 0-3 (R)
```



## CR0 values on 3DS


```
  [1000CE00h]=000167035h  ;ARM9         (12 events, 8 peripherals, 4 channels)
  [10200E00h]=0001f1075h  ;Old3DS/ARM11 (16 events, 18 peripherals, 8 channels)
  [10206E00h]=0003ff075h  ;New3DS/ARM11 (32 events, 32 peripherals, 8 channels)
```




# <a name="3dsdmacorelinkdmainterruptandfaultstatusregisters"></a>3DS DMA - Corelink DMA - Interrupt and Fault Status Registers



```
 ___________________________ DMAC Control Registers ___________________________
```



## 10xxx000h - DSR - DMA Manager Status Register (R)


```
  0-3   DMA Manager State (see below)
  4-8   DMA Manager DMA_WFE opcode (wait for event) (0..31 = Event 0..31)
  9     DMA Manager Non-Secure state (0=Secure, 1=Non-secure)
  10-31 Unused (undef)
```

DMA Manager States:

```
  00h     = Stopped
  01h     = Executing
  02h     = Cache Miss
  03h     = Updating PC
  04h     = Wait for event (WFE, see bit4-8 for event number)
  05h-0Eh = Reserved
  0Fh     = Faulting
```



## 10xxx004h - DPC - DMA Manager Program Counter (R)


```
  0-31  DMA Manager Program Counter
```



## 10xxx020h - INTEN - Interrupt Enable Register (R/W)


```
  0-31  Mode for DMA_SEV opcode event 0-31 "event_irq_select for event 0..31"
```

Bit [N] = 0 If the DMAC executes DMASEV for the event-interrupt resource N then
the DMAC signals event N to all of the threads. Set bit [N] to 0 if your system
design does not use irq[N] to signal an interrupt request.

Bit [N] = 1 If the DMAC executes DMASEV for the event-interrupt resource N then
the DMAC sets irq[N] HIGH. Set bit [N] to 1 if your system design requires
irq[N] to signal an interrupt request.

Note: See DMASEV on page 4-14 for information about selecting an event number.



## 10xxx024h - INT\_EVENT\_RIS - Event-Interrupt Raw Status Register (R)



## 10xxx028h - INTMIS - Interrupt Status Register (R)


```
  0-31  Event/Interrupt 0-31 Active (0=Inactive/Low, 1=Active/High)
```



## 10xxx02Ch - INTCLR - Interrupt Clear Register (W)


```
  0-31  Interrupt 0-31 (0=No change, 1=Clear Interrupt)
```



## 10xxx030h - FSRD - DMA Manager Fault Status Register (R)


```
  0     DMA Manager Thread in Faulting state (0=No, 1=Fault)
  1-31  Unused (undef)
```



## 10xxx034h - FSRC - DMA Channel(s) Fault Status Register (R)


```
  0-7   Fault Status for channel 0-7 (0=No, 1=Fault)
  8-31  Unused (undef)
```



## 10xxx038h - FTRD - DMA Manager Fault Type Register (R)


```
  0     Undefined Instruction                                   (0=No, 1=Fault)
  1     Invalid Instruction Operand                             (0=No, 1=Fault)
  2-3   Unused (undef)
  4     DMA_GO with inappropriate security permissions          (0=No, 1=Fault)
  5     DMA_WFE or DMA_SEC with inappropriate security          (0=No, 1=Fault)
  6-15  Unused (undef)
  16    AXI Response on RRESP bus              (0=OKAY, 1=EXOKAY/SLVERR/DECERR)
  17-29 Unused (undef)
  30    DMA Abort program-counter location (0=System memory, 1=Debug interface)
  31    Unused (undef)
```



## 10xxx040h+n\*4 - FTRn - DMA channel n Fault type (R)


```
  0     Undefined Instruction                                   (0=No, 1=Fault)
  1     Invalid Instruction Operand                             (0=No, 1=Fault)
  2-4   Unused (undef)
  5     DMA_WFE or DMA_SEC with inappropriate security          (0=No, 1=Fault)
  6     Non-secure tried DMAWFP,DMALDP,DMASTP,DMAFLUSHP         (0=No, 1=Fault)
  7     Non-secure channel tried to change CCR                  (0=No, 1=Fault)
  8-11  Unused (undef)
  12    MFIFO too small for DMALD/DMAST                         (0=No, 1=Fault)
  13    MFIFO lacks data for DMAST                              (0=No, 1=Fault)
  14-15 Unused (undef)
  16    AXI Response on RRESP bus, opcode      (0=OKAY, 1=EXOKAY/SLVERR/DECERR)
  17    AXI Response on BRESP bus, data.write  (0=OKAY, 1=EXOKAY/SLVERR/DECERR)
  18    AXI Response on RRESP bus, data.read   (0=OKAY, 1=EXOKAY/SLVERR/DECERR)
  19-29 Unused (undef)
  30    DMA Abort program-counter location (0=System memory, 1=Debug interface)
  31    DMA channel locked-up because of insufficient resources (0=No, 1=Fault)
```




# <a name="3dsdmacorelinkdmainternalstatestatusregisters"></a>3DS DMA - Corelink DMA - Internal State Status Registers



```
 ____________________ DMAC Channel Thread Status Registers ____________________
```



## 10xxx100h+n\*8 - CSRn - DMA channel n Channel status (R)


```
  0-3   Channel Status   (see below)
  4-8   Wakeup number    (0-31, channel is waiting for event/peripheral 0-31)
  9-13  Unused (undef)
  14    DMAWFP executed with single/burst operand set     (0=Single, 1=Burst)
  15    DMAWFP executed with/without periph operand set   (0=Without, 1=With)
  16-20 Unused (undef)
  21    Channel operates in Non-Secure state         (0=Secure, 1=Non-secure)
  22-31 Unused (undef)
```

Channel Status:

```
  00h     = Stopped
  01h     = Executing
  02h     = Cache miss
  03h     = Updating PC
  04h     = Waiting for event
  05h     = At barrier
  06h     = reserved
  07h     = Waiting for peripheral
  08h     = Killing
  09h     = Completing
  0Ah-0Dh = reserved
  0Eh     = Faulting completing
  0Fh     = Faulting
```



## 10xxx104h+n\*8 - CPCn - DMA channel n Channel PC (R)


```
  0-31  DMA Channel's Program Counter
```


```
 _________________ DMAC AXI Status and Loop Counter Registers _________________
```



## 10xxx400h+n\*20h - SARn - DMA channel n Source address (R)



## 10xxx404h+n\*20h - DARn - DMA channel n Destination address (R)


```
  0-31  DMA Channel's Source/Destination memory address
```



## 10xxx408h+n\*20h - CCRn - DMA channel n Channel control (R)


```
  0     Source Burst type      (0=Fixed address, 1=Incrementing address)
  1-3   Source Burst size      (0-4 = 1,2,4,8,16 bytes per beat) (5-7=Reserved)
  4-7   Source Burst len       (0-15 = 1..16 data transfers)
  8     Source ARPROT.bit0 Privileged  (0=Unprivileged, 1=Privileged) ;\access
  9     Source ARPROT.bit1 Non-secure  (0=Secure, 1=Non-secure)       ; type
  10    Source ARPROT.bit2 Instruction (0=Data, 1=Instruction)        ;/
  11-13 Source ARCACHE.bit0-2         ;ARCACHE.bit3 is always low
  14    Dest Burst type (0=Fixed address, 1=Incrementing address)
  15-17 Dest Burst size (0-4 = 1,2,4,8,16 bytes per beat) (5-7=Reserved)
  18-21 Dest Burst len  (0-15 = 1..16 data transfers)
  22    Dest AWPROT.bit0 Privileged    (0=Unprivileged, 1=Privileged) ;\access
  23    Dest AWPROT.bit1 Non-Secure    (0=Secure, 1=Non-secure)       ; type
  24    Dest AWPROT.bit2 Instruction   (0=Data, 1=Instruction)        ;/
  25-27 Dest AWCACHE.bit0,1,3  ;AWCACHE.bit2 is always low
  28-30 Endian swap bytes  (0=Off) (1-4=Within 16,32,64,128 bit) (5-7=Reserved)
  31    Unused (undef)
```

Bit9,23 should/must be both set, else faults (depending on secure mode, or so).



## 10xxx40Ch+n\*20h - LC0\_n - DMA channel n Loop counter 0 (R)



## 10xxx410h+n\*20h - LC1\_n - DMA channel n Loop counter 1 (R)


```
  0-7   Remaining loop count, minus 1   (00h..FFh = Loop 1..256 times)
  8-31  Unused (undef)
```




# <a name="3dsdmacorelinkdmatransferstartakadebugregisters"></a>3DS DMA - Corelink DMA - Transfer Start (aka "Debug" Registers)



```
 ____________________________ DMAC Debug Registers ____________________________
         (debugging is meant to be a synonym for "start execution")
```



## 10xxxD00h - DBGSTATUS - Debug Status Register (R)


```
  0     Debug Status  (0=Idle, 1=Busy)    ;aka INST0/INST1 busy?
  1-31  Unused (undef)
```



## 10xxxD04h - DBGCMD - Debug Command Register (W) (start INST code)


```
  0-1   Execution (0=Execute DBGINST, 1..3=Reserved)
  2-31  Unused (0)
```



## 10xxxD08h - DBGINST0 - Debug Instruction-0 (W) (code[2]+ch+thread)



## 10xxxD0Ch - DBGINST1 - Debug Instruction-1 (W) (byte[4])


```
  0     Debug thread  (0=DMA Manager thread, 1=DMA channel 0..7) ;\
  1-7   Reserved (0)                                             ; usually
  8-10  DMA channel (0..7 for channel 0..7) (when above bit0=1)  ; zero
  11-15 Reserved (0)                                             ;/
  16-23 Instruction Byte 0    ;-usually DMA_GO opcode
  24-31 Instruction Byte 1    ;-usually target_channel for DMA_GO
  32-39 Instruction Byte 2    ;\
  40-47 Instruction Byte 3    ; usually target_address for DMA_GO
  48-55 Instruction Byte 4    ;
  56-63 Instruction Byte 5    ;/
```

Examples:

```
  db 00h,00h,DMA_GO,<chn>,<addr32bit>  ;<-- start channel code
  db 01h,<chn>,DMA_KILL,0,0,0,0,0      ;<-- kill channel (eg. after fault/hang)
```




# <a name="3dsdmacorelinkdmafixedconfigurationandidregisters"></a>3DS DMA - Corelink DMA - Fixed Configuration and ID Registers



```
 ________________________ DMAC Configuration Registers ________________________
```



## 10xxxE00h - CR0 - Configuration Register 0 - Misc Info (R)


```
  0     Peripheral Requests supported         (0=None, 1=Yes, see bit12-16)
  1     boot_from_pc signal state at reset    (0=Was Low, 1=Was High)
  2     boot_manager_ns signal state at reset (0=Was Low, 1=Was High)
  3     Reserved (undef)
  4-6   Number of supported DMA channels      (0..7 = 1..8 channels)
  7-11  Reserved (undef)
  12-16 Number of supported Peripherals       (0..31 = 1..32 peripherals)
  17-21 Number of supported Interrupt outputs (0..31 = 1..32 interrupts)
  22-31 Reserved (undef)
```

Bit1/2 are probably related to CR2 boot address, excecuting in secure or
non-secure state... but it's unspecified if Low/High means on or off.

```
  CR0 values on 3DS:
  [1000CE00h]=000167035h  ;ARM9         (12 events, 8 peripherals, 4 channels)
  [10200E00h]=0001f1075h  ;Old3DS/ARM11 (16 events, 18 peripherals, 8 channels)
  [10206E00h]=0003ff075h  ;New3DS/ARM11 (32 events, 32 peripherals, 8 channels)
```



## 10xxxE04h - CR1 - Configuration Register 1 - Cache Info (R)


```
  0-2   Size of an i-cache line (2,3,4,5 = 4,8,16,32 bytes) (0,1,6,7=Reserved)
  3     Reserved (undef)
  4-7   Number of i-cache lines (0..15 = 1..16 lines)
  8-31  Reserved (undef)
```



## 10xxxE08h - CR2 - Configuration Register 2 - Boot Address (R)


```
  0-31  Reset entrypoint (for DMA Manager?)
```



## 10xxxE0Ch - CR3 - Configuration Register 3 - Boot Event/Irq Security (R)


```
  0-31  Security state for Event-interrupt 0..31 (0=Secure, 1=Non-secure)
```



## 10xxxE10h - CR4 - Configuration Register 4 - Boot Peripheral Security (R)


```
  0-31  Security state for Peripheral 0..31      (0=Secure, 1=Non-secure)
```



## 10xxxE14h - CRD - DMA Configuration Register (R)


```
  0-2   AXI master Data width (2,3,4 = 32,64,128 bit) (0,1,5,6,7=Reserved)
  3     Reserved (undef)
  4-6   Write capability, max number outstanding transactions (0..7 = 1..8)
  7     Reserved (undef)
  8-11  Write queue depth                             (0..15 = 1..16 lines)
  12-14 Read capability, max number outstanding transactions  (0..7 = 1..8)
  15    Reserved (undef)
  16-19 Read queue depth                              (0..15 = 1..16 lines)
  20-29 Data buffer depth                         (0..3FFh = 1..1024 lines)
  30-31 Reserved (undef)
```



## 10xxxE80h - WD - Watchdog Register (R/W) (rev1 only)


Supported on rev1 only (ie. r1p0/r1p1/r1p2, but not r0p0).

```
  0     Action on Lock-up (0=IRQ and Abort contributing channels, 1=IRQ only)
  1-31  Reserved (undef)
```


```
 ______________ Peripheral and component identification register ______________
```



## 10xxxFE0h-FECh - periph\_id\_n - Peripheral Identification Registers 0-3 (R)


This region contains four 32bit registers (30h,13h,x4h,00h). One is supposed to
extract the lower 8bit of these 32bit values, and then to merge them into a
"conceptual-32bit-value" (00x41330h). And then interprete it as so:

```
  0-11  Part number            (330h=DMAC)
  12-19 Designer               (41h=ARM)
  20-23 Revision               (0=r0p0, 1=r1p0, 2=r1p1, 3=r1p2)
  24    Integration test logic (0=None, 1=Exists)
  25-31 Reserved (undef)
```



## 10xxxFF0h-FFCh - pcell\_id\_n - Component Identification Registers 0-3 (R)


This region contains four 32bit registers (0Dh,F0h,05h,B1h). One is supposed to
extract the lower 8bit of these 32bit values, and then to merge them into a
"conceptual-32bit-value" (B105F00Dh). And then interprete it as so:

```
  0-31  Component ID (B105F00Dh)
```




# <a name="3dsdmacorelinkdmaopcodesummary"></a>3DS DMA - Corelink DMA Opcode Summary




## Corelink DMA Opcode Summary


```
  Opcode             CM Syntax
  00h                CM DMAEND                  ;-done  (finish transfer)
  01h                CM DMAKILL                 ;-abort (unfinished transfer)
  04h                C- DMALD                   ;\
  05h                C- DMALDS           ;\cond ; load from SAR (to dmafifo)
  07h                C- DMALDB           ;/     ;/
  08h                C- DMAST                   ;\
  09h                C- DMASTS           ;\cond ; store to DAR (from dmafifo)
  0Bh                C- DMASTB           ;/     ;/
  0Ch                C- DMASTZ                  ;-store zero to DAR
  12h                C- DMARMB                  ;-read memory barrier
  13h                C- DMAWMB                  ;-write memory barrier
  18h                CM DMANOP                  ;-no operation (align padding)
  20h,len-1          C- DMALP lpc0,len          ;\loop start with loop count
  22h,len-1          C- DMALP lpc1,len          ;/
  25h,periph*8       C- DMALDPS periph   ;\     ;\load and notify peripheral
  27h,periph*8       C- DMALDPB periph   ; cond ;/
  29h,periph*8       C- DMASTPS periph   ;      ;\store and notify peripheral
  2Bh,periph*8       C- DMASTPB periph   ;/     ;/
  2Ch,rel_addr       C- DMALPEND                ;-loop end for DMALPFE
  30h,periph*8       C- DMAWFP periph,single    ;\
  31h,periph*8       C- DMAWFP periph,periph    ; wait for peripheral
  32h,periph*8       C- DMAWFP periph,burst     ;/
  34h,event*8        CM DMASEV event            ;-send event (or interrupt)
  35h,periph*8       C- DMAFLUSHP periph        ;-init peripheral
  36h,event*8+00h    CM DMAWFE event            ;\wait for event (with optional
  36h,event*8+02h    CM DMAWFE event,invalid    ;/  code cache invalidate)
  38h,rel_addr       C- DMALPEND  lpc0          ;\
  39h,rel_addr       C- DMALPENDS lpc0   ;\cond ;
  3Bh,rel_addr       C- DMALPENDB lpc0   ;/     ; loop end for DMALP lpc0/1
  3Ch,rel_addr       C- DMALPEND  lpc1          ;
  3Dh,rel_addr       C- DMALPENDS lpc1   ;\cond ;
  3Fh,rel_addr       C- DMALPENDB lpc1   ;/     ;/
  54h,imm16          C- DMAADDH SAR,imm16       ;\add halfword
  56h,imm16          C- DMAADDH DAR,imm16       ;/  ("positive")
  5Ch,imm16          C- DMAADNH SAR,imm16       ;\add imm16+0FFFF0000h
  5Eh,imm16          C- DMAADNH DAR,imm16       ;/  ("negative", rev1 only)
  A0h,channel,imm32  -M DMAGO channel,imm32     ;\jump/goto entrypoint
  A2h,channel,imm32  -M DMAGO channel,imm32,ns  ;/  (ns=non-secure mode)
  BCh,00h,imm32      C- DMAMOV SAR,imm32        ;\
  BCh,01h,imm32      C- DMAMOV CCR,imm32        ; move to register
  BCh,02h,imm32      C- DMAMOV DAR,imm32        ;/
  imm8               -- DCB imm8                ;\manually defined 'code'
  imm32              -- DCD imm32               ;/
  -  (no opcode)     C- DMALPFE   ;loop forever ;-loop start without loop count
```

All opcodes and parameters (except imm16/imm32) are 8bit wide. The CM column
indicates if the opcode can be used in Channel or Manager threads (or both).

The rel\_addr parameters are unsigned offsets (jump target is $-rel\_addr).



## Nocash Syntax


Allows MOV instead LP, and LOOP instead LPEND, and "ADD reg,+/-imm" instead of
"ADDH/ADNH reg,imm".




# <a name="3dsconfigregisters"></a>3DS Config Registers



- [3DS Config - CONFIG9 Registers](#3dsconfigconfig9registers)
- [3DS Config - CONFIG11 Registers](#3dsconfigconfig11registers)
- [3DS Config - AXI Registers](#3dsconfigaxiregisters)
- [3DS Config - L2C-310 Level 2 Cache Controller (New3DS)](#3dsconfigl2c310level2cachecontrollernew3ds)
- [3DS Config - ARM7 Registers (GBA/NDS/DSi Mode)](#3dsconfigarm7registersgbandsdsimode)



# <a name="3dsconfigconfig9registers"></a>3DS Config - CONFIG9 Registers




## CONFIG9 Registers (ARM9 only)


```
  Address Width Old3DS  Name                    Used by
  10000000h 1  Yes   CFG9_SYSPROT9              Boot9
  10000001h 1  Yes   CFG9_SYSPROT11             Boot9
  10000002h 1  Yes   CFG9_RST11                 Boot9
  10000004h 4  Yes   CFG9_DEBUGCTL
  10000008h 1  Yes   CFG9_AES                   Boot9, Process9, TwlProcess9
  1000000Ch 2  Yes   CFG9_CARD_CTL              Process9
  10000010h 1  Yes   CFG9_CARD_POWER            Process9
  10000012h 2  Yes   CFG9_CARD_INSERT_DELAY     Boot9, Process9
  10000014h 2  Yes   CFG9_CARD_PWROFF_DELAY     Boot9, Process9
  10000020h 2  Yes   CFG9_SDMMCCTL              Process9
  10000100h 2  Yes   CFG9_UNKNOWN
  10000200h 1  No    CFG9_EXTMEMCNT9 (New3DS)   NewKernel9
  10000FFCh 4  Yes   CFG9_MPCORECFG
  10010000h 4  Yes   CFG9_BOOTENV
  10010010h 1  Yes   CFG9_UNITINFO              Process9
  10010014h 1  Yes   CFG9_TWLUNITINFO           Process9
```



## 10000000h - CFG9\_SYSPROT9


```
  0     Disables ARM9 bootrom "(+8000h)" when set to 1, and enables access to
          FCRAM. Cannot be cleared to 0 once set to 1.  Boot9
  1     Disables OTP area when set to 1. Cannot be cleared to 0 once set to 1.
          NewKernel9Loader, Process9
  2-7   Unused (0)
```


On Old 3DS, NATIVE\_FIRM reads CFG9\_SYSPROT9 to know whether it has previously
initialized the TWL console-unique keys using the OTP data. After setting the
TWL console-unique keys, NATIVE\_FIRM sets CFG9\_SYSPROT9 bit 1 to disable the
OTP area. In subsequent FIRM launches prior to the next reset, NATIVE\_FIRM will
see that the OTP area is disabled, and skip this step.


On New 3DS, the above is instead done by the Kernel9 loader. In addition to
using the OTP data for initializing the TWL console-unique keys, the Kernel9
loader will generate the decryption key for NATIVE\_FIRM. The final keyslot for
NATIVE\_FIRM is preserved, so that at a non-reset FIRM launch, the keyslot can
be reused, since the OTP would then be inaccessible.



## 10000001h - CFG9\_SYSPROT11


```
  0     Disables ARM11 bootrom "(+8000h)" when set to 1, and enables access
          to FCRAM. Cannot be cleared to 0 once set to 1.  Boot9
  1-7   Unused (0)
```



## 10000002h - CFG9\_RST11


```
  0     Presumably takes ARM11 out of reset. Cannot be set to 1 once it has
          been cleared.
        Reportedly: Bit0 is actually for "write-protecting the bootrom area"
  1-7   Unused (0)
```



## 10000004h - CFG9\_DEBUGCTL


```
  0-31  Whatever, debug related (readonly, always zero on retail consoles)
```



## 10000008h - CFG9\_AES (R/W)


```
  0-1   Unknown (R/W)
  2-3   AES related? Value 3 written after write to AES_CTL (R/W)
  4-7   Unused (0)
```



## 1000000Ch - CFG9\_CARD\_CTL - Gamecard Controller Select (R/W)


```
  0-1   Gamecard ROM controller  (0=NTRCARD, 1=?, 2=CTRCARD0, 3=CTRCARD1)
  2-3   Unused (0)
  4     Gamecard SPI_CARD mode   (0=Manual, 1=FIFO)
  5-7   Unused (0)
  8     Gamecard SPI controller  (0=NTRCARD, 1=SPI_CARD)
  9-11  Unused (0)
  12    Unknown...? (R/W)
  13-15 Unused (0)
```

There are three controllers for ROM cartridge commands:

```
  xxx0h/xxx1h? NTRCARD  (8-byte commands)  (bit1=0)         (Port 10164000h)
  xxx2h        CTRCARD0 (16-byte commands) (bit1=1, bit0=0) (Port 10004000h)
  xxx3h        CTRCARD1 (16-byte commands) (bit1=1, bit0=1) (Port 10005000h)
```

And three controllers for SPI-bus cartridge savedata:

```
  x0x0h/x0x1h  NTRCARD Manual NDS-style    (bit8=0, bit1=0) (Port 10164000h)
  x0x2h/x0x3h  None                        (bit8=0, bit1=1) (N/A)
  x10xh        SPI_CARD in Manual Mode     (bit8=1, bit4=0) (Port 1000D000h)
  x11xh        SPI_CARD in FIFO Mode       (bit8=1, bit4=1) (Port 1000D800h)
```

The deselected controllers are disconnected from the cartridge bus (and tend to
return data=FFh when trying to read from the cartridge).



## 10000010h - CFG9\_CARD\_POWER (same as SCFG\_MC on DSi) (R/W)


```
  0     NDS Slot Game Cartridge (0=Inserted, 1=Ejected)               (R)
  1     NDS Slot Unknown/Unused (0)
  2-3   NDS Slot Power State (0=Off, 1=On+Reset, 2=On, 3=RequestOff)  (R/W)
  4-15  Unused (0)
```

Same as SCFG\_MC on DSi (but with the bits for 2nd cartridge slot removed). See
DSi specs for cartridge power on/off sequences.

- [DSi Control Registers (SCFG)](ds.html#dsicontrolregistersscfg)


## 10000012h - CFG9\_CARD\_INSERT\_DELAY (usually 1988h = 100ms) (R/W)



## 10000014h - CFG9\_CARD\_PWROFF\_DELAY (usually 264Ch = 150ms) (R/W)


Same as 4004012h/4004014h on DSi, see DSi SCFG registers for details.

```
  0-15  Delay in 400h cycle units (at 67.027964MHz)  ;max FFFFh=ca. 1 second
```

There are related IRQs on ARM9 and ARM11 side (CGC aka Change Gamecard or so):

```
  ARM9 IF.bit25, and ARM11 Interrupt 74h   ;at begin of PWROFF delay
  ARM9 IF.bit26, and ARM11 Interrupt 75h   ;at end of INSERT delay
```



## 10000020h - CFG9\_SDMMCCTL


Controls power? Also controls SD card detect?

```
  0     SD slot power                                 (1=Unknown?) Process9
  1     eMMC power? NAND init hangs if set            (1=Set?)     Process9
  2-3   Other power supplies?                         (??)         Process9
  4-5   Unused (0)
  6     Unknown, set at cold boot                     (1=Set?)     R/W
  7     Unknown                                       (?)          R/W
  8     ? This bit seems to do nothing.               (?)          Process9
  9     If not set force pulls all SD card lines high (0=Not set?) Process9
  10-15 Unused (0)
```

This register controls power of multiple ports/controllers and allows to map
controller 3 to ARM9 or ARM11. The SD card can be accessed on ARM11 by setting
bit8 and clearing bit9.

```
  0     Controller 1/3 port 0 power (SD card) (0=On, 1=Off)  ;10xxx000h.port0
  1     Controller 1 port 1 power (eMMC)      (0=On, 1=Off)  ;10006000h.port1
  2     Controller 2 port 0 power (WiFi SDIO) (0=On, 1=Off)  ;10122000h.port0
  3     Controller 3 port 1 power? Set at cold boot????      ;?
  4-5   Unused (0)
  6     Wifi port related? Pull up? Set at cold boot
  7         R/W
  8     Controller 3 mapping (0=ARM9 0x10007000, 1=ARM11 0x10100000)
  9     SD card controller select (0=0x10007000/0x10100000, 1=0x10006000)
  10-15 Unused (0)
```



## 10000100h - CFG9\_UNKNOWN


```
  0-1   Unknown (R/W)
  2     Unused (0)
  3     Unknown (R/W)
  4-7   Unused (0)
  8-13  Unknown (R/W)
  14-15 Unused (0)
```



## 10000200h - New3DS - CFG9\_EXTMEMCNT9


```
  0     New3DS: Extended ARM9 memory at 08100000h..0817FFFFh (0=Off, 1=On)
  1-31  Unused (0)
```



## 10000FFCh - CFG9\_MPCORECFG (R)


Identical to "PDN\_MPCORE\_CFG". Uh, what?

Above seems to refer to one of the "CONFIG11" registers.

Perhaps 10140FFCh - 16bit CFG11\_SOCINFO, though the ARM9 register is 32bit?

Or maybe one of the CFG11\_MPCORE\_xxx registers, though those are New3DS only?

Or maybe it does actually refer to ARM11 cp15 coprocessor registers???

Or maybe one of the MPCore registers at 17E0xxxxh?

PROBABLY it's CFG11\_SOCINFO (as they are both read-only 0007h on New3DS)!



## 10010000h - CFG9\_BOOTENV


```
  0-31  Value (0..FFFFFFFFh) (R/W)
```

This register is used to determine what the previous running FIRM was. Its
value is kept following an MCU reboot. Its initial value (on a cold boot) is 0.
NATIVE\_FIRM sets it to 1 on shutdown/FIRM launch.

```
  LGY FIRM writes value 3 here when launching a TWL title
  LGY FIRM writes value 7 when launching an AGB title
```

NATIVE\_FIRM will only launch titles if this is not value 0, and will only save
the AGB\_FIRM savegame to SD if this is value 7.



## 10010010h - CFG9\_UNITINFO (R)


This 8bit register is value zero for retail, non-zero for dev/debug units.



## 10010014h - CFG9\_TWLUNITINFO (R/W)


```
  0-1   Value (to be copied from CFG9_UNITINFO)
  2-7   Unused (0)
```

In the console-unique TWL key-init/etc function the ARM9 copies the u8 value
from REG\_UNITINFO to this register.




# <a name="3dsconfigconfig11registers"></a>3DS Config - CONFIG11 Registers




## CONFIG11 Registers (also referred to as "PDN" Registers)


```
  Address   Width Old3DS  Name                            Used by
  10140000h 1*8   Yes     CFG11_SHAREDWRAM_32K_CODE<0-7>  Boot11,Process9,DSP
  10140008h 1*8   Yes     CFG11_SHAREDWRAM_32K_DATA<0-7>  Boot11,Process9,DSP
  10140100h 2     Yes     ?
  10140102h 2     Yes     ?
  10140104h 1     Yes     CFG11_FIQ_CNT                   Kernel11
  10140105h 1     Yes     ?                               Kernel11
  10140108h 2     Yes     ?  Related to HID_PAD_IRQ (??)  TwlBg
  1014010Ch 2     Yes     CFG11_CDMA_CNT                  TwlBg
  10140140h 4     Yes     CFG11_GPUPROT                   Kernel11
  10140180h 1     Yes     CFG11_WIFICNT                   TwlBg, NWM Services
  101401C0h 4     Yes     CFG11_SPI_CNT                   SPI Services, TwlBg
  10140200h 4     Yes     ?
  10140400h 1     No      ?  Clock related?               NewKernel11
  10140410h 4     No      CFG11_CDMA_PERIPHERALS          NewKernel11
  10140420h 1     No      CFG11_BOOTROM_OVERLAY_CNT       NewKernel11
  10140424h 4     No      CFG11_BOOTROM_OVERLAY_VAL       NewKernel11
  10140428h 4     No      ?
  10140FFCh 2     Yes     CFG11_SOCINFO                   Boot11, Kernel11
  10141000h 2     Yes     CFG11_PDN_CNT          ;???     Kernel11, TwlBg
  10141008h 4     Yes     CFG11_PDN_WAKE_ENABLE           PTM, PDN
  1014100Ch 4     Yes     CFG11_PDN_WAKE_REASON           PTM, TwlBg, PDN
  10141100h 2     Yes     CFG11_TWLMODE_BOOT              TwlProcess9, TwlBg
  10141104h 2     Yes     CFG11_TWLMODE_SLEEP             TwlBg
  10141108h 2     Yes     CFG11_TWLMODE_2  ;IRQ? ;?       TwlBg
  1014110Ah 2     Yes     CFG11_TWLMODE_HID_IRQ           TwlBg
  1014110Ch 1     Yes     CFG11_WIFIUNK                   NWM Services
  10141110h 2     Yes     CFG11_TWLMODE_HID_MODE          TwlBg
  10141112h 2     Yes     CFG11_TWLMODE_HID_SET           TwlBg
  10141114h 2     Yes     CFG11_CODEC_0                   Codec, TwlBg
  10141116h 2     Yes     CFG11_CODEC_1                   Codec, TwlBg
  10141118h 1     Yes     ?                               TwlBg
  10141119h 1     Yes     ?                               TwlBg
  10141120h 1     Yes     ?                               TwlBg
  10141200h 4     Yes     CFG11_GPU_CNT         Boot11, Kernel11, PDN, TwlBg
  10141204h 4     Yes     CFG11_GPU_CNT2        Boot11, Kernel11, TwlBg
  10141208h 1     ?       ? GPU related?        Boot11
  10141210h 2     Yes     CFG11_FCRAM_CNT                 Kernel11, TwlBg
  10141220h 1     Yes     CFG11_CODEC_CNT                 Boot11, TwlBg, PDN
  10141224h 1     Yes     CFG11_CAMERA_CNT                PDN Services
  10141230h 1     Yes     CFG11_DSP_CNT                   Process9, PDN
  10141240h ?     No      unknown (nonzero in New3DS mode) XXX !!!!!!!!!!!!
  10141300h 4     No      CFG11_MPCORE_CLKCNT             NewKernel11
  10141304h 2     No      CFG11_MPCORE_CNT                NewKernel11
  10141310h 1     No      CFG11_MPCORE_BOOTCNT_CPU0       NewKernel11
  10141311h 1     No      CFG11_MPCORE_BOOTCNT_CPU1       NewKernel11
  10141312h 1     No      CFG11_MPCORE_BOOTCNT_CPU2       NewKernel11
  10141313h 1     No      CFG11_MPCORE_BOOTCNT_CPU3       NewKernel11
```



## 10140000h+0..7 - CFG11\_SHAREDWRAM\_32K\_CODE --- aka MBK



## 10140008h+0..7 - CFG11\_SHAREDWRAM\_32K\_DATA --- aka MBK


Used for mapping 32K chunks of shared WRAM for Teak DSP code/data.

```
  0     Master (0=ARM only, 1=ARM and DSP)
  1     Unused (0)
  2-4   Offset (0..7) (slot 0..7) (LSB of address in 32Kbyte units)
  5-6   Unused (0)
  7     Enable (0=Disable, 1=Enable)
```

ARM11 and ARM9 can access the memory regardless of bit0 (but trigger data abort
if bit7 is cleared, or on missing slot values in bit2-4).

```
  DSP Code is mapped at 1FF00000h..1FF3FFFFh in ARM memory (256Kbytes)
  DSP Data is mapped at 1FF40000h..1FF7FFFFh in ARM memory (256Kbytes)
```



## 10140100h - ??? 1bit? (R/W)



## 10140102h - ??? 1bit? (R)   -- But, cleared in New3DS mode?


Unknown.



## 10140104h - CFG11\_FIQ\_CNT


```
  0-1   FIQ related? (R/W)
  2-3   New3DS only: unknown...?      ;initially set, (R/W) in New3DS mode!
  4-7   Unused (0)
```

"Writing bit1 to this register disables FIQ interrupts.

This bit is set upon receipt of a FIQ interrupt and when svcUnbindInterrupt is
called on the FIQ-abstraction software interrupt for the current core. It is
cleared when binding that software interrupt to an event and just before that
event is signaled."

Maybe bit0-3 are for CPU0-3 (with above mentioned bit1 being for CPU1)? If the
bits are really FIQ related, then they are probably used on debug hardware
only.



## 10140105h - ???


```
  0-1   Unknown...? (R/W)
  2-3   New3DS only: unknown...?      ;initially set, (R/W) in New3DS mode!
  4-7   Unused (0)
```

Unknown. Maybe bit0-3 are for CPU0-3?



## 10140108h - Related to HID\_PAD\_IRQ (??) TwlBg


```
  0     Unknown...? (R/W)
  1-15  Unused (0)
```



## 1014010Ch - CFG11\_CDMA\_CNT (R/W)


```
  0     Enable Microphone DMA             (0=Off, 1=Enable CDMA 00h)      (R/W)
  1     Enable NTRCARD DMA on ARM11 side  (0=Off, 1=Enable CDMA 01h)      (R/W)
  2-3   Unused (0)
  4-5   Unknown...?                                                       (R/W)
  6-15  Unused (0)
```



## 10140140h - CFG11\_GPUPROT


```
  0-3   Old FCRAM DMA cutoff size, 0 = no protection
  4-7   New FCRAM DMA cutoff size, 0 = no protection   ;<--New3DS mode only
  8     AXI WRAM protection, 0 = accessible
  9-10  QTM DMA cutoff size                            ;<--New3DS mode only
  11-31 Unused (0)
```

The New3DS bits are writeable only after enabling New3DS mode.

When this register is set to value 0, the GPU can access the entire FCRAM, AXI
WRAM, and on New3DS all QTM-mem. On cold boot this reg is set to 0.

Initialized during kernel boot, and used with SVC 59h which was implemented
with v11.3.

```
  The first 800000h-bytes of Old FCRAM cannot be protected.
  The first 800000h-bytes of New FCRAM are protected if Old FCRAM cutoff<>0
  The first 100000h-bytes of QTM cannot be protected.
  Old FCRAM DMA cutoff protects from 28000000h-(800000h*x) until end of FCRAM
  New FCRAM DMA cutoff protects from 30000000h-(800000h*x) until end of FCRAM
  QTM DMA cutoff       protects from 1F400000h-(100000h*x) until end of QTM
```



## 10140180h - CFG11\_WIFICNT


```
  0     Enable wifi subsystem
  1-7   Unused (0)
```



## 101401C0h - CFG11\_SPI\_CNT


```
  0     SPI_BUS0 Mode (registers at 10160000h)  (0=Manual, 1=Fifo/Autopoll)
  1     SPI_BUS1 Mode (registers at 10142000h)  (0=Manual, 1=Fifo/Autopoll)
  2     SPI_BUS2 Mode (registers at 10143000h)  (0=Manual, 1=Fifo/Autopoll)
  3-31  Unused (0)
```

The registers for the deselected mode are disconnected from the bus, but they
are still working internally (that is, transfer attempts will finish after the
expected amount of time, but SPI reads return nothing useful: FFh for Manual
reads, and 00h for FIFO/Autopoll reads).



## 10140200h - ???


```
  0-31  Unknown (R/W)
```

Unknown.



## 10140400h - New3DS - Clock related?


```
  0-1   Unknown (R/W, even if New3DS didn't enable New3DS mode)
  2-31  Zero
```



## 10140410h - New3DS - CFG11\_CDMA\_PERIPHERALS (R/W)


```
  0-17  CDMA Peripheral 00h-11h data request target (0=Old CDMA, 1=New CDMA)
  18-31 Zero
```



## 10140420h - New3DS - CFG11\_BOOTROM\_OVERLAY\_CNT (R/W)


```
  0     ARM11 Bootrom Overlay Enable (0=Disable, 1=Enable)
  1-31  Unused (0)
```

When enabled, opcode/data reads from physical(?) address 00010000h-00010FFFh
and FFFF0000h-FFFF0FFFh will return following values:

```
  ARM11 Opcode reads --> E59FF018h    (opcode LDR PC,[$+20h]
  ARM11 Data reads   --> [10140424h]  (CFG11_BOOTROM_OVERLAY_VAL)
```

This is intended for redirecting the CPU2/3 reset vectors, however, it does
also affect all other exception vectors, including for CPU0/1 (so one should
usually disable IRQs while having the overlay enabled).

See CFG11\_MPCORE\_BOOTCNT\_CPU2/3 for details on starting CPU2/3.



## 10140424h - New3DS - CFG11\_BOOTROM\_OVERLAY\_VAL (R/W)


```
  0-31  ARM11 Bootrom Overlay Data (aka CPU2/3 entrypoint)
```

Note: For redirecting to different entrypoints for CPU2/3, one can use opcode
EE10nFB0h (mov Rn,p15,0,c0,c0,5) to obtain the current CPU number.



## 10140428h - New3DS - ??? (R/W)


```
  0     Unknown (R/W, only in New3DS mode)
  1-31  Unused (0)
```

Unknown.



## 10140FFCh - CFG11\_SOCINFO (R)


```
  0     Always 1 (bootrom would do extra GPIO if it were cleared)      (R)
  1     Console Type        (0=Old3DS, 1=New3DS)                       (R)
  2     Max Clock on New3DS (0=536MHz, 1=804MHz) ;unused 0 on Old3DS   (R)
  3-15  Unused (0)
```

Unknown if there are any New3DS consoles released with bit2=0.

Bit2 is also related to CFG11\_MPCORE\_CNT bit8?



## 10141000h - CFG11\_PDN\_CNT (R or W?)


```
  0     Request sleep?   (0=No, 1=Enter sleep mode?)                     (W?)
  1-14  Unused (0)
  15    Ready to sleep?  (0=No, 1=GPU halted via CFG11_GPU_CNT.bit16=0)  (R?)
```



## 10141008h - CFG11\_PDN\_WAKE\_ENABLE (0=Disable, 1=Enable) (R/W)



## 1014100Ch - CFG11\_PDN\_WAKE\_REASON (0=No, 1=Yes/Ack) (R/ack)


```
  0     Unused (0)                   -
  1     HID_PAD_IRQ                  IRQ 5Bh Controller Buttons
  2     Unused (0)                   -
  3     GPIO_DATA0_DATA_IN.bit2=0    IRQ 60h Hinge is Open
  4     GPIO_DATA1_IRQ_ENABLE.bit0   IRQ 64h Headphone connect
  5     Unused (0)                   -
  6     GPIO_DATA1_IRQ_ENABLE.bit1   IRQ 66h ?
  7     Unknown...?                  IRQ ?   ?
  8     Unknown...?                  IRQ ?   ?
  9-15  Unused (0)                   -
  16    Unknown...?                  IRQ ?   ?
  17    GPIO_DATA3_IRQ_ENABLE.bit0   IRQ 68h C-stick
  18    GPIO_DATA3_IRQ_ENABLE.bit1   IRQ 69h IrDA IRQ
  19    GPIO_DATA3_IRQ_ENABLE.bit2   IRQ 6Ah Gyro IRQ
  20    GPIO_DATA3_IRQ_ENABLE.bit3   IRQ 6Bh ?
  21    GPIO_DATA3_IRQ_ENABLE.bit4   IRQ 6Ch ?
  22    GPIO_DATA3_IRQ_ENABLE.bit5   IRQ 6Dh ?
  23    GPIO_DATA3_IRQ_ENABLE.bit6   IRQ 6Eh ?
  24    GPIO_DATA3_IRQ_ENABLE.bit7   IRQ 6Fh ?
  25    GPIO_DATA3_IRQ_ENABLE.bit8   IRQ 70h TSC[67h:2Bh] (Headphone connect)
  26    GPIO_DATA3_IRQ_ENABLE.bit9   IRQ 71h MCU[10h-1Fh]
  27    GPIO_DATA3_IRQ_ENABLE.bit10  IRQ 72h NFC?
  28    GPIO_DATA3_IRQ_ENABLE.bit11  IRQ 73h ?
  29    Unknown...?                  IRQ ?   ? ... triggers always/often?
  30    GPIO_DATA0_DATA_IN.bit1=0    IRQ 63h Touchscreen Pen is down
  31    GPIO_DATA0_DATA_IN.bit2=1    IRQ 62h Hinge is Closed
```

Note: TSC triggers on headphone connect, ack by reading TSC[67h:2Bh].

The REASON bits are getting set only if enabled in CFG11\_PDN\_WAKE\_ENABLE (and
only if the corresponding bits in GPIO\_DATA1\_IRQ\_ENABLE, GPIO\_DATA3\_IRQ\_ENABLE,
and HID\_PAD\_IRQ are also enabled).

The REASON bits can be cleared by writing 1 (unless the request condition is
still enabled and true).

Caution: Nonzero REASON bits can cause attempts to switch to New3DS mode (via
CFG11\_MPCORE\_CLKCNT) to hang?

Caution: Above is for New3DS (Old3DS doesn't have NFC and C-stick, and the
other bits are probably all completely different and still unknown).



## 10141100h - CFG11\_TWLMODE\_BOOT (R/W)


```
  0-1   Setting from ARM7_CNT (Port 10018000h) (0=3DS, 1=NDS/DSi, 2=GBA)    (R)
  2-14  Unused (0) ?
  15    Enable GBA/NDS/DSi hardware   (can be set ONLY if bit0-1=nonzero) (R/W)
```



## 10141104h - CFG11\_TWLMODE\_SLEEP (R/W)


```
  0     ARM7 Wakeup                   (0=No change, 1=Wakeup; clear bit1-2) (W)
  1-2   ARM7 Sleep state              (0=Normal/awake, 1-2=?, 3=Sleeping)   (R)
  3-14  Unused? (0)
  15    Enable IRQ upon ARM7 Sleep    (0=Disable, 1=Enable IRQ 59h)       (R/W)
```

Allows to trigger an IRQ when ARM7 enters lower power sleep mode (via GBA SWI
03h or NDS7/DSi7 SWI 07h). If so, one should forward the ARM7 wakeup condition
from CFG11\_TWLMODE\_HID\_IRQ to ARM11 register HID\_PAD\_IRQ, enter sleep mode on
ARM11 side, and (after ARM11 wakeup) wakeup ARM7 via CFG11\_TWLMODE\_SLEEP.bit0.



## 10141108h - CFG11\_TWLMODE\_2 ;IRQ? (R?)


```
  0-15  Unknown, reportedly "Bitfield", but looks like readonly, returns zero?
```



## 1014110Ah - CFG11\_TWLMODE\_HID\_IRQ (R)


```
  0-9   Button IRQ Enable flags (0=Ignore, 1=Select)
  10-13 Not used
  14    IRQ Enable Flag (0=Disable, 1=Enable)
  15    IRQ Condition   (0=Logical OR, 1=Logical AND)
```

This is a readonly mirror of the ARM7 Key Interrupt Control register (KEYCNT,
GBA/NDS Port 4000132h). The ARM7 uses this as wakeup condition for sleep mode,
the ARM11 could forward that value to HID\_PAD\_IRQ when entering sleep mode,
too. In homebrew code, one can also mis-use the register to send data from ARM7
to ARM11.

Note: The NDS does also have a separate KEYCNT register on ARM9, but that isn't
forwarded to ARM11 side.



## 1014110Ch - CFG11\_WIFIUNK (always 0, not R/W?)


```
  0-3   unknown/unspecified
  4     Wifi-related? Set to 1 very early in NWM-module... but isn't R/W... ?
  5-xx  unknown/unspecified
```

Read-only or write-only, always returns zero?



## 10141110h - CFG11\_TWLMODE\_HID\_MODE - R/W:0FFFh


```
  0-11  GBA/NDS Button Mode  (0=Auto/HID_PAD, 1=Manual/CFG11_TWLMODE_HID_SET)
  12    Unknown, if any (not R/W, but reportedly used???) (dev hw maybe?)
  13-15 Unused (0)
```

Set bits will use the corresponding values from CFG11\_TWLMODE\_HID\_SET instead
of allowing the hardware to read it from HID\_PAD.

This is set to 0x1FFF (all buttons and the debug key) and CFG11\_TWLMODE\_HID\_SET
is set to 0 when the "Close this software and return to HOME Menu?" dialog is
shown to prevent the button presses from propagating to the DS/GBA CPU.



## 10141112h - CFG11\_TWLMODE\_HID\_SET - R/W:0FFFh


```
  0-11  Buttons   ... unknown, reportedly 0 when NOT pressed ??????????
  12    Unknown, if any (not R/W, but reportedly used???) (dev hw maybe?)
  13-15 Unused (0)
```

Works the same way as HID\_PAD, but the values set here are only replaced in the
HID\_PAD seen by the NDS/GBA CPUs when the corresponding bits in
CFG11\_TWLMODE\_HID\_MODE are set.



## 10141114h - 2 - R/W:0287h CFG11\_CODEC\_0



## 10141116h - 2 - R/W:0387h CFG11\_CODEC\_1



## 10141118h - 1 - R/W:01h ?



## 10141119h - 1 - R/W:01h ?



## 10141120h - 1 - R:0 ?


Unknown.



## 10141200h - CFG11\_GPU\_CNT (R/W)


```
  0     Enable GPU registers at 10400000h and up (0=DANGER) (vram=snow?)
         "When this is unset VRAM is not accessible and triggers exceptions."
  1     Enable GPU_MEMFILL 0/1                   (0=Disable, 1=Enable)    (R/W)
  2     Enable reading GPU Internal registers?   (0=Hangs, 1=Enable)      (R/W)
  3     Enable reading GPU Internal registers?   (0=Hangs, 1=Enable)      (R/W)
  4     Enable GPU_MEMCOPY                       (0=Disable, 1=Enable)    (R/W)
  5     unknown, DANGER, hangs when cleared?     (0=DANGER, 1=Enable)
  6     Enable LCD Pixel Output                  (0=Off/fade, 1=Enable)   (R/W)
  7-15  Unused (0)
  16    Enable LCD Backlight and GPU/VRAM clock? (0=Off/dark, 1=Enable)   (R/W)
  17-31 Unused (0)
```



## 10141204h - CFG11\_GPU\_CNT2 (W)


```
  0     Power on GPU? (W)
  1-31  unknown/unspecified (0)
```



## 10141208h - CFG11\_GPU\_..........? (W)


```
  0     unknown/unspecified (used by bootrom) (W)
  1-7   unknown/unspecified (0)
```



## 10141210h - CFG11\_FCRAM\_CNT (R/W)


Used to apply changes to Port 102010xxh FCRAM Registers (which is needed only
when switching to GBA mode; or when using nonstandard FCRAM timings).

```
  0     Apply FCRAM Config     (0=Prepare, 1=Apply; on 0-to-1 transition) (R/W)
  1     Allow 3DS FCRAM access (0=Disable, 1=Enable)                      (R/W)
  2     Apply Busy flag    (0=Ready, 1=Busy; or bit0-1 aren't set to 01h)   (R)
  3-31  Unused (0)
```

After toggling bit0 from 0-to-1, one must wait until the apply has finished.
Weirdly, the Busy flag cannot be read when bit1=1, however, below are some
working apply sequences:

```
  Write 0h, Write 1h, Wait until Bit2=0, Write 3h ;best, for GBA and 3DS mode
  Write 0h, Write 1h, Wait until Bit2=0           ;good, for GBA mode only
  Write 0h, Write 3h, do ugly hardcoded delay     ;ugly, for GBA and 3DS mode
```

Note: ARM11 hangs when accessing FCRAM if bit0 or bit1 are zero, or if apply is
busy (or if GBA mode is active).



## 10141220h - CFG11\_CODEC\_CNT


```
  0     Unknown...?            (R/W)
  1     turn on/off DSP ... ?  (R/W)
  2-xx  Unused (0)
```

This (what?) is the only time the ARM11 CODEC module uses any 10141xxxh
registers. In one case CODEC module clears bit1 in register 10141114h, in the
other case CODEC module sets bit1 in registers 10141114h and 10141116h.



## 10141224h - CFG11\_CAMERA\_CNT


```
  0     Camera Enable (needed for camera I2C bus)  (0=Disable, 1=Enable)
 (1)    Unused (0)      ;<--- reportedly "turn on/off cameras" uh???
  1-31  Unused (0)
```



## 10141230h - CFG11\_DSP\_CNT (R/W)


```
  0-1   Enable DSP registers at 10203000h (0,1,2=Disable, 3=Enable) (R/W)
  2-7   Unused (0)
```

Unknown what bit0-1 do exactly, maybe one is reset, and one is stop (they must
be BOTH set though, otherwise registers at 10203000h are always zero).



## 10141240h - New3DS - unknown?


```
  0     Unknown (R/W)
  1-31  Unused (0) (?)
```



## 10141300h - New3DS - CFG11\_MPCORE\_CLKCNT


```
  0-2    Desired Mode (0,1,2,3,4,5,6,7) (see below)                   (R/W)
  3-14   Unused (0)
  15     Mode Change IRQ Flag (0=None, 1=IRQ 58h) (write 1 to reset)  (R/ack)
  16-18  Current Mode (0,1,3,5,7) (never 2,4,6) (see below)           (R)
  19-31  Unused (0)
```

Mode values:

```
  Mode 0: Old3DS Mode, 268MHz (1x), 128MB FCRAM, no L2C cache
  Mode 1: New3DS Mode, 268MHz (1x), 256MB FCRAM, and L2C cache controller
  Mode 3: New3DS Mode, 536MHz (2x), 256MB FCRAM, and L2C cache controller
  Mode 5: New3DS Mode, 804MHz (3x), 256MB FCRAM, and L2C cache controller
  Mode 2/4/6 are same as Mode 0. Mode 7 is same as Mode 5
```

Mode changes are applied ONLY once when all ARM11 cores are in Wait for IRQ
state (eg. "WFI" opcode). At that point, the IRQ flag in bit15 is set, and IRQ
58h is triggered.

Mode changes (and IRQs) occur ONLY when changing to different modes:

```
  - Changing between mode 0/1/3/5/7 (because they are different)
  - Changing between mode 5/7 (although they appear to be same)
```

Mode changes (and IRQs) do NOT occur when:

```
  - Rewriting the current mode value (because mode is already same)
  - Changing between mode 0/2/4/6 (because they are all same as mode 0)
```

New3DS mode enables some registers (eg. 10141240h, which are always zero in
Old3DS mode), and unlocks some Memory and I/O regions (which trigger data abort
in Old3DS mode):

```
  10130000h (L2B_0, L2B_1, Y2R_1, and MVD registers)
  10206000h (newer CDMA controller)
  17E10000h (L2C cache controller)
  28000000h (Extra FCRAM)
```

Other New3DS memory isn't automatically enabled (and keeps triggering data
abort even in New3DS mode, until explicitely enabling it):

```
  08100000h (Extended ARM9 RAM, needs enable via CFG9_EXTMEMCNT9.bit0)
  1F000000h (New VRAM aka QTM, needs enable via CFG11_MPCORE_CNT.bit0)
```

Clock changes affect the ARM11 CPU clock, including the MPCore Timer/Watchdog
registers at 17E00600h (if desired, one can change their prescalers to maintain
them running at same speed despite of the higher CPU clock).

The 804MHz mode should be used only if CFG11\_SOCINFO.bit2 indicates that it is
supported.

The IRQ flag in bit15 should be acknowledge before (or alongsides with) writing
the desired clock value (needed if it was still set from an older
un-acknowledged clock change).

IRQ 58h should be enabled to recover from WFI (or maybe anything like Hblank
IRQ might work for that, too). CPSR.I flag does not need to be enabled, WFI
does only wait for IRQs (but can recover without executing them). Using the old
CP15 Wait-for-IRQ opcode instead of WFI does work, too.



## 10141304h - New3DS - CFG11\_MPCORE\_CNT


```
  0     Enable New VRAM aka QTM at 1F000000h-1F3FFFFFh (0=Off, 1=On)      (R/W)
  1-7   Unused (0)
  8     Unknown... should be set only if CFG11_SOCINFO.bit2=1             (R/W)
  9-xx  Unused (0)
```

Kernel11 sets this to 101h when bit2 in CFG11\_SOCINFO is set otherwise 001h.



## 10141310h - New3DS - CFG11\_MPCORE\_BOOTCNT\_CPU0 (R)



## 10141311h - New3DS - CFG11\_MPCORE\_BOOTCNT\_CPU1 (R)


```
  0-7   Fixed (always 30h, even when executing WFI opcode)                  (R)
```

These are readonly dummy registers, somewhat indicating that CPU0/1 do exist
and that they were already started (of which, CPU0 is actually running code,
and CPU1 is initially hanging in a bootrom waitloop; which waits for FIRM code
to send software interrupt 01h via Port 17E01F00h, and then jumps to
[1FFFFFDCh]).



## 10141312h - New3DS - CFG11\_MPCORE\_BOOTCNT\_CPU2 (R/W)



## 10141313h - New3DS - CFG11\_MPCORE\_BOOTCNT\_CPU3 (R/W)


```
  0     Start/Stop CPU core         (0=Stop upon WFI, 1=Start/Enable)     (R/W)
  1     Must be 1 when starting CPU (0=Hangs when setting bit0, 1=Works)  (R/W)
  2-3   Unused (0)
  4     CPU started                 (0=No, 1=Yes, bit0 is/was set)          (R)
  5     CPU not in WFI state        (0=Executes WFI opcode, 1=Normal)       (R)
  6-7   Unused (0)
```

Starting CPU2/3 must be done with CFG11\_BOOTROM\_OVERLAY\_CNT/VAL (the default
reset vector in ARM11 bootrom doesn't support booting CPU2/3).

Bit0 enables CPU2/3 (and alongsides enables corresponding registers at
17E00900h/17E00A00h).

Bit1 must be set alongsides with bit0 (otherwise the CPU hangs somehow), once
when the CPU is started, toggling bit1 won't affect the CPU operation; clearing
bit1 is commonly done to notify CPU0 that the CPU has started.

Note: When starting/stopping CPU2/3, one should also notify the hardware about
the new state (via Port 17E00008h, SCU CPU Status Register).




# <a name="3dsconfigaxiregisters"></a>3DS Config - AXI Registers




## PrimeCell High-Performance AXI Bus Matrix (HPM) (PL301) Revision: r1p2


This is something for configuring interactions between Master Interfaces (MIs)
and Slave Interfaces (SIs). The datasheet contains only meaningless blurb in a
too-big-too-fail language. Guessing between the lines, Master does probably
refer to CPUs and DMA controllers, and Slave might refer to Memory Chips.

```
  1020F000h-3FCh   Unused (0)                                               (-)
  1020F400h+MI*20h QoS Tidemark for Master MI=00h                         (R/W)
  1020F404h+MI*20h QoS Access Control for Master MI=00h                   (R/W)
  1020F408h+MI*20h AR Channel Arbitration value for MI=00h..NumMI-1       (R/W)
  1020F40Ch+MI*20h AW Channel Arbitration value for MI=00h..NumMI-1       (R/W)
  1020F800h-FBCh   Reserved (0)                                             (-)
  1020FFC0h        PrimeCell Configuration Register 0 NumSI's (07h/0Ah)     (R)
  1020FFC4h        PrimeCell Configuration Register 1 NumMI's (11h/16h)     (R)
  1020FFC8h        PrimeCell Configuration Register 2 Zero    (00h)         (R)
  1020FFCCh        PrimeCell Configuration Register 3 Zero    (00h)         (R)
  1020FFD0h-FDCh   Reserved (0)                                             (-)
  1020FFE0h-FECh   PrimeCell Peripheral Register 0,1,2,3 (01h,13h,x4h,00h)  (R)
  1020FFF0h-FFCh   PrimeCell ID Register 0,1,2,3         (0Dh,F0h,05h,B1h)  (R)
```

These registers allow to read some fixed settings, and to change a few variable
settings (there must be a lot more fixed internal settings assigned at
manufacturing time, but one cannot read or change them).

The 3DS seems to support 1020F400h/1020F404h for Master 0 only.

Whilst 1020F408h/1020F40Ch are supported for Master 0 and up.



## 1020F400h+MI\*20h - QoS Tidemark for Master MI=00h (R/W)


```
  0-6   Max number of outstanding transactions before activating QoS (0..7Fh)
  7-31  Unused (0)
```

A value of 00h does completely disable QoS (instead of instantly triggering it
upon 0 outstanding transactions). QoS is short for Quality of Service (whatever
than means).



## 1020F404h+MI\*20h - QoS Access Control for Master MI=00h (R/W)


```
  0-6   Permit Slave 0-6 to use reserved slots (1=Yes) ;\Old3DS mode
  7-31  Unused (0)                                     ;/
  0-9   Permit Slave 0-9 to use reserved slots (1=Yes) ;\New3DS mode
  10-31 Unused (0)                                     ;/
```



## 1020F408h+MI\*20h AR Channel Arbitration value for MI=00h..NumMI-1 (R/W)



## 1020F40Ch+MI\*20h AW Channel Arbitration value for MI=00h..NumMI-1 (R/W)


Arbitration for AXI read (AR) and AXI write (AW) address channel signals.

The meaning of these register depends on the chip-configuration. There are
three possible modes for each MI (of which, the 3DS uses LRG for MI=00h, and
Fixed RR for MI=01h and up).

- Programmable Least Recently Granted (LRG) arbitration (3DS: used for MI=00h)
  - Write ii00pp00h   ;set priority for interface                         ;-write
  - Write FF0000iih   ;select interface for reading                       ;\read
  - Read  0000ppiih   ;read priority for previously selected interface    ;/
- Fixed Round-robin (RR) arbitration scheme (3DS: used for MI=01h..NumMI-1)
  - Write xxxxxxxxh   ;ignored (values are fixed)                         ;-write
  - Write FF0000ssh   ;select slot for reading                            ;\read
  - Read  000000iih   ;read interface for previously selected slot        ;/
- Programmable Round-robin (RR) arbitration scheme (3DS: not used)
  - Write ss0000iih   ;set interface for slot                             ;-write
  - Write FF0000ssh   ;select slot for reading                            ;\read
  - Read  000000iih   ;read interface for previously selected slot        ;/

Whereas, the parameter bits are:

```
  pp = Priority               (00h..FFh; 00h=Highest, FFh=Lowest)  ;for LRG
  ss = Slot number            (00h..unknown max value)             ;for RR
  ii = Slave interface number (00h..NumSI-1)
  FF = Fixed code for reading (FFh)
  00 = Unused/reserved        (00h)
```

The following settings exist on New3DS (the fixed values are same for AR+AW):

```
  Master  Old3DS Mode                        New3DS Mode
  MI=00h  pp pp pp pp pp pp pp -- -- -- --   pp pp pp pp pp pp pp pp pp pp --
  MI=01h  -- 01 02 03 04 05 06 -- -- -- --   -- 01 02 03 04 05 06 07 08 09 --
  MI=02h  01 02 05 06 -- -- -- -- -- -- --   01 02 05 06 08 09 -- -- -- -- --
  MI=03h  01 02 04 05 06 -- -- -- -- -- --   01 02 04 05 06 08 09 -- -- -- --
  MI=04h  01 02 04 -- -- -- -- -- -- -- --   01 02 04 08 -- -- -- -- -- -- --
  MI=05h  01 02 04 -- -- -- -- -- -- -- --   01 02 04 08 -- -- -- -- -- -- --
  MI=06h  01 02 04 -- -- -- -- -- -- -- --   01 02 04 08 -- -- -- -- -- -- --
  MI=07h  01 02 -- -- -- -- -- -- -- -- --   01 02 08 -- -- -- -- -- -- -- --
  MI=08h  01 02 -- -- -- -- -- -- -- -- --   01 02 08 -- -- -- -- -- -- -- --
  MI=09h  01 02 -- -- -- -- -- -- -- -- --   01 02 08 -- -- -- -- -- -- -- --
  MI=0Ah  01 02 05 -- -- -- -- -- -- -- --   01 02 05 08 -- -- -- -- -- -- --
  MI=0Bh  -- -- -- -- -- -- -- -- -- -- --   02 08 -- -- -- -- -- -- -- -- --
  MI=0Ch  -- -- -- -- -- -- -- -- -- -- --   08 02 -- -- -- -- -- -- -- -- --
  MI=0Dh  -- -- -- -- -- -- -- -- -- -- --   01 08 -- -- -- -- -- -- -- -- --
  MI=0Eh  -- -- -- -- -- -- -- -- -- -- --   -- -- -- -- -- -- -- -- -- -- --
  MI=0Fh  -- -- -- -- -- -- -- -- -- -- --   -- -- -- -- -- -- -- -- -- -- --
  MI=10h  -- -- -- -- -- -- -- -- -- -- --   -- -- -- -- -- -- -- -- -- -- --
  MI=11h  -- -- -- -- -- -- -- -- -- -- --   01 08 -- -- -- -- -- -- -- -- --
  MI=12h  -- -- -- -- -- -- -- -- -- -- --   01 08 -- -- -- -- -- -- -- -- --
  MI=13h  -- -- -- -- -- -- -- -- -- -- --   01 08 -- -- -- -- -- -- -- -- --
  MI=14h  -- -- -- -- -- -- -- -- -- -- --   -- 01 02 03 04 05 06 07 08 09 --
  MI=15h  -- -- -- -- -- -- -- -- -- -- --   -- 01 02 03 04 05 06 07 08 09 --
```

Entries with value "01..09" are fixed (and have same values for AR and AW).

Entries marked "--" are reading as zero (but there seems to be no way to
distinguish between SI=00h and SI=None).

The priority values (pp) for MI=00h are ininitally 00h, but can be changed,
New3DS has 34 priority values in total (7+7 for AR+AW in Old3DS mode, and
another 10+10 for AR+AW in New3DS mode).



## 1020FFC0h PrimeCell Configuration Register 0 Num SIs (R)



## 1020FFC4h PrimeCell Configuration Register 1 Num MIs (R)


```
  0-7   Number of Master/Slave Interfaces (MIs/SIs) (01h..20h)
  8-31  -
```

The values here change depending on whether running in Old3DS or New3DS mode.

```
  Old3DS Mode: NumMI=11h, NumSI=07h
  New3DS Mode: NumMI=16h, NumSI=0Ah
```



## 1020FFC8h PrimeCell Configuration Register 2 Zero (R)



## 1020FFCCh PrimeCell Configuration Register 3 Zero (R)


```
  0-31  Zero
```



## 1020FFE0h-FECh - PrimeCell Peripheral Register 0-3 (R)


This region contains four 32bit registers (01h,13h,x4h,00h). One is supposed to
extract the lower 8bit of these 32bit values, and then to merge them into a
"conceptual-32bit-value" (00x41301h). And then interprete it as so:

```
  0-11  Part number            (301h=HPM)
  12-19 Designer               (41h=ARM)
  20-23 Revision               (1=r1p0, 2=r1p1, 3=r1p2)
  24-31 Reserved (undef)
```

This value is fixed=00341301h on New3DS (ie. r1p2, no matter if running in
Old3DS or New3DS mode).

The value on actual Old3DS is unknown (although, some consoles are reportedly
using r1p0?).



## 1020FFF0h-FFCh - PrimeCell ID Register 0-3 (R)


This region contains four 32bit registers (0Dh,F0h,05h,B1h). One is supposed to
extract the lower 8bit of these 32bit values, and then to merge them into a
"conceptual-32bit-value" (B105F00Dh). And then interprete it as so:

```
  0-31  Component ID (B105F00Dh) (same ID as for Corelink DMA controller)
```



## Guesses on possible Master Interfaces (MIs)


Old3DS = 11h MI's

```
  1xARM11 (with 2 CPU cores)
  1xCDMA  (with 8 channels)
  1xCSND  (with 32+2 sound+capture channels)
  1xGPU   (internal rendering, external to 2 LCD's, and memcopy/memfill)
  1xDSP
  1xARM9                                ;\
  1xXDMA  (with 4 channels)             ; ARM9
  1xNDMA  (with 8 channels)             ;
  1xDMA   (with 4 channels)             ;/
  1xARM7                                ;\
  1xNDMA  (with 4 channels)             ; ARM7
  1xDMA   (with 4 channels)             ; (can't really share ARM11 bus though)
  1xNDS/GBA GPU (2x 2D and 1x 3D)       ;
  1xNDS/GBA Sound (with 15+2 channels)  ;/
```

New3DS = 16h MIs (five more than Old3DS)

```
  0xNewARM11 (but with 2 more CPU cores)
  1xNewCDMA  (with 8 channels)
  1xMVD
  1xLevel 2 Cache Controller
```



## Guesses on possible Slave Interfaces (SIs)


Old3DS = 07h SI's

```
  FCRAM
  VRAM
  ARM9 RAM
  DSP RAM
  AXI RAM
  BIOS ROM(s)
  I/O Area(s)
```

New3DS = 0Ah SIs (three more than Old3DS)

```
  Extended VRAM? aka QTM?
  Extended ARM9 RAM
  Extended FCRAM
```



## Datasheets


Reportedly "CoreLink NIC-301 r1p0" (aka NIC-301 Network Interconnect)

- [http://infocenter.arm.com/help/topic/com.arm.doc.ddi0422a/CHDGHIID.html](http://infocenter.arm.com/help/topic/com.arm.doc.ddi0422a/CHDGHIID.html)
  - DDI0422.pdf

But, the ID values don't match up (at least not on New3DS, it's actually: r1p2)

```
  DDI0422D_hpm_pl301_r1p2_ts.pdf
```




# <a name="3dsconfigl2c310level2cachecontrollernew3ds"></a>3DS Config - L2C-310 Level 2 Cache Controller (New3DS)




## L2C-310 r3p3, Level 2 Cache Controller (New3DS only)


```
  17E10000h     L2C_CACHE_ID             R  410000C9h ;\Cache ID and Cache Type
  17E10004h     L2C_CACHE_TYPE           R  9E440440h ;/
  17E10100h     L2C_CONTROL              RW 00000000h ;\
  17E10104h     L2C_AUX_CONTROL          RW 02090000h ; Control
  17E10108h     L2C_TAG_RAM_CONTROL      RW 00000111h ;
  17E1010Ch     L2C_DATA_RAM_CONTROL     RW 00000221h ;/
  17E10200h     L2C_EV_COUNTER_CTRL      RW 00000000h ;\
  17E10204h     L2C_EV_COUNTER1_CFG      RW 00000000h ; Interrupt and
  17E10208h     L2C_EV_COUNTER0_CFG      RW 00000000h ; Counter Control
  17E1020Ch     L2C_EV_COUNTER1          RW 00000000h ;
  17E10210h     L2C_EV_COUNTER0          RW 00000000h ;
  17E10214h     L2C_INT_MASK             RW 00000000h ;  ;\
  17E10218h     L2C_INT_STATUS_MASKED    R  00000000h ;  ; Interrupts
  17E1021Ch     L2C_INT_STATUS_RAW       R  00000000h ;  ;
  17E10220h     L2C_INT_CLEAR            W  00000000h ;/ ;/
  17E10730h     L2C_CACHE_SYNC           RW 00000000h ;\
  17E10770h     L2C_INV_PA               RW 00000000h ;
  17E1077Ch     L2C_INV_WAY              RW 00000000h ; Cache Maintenance
  17E107B0h     L2C_CLEAN_PA             RW 00000000h ; Operations
  17E107B8h     L2C_CLEAN_INDEX          RW 00000000h ;
  17E107BCh     L2C_CLEAN_WAY            RW 00000000h ;
  17E107F0h     L2C_CLEAN_INV_PA         RW 00000000h ;
  17E107F8h     L2C_CLEAN_INV_INDEX      RW 00000000h ;
  17E107FCh     L2C_CLEAN_INV_WAY        RW 00000000h ;/
  17E10900h+N*8 L2C_D_LOCKDOWN_0..7      RW 00000000h ;\
  17E10904h+N*8 L2C_I_LOCKDOWN_0..7      RW 00000000h ; Cache Lockdown
  17E10950h     L2C_LOCK_LINE_EN         RW 00000000h ;
  17E10954h     L2C_UNLOCK_WAY           RW 00000000h ;/
  17E10C00h     L2C_ADDR_FILTERING_START RW 00000000h ;\Address Filtering
  17E10C04h     L2C_ADDR_FILTERING_END   RW 00000000h ;/
  17E10F40h     L2C_DEBUG_CTRL           RW 00000004h ;\
  17E10F60h     L2C_PREFETCH_CTRL        RW 04000000h ; Debug, Prefetch, Power
  17E10F80h     L2C_POWER_CTRL           RW 00000000h ;/
```

Caution: L2C registers can be read via LDR only (LDRB/LDRH cause data abort).

Note: Some L2C registers are write-able only with Secure access (S), not with
Non-secure access (NS), but that seems to apply only for TrustZone extension
(which doesn't seem to exist in 3DS).

Official specs: DDI0246H\_l2c310\_r3p3\_trm.pdf


```
 _____________________ Cache ID and Cache Type (NS and S) _____________________
```



## 17E10000h - L2C\_CACHE\_ID - Cache ID Register (410000C9h) (R)


```
  0-5   RTL release               (9=r3p3)
  6-9   Part number               (3=L2C-310)
  10-15 CACHEID pins              (reads as 0 on New3DS)
  16-23 Reserved (0)
  24-31 Implementer               (41h=ARM)
```



## 17E10004h - L2C\_CACHE\_TYPE - Cache Type Register (9E440440h) (R)


```
  0-1   L2 cache line length      (0=32 bytes)                    ;\
  2-5   Reserved (0)                                              ;
  6     L2 associativity          (from L2C_AUX_CONTROL.bit16)    ; instruction
  7     Reserved (0)                                              ;
  8-10  Isize L2 cache way size   (from L2C_AUX_CONTROL.bit19-17) ;
  11    Reserved (0)                                              ;/
  12-13 L2 cache line length      (0=32 bytes)                    ;\
  14-17 Reserved (0)                                              ;
  18    L2 associativity          (from L2C_AUX_CONTROL.bit16)    ; data
  19    Reserved (0)                                              ;
  20-22 Dsize L2 cache way size   (from L2C_AUX_CONTROL.bit19-17) ;
  23    Reserved (0)                                              ;/
  24    Harvard                   (0=Unified, 1=Harvard)          ;-harvard
  25    Lockdown by Line option   (0=Off, 1=On)                   ;\
  26    Lockdown by Master option (0=Off, 1=On)                   ; ctype
  27-28 Fixed (always 3)                                          ;/
  29-30 Reserved (0)
  31    Data banking              (0=Not implemented, 1=Implemented)
```


```
 ______________________ Control (Write S, Read NS and S) ______________________
```



## 17E10100h - L2C\_CONTROL - Control Register (R/W)


```
  0     L2 Cache enable           (0=Disable, 1=Enable)
  1-31  Reserved (0)
```

Caution: The cache seems to contain garbage on power-up. Set L2C\_INV\_WAY=FFFFh,
then wait for L2C\_INV\_WAY=0 before enabling L2C\_CONTROL.



## 17E10104h - L2C\_AUX\_CONTROL - Auxiliary Control Register (02090000h) (R/W)


```
  0     Full Line of Write Zero Enable (0=Disable, 1=Enable)
  1-7   Reserved (0) (actually R/W, but unknown/undocumented)
  8     Reserved (0) (always 0)
  9     Reserved (0) (actually R/W, but unknown/undocumented)
  10    Priority for Strongly Ordered and Device Reads Enable (0=Low, 1=High)
  11    Limit  (0=Device writes can use all slots, 1=Ensure one Memory slot)
  12    Exclusive cache configuration      (0=Disable, 1=Enable)
  13    Shared Attribute Invalidate Enable (0=Disable, 1=Enable if no override)
  14-15 Reserved (0) (actually R/W, but unknown/undocumented)
  16    Associativity               (0=8-way, 1=16-way)
  17-19 Way-size (1=16K, 2=32K, 3=64K, 4=128K, 5=256K, 6=512K, 0/7=Same as 1/6)
  20    Event monitor bus enable    (0=Disable, 1=Enable)
  21    Parity enable               (0=Disable, 1=Enable)
  22    Shared attribute override   (0=No, 1=Ignore Shared Attrubute)
  23-24 Force write allocate (0=Use WA, 1=ForceWA=0, 2=ForceWA=1, 3=Same as 0?)
  25    Cache Replacement Policy    (0=Pseudo-random/LFSR, 1=Round-robin)
  26    Lockdown Register Writes    (0=Secure only, 1=Allow non-secure)
  27    Interrupt MASK/CLEAR Access (0=Secure only, 1=Allow non-secure)
  28    Data Prefetch Enable        (0=Disable, 1=Enable)
  29    Instruction Prefetch Enable (0=Disable, 1=Enable)
  30    Early BRESP Enable          (0=Disable, 1=Enable, Early write response)
  31    Reserved (0) (actually R/W, but unknown/undocumented)
```

Cache size is reportedly "2MB" on New3DS, which is probably meant to be 2Mbyte,
ie. 16 ways of 128Kbyte each, and that shared for both code and data caching?



## 17E10108h - L2C\_TAG\_RAM\_CONTROL - Tag RAM Latency Control (00000111h) (R/W)



## 17E1010Ch - L2C\_DATA\_RAM\_CONTROL - Data RAM Latency Control (00000221h) (R/W)


```
  0-2   RAM setup latency           (0-7 = 1..8 cycles of latency)
  3     Reserved (0)
  4-6   RAM read access latency     (0-7 = 1..8 cycles of latency)
  7     Reserved (0)
  8-10  RAM write access latency    (0-7 = 1..8 cycles of latency)
  11-31 Reserved (0)
```

Uh, is that the latency of the Cache Memory (ie. not the external "cached"
memory)?


```
 __________________ Interrupt and Counter Control (NS and S) __________________
```



## 17E10200h - L2C\_EV\_COUNTER\_CTRL - Event Counter Control (R/W)


```
  0     Event Counting Enable       (0=Disable, 1=Enable)    (R/W)
  1     Event Counter 0 Reset       (0=No change, 1=Reset)   (W)
  2     Event Counter 1 Reset       (0=No change, 1=Reset)   (W)
  3-31  Reserved (0)
```



## 17E10204h - L2C\_EV\_COUNTER1\_CFG - Event Counter 1 Configuration (R/W)



## 17E10208h - L2C\_EV\_COUNTER0\_CFG - Event Counter 0 Configuration (R/W)


```
  0-1   Event counter interrupt generation  (00h-03h, see below)
  2-5   Counter event source                (00h-0Fh, see below)
  6-31  Reserved (0)
```

Event counter interrupt generation:

```
  00h Disabled                          ;count, without irq
  01h Enabled: Increment condition      ;count, with irq on any increment
  02h Enabled: Overflow condition       ;count, with irq on overflow
  03h Interrupt generation is disabled  ;count, without irq (same as 0?)
```

Counter event source:

```
  00h  -        Counter Disabled
  01h  CO       Eviction, CastOUT, of a line from the L2 cache
  02h  DRHIT    Data read hit in the L2 cache
  03h  DRREQ    Data read lookup to the L2 cache
  04h  DWHIT    Data write hit in the L2 cache
  05h  DWREQ    Data write lookup to the L2 cache
  06h  DWTREQ   Data write lookup to the L2 cache with Write-Through attribute
  07h  IRHIT    Instruction read hit in the L2 cache
  08h  IRREQ    Instruction read lookup to the L2 cache
  09h  WA       Allocation into the L2 cache caused by a write, with
                  Write-Allocate attribute, miss
  0Ah  IPFALLOC Allocation of a prefetch generated by L2C-310 into the L2 cache
  0Bh  EPFHIT   Prefetch hint hits in the L2 cache
  0Ch  EPFALLOC Prefetch hint allocated into the L2 cache
  0Dh  SRRCVD   Speculative read received by slave port(s)
  0Eh  SRCONF   Speculative read confirmed in slave port(s)
  0Fh  EPFRCVD  Prefetch hint received by slave port(s)
  Note: All REQ lookups will subsequently result in a hit or miss.
```



## 17E1020Ch - L2C\_EV\_COUNTER1 - Event counter 1 value (R/W)



## 17E10210h - L2C\_EV\_COUNTER0 - Event counter 0 value (R/W)


```
  0-31  Counter value, incremented on selected event
```

If a counter reaches its maximum value, it saturates at that value until it is
reset.



## 17E10214h - L2C\_INT\_MASK - Interrupt Mask (0=Disable, 1=Enable) (R/W)



## 17E10218h - L2C\_INT\_STATUS\_MASKED - Masked Interrupt Status Register (R)



## 17E1021Ch - L2C\_INT\_STATUS\_RAW - Raw Interrupt Status (1=IRQ) (R)



## 17E10220h - L2C\_INT\_CLEAR - Interrupt Clear (0=No change, 1=Clear) (W)


```
  0     ECNTR: Event Counter 0 and 1 Overflow/Increment
  1     PARRT: Parity Error on L2 tag RAM, Read
  2     PARRD: Parity Error on L2 data RAM, Read
  3     ERRWT: Error on L2 tag RAM, Write
  4     ERRWD: Error on L2 data RAM, Write
  5     ERRRT: Error on L2 tag RAM, Read
  6     ERRRD: Error on L2 data RAM, Read
  7     SLVERR: SLVERR from L3
  8     DECERR: DECERR from L3
  9-31  Reserved (0)
```

Note: STATUS\_MASKED is same as STATUS\_RAW, but ANDed with MASK.

The IRQ triggers interrupt 76h.


```
 ________________________ Cache Maintenance Operations ________________________
```



## 17E10730h - L2C\_CACHE\_SYNC - Cache Maintenance Operations (R and W)


```
  0     C, When writing: Must be 0 (trigger cache sync...?)
  0     C, When reading: Background/Way operation is in progress (0=No, 1=Yes)
  1-31  Reserved (0)
```



## 17E10770h - L2C\_INV\_PA - Invalidate by Physical Address (R/W)



## 17E107B0h - L2C\_CLEAN\_PA - Clean by Physical Address (R/W)



## 17E107F0h - L2C\_CLEAN\_INV\_PA - Clean+Invalidate by Physical Address (R/W)


```
  0     C (uh, is that same meaning as in L2C_CACHE_SYNC.bit0?)   (R?)
  1-4   Reserved (0)
  5-xx  Index                                                     (W?)
  xx-31 Tag                                                       (W?)
```



## 17E1077Ch - L2C\_INV\_WAY - Invalidate by Way (R/W)



## 17E107BCh - L2C\_CLEAN\_WAY - Clean by Way (R/W)



## 17E107FCh - L2C\_CLEAN\_INV\_WAY - Clean+Invalidate by Way (R/W)


```
  0-15  Way bits (for way 0..15) (1=Trigger/busy?)                (R/W)
  16-31 Reserved (0)
```



## 17E107B8h - L2C\_CLEAN\_INDEX - Clean by Index (R/W)



## 17E107F8h - L2C\_CLEAN\_INV\_INDEX - Clean+Invalidate by Index (R/W)


```
  0     C (uh, is that same meaning as in L2C_CACHE_SYNC.bit0?)   (R?)
  1-4   Reserved (0)
  5-xx  Index                                                     (W?)
  xx-xx Reserved (0)
  28-31 Way number (0..15)                                        (W?)
```


```
 _______________________________ Cache Lockdown _______________________________
```



## 17E10900h+N\*8 - L2C\_D\_LOCKDOWN\_0..7 - Data Cache lockdown 0-7 (R/W)



## 17E10904h+N\*8 - L2C\_I\_LOCKDOWN\_0..7 - Instruction Cache lockdown 0-7 (R/W)


```
  0-15  DATALOCK/INSTRLOCK 000..111  (use when AyUSERSx[7:5]=000b..111b) ;way?
  16-31 Reserved (0)
```



## 17E10950h - L2C\_LOCK\_LINE\_EN - Lockdown by Line Enable (R/W)


```
  0     Lockdown by Line Enable (0=Disable, 1=Enable)
  1-31  Reserved (0)
```



## 17E10954h - L2C\_UNLOCK\_WAY - Unlock all Lines by Way (R/W)


```
  0-15  Unlock all Lines by Way operation (0=No/off, 1=Unlock/Busy) ;way0-15
  16-31 Reserved (0)
```

Caution: When busy, all other L2C registers are becoming readonly (so after
writing, one MUST wait until above busy flags go off).


```
 _________________ Address Filtering (Write S, Read NS and S) _________________
```



## 17E10C00h - L2C\_ADDR\_FILTERING\_START - Address filtering Start (R/W)



## 17E10C04h - L2C\_ADDR\_FILTERING\_END - Address filtering End (R/W)


Not implemented, always zero in New3DS. Allows to redirect a whole address
range to master 1 (when two masters are implemented).

```
  0     Address Filtering Enable (0=Disable, 1=Enable)  ;<-- in Start register
  0     Reserved (0)                                    ;<-- in End register
  1-19  Reserved (0)
  20-31 Address Filtering Start/End Address bit31-20
```


```
 _____________ Debug, Prefetch and Power (Write S, Read NS and S) _____________
```



## 17E10F40h - L2C\_DEBUG\_CTRL - Debug Register (00000004h) (R/W)


```
  0     Disable cache linefill (0=Enable, 1=Disable cache linefills)      (R/W)
  1     Disable write-back     (0=Write-back, 1=Force Write-through)      (R/W)
  2     Secure Privileged Non-Invasive Debug Enable SPNIDEN option (1=on?)  (R)
  3-31  Reserved (0)
```



## 17E10F60h - L2C\_PREFETCH\_CTRL - Prefetch Control Register (04000000h) (R/W)


```
  0-4   Prefetch Offset (must be 0-7, 15, 23, or 31) (other=Unsupported)
  5-20  Reserved (0) (always 0)
  21    Not same AXI ID on exclusive sequence enable   (0=Same ID, 1=Not same)
  22    Reserved (0) (actually R/W, but unknown/undocumented)
  23    Incr Double Linefill enable (allow 8x64bit)    (0=Disable, 1=Allow)
  24    Prefetch drop, Discard prefetch reads to L3    (0=Disable, 1=Enable)
  25    Reserved (0) (actually R/W, but unknown/undocumented)
  26    Speculative Read Synthesis Option (read-only)  (0=On, 1=Off)        (R)
  27    Double linefill on WRAP read disable           (0=Enable, 1=Disable)
  28    Data prefetch enable                           (0=Disable, 1=Enable)
  29    Instruction prefetch enable                    (0=Disable, 1=Enable)
  30    Double Linefill, Read bursts to L3 on L2 miss  (0=4x64bit, 1=8x64bit)
  31    Reserved (0) (actually R/W, but unknown/undocumented)
```



## 17E10F80h - L2C\_POWER\_CTRL - Power Control Register (R/W)


```
  0     Standby mode enable         (0=Disable, 1=Enable)
  1     Dynamic clock gating enable (0=Disable, 1=Enable)
  2     Reserved (0) (actually R/W, but unknown/undocumented)
  3-31  Reserved (0) (always 0)
```




# <a name="3dsconfigarm7registersgbandsdsimode"></a>3DS Config - ARM7 Registers (GBA/NDS/DSi Mode)



The somewhat misnamed "ARM7" registers are actually ARM9 registers, used to
configure GBA/NDS/DSi mode.

```
  10018000h 1   ARM7_CNT                ;\GBA/NDS/DSi mode
  10018080h 20h ARM7_BOOTCODE           ;/
  10018100h 2   ARM7_SAVE_TYPE          ;\GBA savedata
  10018104h 2   ARM7_SAVE_CNT           ;/
  10018108h 2   ARM7_RTC_CNT            ;\
  10018110h 4   ARM7_RTC_BCD_DATE       ;
  10018114h 4   ARM7_RTC_BCD_TIME       ; GBA real time clock
  10018118h 4   ARM7_RTC_HEX_TIME       ;
  1001811Ch 4   ARM7_RTC_HEX_DATE       ;/
  10018120h 4   ARM7_SAVE_CFG_?         ;\
  10018124h 4   ARM7_SAVE_CFG_?         ; GBA savedata timings?
  10018128h 4   ARM7_SAVE_CFG_?         ;
  1001812Ch 4   ARM7_SAVE_CFG_?         ;/
  04700000h 4   <-- on ARM7 side, disable bootcode overlay
```

For specs on GBA/NDS/DSi mode:

- [GBA Reference](gba.html#gbareference)
- [NDS Reference](#ndsreference)
- [DSi Reference](ds.html#dsireference)
The ARM7\_RTC\_xxx registers are emulating the GBA cartridge RTC. The RTC for
NDS/DSi mode is emulated separately via registers in the 3DS GPIO register
space:

- [3DS GPIO Registers](#3dsgpioregisters)
The GBA/NDS/DSi video must be forwarded to 3DS framebuffers via ARM11 DMA:

- [3DS Video LGY Registers (Legacy GBA/NDS Video to Framebuffer)](#3dsvideolgyregisterslegacygbandsvideotoframebuffer)
GBA Audio requires enabling amplifiers via TSC register, and enabling GBA sound
via CODEC\_SNDEXCNT.

NDS/DSi sound probably requires something similar, and more extensive TSC
initialization for NDS or DSi touchscreen mode; and adjusting the TSC
calibration points depending on whether using LGYFB scaling.



## 10018000h - ARM7\_CNT (R/W)


```
  0-1   Console Mode (0=3DS, 1=NDS/DSi, 2=GBA, 3=Auto-replaced by 0)      (R/W)
  2-31  Unused (0)
```

After writing ARM7\_CNT, apply the mode value by writing [10141100h].bit15=1
(CFG11\_TWLMODE\_BOOT). GBA/NDS/DSi mode will start ARM7, executing the
ARM7\_BOOTCODE.

NDS/DSi mode changes the ARM9 memory map (to survive the changed memory map,
ARM9 should execute ITCM code during the mode change). GBA mode does keep ARM9
in 3DS mode. ARM11 is always kept running in 3DS mode.



## 10018080h..1001809Fh - ARM7\_BOOTCODE (32 bytes) (R/W)


These 32 bytes do overlay the exception vectors at 00000000h..0000001Fh in the
ARM7 BIOS ROMs (for GBA/NDS/DSi mode). The ARM7 reset vector opcode(s) are
executed after switching to GBA/NDS/DSi mode (see ARM7\_CNT
CFG11\_TWLMODE\_BOOT.bit15).

After booting, ARM7 can disable the BOOTCODE overlay by writing [4700000h]=1.



## ARM7:04700000h - on ARM7 side, disable bootcode overlay (W)


```
  0     Disable ARM7_BOOTCODE overlay (0=No, 1=Disable) (SET-ONCE)
  1-31  Unused (0)
```


```
 ____________________ GBA Mode Cartridge Savedata and RTC ____________________
```



## 10018100h - ARM7\_SAVE\_TYPE (R/W)


```
  0-3   GBA Cartridge Type (00h-0Fh, see below)                           (R/W)
  4-15  Unused (0)
```

Type values (same as used in the footer of the GBA ROM-image):

```
  00h = ROM 16.0Mbyte, EEPROM 0.5Kbyte (in upper 16Mbyte of ROM area)
  01h = ROM 31.9Mbyte, EEPROM 0.5Kbyte (in upper 100h byte of ROM area)
  02h = ROM 16.0Mbyte, EEPROM 8Kbyte   (in upper 16Mbyte of ROM area)
  03h = ROM 31.9Mbyte, EEPROM 8Kbyte   (in upper 100h byte of ROM area)
  04h = ROM 32Mbyte, FLASH 64Kbyte, RTC   ;\(FLASH ID=3D1Fh, Atmel)
  05h = ROM 32Mbyte, FLASH 64Kbyte        ;/
  06h = ROM 32Mbyte, FLASH 64Kbyte, RTC   ;\(FLASH ID=D4BFh, SST)
  07h = ROM 32Mbyte, FLASH 64Kbyte        ;/
  08h = ROM 32Mbyte, FLASH 64Kbyte, RTC   ;\(FLASH ID=1B32h, Panasonic)
  09h = ROM 32Mbyte, FLASH 64Kbyte        ;/
  0Ah = ROM 32Mbyte, FLASH 128Kbyte, RTC  ;\(FLASH ID=09C2h, Macronix)
  0Bh = ROM 32Mbyte, FLASH 128Kbyte       ;/
  0Ch = ROM 32Mbyte, FLASH 128Kbyte, RTC  ;\(FLASH ID=1362h, Sanyo)
  0Dh = ROM 32Mbyte, FLASH 128Kbyte       ;/
  0Eh = ROM 32Mbyte, SRAM 32Kbyte         ;-SRAM
  0Fh = ROM 32Mbyte                       ;-Raw ROM
```



## 10018104h - ARM7\_SAVE\_CNT (R/W)


```
  0     Savedata mapping (0=GBA:0E000000h, 1=3DS:08080000h)               (R/W)
  1-15  Unused (0)
```



## 10018108h - ARM7\_RTC\_CNT (W and R)


```
  0     Write   (0=No change, 1=Apply RTC_HEX)                              (W)
  1     Read    (0=No change, 1=Latch RTC_BCD and RTC_HEX)                  (W)
  2-13  Unused (0)
  14    Write Error Flag      (0=Okay, 1=Error, invalid data)               (R)
  15    Write/Read Busy Flag  (0=Ready, 1=Busy)                             (R)
```

To get the current time:

```
  Set Read flag, wait until busy=0, then read RTC_HEX or RTC_BCD registers
```

To set the current time:

```
  Write RTC_HEX registers, then set Write flag, then wait until busy=0
  (this does also set BCD registers, the hardware auto-converts HEX to BCD)
```

The initial time on power-up in 01 Jan 2000, 00:00:00. The actual battery
backed time can be obtained from MCU[30h..36h].

The GBA software can access the RTC via port 080000C4h, 080000C6h, 080000C8h.



## 10018110h - ARM7\_RTC\_BCD\_DATE (R)


```
  0-7   Year  BCD   (00h..99h)
  8-15  Month BCD   (01h..12h)
  16-23 Day   BCD   (01h..31h)
  24-31 Day of Week (00h..06h) (WHAT=Monday?)
```



## 10018114h - ARM7\_RTC\_BCD\_TIME (R)


```
  0-7   Hour    BCD (00h..23h) (always 24-hours, even in AM/PM mode)
  8-15  Minute  BCD (00h..59h)
  16-23 Second  BCD (00h..59h)
  24-31 Zero        (00h)
```



## 10018118h - ARM7\_RTC\_HEX\_TIME (R=Latched Read value, W=Written value)


```
  0-6   Second      (signed -40h..+3Fh, usually 00h..3Bh)
  7     Force Reset (0=Normal, 1=Force 1st Jan 2000, 00:00:00)
  8-14  Minute      (signed -40h..+3Fh, usually 00h..3Bh)
  15    12/24-hour  (0=12 hour, 1=24 hour) (for GBA side, both with AM/PM flag)
  16-21 Hour        (signed -20h..+1Fh, usually 00h..17h)
  22-23 Unused      (0)
  24-27 Day of Week (signed -08h..+07h, usually 00h..06h) (WHAT=Monday?)
  28-30 Unknown     (can be 0..7)
  31    Error       (0=Normal, 1=Triggers error)
```



## 1001811Ch - ARM7\_RTC\_HEX\_DATE (R=Latched Read value, W=Written value)


```
  0-15  Days since 1st Jan 2000 (0000h..8EACh=100 years, Bigger=Triggers error)
  16-31 Unknown                 (can be 0000h..FFFFh)
```



## 10018120h - ARM7\_SAVE\_CFG\_? - R/W mask 00FFFFFFh (reset=007FD000h=8376320)



## 10018124h - ARM7\_SAVE\_CFG\_? - R/W mask 00FFFFFFh (reset=007FD000h=8376320)



## 10018128h - ARM7\_SAVE\_CFG\_? - R/W mask 000FFFFFh (reset=000000E0h=224)



## 1001812Ch - ARM7\_SAVE\_CFG\_? - R/W mask 000FFFFFh (reset=00051000h=331776)


Maybe video/color config, or write/erase timings, or so?

```
  "This is copied from rom footer + 10h."
```

Uh, but the description of the ROM footer doesn't mention anything at
"footer+10h".

Maybe this is the "ghosting" stuff, whatever that is... maybe color bleeding?


```
 ______________________ Memory Maps in GBA/NDS/DSi Modes ______________________
```



## Memory map in GBA Mode


```
  3DS       --> GBA
  08080000h --> 0E000000h, GBA Cart FLASH/SRAM/EEPROM (max 128Kbyte)
  080A0000h --> 06000000h, GBA 2D-Engine VRAM (64K+32Kbyte)
  080B8000h --> 03000000h, GBA Fast WRAM (32Kbyte)
  080C0000h --> 02000000h, GBA Slow WRAM (256Kbyte)
  20000000h --> 08000000h, GBA Cart ROM (32Mbyte max)
```

Cart ROM is unstable: About 99% reads are reading from addr+20h (within
800h-byte pages), and about 1% are randomly reading as wanted from address+0.

```
  see FCRAM_MODE.bit0 for workaround
```

When in GBA mode, ARM9 seems to be no longer able to access the remapped ARM9
memory blocks (ARM9 only sees 00h's)? And, ARM9/ARM11 seem to HANG (without any
exception) when trying to access Main RAM at 20000000h?



## Memory map in NDS/DSi Mode


```
  3DS       --> NDS/DSi
  08000000h --> 06800000h, NDS VRAM A (128Kbyte)
  08020000h --> 06820000h, NDS VRAM B (128Kbyte)
  08040000h --> 06840000h, NDS VRAM C (128Kbyte)
  08060000h --> 03800000h, NDS ARM7 WRAM (64Kbyte) (ARM7 only)
  08070000h --> 06898000h, NDS VRAM H (32Kbyte)
  08078000h --> 068A0000h, NDS VRAM I (16Kbyte)
  08080000h --> 06860000h, NDS VRAM D (128Kbyte)
  080A0000h --> 06880000h, NDS VRAM E (64Kbyte)
  080B0000h --> 06890000h, NDS VRAM F (16Kbyte)
  080B4000h --> 06894000h, NDS VRAM G (16Kbyte)
  080B8000h --> 03000000h, NDS Shared RAM (32Kbyte) (initially mapped to ARM9)
  080C0000h --> 03xxxxxxh, DSi New Shared WRAM A (256Kbyte) (Misc)
  10174000h --> 04804000h, NDS Wifi RAM (8Kbyte)
  1FF00000h --> 03xxxxxxh, DSi New Shared WRAM B (256Kbyte) (DSP Code)
  1FF40000h --> 03xxxxxxh, DSi New Shared WRAM C (256Kbyte) (DSP Data)
  20000000h --> 02000000h, NDS Main RAM (max 16MByte)     ;\only each 4th
  20000000h --> 0C000000h, DSi Main RAM (max 32Mbyte)     ;/halfword used
  ITCM/DTCM --> ITCM/DTCM, NDS ITCM/DTCM (32K+16K, same mapping as in 3DS mode)
  FF-filled --> 08000000h, GBA Cart ROM/SRAM (32MB+64K) (empty, FFh-filled)
```

Main RAM needs enable in EXMEMCNT, Main RAM uses only the lower 16bit of the
64bit FCRAM data bus (ie. only each 4th halfword is used). OAM/Palette need
enable in POWCNT1. VRAM needs enable in VRAMCNT. New Shared WRAM needs MBK.
Wifi RAM needs POWCNT2.



## GBA Footers


GBA ROM-images are reportedly stored in .code files (in NCCH .app files, which
can also contain the usual NCCH icon/banner/logo).

Nintendo is using 360h-byte footers in GBA ROM-images (at the end of the .code
file?).

- Config Data:
  - 000h 4    Unknown (usually 0) (maybe ROM-image Offset, or version)
  - 004h 4    ROM-image Size (usually Romsize)
  - 008h 4    Cartridge Type (Port 10018100h, ARM7\_SAVE\_TYPE)
  - 00Ch 4    Unknown (usually 0000FFFFh) (guess: savedata fillvalue?)
  - 010h 4    Unknown (Port 10018120h, reportedly 1561662 or 2607238) ;\maybe
  - 014h 4    Unknown (Port 10018124h, reportedly 156166  or 577077 ) ; write
  - 018h 4    Unknown (Port 10018128h, reportedly 134     or 388    ) ; erase
  - 01Ch 4    Unknown (Port 1001812Ch, reportedly 187667  or 201072 ) ;/timings?
  - 020h 4    LCD Ghosting (01h..FFh) (uh, what is that?)
  - 024h 300h LCD Video LUT (guess: maybe for Port 10400484h/10400584h or so?)
  - 324h 0Ch  Padding (0)
- 1st Descriptor:
  - 330h 4    Descriptor Type  (00h=ROM-Image)
  - 334h 4    ROM-image Offset (usually 0)
  - 338h 4    ROM-image Size   (usually Romsize)
  - 33Ch 4    Padding (0)
- 2nd Descriptor:
  - 340h 4    Descriptor Type  (01h=Config Data)
  - 344h 4    Config Offset    (usually Romsize+0)
  - 348h 4    Config Size      (usually 324h)
  - 34Ch 4    Padding (0)
- Footer Entrypoint (in last 10h-byte of .code file):
  - 350h 4    GBA Footer ID          (".CAA")
  - 354h 4    Maybe Version          (must be 1)
  - 358h 4    Descriptor List Offset (usually Romsize+330h)
  - 35Ch 4    Descriptor List Size   (usually 20h) (2\*10h)



## GBA Savedata


Upon power-off, GBA savedata is usually temporarily stored in a small eMMC
partition, and later copied to the actual savedata file upon reboot. The file
format and filename for that savedata are unknown...?



## ARM7 Registers Misc...


ARM7 has the GBA BIOS implemented in hardware. The BIOS is completely identical
to the original GBA BIOS (uh, actually, it is the GBA BIOS version from NDS,
which has [3F0Ch]=01h).

The system is booted silently by calling SWI 01h (aka RegisterRamReset),
followed by jumping to the code that does SWI 00h (aka SoftReset) to finish
booting. The boot splash is still in BIOS, however, and can be seen by calling
or replacing one of the previous interrupts with SWI 26h (aka HardReset).

ARM7\_BOOTCODE: "This is the first code that will be run after execution begins.
TwlProcess9 uses this to put ARM7 in a loop (TWL), and to set the POSTFLG and
branch to more copied code (GBA)."




# <a name="3dsspiandi2cbus"></a>3DS SPI and I2C Bus



```
 __________________________________ SPI Bus __________________________________
```



## SPI Bus


- [3DS SPI Registers](#3dsspiregisters)


## SPI Devices


- [3DS SPI Devices](#3dsspidevices)

```
 __________________________________ I2C Bus __________________________________
```



## I2C Bus


- [3DS I2C Registers](#3dsi2cregisters)


## I2C Device List


- [3DS I2C Device List](#3dsi2cdevicelist)


## I2C Device Specs...


- [3DS I2C MCU Register Summary](#3dsi2cmcuregistersummary)
- [3DS I2C MCU[00h-01h,05h-07h] - Firmware](#3dsi2cmcu00h01h05h07hfirmware)
- [3DS I2C MCU[02h-0Fh] - Status](#3dsi2cmcu02h0fhstatus)
- [3DS I2C MCU[10h-1Fh] - Interrupt Flags](#3dsi2cmcu10h1fhinterruptflags)
- [3DS I2C MCU[20h-24h] - Power Control](#3dsi2cmcu20h24hpowercontrol)
- [3DS I2C MCU[28h-2Eh] - LED Control](#3dsi2cmcu28h2ehledcontrol)
- [3DS I2C MCU[30h-3Fh] - Real-Time Clock (RTC)](#3dsi2cmcu30h3fhrealtimeclockrtc)
- [3DS I2C MCU[40h-51h] - Accelerometer/Pedometer](#3dsi2cmcu40h51haccelerometerpedometer)
- [3DS I2C MCU[60h-7Fh] - Misc Status](#3dsi2cmcu60h7fhmiscstatus)
- [3DS I2C MCU secondary I2C Devices (on MCU bus)](#3dsi2cmcusecondaryi2cdevicesonmcubus)
- [DSi I2C Device 4Ah (BPTWL chip)](ds.html#dsii2cdevice4ahbptwlchip)
- [3DS I2C Gyroscope (old version)](#3dsi2cgyroscopeoldversion)
- [3DS I2C Gyroscope (new version)](#3dsi2cgyroscopenewversion)
- [3DS I2C Infrared Receiver/Transmitter (IrDA)](#3dsi2cinfraredreceivertransmitterirda)
- [3DS I2C LCD Screen Controllers](#3dsi2clcdscreencontrollers)
- [3DS I2C New3DS Near-Field Communication (NFC)](#3dsi2cnew3dsnearfieldcommunicationnfc)
- [3DS I2C New3DS C-Stick and ZL/ZR-Buttons](#3dsi2cnew3dscstickandzlzrbuttons)
- [3DS I2C New3DS 16bit IO Expander (aka QTM)](#3dsi2cnew3ds16bitioexpanderakaqtm)
- [3DS I2C Other/Unused/Debug Devices](#3dsi2cotherunuseddebugdevices)



# <a name="3dsspiregisters"></a>3DS SPI Registers




## SPI Registers


There are four SPI buses (most of them can have up to 3 devices attached):

```
  1000D000h ARM9        SPI_CARD (savedate in game card SPI FLASH memory)
  10160000h ARM9/ARM11  SPI_BUS0 (0=Powerman, 1=Wifi-FLASH, 2=Touchscr/sound)
  10142000h ARM9/ARM11  SPI_BUS1 (0=Touchscr/sound with extra 3ds registers)
  10143000h ARM9/ARM11  SPI_BUS2 (unused)
```

The separate registers (at the above base addresses) are:

```
  10xxx000h 2   SPI_MANUAL_CNT    (R/W)  ;\Manual Access
  10xxx002h 1/2 SPI_MANUAL_DATA   (R/W)  ;/
  10xxx800h 4   SPI_FIFO_CNT      (R/W)  ;\
  10xxx804h 4   SPI_FIFO_DONE     (R/W)  ;
  10xxx808h 4   SPI_FIFO_BLKLEN   (R/W)  ; FIFO Access
  10xxx80Ch 4   SPI_FIFO_DATA     (R/W)  ; (and AUTOPOLL for
  10xxx810h 4   SPI_FIFO_STATUS   (R)    ; status reads)
  10xxx814h 4   SPI_AUTOPOLL      (R/W)  ;
  10xxx818h 4   SPI_FIFO_INT_MASK (R/W)  ;
  10xxx81Ch 4   SPI_FIFO_INT_STAT (R/ack);/
```

Interrupt IDs and DMA/FIFO startup/peripheral IDs are:

```
  SPI_CARD   ARM9 IF.bit23    Various (ARM9 NDMA and ARM9 XDMA)
  SPI_BUS0   ARM11 IRQ 56h    ARM11 CDMA 0Fh
  SPI_BUS1   ARM11 IRQ 57h    ARM11 CDMA 10h
  SPI_BUS2   ARM11 IRQ 24h    ARM11 CDMA 11h
```



## Config registers


```
  CFG11_SPI_CNT - mode select for SPI_BUS0,1,2 (Manual or Fifo)
  CFG9_CARD_CTL - mode select for SPI_CARD     (Manual or Fifo or NTRCARD)
```

- [3DS Config - CONFIG11 Registers](#3dsconfigconfig11registers)
- [3DS Config - CONFIG9 Registers](#3dsconfigconfig9registers)

```
 ___________________________ SPI Manual Access Mode ___________________________
```



## 10xxx000h - SPI\_MANUAL\_CNT



## 10xxx002h - SPI\_MANUAL\_DATA


Manual access mode works same as on DSi. Max transfer rate is 8MHz, 1bit mode
only, and the manual byte-by-byte transfer adds some software overload to the
transfer time.

- [DS Serial Peripheral Interface Bus (SPI)](ds.html#dsserialperipheralinterfacebusspi)
One advantage is that the manual mode supports true bi-directional SPI
transfers (which aren't really needed because most SPI chips use only one
direction at a time, with dummy data in opposite direction).


```
 ____________________________ SPI FIFO Access Mode ____________________________
```



## 10xxx800h - SPI\_FIFO\_CNT (R/W)


```
  0-2   Baudrate   (0=512KHz, 1=1MHz, 2=2MHz, 3=4MHz, 4=8MHz, 5..7=16MHz)
  3-5   Unused (0)
  6-7   SPI_BUS0-2: Device Select (0..2, or 3=Hangs/Reads as 2)
        SPI_CARD:   Unused (0)
  8-11  Unused (0)
  12    Bus Mode                (0=1bit, 1=4bit)
  13    Transfer Direction      (0=Read, 1=Write)
  14    Unused (0)
  15    Start Transfer          (0=Idle/Ready, 1=Start/Busy)
  16-31 Unused (0)
```

CARD: This register seems to have a bug where the lower 8 bits are shifted up
by 16 when reading this register. Uh, really?



## 10xxx804h - SPI\_FIFO\_DONE (R/W) (or R when busy?)


```
  0     Chip Select             (0=Not Selected, 1=Selected)
  1-31  Unused (0)
```

Select occurs automatically (when starting a transfer via SPI\_FIFO\_CNT).
However, deselect must be done manually (by writing 0 to SPI\_FIFO\_DONE after
last data block). This allows to keep the chip selected during multiple
transfer blocks (including blocks with different data direction, eg. WriteCmd +
ReadData).



## 10xxx808h - SPI\_FIFO\_BLKLEN (R/W) (or R when busy?)


```
  0-20  Transfer length (1..1FFFFFh bytes, 0=?)
  21-31 Unused (0)
```



## 10xxx80Ch - SPI\_FIFO\_DATA (R/W)


```
  0-31  32bit FIFO for reading/writing data
```



## 10xxx810h - SPI\_FIFO\_STATUS (R)


```
  0     Whatever FIFO busy... or FIFO full (0=Not full, 1=Full)
  1-31  unknown/unspecified
```

"At transfer start and every 32 bytes the FIFO becomes busy."

Uh, unknown if this refers to Send FIFO or Receive FIFO. For the latter having
a Empty flag would be most useful.

Might be also a generic "data request" flag, rather than a "full/busy" flag?



## 10xxx814h - SPI\_AUTOPOLL (R/W)


```
  0-7   Command byte (eg. 05h=RDSR, aka FLASH read status)
  8-15  Unused (0)
  16-19 Timeout    (0..10 = 1ms,2ms,4ms,8ms,..,512ms,1024ms, or 11..15=Never)
  20-23 Unused (0)
  24-26 Bit number (0..6=Bit0..6, or 7=Bugged?, always "ready" after 1st poll?)
  27-29 Unused (0)
  30    Bit value  (0=WaitUntilZero, 1=WaitUntilSet)
  31    Start Poll (0=Idle/Ready, 1=Start/Busy)
```

Autopoll does repeatedly transfer command+reply bytes, until reaching the
desired reply bit state (or until reaching timeout). Autopoll uses the device
number and baudrate selected in SPI\_FIFO\_CNT.



## 10xxx818h - SPI\_FIFO\_INT\_MASK (R/W) (or R when busy?)


```
  0     Transfer Finished Interrupt Disable  (0=Enable, 1=Disable)
  1     Autopoll Success Interrupt Disable   (0=Enable, 1=Disable)
  2     Autopoll Timeout Interrupt Disable   (0=Enable, 1=Disable)
  3     Unknown (R/W)                        (?)
  4-31  Unused (0)
```



## 10xxx81Ch - SPI\_FIFO\_INT\_STAT (R/ack)


```
  0     Transfer Finished Flag   (0=No, 1=Yes/IRQ) (write 1 to clear)
  1     Autopoll Success Flag    (0=No, 1=Yes/IRQ) (write 1 to clear)
  2     Autopoll Timeout Flag    (0=No, 1=Yes/IRQ) (write 1 to clear)
  3     Unknown (usually 0, but might be something related to INT_MASK.bit3 ?)
  4-31  Unused (0)
```

Bit0 also fires on each autopoll try? No: it does not fire on autopoll.




# <a name="3dsspidevices"></a>3DS SPI Devices




## SPI Device List


```
  Bus0, Device 0      Power Managment Device             ;\
  Bus0, Device 1      Wifi FLASH                         ; same as NDS/DSi
  Bus0, Device 2      DSi Touchscreen/Sound/Microphone   ;/
  Bus1, Device 0      3DS Touchscreen/Sound/Microphone   ;-extra 3ds registers
  Bus1, Device 1,2    Unused
  Bus2, Device 0,1,2  Unused
  Card, Device 0      Cartridge SPI (eg. FLASH savedata) ;-similar as NDS/DSi
  Card, Device 1,2    Don't exist (there are no device-select bits for card)
```



## SPI Bus/Device 0:0 - Power Managment Device


The old power managment SPI registers are mostly for NDS mode:

- [DS Power Management Device](ds.html#dspowermanagementdevice)
On 3DS, backlight and power-down are controlled via MCU.



## SPI Bus/Device 0:1 - Wifi FLASH


This chip did contain the firmware in NDS consoles. On 3DS it does merely
contain some wifi/user settings, mostly for NDS titles.

- [DS Firmware Serial Flash Memory](ds.html#dsfirmwareserialflashmemory)
- [DS Firmware Header](ds.html#dsfirmwareheader)
- [DS Firmware Wifi Calibration Data](ds.html#dsfirmwarewificalibrationdata)
- [DS Firmware Wifi Internet Access Points](ds.html#dsfirmwarewifiinternetaccesspoints)
- [DS Firmware User Settings](ds.html#dsfirmwareusersettings)
The 3DS does probably additionally store User settings (and maybe also Wifi
Acess Point info) in a eMMC file, but unknown where?



## SPI Bus/Device 0:2 - DSi Touchscreen/Sound (DSi mode)


This SPI bus is used for accessing the TSC chip in DSi mode.

- [DSi Touchscreen/Sound Controller](ds.html#dsitouchscreensoundcontroller)
Touchscreen calibration points for NDS/DSi titles are in Wifi FLASH (matched to
the current NDS/DSi screen resolution, which can be 256x192pix or fullscreen;
selected by holding Start+Select when starting NDS/DSi title).



## SPI Bus/Device 1:0 - 3DS Touchscreen/Sound (3DS mode)


This is another SPI bus wired to the TSC chip, this bus can be accessed in 3DS
mode only, giving access to the normal DSi registers, plus some additional 3DS
registers in TSC page 64h,65h,67h,FBh. These new registers are required for
activating sound output, and for reading the Circle Pad.

- [3DS TSC, Register Summary](#3dstscregistersummary)
Touchscreen calibration points for 3DS titles are stored in HWCAL0/1.dat files,
that files do also include calibration data for Circle Pad, and various initial
TSC register settings.



## Cartridge SPI


Cartridge SPI can be wired to FLASH savedata (or theoretically anything else).

This can use 4bit SPI mode (if the chip is 4bit compatible, and if 4bit related
signals are wired up accordingly, and if the specific commands support 4bit
transfers).




# <a name="3dstscregistersummary"></a>3DS TSC, Register Summary




## Page Selection


```
  TSC[xxh:00h]=page    ;Page (each TSC SPI bus probably has own page+index?)
```



## Page 00h-01h (DSi Registers)


```
  TSC[00h:02h]=read    ;DSi Undocumented status (reserved bits)
  TSC[00h:03h]=read    ;DSi Overtemperature OT Flag (reserved bits)
  TSC[00h:0Bh]=87h     ;DSi DAC NDAC Value
  TSC[00h:39h]=66h     ;DSi ADC DC Measurement 1 (reset=00h, ORed with 66h)
  TSC[00h:3Fh]=D4h     ;DSi DAC Data-Path Setup  (reset=D4h, ORed with C0h)
  TSC[00h:40h]=00h     ;DSi DAC Volume Control
  TSC[00h:41h]=FDh     ;DSi DAC Left Volume Control  ;\aka 3DS     ;HWCAL[2E4h]
  TSC[00h:42h]=FDh     ;DSi DAC Right Volume Control ;/ShutterVol0 ;HWCAL[2E4h]
  TSC[00h:51h]=00h/80h ;DSi Microphone Mute/Unmute ;ADC Digital Mic
  TSC[00h:52h]=80h/00h ;DSi Microphone Mute/Unmute ;ADC Digital Volume
  TSC[01h:2Eh]=03h     ;DSi Microphone MIC BIAS
  TSC[01h:2Fh]=2Bh     ;DSi Microphone MIC PGA
  TSC[01h:30h]=40h     ;DSi P-Terminal ADC Channel Fine-Gain Input (reset=40h)
  TSC[01h:31h]=40h     ;DSi M-Terminal ADC Input Selection         (reset=40h)
```

The 3DS does usually access only the registers mentioned above (but there are
many more DSi-style registers in page 00h,01h,03h; see DSi chapter for
details).



## Page 04h-0Ch (DSi Coefficient RAM)


```
  TSC[04h:08h-0Dh]=... ;DSi Mic Autogain ;IIR, as DSi (7Fh,E1h,80h,1Fh,7Fh,C1h)
  TSC[05h:08h-3Fh]=... ;3DS FilterMic32  ;IIR+Biquad A,B,C,D,E;HWCAL[364h-39Bh]
  TSC[05h:48h-7Fh]=... ;3DS FilterMic47  ;IIR+Biquad A,B,C,D,E;HWCAL[39Ch-3D3h]
  TSC[08h:0Ch-3Dh]=... ;3DS FilterFreeB  ;Biquad ;\initialized;HWCAL[3DAh-40Bh]
  TSC[08h:4Ch-7Dh]=... ;3DS FilterFreeB' ;Biquad ; for        ;HWCAL[3DAh-40Bh]
  TSC[09h:02h-07h]=... ;3DS FilterFreeA  ;IIR.L  ; non-GBA    ;HWCAL[3D4h-3D9h]
  TSC[09h:08h-0Dh]=... ;3DS FilterFreeA' ;IIR.R  ;/only       ;HWCAL[3D4h-3D9h]
  TSC[0Ah:02h-07h]=... ;3DS FilterFreeA'';IIR?      HP47  ;\  ;HWCAL[3D4h-3D9h]
  TSC[0Ah:0Ch-3Dh]=... ;3DS FilterFreeB'';Biquad?   HP47  ;/  ;HWCAL[3DAh-40Bh]
  TSC[0Bh:02h-1Fh]=... ;3DS FilterHP32   ;Biquad.L A,B,C  ;\  ;HWCAL[2ECh-309h]
  TSC[0Bh:20h-3Dh]=... ;3DS FilterHP47.L ;Biquad.L D,E,F  ;/  ;HWCAL[30Ah-327h]
  TSC[0Bh:42h-5Fh]=... ;3DS FilterHP32'  ;Biquad.R A,B,C  ;\  ;HWCAL[2ECh-309h]
  TSC[0Bh:60h-7Dh]=... ;3DS FilterHP47.R ;Biquad.R D,E,F  ;/  ;HWCAL[30Ah-327h]
  TSC[0Ch:02h-1Fh]=... ;3DS FilterSP32   ;Biquad.L A,B,C  ;\  ;HWCAL[328h-345h]
  TSC[0Ch:20h-3Dh]=... ;3DS FilterSP47   ;Biquad.L D,E,F  ;/  ;HWCAL[346h-363h]
  TSC[0Ch:42h-5Fh]=... ;3DS FilterSP32'  ;Biquad.R A,B,C  ;\  ;HWCAL[328h-345h]
  TSC[0Ch:60h-7Dh]=... ;3DS FilterSP47'  ;Biquad.R D,E,F  ;/  ;HWCAL[346h-363h]
```

The above coefficient RAM pages exists on DSi, too. However, the DSi is usually
initializing only those in page 04h.

Unknown how the 3DS is using the extra coefficients... does it use miniDSP
instructions for that?

Unknown what the duplicated entries are for... maybe left/right channels?



## Page 64h (3DS Sound/Microphone Config)


```
  TSC[64h:01h]=01h     ;3DS Software Reset (?)
  TSC[64h:22h]=18h     ;3DS ? (reset=00h, ORed with 18h, later bit2=cleared)
  TSC[64h:25h]=read    ;3DS status, wait for bit3,7
  TSC[64h:26h]=read    ;3DS status, wait for bit3,7
  TSC[64h:2Ch]         ;unused, but nonzero  ;bit0,1=headphone connect status
  TSC[64h:30h]         ;unused, but nonzero
  TSC[64h:31h]=00h/44h ;3DS ? (reset=00h) (GBA:00h, Other:44h)
  TSC[64h:43h]=11h/91h ;3DS set to 11h, later toggles bit=0 then bit7=1
  TSC[64h:44h]         ;unused, but nonzero
  TSC[64h:45h]=20h/30h ;3DS Speaker off (reset=00h, later=20h, 30h=speakerOff)
  TSC[64h:75h]         ;unused, but nonzero
  TSC[64h:76h]=14h/D4h ;3DS Lock Coefficient RAM? (reset=14h, ORed with C0h)
  TSC[64h:77h]=0Ch/00h ;3DS ? (reset=0Ch, later clear bit2,3 after coeff init)
  TSC[64h:78h]=00h     ;3DS ?
  TSC[64h:7Ah]=00h     ;3DS ?
  TSC[64h:7Bh]=ECh     ;3DS ShutterVolume1                   ;HWCAL[2E5h]
  TSC[64h:7Ch]=0Ah     ;3DS ? (reset=0Ah, later clears bit0)
```



## Page 65h (3DS Sound/Microphone Gains)


```
  TSC[65h:0Ah]=0Ah     ;3DS ?
  TSC[65h:0Bh]=1Ch/3Ch ;3DS ?  ... depends on TSC[00h:02h..03h]   ;HP
  TSC[65h:0Ch]=04h     ;3DS DriverGainHP                     ;HWCAL[2E0h]*8+4
  TSC[65h:11h]=10h/D0h ;3DS ? (reset=00h, ORed with 10h, later ORed with C0h)
  TSC[65h:12h]=06h     ;3DS DriverGainSP    ;\maybe left?    ;HWCAL[2E1h]*4+2
  TSC[65h:13h]=06h     ;3DS DriverGainSP'   ;/      right?   ;HWCAL[2E1h]*4+2
  TSC[65h:16h]=00h     ;3DS AnalogVolumeHP Left  (0..7Eh?)   ;HWCAL[2E2h]
  TSC[65h:17h]=00h     ;3DS AnalogVolumeHP Right (0..7Eh?)   ;HWCAL[2E2h]
  TSC[65h:1Bh]=07h     ;3DS AnalogVolumeSP  ;\maybe left?    ;HWCAL[2E3h]
  TSC[65h:1Ch]=07h     ;3DS AnalogVolumeSP' ;/      right?   ;HWCAL[2E3h]
  TSC[65h:33h]=03h     ;3DS MicrophoneBias                   ;HWCAL[2E6h]
  TSC[65h:41h]=00h+wait;3DS PGA_GAIN (mic)      (bit0-5)     ;HWCAL[2E8h]
  TSC[65h:42h]=02h+wait;3DS QuickCharge (what?) (bit0-1)     ;HWCAL[2E7h]
  TSC[65h:47h,4Bh,4Ch,4Dh,4Eh,52h,53h]  ;unused, but nonzero
  TSC[65h:77h]=94h/95h ;3DS ? (reset=94h, ORed with 01h)
  TSC[65h:78h]         ;unused, but nonzero
  TSC[65h:7Ah]=01h     ;3DS ?
```

Some here seem to be alike TSC[1:24h]..TSC[1:2Bh]



## Page 67h,FBh (3DS Touchscreen/Circle Pad)


```
  TSC[67h:17h]=43h     ;3DS AnalogSense & Precharge     ;HWCAL[40Fh]+[40Eh]*10h
  TSC[67h:19h]=69h     ;3DS AnalogStabilize & XP Pullup ;HWCAL[40Dh]+[411h]*10h
  TSC[67h:1Bh]=80h     ;3DS AnalogDebounce & YM_Driver  ;HWCAL[410h]+[412h]*80h
  TSC[67h:24h]=98h/18h ;3DS bit7=0=touchscreen.on  ;bit2=1=has new touchdata?
  TSC[67h:25h]=43h/53h ;3DS bit5-2=0100b=touchscreen.on
  TSC[67h:26h]=00h/ECh ;3DS bit7=1=touchscreen.on  ;bit1=1=had old touchdata?
  TSC[67h:27h]=11h     ;3DS AnalogInterval           ;HWCAL[40Ch]+10h
  TSC[67h:2Bh]=read    ;3DS Ack Headphone connect IRQ (always returns 00h)
  TSC[FBh:01h]=read    ;3DS fifo 26x16bit; 5xTSC.x, 5xTSC.y, 8xCPAD.y, 8xCPAD.x
```




# <a name="3dsi2cregisters"></a>3DS I2C Registers




## I2C Registers


```
  Address   Width Old3DS  Name
  10161000h 1     Yes     I2C_BUS0_DATA     ;\
  10161001h 1     Yes     I2C_BUS0_CNT      ; BUS 0 (old DSi devices)
  10161002h 2     Yes     I2C_BUS0_CNTEX    ;
  10161004h 2     Yes     I2C_BUS0_SCL      ;/
  10144000h 1     Yes     I2C_BUS1_DATA     ;\
  10144001h 1     Yes     I2C_BUS1_CNT      ; BUS 1 (extra 3DS devices)
  10144002h 2     Yes     I2C_BUS1_CNTEX    ;
  10144004h 2     Yes     I2C_BUS1_SCL      ;/
  10148000h 1     Yes     I2C_BUS2_DATA     ;\
  10148001h 1     Yes     I2C_BUS2_CNT      ; BUS 2 (extra 3DS gimmicks)
  10148002h 2     Yes     I2C_BUS2_CNTEX    ;
  10148004h 2     Yes     I2C_BUS2_SCL      ;/
```



## 10161000h - I2C\_BUS0\_DATA



## 10144000h - I2C\_BUS1\_DATA



## 10148000h - I2C\_BUS2\_DATA


Unknown. Supposedly data.



## 10161001h - I2C\_BUS0\_CNT



## 10144001h - I2C\_BUS1\_CNT



## 10148001h - I2C\_BUS2\_CNT


```
  0     Stop  (0=No, 1=Stop/last byte)
  1     Start (0=No, 1=Start/first byte)
  2     Pause (0=Transfer Data, 1=Pause after Error, used with/after Stop)
  3     unknown/unspecified
  4     Ack Flag (0=Error, 1=Okay) (For DataRead: W, for DataWrite: R)
  5     Data Direction (0=Write, 1=Read)
  6     Interrupt Enable (0=Disable, 1=Enable)
  7     Start/busy (0=Ready, 1=Start/busy)
```



## 10161002h - I2C\_BUS0\_CNTEX



## 10144002h - I2C\_BUS1\_CNTEX



## 10148002h - I2C\_BUS2\_CNTEX


```
  0     Current SCL pin state (0=Low, 1=High/idle)                       (R)
  1     Wait if SCL held low  (0=No/fixed delay, 1=Yes, wait if SCL=low) (R/W)
  3-14  Unused (0)
  15    Unknown (BUS0: can be set, alongsides bit1 becomes read-only?)   (?)
```

Bit1=0 appends a short fixed delay after each byte. Bit1=1 will automatically
wait if the SCL clock pin is held low: If the peripheral doesn't do that then
it can be even slightly faster than the fixed delay, if the peripheral does
hold SCL low then the 3DS will wait as long as needed (eg. required for
3DS/New3DS MCU and New3DS C-Stick).



## 10161004h - I2C\_BUS0\_SCL



## 10144004h - I2C\_BUS1\_SCL



## 10148004h - I2C\_BUS2\_SCL


```
  0-5   Duration for SCL=Low   (0..3Fh, 0=Fastest)  ;default=0
  6-7   Unused (0)
  8-12  Duration for SCL=High  (0..1Fh, 0=Fastest)  ;default=5
  13-15 Unused (0)
```

The fastest setting (0000h) is about 380kHz (about 41Kbyte/s).

The slowest setting (1F3Fh) is about 84kHz (about 9Kbyte/s)

Hmmm, or maybe the raw bitrate is faster, but with short pause between bytes?




# <a name="3dsi2cdevicelist"></a>3DS I2C Device List




## I2C Devices


```
  id  bus:dev  service      Device description
  0   0:4Ah    "i2c::MCU"   BPTWL (aka MCU registers for DSi mode)  ;\same
  1   0:7Ah    "i2c::CAM"   Camera0 (internal camera, self-facing)  ; as DSi
  2   0:78h    "i2c::CAM"   Camera1 (external camera, right eye)    ;/
  3   1:4Ah    "i2c::MCU"   MCU (aka MCU registers for 3DS mode)
  4   1:78h    "i2c::CAM"   Camera2 (external camera, left eye)
  5   1:2Ch    "i2c::LCD"   Upper LCD screen (lcd0)
  6   1:2Eh    "i2c::LCD"   Lower LCD screen (lcd1)
  7   1:40h    "i2c::DEB"   Reserved for Debug?
  8   1:44h    "i2c::DEB"   Reserved for Debug?
  9   2:A6h/D6h"i2c::HID"   Debug?? addr changed from A6h to D6h in 8.0.0-18
  10  2:D0h    "i2c::HID"   Gyroscope (old version)  <-- read = FFh's ?
  11  2:D2h    "i2c::HID"   Gyroscope (new version)  <-- EXISTS in New3DS
  12  2:A4h    "i2c::HID"   Reserved for DebugPad
  13  2:9Ah    "i2c::IR"    Infrared Transmitter/Receiver (IrDA)
  14  2:A0h    "i2c::EEP"   Reserved for DebugEeprom?
  15  1:EEh    "i2c::NFC"   New3DS-only NFC (Near-field communication)
  16  0:40h    "i2c::QTM"   New3DS-only QTM (head tracking?) IO Expander!
  17  2:54h    "i2c::IR"    New3DS-only C-stick and ZL/ZR.. 44pin chip??
  -   none(?)  -            New3DS-only Hasn't co-packaged EEPROM in NFC chip?
  -   0:A0h    -            Reserved for Unknown DSi camera0 (Ext)
  -   0:E0h    -            Reserved for Unknown DSi camera1 (Self)
  -   0:40h    -            Reserved for Unknown DSi Debug stuff? and QTM
  -   0:90h    -            Reserved for Unknown DSi Debug stuff?
  -   0:00h-0Eh             Mirrors to BPTWL for whatever reason
  -   0:F0h-FEh             Mirrors to BPTWL for whatever reason
  -   0:5Ah                 Internal dummy addr used by BPTWL when busy?
  -   2:00h                 Unknown, something responds here with ACK and FFh's
```

Notice: These device addresses are used for writing to the respective device,
for reading bit0 must be set (see I2C protocol).



## 3DS Secondary I2C Devices


There are also some internal/secondary I2C busses (not connected to the ARM
CPUs).

```
  MCU:30h   Accelerometer                                 ;\
  MCU:6Ch   Fuel Gauge MAX17040 (or newer chip in New3DS) ; connected to
  MCU:84h   video related?   ;Power Managment Device?     ; MCU chip)
  MCU:A4h   batt.flg/volume? ;Touchscreen/Sound chip?     ;/
  Wifi:A0h  I2C bus EEPROM                   ;connected to Atheros Wifi chip
  NFC:Axh   NFC chip has on-chip CAT24C64 EEPROM (?), but not wired to ARM (?)
```




# <a name="3dsi2cmcuregistersummary"></a>3DS I2C MCU Register Summary




## Bus/Device 1:4Ah - MCU


The McuIndex is usually automatically incremented after each data byte (eg.
allowing to read the two Version bytes in one pass).

However, there are a few arrays (at McuIndex=29h,2Dh,4Fh,61h,7Fh), which will
increment the ArrayIndex instead of the McuIndex. This happens only if the
index value (in the I2C command) was pointing to the array (eg. writing 5 bytes
to index 29h will update the Power LED Array. But, writing 5 bytes to index 28h
will update McuIndex 28h,29h,2Ah,2Bh,2Ch; without getting stuck at 29h, and
thus updating only the 1st byte of the Power LED Array).

The extra-special case is using index 60h in the I2C command (it will increment
once, then stay at index 61h).



## MCU Registers


```
  00h     R    Version high (bit0-3) and hardware.type? (bit4-7)         ;\Firm
  01h     R    Version low (8bit)                                        ;/
  02h     R/W  Reset Event flags                                         ;-Stat
  03h     R/W  Top screen flicker                                        ;\
  04h     R/W  Bottom screen flicker                                     ;/
  05h-07h R/W  MCU Firmware update unlock sequence   ;ARRAY[4003h]       ;-Firm
  08h     R    Raw 3D slider position                                    ;\
  09h     R    Volume slider state (00h..3Fh) (as MCUHWC:GetSoundVolume) ;
  0Ah     R    Battery PCB Temperature Celsius (signed)                  ; Stat
  0Bh     R    Fuel Gauge Battery Percentage, msb (percent, 0..64h)      ;
  0Ch     R    Fuel Gauge Battery Percentage, lsb (percent/256, 0..FFh)  ;
  0Dh     R    Fuel Gauge Battery Voltage (in 20mV units)                ;
  0Eh     R    Sub-Device Access Flags? (bit0,1,2-3,4)                   ;
  0Fh     R    Power Status Flags                                        ;/
  10h-13h R    MCU Interrupt Flags, bit0-31 (1=IRQ, cleared after read)  ;\
  14h     R    Unused (cleared after reading, like above IRQ flags)      ;
  15h-17h R/W  Unused                                                    ; IRQs
  18h-1Bh R/W  MCU Interrupt Mask, bit0-31 (0=Enable, 1=Disable)         ;
  1Ch-1Fh R/W  Unused                                                    ;/
  20h     W    System power control (bits are 0=No change, 1=Trigger)    ;\
  21h     W    Change DSi Power Button Status register BPTWL[10h]        ;
  22h     W    Used to set LCD states (bits are 0=No change, 1=Trigger)  ; PWR
  23h     -    Unused (has a dummy write handler, but does nothing)      ;
  24h     R/W  Forced Power Off delay (0=Never, 1=Fastest, 5Dh=Insane)   ;/
  25h-26h R/W  Unused
  27h     R/W  Raw volume slider state                                   ;-
  28h     R/W  Brightness of Wifi/Power/3D LEDs                          ;\
  29h *   R/W  Power LED state + Power LED blink pattern ;ARRAY[5]       ;
  2Ah     R/W  Wifi LED state, 4 bits wide                               ; LEDs
  2Bh     R/W  Camera LED state, 4bits wide                              ;
  2Ch     R/W  3D LED state, 4 bits wide                                 ;
  2Dh *   W    Notification LED Array (4+3x20h bytes)    ;ARRAY[64h]     ;
  2Eh     R    Notification LED Status when read (1=new cycle started)   ;/
  2Fh     -    Unused (has a dummy write handler, but does nothing)
  30h     R/W  RTC Time second  (7bit)   (BCD, 00h..59h)                 ;\
  31h     R/W  RTC Time minute  (7bit)   (BCD, 00h..59h)                 ;
  32h     R/W  RTC Time hour    (6bit)   (BCD, 00h..23h)                 ;
  33h     R/W  RTC Time day of week? (3bit) (?..?, ?=Monday)             ;
                   (renesas calls this "Week 0=Sunday")                  ; RTC
                   (unknown what Nintendo is using here)                 ;
  34h     R/W  RTC Time day     (6bit)   (BCD, 01h..31h)                 ;
  35h     R/W  RTC Time month   (5bit)   (BCD, 01h..12h)                 ;
  36h     R/W  RTC Time year    (8bit)   (BCD, 00h..99h)                 ;
  37h     R/W  RTC Watch Error Correction (SUBCUD)  ;NOT leap year       ;
  38h     R/W  RTC Alarm minute (7bit)   (BCD, 00h..59h)                 ;
  39h     R/W  RTC Alarm hour   (6bit)   (BCD, 00h..23h)                 ;
  3Ah     R/W  RTC Alarm day    (6bit)   (BCD, 01h..31h) ;\maybe 0=off?  ;
  3Bh     R/W  RTC Alarm month  (5bit)   (BCD, 01h..12h) ;/              ;
  3Ch     R/W  RTC Alarm year   (8bit)   (BCD, 00h..99h)                 ;
  3Dh     R    RTC RSUBC.lsb (in 32768Hz units)         ;\range 0..7FFFh ;
  3Eh     R    RTC RSUBC.msb (latched when reading lsb) ;/(or 0..80xxh)  ;
  3Fh     W    RTC Flags (bit0=ScreenBlack?, bit1=DisableRtc32KHzOutput) ;/
  40h     R/W  Accelerometer Mode (bit0=AccelerometerOn, bit1=PedometerOn)   ;\
  41h     R/W  Accelerometer Index for Manual I2C Read via MCU[44h]          ;
  42h     R/W  Unused                                                        ;
  43h     R/W  Accelerometer Index for Manual I2C Write via MCU[44h]         ;
  44h     R/W  Accelerometer Data from/to Read/Write via MCU[41h/43h]        ;
  45h,46h R    Accelerometer Output X (lsb,msb) ;resting=+/-00xxh            ;
  47h,48h R    Accelerometer Output Y (lsb,msb) ;resting=+/-00xxh            ;
  49h,4Ah R    Accelerometer Output Z (lsb,msb) ;resting=-41xxh (gravity)    ;
  4Bh     R/W  Pedometer Step Count, bit0-7    ;\(for the current day)       ;
  4Ch     R/W  Pedometer Step Count, bit8-15   ; (uh, how/which day?)        ;
  4Dh     R/W  Pedometer Step Count, bit16-23  ;/(rather total count?)       ;
  4Eh     R/W  Pedometer Flags (Wr.bit0=ClearArray?, Rd.bit4=ArrayFull?)     ;
  4Fh *   R    Pedometer Timestamp[6] and StepCounts[2*A8h]  ;ARRAY[6+2*A8h] ;
  50h,51h R/W  Pedometer Minute,Second compare values (?)                    ;/
  52h-57h R/W  Unused, except some bytes are set to fixed values once and then
  58h     R/W  Volume slider calibration point for 0%   (default=36h)
  59h     R/W  Volume slider calibration point for 100% (default=C9h)
  5Ah     R/RW Invalid, do not use!
                 on newer MCU_FIRM versions this is set to FFh once and then
                 on older MCU_FIRM versions this is a read-only counter
  5Bh-5Fh -    N/A (write=ignored, read=FFh)
  60h *   R/W  Battery-backed RAM Index                                  ;\
  61h *   R/W  Battery-backed RAM Data (200 bytes) ;ARRAY[C8h]           ; Misc
  62h-7Eh -    N/A (write=ignored, read=FFh)                             ;
  7Fh *   R    Various system state information ;ARRAY[09h/13h]          ;/
  80h-FFh -    N/A (write=ignored, read=FFh)
```



## Blurb


On old versions of MCU\_FIRM none of the invalid registers are masked away by
the read handler function, but are still read-only. Newer MCU\_FIRM versions
return the hardcoded value FF instead.

Reportedly register 3Bh (RTC Alarm month) "could be used on very old MCU\_FIRM
versions to upload MCU firmware if some conditions (?) are met", uh?.




# <a name="3dsi2cmcu00h01h05h07hfirmware"></a>3DS I2C MCU[00h-01h,05h-07h] - Firmware




## MCU[00h] - Version high (bit0-3) and hardware.type? (bit4-7) (R)



## MCU[01h] - Version low (8bit) (R)


```
  OldMCU: Version 0.008 or lower   ;\differs on LCD bits:
  NewMCU: Version 0.009 or higher  ;/backlight and "push"
```



## MCU[05h-07h] - MCU Firmware update unlock sequence ;ARRAY[4003h] (R/W)


Updating MCU Firmware FLASH is done by writing 4003h bytes to MCU[05h and up].
The I2C transfer timings (and flash write timings) are automatically handled
via SCL-hold. The upload takes about 2 seconds, and the console does then
reboot the MCU... the backlights stay on, but I2C MCU access seems to be
non-functional... for a while?

The first three bytes must be 6Ah,68h,6Ch (aka "jhl"), if the 3rd write does
match (and 1st-2nd write were also correct), then the MCU switches to receiving
a 4000h-byte firmware image. The image consists of two blocks:

```
  1000h bytes written to flash address 0000h-0FFFh (4K)
  3000h bytes written to flash address 2000h-4FFFh (12K)
```

For error checking, the image must contain three identical 9-byte
"HH:MM:SS",00h timestamps:

```
  0FF6h..0FFEh - 1st timestamp
  2000h..2008h - 2nd timestamp
  4FF6h..4FFEh - 3rd timestamp
```

The first byte of the timestamp must be other than FFh, and the third byte must
be ":".

BUG: The 1st/3rd timestamp are checked before applying the firmware update, but
2nd timestamp isn't checked until AFTER applying it (then causing blinking red
power led, and requiring the reflash via UART pin).

- [3DS I2C MCU - RL78 Flash Programming via UART](#3dsi2cmcurl78flashprogrammingviauart)
Uploading bugged code may also require reflashing via UART (the UART stuff is
handled in ROM, and works safely even if the whole flash is erased).



## Firmware Inner Workings


The MCU contains a RL78 processor with reflashable firmware.

- [3DS I2C MCU - RL78 CPU Opcode List](#3dsi2cmcurl78cpuopcodelist)
- [3DS I2C MCU - RL78 CPU Opcode Map](#3dsi2cmcurl78cpuopcodemap)
- [3DS I2C MCU - RL78 CPU Registers and Flags](#3dsi2cmcurl78cpuregistersandflags)
- [3DS I2C MCU - RL78 SFR Registers (Special Function Registers) (I/O ports)](#3dsi2cmcurl78sfrregistersspecialfunctionregistersioports)
- [3DS I2C MCU - RL78 Misc](#3dsi2cmcurl78misc)


## Firmware Nocash MCU Patches


Code Execution in Battery RAM:

```
  MCU[05h-07h] = "exc"  --> Battery RAM code gets executed immediately
  MCU[05h-07h] = "exq"  --> Battery RAM code gets enqueued as callback
  Before execution, use MCU[61h] to upload code to Battery RAM, the RAM
  can be also used to store parameters and return values, you may want to
  restore the original RAM content after execution for not confusing the OS.
  The ROM/RAM memory map varies for different MCU firmware versions, however,
  the patched firmware provides useful ROM/RAM addresses in below tables,
  code should either use relative jumps, or addresses from those tables.
```

Call Table Vectors for ROM functions:

```
  00080h  Process Standard Callbacks    ;\
  00082h  Add Callback AX               ; Nintendo's own stuff (not useful)
  00084h  Process Enqueued Callbacks    ;/
  000B4h  I2C_Receive_Block             ;\Slave I2C recv/send (can be used
  000B6h  I2C_Send_Block                ;/from within callbacks only)
  000B8h  FLASH Init and kill IRQs      ;\
  000BAh  FLASH Erase 400h bytes        ; FLASH init/erase/write/finish
  000BCh  FLASH Write max 100h bytes    ; (eg. for custom code in backup area)
  000BEh  FLASH Finish 400h bytes       ;/
```

Pointers to RAM arrays:

```
  F4FE8h  MCU[00h..5Ah] Registers  (5Bh bytes)  ;\
  F4FEAh  MCU[61h] Battery RAM     (C8h bytes)  ; Pointers to RAM arrays
  F4FECh  MCU[2Dh] Notify LED RAM  (64h bytes)  ;
  F4FEEh  MCU[4Fh] Pedometer_array (150h bytes) ;/
```

Other General Patches:

```
  Faster power button tap duration (0s instead laggy delay)
  Faster power button hold duration (1s instead 3s)
  Changed Power LED color upon holding power button (purple)
  Faster shutdown after holding power button (can be 0s instead 12s)
  Faster shutdown after normal power down (omitting LED fade-out delay)
```



## Firmware Image/Dumping


A copy of the firmware-image can be found in the System Modules folder,

```
  3ds:\title\00040130\00001f02\content\000000vv.app ;MCU
  3ds:\title\00040130\20001f02\content\000000vv.app ;MCU New3DS
  3ds:\title\00040130\00001f03\content\000000vv.app ;MCU Safe mode
  3ds:\title\00040130\20001f03\content\000000vv.app ;MCU Safe mode New3DS
```

The .app file contains a .code file with ARM11 code (and the MCU firmware
somewhere inside of that .code file, usually at file offset A078h or A07Ch;
starting with the 3-byte unlock code ("jhl"), followed by the 4000h-byte
firmware image).

Dumping the firmware directly from FLASH memory isn't supported. However, one
could patch the firmware, and then dump the backup of the old version (that
will destroy the backup of the yet older version though).




# <a name="3dsi2cmcu02h0fhstatus"></a>3DS I2C MCU[02h-0Fh] - Status




## MCU[02h] - Reset Event flags (R/W)


2bit value, writing will mask away/"acknowledge" the event, set to 3 by
mcuMainLoop on reset if reset source is "Watchdog", uh?

```
  0    RTC clock value got reset to defaults           (R/ack)
  1    Watchdog reset happened                         (R/ack)
  2-4
  5    value from BPTWL[12h].bit7 (Unknown)               (R)
  6    value from BPTWL[12h].bit0 (1=IRQ on Pwr Butt tap) (R)
  7    value from BPTWL[12h].bit1 (Unknown)               (R)
```

actually, this register returns C0h or C1h

bit0 can be cleared by writing bit0=0 (writing bit0=1 has no effect)



## MCU[03h] - Top screen flicker (R/W)



## MCU[04h] - Bottom screen flicker (R/W)


Whatever. Maybe from HWCAL files?



## MCU[08h] - Raw 3D slider position (R)


Slider.



## MCU[09h] - Volume slider state (00h..3Fh) (as MCUHWC:GetSoundVolume) (R)


Slider.



## MCU[0Ah] - Battery PCB Temperature Celsius (signed) (R)


```
  0-7  Degrees Celsius (51F3h-(ADC(8)*70h))/100h  ;signed, usually 17h..19h
```



## MCU[0Bh] - Fuel Gauge Battery Percentage, msb (percent, 0..64h) (R)



## MCU[0Ch] - Fuel Gauge Battery Percentage, lsb (percent/256, 0..FFh) (R)


Battery pecentage, from Fuel Gauge SOC register (State Of Charge).



## MCU[0Dh] - Fuel Gauge Battery Voltage (in 20mV units) (R)


Battery voltage, from upper 8bit of Fuel Gauge VCELL register.



## MCU[0Eh] - Sub-Device Access Flags? (bit0,1,2-3,4) (R)


```
  0    Device 6Ch Error (Fuel Gauge)    (0=Okay, 1=Error)
  1    Device 30h Error (Accelerometer) (0=Okay, 1=Error)
  2-3  Device A4h related (Volume etc.)    ;TSC[10h]
  4    LED brightness related
  5-7  Unused
```

Whatever.



## MCU[0Fh] - Power Status Flags (R)


```
  0    Unused
  1    ShellState (hinge)  (1=Shell open)               ;\
  2    Unused                                           ; mcu::RTC
  3    AdapterState (Charger connected)                 ;
  4    BatteryChargeState  (1=Charging)                 ;/
  5    OldMCU: Unused                                   ;\
  6    OldMCU: something (1bit) ;\back-                 ; mcu::GPU
  5-6  NewMCU: something (2bit) ;/light(s)?             ;
  7    whatever                 ;-push?                 ;/
```




# <a name="3dsi2cmcu10h1fhinterruptflags"></a>3DS I2C MCU[10h-1Fh] - Interrupt Flags




## MCU[10h-13h] - MCU Interrupt Flags, bit0-31 (1=IRQ, cleared after read) (R)



## MCU[18h-1Bh] - MCU Interrupt Mask, bit0-31 (0=Enable, 1=Disable) (R/W)


```
  0     Power button press (for 27 "ticks") aka 0.2s
  1     Power button held (for 375 "ticks" aka 3s, turns off after another 12s)
  2     HOME button press (for 5 "ticks") aka 0.04s
  3     HOME button release
  4     Wifi button press (for 5 "ticks") aka 0.04s
  5     Shell close
  6     Shell open
  7     Fatal hardware condition? (sent when MCU gets reset by Watchdog timer)
  8     Charger removed
  9     Charger plugged in
  10    RTC alarm
  11    Accelerometer I2C manual read/write done
  12    Accelerometer new XYZ sample update
  13    Battery dropped below 11%, 6% or 1% (warns at those 3 points)
  14    Battery charging stop (independent of charger state)
  15    Battery charging start
  16    TSC[10h].bit0=1=Whatever, or BPTWL[11h]=01h=Reset
  17    TSC[10h].bit6=1=Whateverelse
  18    TSC[10h].bit2 changed to zero
  19    TSC[10h].bit2 changed to one
  20    TSC[10h].bit3 changed to zero
  21    TSC[10h].bit3 changed to one
  22    Volume slider position change
  23    Read from BPTWL[00h] version register has occurred
  24    Video Display "push" off
  25    Video Display "push" on
  26    Video Bottom screen backlight off
  27    Video Bottom screen backlight on
  28    Video Top screen backlight off
  29    Video Top screen backlight on
  30    set by mcu sysmodule  ;\uh, flag bits aren't set by MCU (and can't be
  31    set by mcu sysmodule  ;/set by ARM), but maybe ARM sets mask bits..?
```




# <a name="3dsi2cmcu20h24hpowercontrol"></a>3DS I2C MCU[20h-24h] - Power Control




## MCU[20h] - System power control (bits here are 0=No change, 1=Trigger) (W)


```
  0     Power off
  1     Reboot (unused?)
  2     Reboot (used by mcu sysmodule and LgyBg)
  3     Used by LgyBg to power off, causes hangs in 3DS-mode
  4     NewMCU: looks like power-off type (real power off, or sleep state...?)
          "an mcu::RTC command uses this, seems to do something with the
          watchdog: Bit 4 sets a bit at a RAM address which seems to control
          the watchdog timer state, then this bit is immediately unmasked.
          This field has a bitmask of 0x0F."
  4     OldMCU: Both backlights off
  5     OldMCU: Both backlights on
  6     OldMCU: Push to LCDs off   ;\uh, what is "push" ?
  7     OldMCU: Push to LCDs on    ;/
```

Unknown how to fully power-off. Writing 01h does somewhat power-off, but the
battery still runs empty after 10-20 hours. Some people execute a
Wait-for-Interrupt opcode after the I2C write; not tested if that does help
(and if that opcode is needed on all ARM11 CPU core(s) and ARM9 side).



## MCU[21h] - Change DSi Power Button Status register BPTWL[10h] (W)


00h=No Change, other=Shuffle bits and set BPTWL[10h]

```
  0     Copied to BPTWL[10h].bit3
  1     Copied to BPTWL[10h].bit0
  2     Copied to BPTWL[10h].bit1
  3     Copied to BPTWL[10h].bit5
  4     Copied to BPTWL[10h].bit4
  5     Copied to BPTWL[10h].bit6
  6-7   Not used (except, affect the "00h=No change" thing)
```



## MCU[22h] - Used to set LCD states (bits here are 0=No change, 1=Trigger) (W)


```
  0     NewMCU: Push to LCDs off   ;\uh, what is "push" ?
  1     NewMCU: Push to LCDs on    ;/
  2     NewMCU: Bottom screen backlight off;\For 2DS:
  3     NewMCU: Bottom screen backlight on ;/both screens
  4     NewMCU: Top screen backlight off   ;\For 2DS:
  5     NewMCU: Top screen backlight on    ;/No effect
```

"The rest of the bits are masked away."



## MCU[24h] - Forced Power Off delay (0=Never,1=Fastest,5Dh=InsaneDefault) (R/W)


```
  0-7   Delay in 8Hz units, this value seems to be battery backed
        (the value seems to also affect the bootrom error screen)
```




# <a name="3dsi2cmcu28h2ehledcontrol"></a>3DS I2C MCU[28h-2Eh] - LED Control




## MCU[28h] - Brightness of Wifi/Power/3D LEDs (R/W)


Brightness for Wifi/Power/3D LEDs (when the LEDs are on). Range 00h..FFh
(default is FFh=max).



## MCU[29h] - Power LED state + Power LED blink pattern ;ARRAY[5] (R/W)


1st byte (Power LED mode):

```
  00h   = fade to brightness MCU[28h] with battery check
  01h   = fade to brightness MCU[28h]
  02h   = pulsating fade on/off with battery check
  03h   = fade to brightness 00h
  04h   = instantly set brightness 00h
  05h   = instantly set brightness FFh
  06h   = Blinking RED (affects Power+Notification LEDs)
  Other = Same as 00h
```

2nd..5th bytes (optional, if any written):

```
  Power LED Blink pattern (default is 55h,55h,55h,55h)
```



## MCU[2Ah] - Wifi LED state, 4 bits wide (R/W)


```
  00h = Wifi LED always off
  01h..0Fh = Wifi LED on (and blink upon traffic?)
```



## MCU[2Bh] - Camera LED state, 4bits wide (R/W)


```
  00h = Camera LED always off
  01h = Camera LED slowly blinking
  02h = Camera LED always on
  03h = Camera LED set via BPTWL[31h] (DSi mode)
  04h = Camera LED flash once (then switch to 00h=off)
  05h = Camera LED off once   (then switch to 02h=on)
  06h..0Fh = Invalid (same as 00h)
```

Camera LED exists only in older 3DS, not in New3DS. The camera LED uses a
digital 1bit signal (without variable brightness).



## MCU[2Ch] - 3D LED state, 4 bits wide (R/W)


```
  00h = 3D LED Off (or fade-out to zero)
  01h = 3D LED On  (or fade-in/out to MCU[28h] setting)
  02h..0Fh = Same as 01h (On)
```

3D LED exists only in older 3DS, not in New3DS.



## MCU[2Dh] - Notification LED Array (4+3x20h bytes) ;ARRAY[64h] (W)


```
  [2Dh.00h]      ;Delay (0..FFh = Delay 1..100h)
  [2Dh.01h]      ;Brightness/divider or so?
  [2Dh.02h]      ;Speed, some timer compare value? (FFh=none?)
  [2Dh.03h]      ;unused
  [2Dh.04h..23h] ;data Red[0..1Fh]
  [2Dh.24h..43h] ;data Green[0..1Fh]
  [2Dh.44h..63h] ;data Blue[0..1Fh]
```

"It's possible to write data here with size less than 64h, and only that
portion of the pattern data will get overwritten. Writing past the size of this
register seems to do nothing. Reading from this register only returns zeroes."



## MCU[2Eh] - Notification LED Status when read (1=new cycle started) (R)


```
  0     Flag
  1-7   Not used
```




# <a name="3dsi2cmcu30h3fhrealtimeclockrtc"></a>3DS I2C MCU[30h-3Fh] - Real-Time Clock (RTC)




## MCU[30h] - RTC Time second  (7bit)   (BCD, 00h..59h) (R/W)



## MCU[31h] - RTC Time minute  (7bit)   (BCD, 00h..59h) (R/W)



## MCU[32h] - RTC Time hour    (6bit)   (BCD, 00h..23h) (R/W)



## MCU[33h] - RTC Time day of week? (3bit) (?..?, ?=Monday) (R/W)


```
              (renesas calls this "Week 0=Sunday")
              (unknown what Nintendo is using here)
```


## MCU[34h] - RTC Time day     (6bit)   (BCD, 01h..31h) (R/W)



## MCU[35h] - RTC Time month   (5bit)   (BCD, 01h..12h) (R/W)



## MCU[36h] - RTC Time year    (8bit)   (BCD, 00h..99h) (R/W)


Date/time.



## MCU[37h] - RTC Watch Error Correction (SUBCUD) (R/W) ;NOT leap year


Error correction. Signed 32768Hz offset or so?



## MCU[38h] - RTC Alarm minute (7bit)   (BCD, 00h..59h) (R/W)



## MCU[39h] - RTC Alarm hour   (6bit)   (BCD, 00h..23h) (R/W)



## MCU[3Ah] - RTC Alarm day    (6bit)   (BCD, 01h..31h) (R/W) ;\maybe 0=off?



## MCU[3Bh] - RTC Alarm month  (5bit)   (BCD, 01h..12h) (R/W) ;/



## MCU[3Ch] - RTC Alarm year   (8bit)   (BCD, 00h..99h) (R/W)


Alarm. Unknown how to enable/disable that feature (other than using a far-away
date, or even using a non-BCD date). Also unknown if alarm is working while
powered off, or while playing a game.



## MCU[3Dh] - RTC RSUBC.lsb (in 32768Hz units) (R)



## MCU[3Eh] - RTC RSUBC.msb (latched when reading lsb) (R)


```
  0-15  Range 0..7FFFh (or 0..80xxh)
```



## MCU[3Fh] - RTC Flags (bit0=ScreenBlack?, bit1=DisableRtc32KHzOutput) (W)


```
  0     ScreenBlack?
  1     DisableRtc32KHzOutput? what for?
```



## Legacy RTC Emulation


The 3DS can emulate GBA/NDS/DSi RTC's. That is, the 3DS software must read the
battery-backed time from MCU RTC registers, and then copy it to the emulated
RTC registers...

NDS/DSi Console RTC:

- [3DS GPIO Registers](#3dsgpioregisters)
GBA Cartridge RTC:

- [3DS Config - ARM7 Registers (GBA/NDS/DSi Mode)](#3dsconfigarm7registersgbandsdsimode)



# <a name="3dsi2cmcu40h51haccelerometerpedometer"></a>3DS I2C MCU[40h-51h] - Accelerometer/Pedometer




## MCU Registers


```
  40h     R/W  Accelerometer Mode (bit0=AccelerometerOn, bit1=PedometerOn)   ;\
  41h     R/W  Accelerometer Index for Manual I2C Read via MCU[44h]          ;
  42h     R/W  Unused                                                        ;
  43h     R/W  Accelerometer Index for Manual I2C Write via MCU[44h]         ;
  44h     R/W  Accelerometer Data from/to Read/Write via MCU[41h/43h]        ;
  45h,46h R    Accelerometer Output X (lsb,msb) ;resting=+/-00xxh            ;
  47h,48h R    Accelerometer Output Y (lsb,msb) ;resting=+/-00xxh            ;
  49h,4Ah R    Accelerometer Output Z (lsb,msb) ;resting=-41xxh (gravity)    ;
  4Bh     R/W  Pedometer Step Count, bit0-7    ;\(for the current day)       ;
  4Ch     R/W  Pedometer Step Count, bit8-15   ; (uh, how/which day?)        ;
  4Dh     R/W  Pedometer Step Count, bit16-23  ;/(rather total count?)       ;
                An up/down movement (on whichever axis that corresponds      ;
                to gravity direction) is treated as step; however, the       ;
                first step isn't counted, so 5 continous steps would         ;
                increment the counter by 4.                                  ;
  4Eh     R/W  Pedometer Flags (Wr.bit0=ClearArray?, Rd.bit4=ArrayFull?)     ;
  4Fh *   R    Pedometer Timestamp[6] and StepCounts[2*A8h]  ;ARRAY[6+2*A8h] ;
  50h,51h R/W  Pedometer Minute,Second compare values (?)                    ;/
```

Reading the Output X/Y/Z registers would be the normal way to get the
accelerometer data (if enabled in the mode register).



## Pedometer (Step counter)


The Pedometer is some software feature in the MCU that converts the
accelerometer data to step counters.

Power-off switches the accelerometer power supply off. However, it is kept
powered & can do step counting in sleep mode. Step counting is used for
"Play Coins" and the pre-installed statistic tool "Omoide Kirokuchou" (probably
has other name in english?).



## Manual access to Accelerometer I2C registers


The manual read/write feature allows to view/modify I2C registers directly; for
debugging/hacking purposes or so. The manual read/write seem to be done in a
callback function (=not immediately after writing MCU[41h] or MCU[44h]), and,
before touching further accelerometer registers, one must wait until the
callback has executed (which is indicated by MCU.interrupt.bit11).



## Accelerometer Chip


On Old3DS it is marked "2048, 33DH, X1MAQ", which is said to be ST LIS331DLH.

On New3DSXL it is marked "KXTKK, 40860, .3413", which might be a Kionix chip,
resembling KXTIK, but with LIS331DLH-style register map & device address.

Both Old3DS and New3DSXL have the chip on the mainboard, somewhere underneath
of the bottom-screen. That (and the exact location) may be important when
interpreting the accelerometer data (ie. the chip isn't parallel with the
top-screen unless the case is fully unfolded).

The Accelerometer chip is wired to the MCU, so it's I2C registers can be
accessed only indirectly, through the MCU.


```
 ___________________ Internal Registes (for manual access) ___________________
```



## Internal LIS331DLH Accelerometer I2C Register map (for manual access)


```
  Addr   Type Default  Name
  00h-0Eh  -  -        -               Reserved (do not modify)
  0Fh      R  00110010 WHO_AM_I        Device identification register (32h)
  10h-1Fh  -  -        -               Reserved (do not modify)
  20h      RW 00000111 CTRL_REG1       Power Control
  21h      RW 00000000 CTRL_REG2       Filter Control
  22h      RW 00000000 CTRL_REG3       Interrupt Control
  23h      RW 00000000 CTRL_REG4       Misc Control
  24h      RW 00000000 CTRL_REG5       Sleep to Wake Control
  25h      R  -        HP_FILTER_RESET High-Pass Filter Clear (Read=clear)
  26h      RW 00000000 REFERENCE       High-pass Filter Reference value
  27h      R  00000000 STATUS_REG      Output Status
  28h      R  output   OUT_X_L         Out.X.L ;\usually near +/-00xxh
  29h      R  output   OUT_X_H         OUT.X.H ;/
  2Ah      R  output   OUT_Y_L         OUT.Y.L ;\usually near +/-00xxh
  2Bh      R  output   OUT_Y_H         OUT.Y.H ;/
  2Ch      R  output   OUT_Z_L         OUT.Z.L ;\usually near -41xxh (gravity)
  2Dh      R  output   OUT_Z_H         OUT.Z.H ;/
  2Eh-2Fh  -  -        -               Reserved (do not modify)
  30h      RW 00000000 INT1_CFG        Interrupt 1 Config      ;\
  31h      R  00000000 INT1_SOURCE     Interrupt 1 Status      ; INT 1
  32h      RW 00000000 INT1_THS        Interrupt 1 Threshold   ;
  33h      RW 00000000 INT1_DURATION   Interrupt 1 Duration    ;/
  34h      RW 00000000 INT2_CFG        Interrupt 2 Config      ;\
  35h      R  00000000 INT2_SOURCE     Interrupt 2 Status      ; INT 2
  36h      RW 00000000 INT2_THS        Interrupt 2 Threshold   ;
  37h      RW 00000000 INT2_DURATION   Interrupt 2 Duration    ;/
  38h-3Fh  -  -        -               Reserved (do not modify)
  40h-7Fh  -  -        -               Undocumented (zero)
  80h-FFh              Same as 00h-7Fh, with auto-incrementing index
```



## ACCL[0Fh] - WHO\_AM\_I - Device identification register (R)


```
  0-7  Fixed (32h for LIS331DLH)
```



## ACCL[20h] - CTRL\_REG1 - Power Control (R/W)


```
  0   Xen  X axis enable        (0=Disable, 1=Enable)               (default=1)
  1   Yen  Y axis enable        (0=Disable, 1=Enable)               (default=1)
  2   Zen  Z axis enable        (0=Disable, 1=Enable)               (default=1)
  3-4 DR   Data rate selection  (0=50Hz, Others: see Table 20)      (default=0)
  5-7 PM   Power mode selection (0=Power-down, Other: see Table 19) (default=0)
```

PM bits allow to select between power-down and two operating active modes. The
device is in power-down mode when PD bits are set to "000" (default value after
boot). Table 19 shows all the possible power mode configurations and respective
output data rates. Output data in the low-power modes are computed with
low-pass filter cut-off frequency defined by DR1, DR0 bits.

DR bits, in the normal-mode operation, select the data rate at which
acceleration samples are produced. In low-power mode they define the output
data resolution. Table 20 shows all the possible configuration for DR1 and DR0
bits.

Table 19. Power mode and low-power output data rate configurations:

```
  PM       Power mode selection     Output data rate ODR'LP
  00h      Power-down               --
  01h      Normal mode              <ODR>
  02h      Low-power                0.5Hz
  03h      Low-power                1Hz
  04h      Low-power                2Hz
  05h      Low-power                5Hz
  06h      Low-power                10Hz
```

Table 20. Normal-mode output data rate configurations and low-pass cut-off

frequencies:

```
  DR       Output Data Rate ODR     Low-pass filter cut-off frequency
  00h      50Hz                     37Hz
  01h      100Hz                    74Hz
  02h      400Hz                    292Hz
  03h      1000Hz                   780Hz
```



## ACCL[21h] - CTRL\_REG2 - Filter Control (R/W)


```
  0-1 HPCF  High pass filter cut-off frequency (HPc) (0..3 = 8,16,32,64)
  2   HPen1 High pass filter for interrupt 1 src (0=Bypassed, 1=Filter enabled)
  3   HPen2 High pass filter for interrupt 2 src (0=Bypassed, 1=Filter enabled)
  4   FDS   Filtered data selection (0=Internal filter bypassed, 1=Data from
                                      internal filter sent to output register)
  5-6 HPM   High pass filter mode   (0=Normal mode, Other=see Table 23)
  7   BOOT  Reboot memory content   (0=Normal mode, 1=Reboot memory content)
```

BOOT bit is used to refresh the content of internal registers stored in the
flash memory block. At the device power up the content of the flash memory
block is transferred to the internal registers related to trimming functions to
permit a good behavior of the device itself.

If for any reason the content of trimming registers was changed it is
sufficient to use this bit to restore correct values. When BOOT=1 the content
of internal flash is copied inside corresponding internal registers and it is
used to calibrate the device. These values are factory trimmed and they are
different for every accelerometer. They permit a good behavior of the device
and normally they have not to be changed. At the end of the boot process the
BOOT bit is set again to 0.

- Table 23. High-pass filter mode configuration
  - HPM    High-pass filter mode
  - 00h    Normal mode (reset reading HP\_RESET\_FILTER)
  - 01h    Reference signal for filtering
  - 02h    Normal mode (reset reading HP\_RESET\_FILTER)


HPCF[1:0]. These bits are used to configure high-pass filter cut-off frequency
ft which is given by:

```
  ... XXX ...
```

The equation can be simplified to the following approximated equation:

```
  ... XXX ...
```

Table 24. High-pass filter cut-off frequency configuration

```
  HPcoeff2,1   ft [Hz]        ft [Hz]         ft [Hz]         ft [Hz]
               Data rate=50Hz Data rate=100Hz Data rate=400Hz Data rate=1000Hz
  00           1              2               8               20
  01           0.5            1               4               10
  10           0.25           0.5             2               5
  11           0.125          0.25            1               2.5
```



## ACCL[22h] - CTRL\_REG3 - Interrupt Control (R/W)


```
  0-1  I1_CFG Data signal on INT 1 pad control bits (see table below)
  2    LIR1   Latch IRQ on INT1_SRC register, with INT1_SRC cleared by reading
                INT1_SRC itself (0=IRQ not latched, 1=IRQ latched)
  3-4  I2_CFG Data signal on INT 2 pad control bits (see table below)
  5    LIR2   Latch IRQ on INT2_SRC register, with INT2_SRC cleared by reading
                INT2_SRC itself (0=IRQ not latched, 1=IRQ latched)
  6    PP_OD  Interrupt Push-pull/Open drain    (0=Push-pull, 1=Open drain)
  7    IHL    Interrupt active high/low         (0=Active high, 1=Active low)
```

Table 27. Data signal on INT 1 and INT 2 pad

```
  I#_CFG INT1/INT2 Pad
  00h    Interrupt 1/2 source
  01h    Interrupt 1 source OR interrupt 2 source
  02h    Data ready
  03h    Boot running
```



## ACCL[23h] - CTRL\_REG4 - Misc Control (R/W)


```
  0    SIM    SPI serial interface mode (0=4-wire, 1=3-wire)
  1    ST     Self-test enable          (0=No, 1=Self-test)
  2    -      Reserved (0)
  3    STsign Self-test sign            (0=Self-test Plus; 1=Self-test Minus)
  4-5  FS     Full-scale selection      (0..3 = +/-2g, +/-4g, Reserved, +/-8g)
  6    BLE    Big/little endian data selection (0=Litte-endian, 1=Big-endian)
  7    BDU    Block data update (0=Continuos update, 1=Output registers
                                    not updated between MSB and LSB reading)
```

BDU bit is used to inhibit output registers update between the reading of upper
and lower register parts. In default mode (BDU=0) the lower and upper register
parts are updated continuously. If it is not sure to read faster than output
data rate, it is recommended to set BDU=1. In this way, after the reading of
the lower (upper) register part, the content of that output registers is not
updated until the upper (lower) part is read too.

This feature avoids reading LSB and MSB related to different samples.



## ACCL[24h] - CTRL\_REG5 - Sleep to Wake Control (R/W)


```
  0-1  Turn-on mode selection for sleep to wake function (0 or 3)
  2-7  Reserved (0)
```

TurnOn bits are used for turning on the sleep to wake function.

```
  Table 32. Sleep to wake configuration
  TurnOn  Sleep to wake status
  00h     Sleep to wake function is disabled
  03h     Turned on: The device is in low power mode (ODR=Defined in CTRL_REG1)
```

Setting TurnOn=3 the "sleep to wake" function is enabled. When an interrupt
event occurs the device is turned to normal mode increasing the ODR to the
value defined in CTRL\_REG1. Although the device is in normal mode, CTRL\_REG1
content is not automatically changed to "normal mode" configuration.



## ACCL[25h] - HP\_FILTER\_RESET - High-Pass Filter Clear content (R=clear)


Dummy register. Reading at this address zeroes instantaneously the content of
the internal high pass-filter. If the high pass filter is enabled all three
axes are instantaneously set to 0g.

This allows to overcome the settling time of the high pass filter.



## ACCL[26h] - REFERENCE - High-pass Filter Reference value (R/W)


```
  0-7  Reference value for high-pass filter. Default=00h
```

This register sets the acceleration value taken as a reference for the
high-pass filter output.

When filter is turned on (at least one of FDS, HPen2, or HPen1 bit is equal to
1) and HPM bits are set to "01", filter out is generated taking this value as a
reference.



## ACCL[27h] - STATUS\_REG - Output Status (R)


```
  0  XDA    New X axis new data available           (0=No, 1=Available)
  1  YDA    New Y axis new data available           (0=No, 1=Available)
  2  ZDA    New Z axis new data available           (0=No, 1=Available)
  3  ZYXDA  New set of X,Y,Z axis available         (0=No, 1=Available)
  4  XOR    Overrun has overwritten X axis data     (0=No, 1=Overrun)
  5  YOR    Overrun has overwritten Y axis data     (0=No, 1=Overrun)
  6  ZOR    Overrun has overwritten Z axis data     (0=No, 1=Overrun)
  7  ZYXOR  Overrun has overwritten X,Y,Z axis data (0=No, 1=Overrun)
```

Overrun means that previous data got overwritten before it was read.

Unknown if the Status bits get cleared after reading the Status register, or
after reading the Output registers, or elsewhere?



## ACCL[28h,29h] - OUT\_X\_L, OUT\_X\_H - X-axis acceleration data (R)



## ACCL[2Ah,2Bh] - OUT\_Y\_L, OUT\_Y\_H - Y-axis acceleration data (R)



## ACCL[2Ch,2Dh] - OUT\_Z\_L, OUT\_Z\_H - Z-axis acceleration data (R)


```
  0-15  The value is expressed as two's complement.
```



## ACCL[30h] - INT1\_CFG - Interrupt 1 source Configuration (R/W)



## ACCL[34h] - INT2\_CFG - Interrupt 2 source Configuration (R/W)


```
  0  XLIE Enable interrupt generation on X low event  (0=Disable, 1=Enable)
  1  XHIE Enable interrupt generation on X high event (0=Disable, 1=Enable)
  2  YLIE Enable interrupt generation on Y low event  (0=Disable, 1=Enable)
  3  YHIE Enable interrupt generation on Y high event (0=Disable, 1=Enable)
  4  ZLIE Enable interrupt generation on Z low event  (0=Disable, 1=Enable)
  5  ZHIE Enable interrupt generation on Z high event (0=Disable, 1=Enable)
  6  6D   6 direction detection function enable.      (See table below)
  7  AOI  AND/OR combination of interrupt events.     (See table below)
```

The six X/Y/Z high/low events trigger when measured accel. value is
higher/lower than preset threshold.

Interrupt mode configuration

```
  AOI 6D  Interrupt mode
  0   0   OR combination of interrupt events
  0   1   6 direction movement recognition
  1   0   AND combination of interrupt events
  1   1   6 direction position recognition
```



## ACCL[31h] - INT1\_SRC - Interrupt 1 source Status (R)



## ACCL[35h] - INT2\_SRC - Interrupt 2 source Status (R)


```
  0  XL  X low event has occurred            (0=No, 1=Yes)
  1  XH  X high event has occurred           (0=No, 1=Yes)
  2  YL  Y low event has occurred            (0=No, 1=Yes)
  3  YH  Y high event has occurred           (0=No, 1=Yes)
  4  ZL  Z low event has occurred            (0=No, 1=Yes)
  5  ZH  Z high event has occurred           (0=No, 1=Yes)
  6  IA  Interrupt active (0=No, 1=One or more interrupts have been generated)
  7  -   Reserved (0)
```

Reading at this address clears INTn\_SRC.bit6 (and the interrupt signal on INTn
pin) and allows the refreshment of data in the INTn\_SRC register if the latched
option was chosen.



## ACCL[32h] - INT1\_THS - Interrupt 1 threshold (R/W)



## ACCL[36h] - INT2\_THS - Interrupt 1? threshold (R/W)


```
  0-6  THS  Interrupt threshold. Default value: 000 0000
  7    -    Reserved (0)
```



## ACCL[33h] - INT1\_DURATION - Minimum duration of Interrupt 2? event (R/W)



## ACCL[37h] - INT2\_DURATION - Minimum duration of Interrupt 2 event (R/W)


```
  0-6  D    Duration value. Default value: 000 0000
  7    -    Reserved (0)
```

These bits set the minimum duration of the Interrupt 2(?) event to be
recognized. Duration time steps and maximum values depend on the ODR chosen.




# <a name="3dsi2cmcu60h7fhmiscstatus"></a>3DS I2C MCU[60h-7Fh] - Misc Status




## MCU[60h] - Battery-backed RAM Index (R/W)



## MCU[61h] - Battery-backed RAM Data (200 bytes) ;ARRAY[C8h] (R/W)


This is a battery-backed 200-byte general purpose RAM area. The MCU itself
doesn't care about the RAM content. Instead, the ARM CPU can use it to store
powerdown/error flags (and then check those flags on next boot).

- The 1st byte at array[00h] is used to store flags for managing FIRM/NS state:
  - bit0 = "WirelessDisabled"
  - bit1 = "SoftwareClosed"
  - bit2 = "PowerOffInitiated"
  - bit4 = "LegacyJumpProhibited"

When exceeding the C8h-byte array size: Writing to index=C8h..FFh is ignored
(and the index is not incremented). Reading from index=C8h..FFh returns
data=00h (and the index is incremented, and can wrap from index=FFh to
index=00h).



## MCU[7Fh] - Various system state information ;ARRAY[09h/13h] (R)


```
  [7Fh:00h] Value 00h..06h (console model? critical_hw_state?) (usually 00h ?)
  [7Fh:01h] Powerman Version (00h=normal) (from POW[00h])
  [7Fh:02h]     battery scheme? (0..7, or FFh) (maybe from middle-batt-pin?)
  [7Fh:03h] Fuel Gauge Version.msb      (00h) ;FUEL[02h]
  [7Fh:04h] Fuel Gauge Version.lsb      (12h) ;FUEL[03h]
  [7Fh:05h] Fuel Gauge Config.msb RCOMP (5Eh) ;FUEL[0Ch]
  [7Fh:06h] Battery PCB Temperature raw ADC(8) value; see MCU[0Ah] for celsius
  [7Fh:07h] Battery PCB Temperature flags (bit0=0=Bad, bit1=0=VeryBad?)
  [7Fh:08h] Fixed 01h on New3DS-XL (older 3DS can be 00h or 01h = what?)
 On MCU_FIRM major version 0:
  [7Fh:09h and up] unknown
 On MCU_FIRM major version 1:
  [7Fh:09h and up] unused (AAh)
 On MCU_FIRM major version 2 and up (or so):
  [7Fh:09h] Sys Model (0=3ds, 1=3dsXL, 2=New3ds, 3=2ds, 4=New3dsXL, 5=New2dsXL)
  [7Fh:0Ah] Power LED color         (0=Blue/off, 1=Red)
  [7Fh:0Bh] Power LED intensity     (00h..FFh)
  [7Fh:0Ch] 3D LED intensity        (00h..FFh)
  [7Fh:0Dh] RGB LED red intensity   (00h..FFh)
  [7Fh:0Eh] RGB LED green intensity (00h..FFh)
  [7Fh:0Fh] RGB LED blue intensity  (00h..FFh)
  [7Fh:10h] Camera LED state        (0=Off, 1=On)
  [7Fh:11h] Wifi LED intensity      (00h..FFh)
  [7Fh:12h] Raw button states
    bit0: Power button        (0=Pressed)
    bit1: Home button         (0=Pressed)
    bit2: Wifi button         (0=Pressed??) (installed in Old3DS only)
    bit5: Charger LED         (0=LED On, 1=LED Off)  ;\or vice-versa?
    bit6: Charger connected AND busy (0=Busy, 1=No)  ;/or one just "connected?"
    this byte is reset to 0 before an svcBreak takes effect, uh?
  [7Fh:13h and up] unused (FFh)
```




# <a name="3dsi2cmcusecondaryi2cdevicesonmcubus"></a>3DS I2C MCU secondary I2C Devices (on MCU bus)




## Bus/Device MCU:30h - Accelerometer


See Accel chapter.

- [3DS I2C MCU[40h-51h] - Accelerometer/Pedometer](#3dsi2cmcu40h51haccelerometerpedometer)


## Bus/Device MCU:6Ch - Fuel Gauge


```
  index____________dir_;MAX17040___________;MAX17048___;Richtek RT9428___
  FUEL[02h]        R   ;VCELL, voltage     ;VCELL      ;VBAT
  FUEL[04h]        R   ;SOC, StateOfCharge ;SOC        ;SOC
  FUEL[06h]        W   ;MODE               ;MODE       ;CONTROL
  FUEL[08h]        R   ;VERSION            ;VERSION    ;DEVICE ID
  FUEL[0Ah]        -   ;-                  ;HIBRT      ;Status, dSOC
  FUEL[0Ch]        R/W ;RCOMP              ;CONFIG     ;CONFIG
  FUEL[0Eh]        R/W ;???                ;???        ;OCV (but read-only!)
  FUEL[14h]        -   ;-                  ;VALRT      ;-
  FUEL[16h]        -   ;-                  ;CRATE      ;-
  FUEL[18h]        -   ;-                  ;VRESET/ID  ;-
  FUEL[1Ah]        -   ;-                  ;STATUS     ;-
  FUEL[3Eh]        W   ;???                ;???        ;???
  FUEL[40h+0..3Eh] W   ;???                ;TABLE      ;???
  FUEL[80h+0..1Eh] W   ;???                ;???        ;???
  FUEL[FEh]        -   ;COMMAND            ;CMD        ;MFA
```

The fuel gauge registers are 16bit, big-endian (eg.
"write(device,index,msb,lsb)").

One should always read/write 2 bytes. Trying to read a single byte from odd
index does instead return the msb from even index. Trying to read more than 2
bytes does weirdly return each 2-byte pair TWICE, and does then advance to the
next 2-byte pair.

Old3DS uses a small 8pin fuel gauge with marking 17040, which is apparently
Maxim MAX17040.

New3DS uses a very tiny 8pin bga fuel gauge with marking 7048, which might be
Maxim MAX17048 (although the MCU firmware uses some undocumented registers that
aren't mentioned in MAX17048 datasheet). The MCU firmware seems to detect
different fuel gauge versions/revisions, unknown which different chip(s) are
used (eg. Richtek RT9428 would be also compatible).



## Bus/Device MCU:84h - Power Managment Device


```
  POW[00h]  Powerman version? (can be read via MCU[7Fh:01h])
  POW[01h]  set to 00h,0Fh,1Fh
  POW[02h]  flags (bit0..bit4 or so)
  POW[03h]  flags (bit0, bit1)
  POW[04h]  backlight enable flags (bit0, bit1)
  POW[05h]  set to 00h,08h,27h   ;00h=Old3DS, 08h=New3DS, 27h=PowerOff??
  POW[06h]  from MCU[03h] ;top_screen_flicker
  POW[07h]  from MCU[04h] ;bottom_screen_flicker
  POW[08h..FFh] unused (mirrors of POW[00h..07h])
```

One should always read/write only 1 byte, trying to read more bytes returns
FFh's for the extra bytes.



## Bus/Device MCU:A4h - Touchscreen/Sound Controller


```
  TSC[10h]  flags?
  TSC[12h]  batt.low.flag (bit0)
  TSC[13h]  volume (38h..7Fh)
  TSC[20h]  set to AAh
```

One can read 1 or more bytes.




# <a name="3dsi2cmcurl78flashprogrammingviauart"></a>3DS I2C MCU - RL78 Flash Programming via UART




## Setting Flash Programming Mode


```
  VDD      __/"""""""""""""""""""""""""""""
  /RESET   ______/"""""""""""""""""""""""""
  FLMD0    xx__/""""""""""""""""""""""""""" (high=flash mode)
  TOOL0    xx__/"""""""\_/"""""\_/"\_/""""" (merged uart rx/tx on one pin)
```

The 3DS seems to have wired some/all of the above pins to the test points
covered by green solder stop layer.



## Old3DS Mainboard (near headphone socket, all 6 pins under solderstop)


```
      ??   FLMD0  ??
     TP79  TP75  TP74
      _ |   _     _
     (_)'  (_)-  (_)-
      _     _     _
    -(_)   (_)-  (_)-
     TP78  TP76  TP77
     GND   TOOL1 TOOL0
```



## New3DS-XL Mainboard (near headphone socket, right 4 pins under solderstop)


```
                           _   _
   _    _    _       TOOL0(_) (_)FLMD0
  (_)  (_)  (_)            _ x _
     ____    _    _  TOOL1(_) (_)/RESET
    (____|  (_)  (_)
    VDD18 PVDD18 GND
```



## Wiring Programmer (PC Parallel Port, GPIO, UART, whatever) to 3DS MCU


```
  /RESET ----------------|>|------------ PC.Data1.Reset
  TOOL0  ------------o---|>|------------ PC.Data0.TX
                     |  BAT85   |  .---- PC.Busy.RX
  FLMD0  -----.      |          | / B
              |      '--[33K]---|<  C
  PVDD18 -----'                 | \ E
                          BC547 |  v--.
  GND    -----------------------------o- PC.Ground
```

The 3DS MCU programming signals are 1.8V, two BAT85 Schottky diodes can be used
as one-directional level changer (with replies ignored/skipped via hardcoded
delays), an additional 10K-65K resistor and BC547 transistor can be used for
bi-directional transfers.



## Command Summary


```
  00h Reset (aka enter flash mode)
  13h Verify/compare
  14h --Undocumented-- verify/compare first 4 bytes of flash, if [000C3h].bit1
  19h --Undocumented-- resembles "internal verify" from write command
  20h Chip Erase
  22h Block Erase
  32h Block Blank check
  40h Write
  9Ah Set Baud Rate
  A0h Set Security
  B0h Get Checksum
  C0h Get Silicon Signature
  C5h Get Version
```

The relevant commands are Reset, Block Erase, and Write.



## Response Status/Error Codes


```
  04h Command Number Error
  05h Parameter Error
  06h Normal Acknowledge (ACK) (okay)
  07h Checksum Error
  0Fh Verify Error
  10h Protect Error
  15h Negative Acknowledge (NACK)
  1Ah MRG10 Error (mrg, uh?)
  1Bh MRG11 Error (mrg, uh?)
  1Ch Write Error
  FFh N/A (for 2nd status byte, when 1st status byte was bad)
```



## Command Frames (Command to chip)


```
  00h 1     Command Start (fixed=01h)
  01h 1     Length (LEN) (1..255, or 00h=256)
  02h 1     Command Number
  03h LEN-1 Command Parameters
  xxh 1     Checksum (01h minus all of the above bytes)
  xxh 1     Command End (fixed=03h)
```



## Data Frames (Data to chip, and Data/Status from chip)


```
  00h 1     Data Start (fixed=02h)
  01h 1     Length (LEN) (1..255, or 00h=256)
  02h LEN   Data
  xxh 1     Checksum (02h minus all of the above bytes)
  xxh 1     Data End (03h=Last Data Frame, or 17h=More data frames follow)
```



## Reset Command (aka Start/Sync)


Drag FLDM0 high (1.8V in 3DS) to enable programming mode, and drag /RESET low
for a moment. Then exchange the following bytes/packets.

Low Pulse (from chip, should arrive within 10ms after releasing /RESET):

```
  00h 1     Low pulse (value 00h)  ;-transferred at 9600 bps
```

Low Pulses (to chip):

```
  00h 1     Low pulse (value 00h)  ;\chip autodetects baudrate based on
  01h 1     Low pulse (value 00h)  ;/transfer time for these two bytes
```

Command (to chip):

```
  00h 3     Start/Len/Command (01h,01h,00h)
  03h 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code
  03h 2     Checksum/End      (CHK,03h)
```



## Set Baudrate Command


Allows to set the baudrate, which isn't really needed because the baudrate is
autodetected when sending the Reset pulses.

Recommended might be 57.6Kbps, higher rates aren't really useful because of the
slow write duration. Tested/working rates are 9.6Kbps through 115.2Kbps,
including odd nonstandard rates.

Bytes should be sent as 8N2 (8 databits, no parity, 2 stopbits). However, the
chip seems to send only 1 stopbit. Nethertheless, it seems to insist on
receiving 2 stopbits (alternately, one could send the 2nd stopbit before
startbit).

Command (to chip):

```
  00h 3     Start/Len/Command (01h,06h,9Ah)
  03h 1     Sync/Connection Mode (00h=Microcontroller, 1=Programmer)
  04h 2     Baud rate, in whatever units
  06h 1     Noise filter (00h=Off, 01h=On)
  07h 1     Speed/voltage (00h=Fast 2.7V and up, 01h=Slow 1.8V and up)
  08h 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code
  03h 2     Checksum/End      (CHK,03h)
```



## Chip Erase Command


Erases the whole flash memory & security settings (unless the security
settings did have disabled the Chip Erase command itself).

Command (to chip):

```
  00h 3     Start/Len/Command (01h,01h,20h)
  03h 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (chip erase result)
  03h 2     Checksum/End      (CHK,03h)
```



## Block Erase Command


Blocks seem to be 1Kbyte (400h bytes). Erasing 1000h bytes at once does also
work.

Command (to chip):

```
  00h 3     Start/Len/Command (01h,07h,22h)
  03h 3     Start address (MSB,MID,LSB) ;lower 10bit=000h  ;\400h byte boundary
  06h 3     End address   (MSB,MID,LSB) ;lower 10bit=3FFh  ;/
  09h 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (block erase result)
  03h 2     Checksum/End      (CHK,03h)
```



## Block Blank Check Command


Command (to chip):

```
  00h 3     Start/Len/Command (01h,08h,32h)
  03h 3     Start address (MSB,MID,LSB) ;lower 10bit=000h  ;\400h byte boundary
  06h 3     End address   (MSB,MID,LSB) ;lower 10bit=3FFh  ;/
  09h 1     Type (00h=Before single block, 01h=Before chip erase)
  0Ah 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (block blank check result)
  03h 2     Checksum/End      (CHK,03h)
```



## Write Command


Requires prior Erase command, max length for erase/write commands seems to be
1000h bytes. To quit flash mode & resume normal operation, it seems to be
required to unplug battery supply for moment after having written all data.

Command (to chip):

```
  00h 3     Start/Len/Command (01h,07h,40h)
  03h 3     Start address (MSB,MID,LSB) ;lower 8bit=00h  ;\100h byte boundary
  06h 3     End address   (MSB,MID,LSB) ;lower 8bit=FFh  ;/
  09h 2     Checksum/End      (CHK,03h)
```

Response (from chip, after command):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (command reception result)
  03h 2     Checksum/End      (CHK,03h)
```

Data (to chip):

```
  00h 2     Start/Len (02h,LEN) ;LEN=1..255 bytes, or 0=256 bytes
  02h LEN   Data (usually 256 bytes)
  xxh 2     Checksum/End      (CHK,03h/17h)  ;03h=Last, 17h=Nonlast
```

Response (from chip, circa 60ms after each data block):

```
  00h 2     Start/Len (02h,02h)
  02h 1     Status/Error code (data reception result)
  02h 1     Status/Error code (write result)
  04h 2     Checksum/End      (CHK,03h)
```

Response (from chip, extra response, about 1.5 seconds after LAST data block):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (internal verify result)
  03h 2     Checksum/End      (CHK,03h)
```

Note: The ugly 1.5 seconds verify delay can avoided by issuing a chip reset
instead of waiting for the final response.



## Verify/Compare Command


Command (to chip):

```
  00h 3     Start/Len/Command (01h,07h,13h)
  03h 3     Start address (MSB,MID,LSB) ;lower 8bit=00h  ;\100h byte boundary
  06h 3     End address   (MSB,MID,LSB) ;lower 8bit=FFh  ;/
  09h 2     Checksum/End      (CHK,03h)
```

Response (from chip, after command):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (command reception result)
  03h 2     Checksum/End      (CHK,03h)
```

Data (to chip):

```
  00h 2     Start/Len (02h,LEN)  ;LEN must be N*4 bytes (usually (1)00h bytes)
  02h LEN   Data
  xxh 2     Checksum/End      (CHK,03h/17h)  ;03h=Last, 17h=Nonlast
```

Response (from chip, after each data block):

```
  00h 2     Start/Len (02h,02h)
  02h 1     Status/Error code (data reception result)
  02h 1     Status/Error code (verify result) (always ACK/okay for Nonlast?)
  04h 2     Checksum/End      (CHK,03h)
```

With data LEN=4, this seems to allow dump the chip content via brute-force (but
requires to send/receive trillions of bits to dump 4 bytes, and gets slower
towards end of 100h-byte snippets).



## Get Checksum Command


Command (to chip):

```
  00h 3     Start/Len/Command (01h,07h,B0h)
  03h 3     Start address (MSB,MID,LSB) ;lower 8bit=00h  ;\100h byte boundary
  06h 3     End address   (MSB,MID,LSB) ;lower 8bit=FFh  ;/blah: "from top 1KB"
  09h 2     Checksum/End      (CHK,03h)
```

Response (from chip, after command):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (command reception result)
  03h 2     Checksum/End      (CHK,03h)
```

Data (from chip, after above response):

```
  00h 2     Start/Len (02h,02h)
  02h 2     Data checksum, 0000h minus all data bytes (MSB,LSB)
  04h 2     Checksum/End      (CHK,03h)
```



## Set Security Command


Allows write protect flash areas. Don't touch (or use with care), some settings
cannot be undone (not even via Chip Erase command).

Command (to chip):

```
  00h 3     Start/Len/Command (01h,03h,A0h)
  03h 2     Fixed (00h,00h)
  08h 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (command reception result)
  03h 2     Checksum/End      (CHK,03h)
```

Data (to chip):

```
  00h 2     Start/Len (02h,06h)   ;uh, len=6 (but below should have len=8)?
  02h 1     FLG   Security Flags (can disable write/erase etc.)
  03h 1     BOT   Boot cluster last block number ("fixed to 03h")
  04h 2     FSWS  Flash shield window start ("Higher bits, Lower bits")
  06h 2     FSWE  Flash shield window end   ("Higher bits, Lower bits")
  08h 2     FFH   Fixed (FFh,FFh)
  0Ah 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (security write result)
  03h 2     Checksum/End      (CHK,03h)
```

Response (from chip):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (internal verify result)
  03h 2     Checksum/End      (CHK,03h)
```



## Get Silicon Signature Command


Command (to chip):

```
  00h 3     Start/Len/Command (01h,01h,C0h)
  03h 2     Checksum/End      (CHK,03h)
```

Response (from chip, after command):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (command reception result)
  03h 2     Checksum/End      (CHK,03h)
```

Data (from chip, after above response):

```
  00h 2     Start/Len (02h,1Bh)
  02h 1     VEN  Vendor                          (10h=NEC/Renseas) ;bit7=parity
  03h 1     MET  Macro extension code            (EFh)             ;bit7=parity
  04h 1     MSC  Macro function code             (04h)             ;bit7=parity
  05h 3     DET  Device extension code 1,2,3     (DCh,FDh,xxh)     ;bit7=parity
  08h 3     UAE  User flash size-1 (LSB,MID,MSB) (007FFFh, little-endian!)
  0Bh 10    DEV  Device name                     ("D79F0104  ", ASCII)
  15h 1     SCF  Security flag information                           ;\same as
  16h 1     BOT  Boot block number ("03h=fixed")                     ; from
  17h 2     FSWS Flash shield window start("Higher side, Lower side"); security
  19h 2     FSWE Flash shield window end  ("Higher side, Lower side"); command?
  1Bh 2     RES  Reserved (FFFFh)                                    ;/
  1Dh 2     Checksum/End      (CHK,03h)
```



## Get Version Command


Command (to chip):

```
  00h 3     Start/Len/Command (01h,01h,C5h)
  03h 2     Checksum/End      (CHK,03h)
```

Response (from chip, after command):

```
  00h 2     Start/Len (02h,01h)
  02h 1     Status/Error code (command reception result)
  03h 2     Checksum/End      (CHK,03h)
```

Data (from chip, after above response):

```
  00h 2     Start/Len (02h,06h)
  02h 3     Device Version    (MSB,MID,LSB) (000000h)
  05h 3     Firmware Version  (MSB,MID,LSB) (010000h)
  08h 2     Checksum/End      (CHK,03h)
```



## Notes


The above protocol is documented in the "78K0R/Kx3-L Flash Memory Programming"
application note.

Unknown if verify/checksum could be tweaked to dump the current flash content.
There is also an undocumented anti-dumping feature related to bytes at 000C4h
(that's probably related to TOOL1 debug pin, not to TOOL0 serial flash pin).




# <a name="3dsi2cmcurl78cpuopcodelist"></a>3DS I2C MCU - RL78 CPU Opcode List




## Move Byte


```
  09/29/49                 MOV A, [nnnn+B]/[nnnn+C]/[nnnn+BC]
  88/89/8A/8B/8C           MOV A, [nn+SP]/[DE]/[nn+DE]/[HL]/[nn+HL]
  8D/8E/8F                 MOV A, [saddr]/[sfr]/[nnnn]
  61C9/61E9                MOV A, [HL+B]/[HL+C]
  60/--/62/63/64/65/66/67  MOV A, X/-/C/B/E/D/L/H
  70/--/72/73/74/75/76/77  MOV X/-/C/B/E/D/L/H, A
  50/51/52/53/54/55/56/57  MOV X/A/C/B/E/D/L/H, imm8
  D8/--/F8/E8              MOV X/-/C/B, [saddr]
  D9/--/F9/E9              MOV X/-/C/B, [nnnn]
  E0/E1/E2/E3/E4/E5        MOV X/A/C/B/[saddr]/[nnnn], 1  ;native: ONEB
  F0/F1/F2/F3/F4/F5        MOV X/A/C/B/[saddr]/[nnnn], 0  ;native: CLRB
  41/61B8                  MOV ES, imm8/[saddr]
  18/28/48                 MOV [nnnn+B]/[nnnn+C]/[nnnn+BC], A
  98/99/9A/9B/9C           MOV [nn+SP]/[DE]/[nn+DE]/[HL]/[nn+HL], A
  9D/9E/9F                 MOV [saddr]/[sfr]/[nnnn], A
  61D9/61F9                MOV [HL+B]/[HL+C], A
  19/38/39                 MOV [nnnn+B]/[nnnn+C]/[nnnn+BC], imm8
  C8/CA/CC                 MOV [nn+SP]/[nn+DE]/[nn+HL], imm8
  CD/CE/CF                 MOV [saddr]/[sfr]/[nnnn], imm8
  08/--/618A/618B/618C/618D/618E/618F   XCH A, X/-/C/B/E/D/L/H
  61AC/61AD/61B9/61A9                   XCH A, [HL]/[HL+byte]/[HL+B]/[HL+C]
  61AE/61AF                             XCH A, [DE]/[DE+byte]
  61AB/61A8/61AA                        XCH A, [sfr]/[saddr]/[nnnn]
```



## Move Word


```
  13/15/17/30              MOVW AX, BC/DE/HL/imm16
  59/69/79                 MOVW AX, [nnnn+B]/[nnnn+C]/[nnnn+BC]
  A8/A9/AA/AB/AC           MOVW AX, [nn+SP]/[DE]/[nn+DE]/[HL]/[nn+HL]
  AD/AE/AF                 MOVW AX, [saddrp]/[sfrp]/[nnnn]
  E6/E7                    MOVW AX/BC,1    ;native: ONEW AX/BC
  F6/F7                    MOVW AX/BC,0    ;native: CLRW AX/BC
  12/32/DA/DB              MOVW BC, AX/#imm16/[saddrp]/[nnnn]
  14/34/EA/EB              MOVW DE, AX/#imm16/[saddrp]/[nnnn]
  16/36/FA/FB              MOVW HL, AX/#imm16/[saddrp]/[nnnn]
  58/68/78                 MOVW [nnnn+B]/[nnnn+C]/[nnnn+BC], AX
  B8/B9/BA/BB/BC           MOVW [nn+SP]/[DE]/[nn+DE]/[HL]/[nn+HL], AX
  BD/BE/BF                 MOVW [saddrp]/[sfrp]/[nnnn], AX
  C9/CB                    MOVW [saddrp]/[sfrp], imm16
  C0/C2/C4/C6/61CD         POP  AX/BC/DE/HL/PSW
  C1/C3/C5/C7/61DD         PUSH AX/BC/DE/HL/PSW
  33/35/37                 XCHW AX, BC/DE/HL
```



## ALU Byte


```
  6100/6101/6102/6103/6104/6105/6106/6107  ADD  X/A/C/B/E/D/L/H, A
  6110/6111/6112/6113/6114/6115/6116/6117  ADDC X/A/C/B/E/D/L/H, A
  6120/6121/6122/6123/6124/6125/6126/6127  SUB  X/A/C/B/E/D/L/H, A
  6130/6131/6132/6133/6134/6135/6136/6137  SUBC X/A/C/B/E/D/L/H, A
  6140/6141/6142/6143/6144/6145/6146/6147  CMP  X/A/C/B/E/D/L/H, A
  6150/6151/6152/6153/6154/6155/6156/6157  AND  X/A/C/B/E/D/L/H, A
  6160/6161/6162/6163/6164/6165/6166/6167  OR   X/A/C/B/E/D/L/H, A
  6170/6171/6172/6173/6174/6175/6176/6177  XOR  X/A/C/B/E/D/L/H, A
  6108/----/610A/610B/610C/610D/610E/610F  ADD  A, X/-/C/B/E/D/L/H
  6118/----/611A/611B/611C/611D/611E/611F  ADDC A, X/-/C/B/E/D/L/H
  6128/----/612A/612B/612C/612D/612E/612F  SUB  A, X/-/C/B/E/D/L/H
  6138/----/613A/613B/613C/613D/613E/613F  SUBC A, X/-/C/B/E/D/L/H
  6148/----/614A/614B/614C/614D/614E/614F  CMP  A, X/-/C/B/E/D/L/H
  6158/----/615A/615B/615C/615D/615E/615F  AND  A, X/-/C/B/E/D/L/H
  6168/----/616A/616B/616C/616D/616E/616F  OR   A, X/-/C/B/E/D/L/H
  6178/----/617A/617B/617C/617D/617E/617F  XOR  A, X/-/C/B/E/D/L/H
  0B/0C/0D/0E/0F                ADD  A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  1B/1C/1D/1E/1F                ADDC A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  2B/2C/2D/2E/2F                SUB  A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  3B/3C/3D/3E/3F                SUBC A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  4B/4C/4D/4E/4F                CMP  A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  5B/5C/5D/5E/5F                AND  A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  6B/6C/6D/6E/6F                OR   A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  7B/7C/7D/7E/7F                XOR  A,[saddr]/#byte/[HL]/[HL+byte]/[nnnn]
  0A                            ADD  [saddr],#byte
  1A                            ADDC [saddr],#byte
  2A                            SUB  [saddr],#byte
  3A                            SUBC [saddr],#byte
  4A/40                         CMP  [saddr]/[nnnn],#byte
  5A                            AND  [saddr],#byte
  6A                            OR   [saddr],#byte
  7A                            XOR  [saddr],#byte
  D0/D1/D2/D3/D4/D5             CMP  X/A/C/B/[saddr]/[nnnn],0  ;native: CMP0
  80/81/82/83/84/85/86/87/A0/A4/6159 INC X/A/C/B/E/D/L/H/[nnnn]/[saddr]/[HL+nn]
  90/91/92/93/94/95/96/97/B0/B4/6169 DEC X/A/C/B/E/D/L/H/[nnnn]/[saddr]/[HL+nn]
```



## ALU Word


```
  01/03/05/07              ADDW AX, AX/BC/DE/HL
  --/23/25/27              SUBW AX, --/BC/DE/HL
  --/43/45/47              CMPW AX, --/BC/DE/HL
  04/02/06/6109/10         ADDW AX, nnnn/[nnnn]/[saddrp]/[HL+nn] / ADDW SP,00nn
  24/22/26/6129/20         SUBW AX, nnnn/[nnnn]/[saddrp]/[HL+nn] / SUBW SP,00nn
  44/42/46/6149/--         CMPW AX, nnnn/[nnnn]/[saddrp]/[HL+nn] / CMPW --
  A1/A3/A5/A7/A2/A6/6179   INCW AX/BC/DE/HL/[nnnn]/[saddrp]/[HL+nn]
  B1/B3/B5/B7/B2/B6/6189   DECW AX/BC/DE/HL/[nnnn]/[saddrp]/[HL+nn]
```



## Rotate/Shift


```
  61DB                  ROR A, 1
  61EB                  ROL A, 1
  61FB                  RCR A, 1         ;native: RORC A,1
  61DC                  RCL A, 1         ;native: ROLC A,1
  3109/3108/3107+n*10   SHL A/B/C, 1..7
  310A+n*10             SHR A, 1..7
  310B+n*10             SAR A, 1..7
  61EE/61FE             RCLW AX/BC, 1    ;native: ROLWC AX/BC,1
  310D/310C+n*10        SHLW AX/BC, 1..15
  310E+n*10             SHRW AX, 1..15
  310F+n*10             SARW AX, 1..15
```



## Jump/Call


```
  61CB                  JMP AX                  ;native: BR AX             ;CS:
  ECnnnn0n              JMP absolute far addr   ;native: BR !!addr20
  EDnnnn                JMP absolute addr       ;native: BR !addr16
  EEnnnn                JMP relative addr       ;native: BR $!addr20
  EFnn                  JMP relative short addr ;native: BR $addr20
  61CA/61DA/61EA/61FA   CALL AX/BC/DE/HL        ;native: CALL AX/BC/DE/HL  ;CS:
  FCnnnn0n              CALL absolute far addr  ;native: CALL !!addr20
  FDnnnn                CALL absolute addr      ;native: CALL !addr16
  FEnnnn                CALL relative addr      ;native: CALL $!addr20
  61nn                  CALL [000xx]            ;native: CALLT [xx]
```



## Conditional Relative Jumps


```
  DCnn                  JC  aka JB  addr  ;carry/below      ;native: BC
  DDnn                  JZ  aka JE  addr  ;zero/equal       ;native: BZ
  61C3nn                JH  aka JA  addr  ;higher/above     ;native: BH
  DEnn                  JNC aka JAE addr  ;not carry/below  ;native: BNC
  DFnn                  JNZ aka JNE addr  ;not zero/equal   ;native: BNZ
  61D3nn                JNH aka JBE addr  ;not higher/above ;native: BNH
```



## Test (and Clear) and Conditional Relative Jump


```
  3100/3180/3181/3101+n*10h  BTCLR|JNZCLR [saddr]/[sfr]/[HL]/A.n, addr
  3102/3182/3183/3103+n*10h  BT|JNZ       [saddr]/[sfr]/[HL]/A.n, addr
  3104/3184/3185/3105+n*10h  BF|JZ        [saddr]/[sfr]/[HL]/A.n, addr
```



## Bit Manipulation


```
  7101/7109/7181/7189+n*10            MOV1 [saddr]/[sfr]/[HL]/A.n, CY
  7104/710C/7184/718C+n*10            MOV1 CY, [saddr]/[sfr]/[HL]/A.n
  7105/710D/7185/718D+n*10            AND1 CY, [saddr]/[sfr]/[HL]/A.n
  7106/710E/7186/718E+n*10            OR1  CY, [saddr]/[sfr]/[HL]/A.n
  7107/710F/7187/718F+n*10            XOR1 CY, [saddr]/[sfr]/[HL]/A.n
  7180/7100/7102/710A/7182/718A+n*10  SET1 CY/[nnnn]/[saddr]/[sfr]/[HL]/A.n
  7188/7108/7103/710B/7183/718B+n*10  CLR1 CY/[nnnn]/[saddr]/[sfr]/[HL]/A.n
  71C0                                NOT1 CY
```



## Misc


```
  00                             NOP
  61CC/61ED/61FD                 BRK/HALT/STOP
  D7/61EC/61FC                   RET/RETB/RETI
  FF                             TRAP     ;pseudo invalid.reset
  717AFA/717BFA                  EI/DI    ;pseudo set/clr.sfr.bit
  61C8/61D8/61E8/61F8/61E3/61F3  SKC/SKNC/SKZ/SKNZ/SKH/SKNH  ;conditional skip
  61CE                           MOVS [HL+byte],X
  61DE                           CMPS X,[HL+byte]
  61CF/61DF/61EF/61FF            SEL RB0/1/2/3
  D6                             MULU X   ;unsigned multiply AX=A*X
  11                             prefix for [ES:addr]   ;native: ES:addr[reg]
```




# <a name="3dsi2cmcurl78cpuopcodemap"></a>3DS I2C MCU - RL78 CPU Opcode Map




## Instruction Map (1st Map) (without prefix)


```
      00               10                 20               30
  00  NOP              ADDW SP,#byte      SUBW SP,#byte    MOVW AX,#word
  01  ADDW AX,AX       PREFIX (ES:)       -                4th MAP !!!
  02  ADDW AX,!addr16  MOVW BC,AX         SUBW AX,!addr16  MOVW BC,#word
  03  ADDW AX,BC       MOVW AX,BC         SUBW AX,BC       XCHW AX,BC
  04  ADDW AX,#word    MOVW DE,AX         SUBW AX,#word    MOVW DE,#word
  05  ADDW AX,DE       MOVW AX,DE         SUBW AX,DE       XCHW AX,DE
  06  ADDW AX,saddrp   MOVW HL,AX         SUBW AX,saddrp   MOVW HL,#word
  07  ADDW AX,HL       MOVW AX,HL         SUBW AX,HL       XCHW AX,HL
  08  XCH  A,X         MOV  word[B],A     MOV  word[C],A   MOV  word[C],#byte
  09  MOV  A,word[B]   MOV  word[B],#byte MOV  A,word[C]   MOV  word[BC],#byte
  0A  ADD  saddr,#byte ADDC saddr,#byte   SUB  saddr,#byte SUBC saddr,#byte
  0B  ADD  A,saddr     ADDC A,saddr       SUB  A,saddr     SUBC A,saddr
  0C  ADD  A,#byte     ADDC A,#byte       SUB  A,#byte     SUBC A,#byte
  0D  ADD  A,[HL]      ADDC A,[HL]        SUB  A,[HL]      SUBC A,[HL]
  0E  ADD  A,[HL+byte] ADDC A,[HL+byte]   SUB  A,[HL+byte] SUBC A,[HL+byte]
  0F  ADD  A,!addr16   ADDC A,!addr16     SUB  A,!addr16   SUBC A,!addr16
```


```
      40                 50               60               70
  40  CMP  !addr16,#byte MOV  X,#byte     MOV  A,X         MOV  X,A
  41  MOV  ES,#byte      MOV  A,#byte     2nd MAP !!!      3rd MAP !!!
  42  CMPW AX,!addr16    MOV  C,#byte     MOV  A,C         MOV  C,A
  43  CMPW AX,BC         MOV  B,#byte     MOV  A,B         MOV  B,A
  44  CMPW AX,#word      MOV  E,#byte     MOV  A,E         MOV  E,A
  45  CMPW AX,DE         MOV  D,#byte     MOV  A,D         MOV  D,A
  46  CMPW AX,saddrp     MOV  L,#byte     MOV  A,L         MOV  L,A
  47  CMPW AX,HL         MOV  H,#byte     MOV  A,H         MOV  H,A
  48  MOV  word[BC],A    MOVW word[B],AX  MOVW word[C],AX  MOVW word[BC],AX
  49  MOV  A,word[BC]    MOVW AX,word[B]  MOVW AX,word[C]  MOVW AX,word[BC]
  4A  CMP  saddr,#byte   AND  saddr,#byte OR   saddr,#byte XOR  saddr,#byte
  4B  CMP  A,saddr       AND  A,saddr     OR   A,saddr     XOR  A,saddr
  4C  CMP  A,#byte       AND  A,#byte     OR   A,#byte     XOR  A,#byte
  4D  CMP  A,[HL]        AND  A,[HL]      OR   A,[HL]      XOR  A,[HL]
  4E  CMP  A,[HL+byte]   AND  A,[HL+byte] OR   A,[HL+byte] XOR  A,[HL+byte]
  4F  CMP  A,!addr16     AND  A,!addr16   OR   A,!addr16   XOR  A,!addr16
```


```
      80                 90               A0                B0
  80  INC  X             DEC  X           INC  !addr16      DEC  !addr16
  81  INC  A             DEC  A           INCW AX           DECW AX
  82  INC  C             DEC  C           INCW !addr16      DECW !addr16
  83  INC  B             DEC  B           INCW BC           DECW BC
  84  INC  E             DEC  E           INC  saddr        DEC  saddr
  85  INC  D             DEC  D           INCW DE           DECW DE
  86  INC  L             DEC  L           INCW saddrp       DECW saddrp
  87  INC  H             DEC  H           INCW HL           DECW HL
  88  MOV  A,[SP+byte]   MOV  [SP+byte],A MOVW AX,[SP+byte] MOVW [SP+byte],AX
  89  MOV  A,[DE]        MOV  [DE],A      MOVW AX,[DE]      MOVW [DE],AX
  8A  MOV  A,[DE+byte]   MOV  [DE+byte],A MOVW AX,[DE+byte] MOVW [DE+byte],AX
  8B  MOV  A,[HL]        MOV  [HL],A      MOVW AX,[HL]      MOVW [HL],AX
  8C  MOV  A,[HL+byte]   MOV  [HL+byte],A MOVW AX,[HL+byte] MOVW [HL+byte],AX
  8D  MOV  A,saddr       MOV  saddr,A     MOVW AX,saddrp    MOVW saddrp,AX
  8E  MOV  A,sfr         MOV  sfr,A       MOVW AX,sfrp      MOVW sfrp,AX
  8F  MOV  A,!addr16     MOV  !addr16,A   MOVW AX,!addr16   MOVW !addr16,AX
```


```
      C0                   D0                E0               F0
  C0  POP  AX              CMP0 X            ONEB X           CLRB X
  C1  PUSH AX              CMP0 A            ONEB A           CLRB A
  C2  POP  BC              CMP0 C            ONEB C           CLRB C
  C3  PUSH BC              CMP0 B            ONEB B           CLRB B
  C4  POP  DE              CMP0 saddr        ONEB saddr       CLRB saddr
  C5  PUSH DE              CMP0 !addr16      ONEB !addr16     CLRB !addr16
  C6  POP  HL              MULU X ;(AX=A*X)  ONEW AX          CLRW AX
  C7  PUSH HL              RET               ONEW BC          CLRW BC
  C8  MOV  [SP+byte],#byte MOV  X,saddr      MOV  B,saddr     MOV  C,saddr
  C9  MOVW saddrp,#word    MOV  X,!addr16    MOV  B,!addr16   MOV  C,!addr16
  CA  MOV  [DE+byte],#byte MOVW BC,saddrp    MOVW DE,saddrp   MOVW HL,saddrp
  CB  MOVW sfrp,#word      MOVW BC,!addr16   MOVW DE,!addr16  MOVW HL,!addr16
  CC  MOV  [HL+byte],#byte BC   $addr20      BR   !!addr20    CALL !!addr20
  CD  MOV  saddr,#byte     BZ   $addr20      BR   !addr16     CALL !addr16
  CE  MOV  sfr,#byte       BNC  $addr20      BR   $!addr20    CALL $!addr20
  CF  MOV  !addr16,#byte   BNZ  $addr20      BR   $addr20     - (TRAP)
```

Opcode FFh = TRAP (illegal opcode, used by 3DS MCU, triggers Reset vector).

Uh, other/prefixed illegal opcodes do not act as TRAP?



## Instruction Map (2nd MAP) (with prefix byte 61h)


```
      00    10    20    30    40    50    60    70      Notes
  00  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands X,A
  01  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,A
  02  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands C,A
  03  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands B,A
  04  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands E,A
  05  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands D,A
  06  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands L,A
  07  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands H,A
  08  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,X
  09  ADDW  -     SUBW  -     CMPW  INC   DEC   INCW    <see below>
  0A  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,C
  0B  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,B
  0C  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,E
  0D  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,D
  0E  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,L
  0F  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,H
  80  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,[HL+B]
  81  -     -     -     -     -     -     -     -       -
  82  ADD   ADDC  SUB   SUBC  CMP   AND   OR    XOR     with operands A,[HL+C]
  83  -     -     -     -     BH    BNH   SKH   SKNH    <see below>
  84  [80h] [82h] [84h] [86h] [88h] [8Ah] [8Ch] [8Eh]   CALLT [0008xh]
  85  [90h] [92h] [94h] [96h] [98h] [9Ah] [9Ch] [9Eh]   CALLT [0009xh]
  86  [A0h] [A2h] [A4h] [A6h] [A8h] [AAh] [ACh] [AEh]   CALLT [000Axh]
  87  [B0h] [B2h] [B4h] [B6h] [B8h] [BAh] [BCh] [BEh]   CALLT [000Bxh]
  88  -     -     XCH   MOV   SKC   SKNC  SKZ   SKNZ    <see below>
  89  DECW  -     XCH   XCH   MOV   MOV   MOV   MOV     <see below>
  8A  XCH   -     XCH   -     CALL  CALL  CALL  CALL    <see below>
  8B  XCH   -     XCH   -     BR    ROR   ROL   RORC    <see below>
  8C  XCH   -     XCH   -     BRK   ROLC  RETB  RETI    <see below>
  8D  XCH   -     XCH   -     POP   PUSH  HALT  STOP    <see below>
  8E  XCH   -     XCH   -     MOVS  CMPS  ROLWC ROLWC   <see below>
  8F  XCH   -     XCH   -     SEL   SEL   SEL   SEL     <see below>
```

Operands for above opcodes:

```
  Operands for ADDW/SUBW/CMPW                AX,[HL+byte]
  Operands for INCW/DECW/INC/DEC             [HL+byte]
  Operands for BR                            AX
  Operands for ROL/ROR/ROLC/RORC             A,1
  Operands for PUSH/POP                      PSW
  Operands for MOVS                          [HL+byte],X
  Operands for CMPS                          X,[HL+byte]
  Operands for SKC/SKNC/SKZ/SKNZ/SKH/SKNH    None
  Operands for BRK/RETB/RETI/HALT/STOP       None
  Operands for BH/BNH                        $addr20
  Operands for ROLWC (opcode EE/FE)          AX,1 / BC,1
  Operands for CALL  (opcode CA/DA/EA/FA)    AX/BC/DE/HL
  Operands for SEL   (opcode CF/DF/EF/FF)    RB0/RB1/RB2/RB3
  Operands for MOV   (opcode C9/D9)          A,[HL+B] / [HL+B],A
  Operands for MOV   (opcode E9/F9/B8)       A,[HL+C] / [HL+C],A / ES,saddr
  Operands for XCH   (opcode 8A..8F)         A,C / A,B / A,E / A,D / A,L / A,H
  Operands for XCH   (opcode A8,A9,AA)       A,saddr / A,[HL+C] / A,!addr16
  Operands for XCH   (opcode AB,AC,AD)       A,sfr /  A,[HL] / A,[HL+byte]
  Operands for XCH   (opcode AE,AF,B9)       A,[DE] / A,[DE+byte] / A,[HL+B]
```

Note  Not mounted on the RL78-S1 core.



## Instruction Map (3rd MAP) (with prefix byte 71h)


```
  00+#*10  SET1 !addr16.#          80+#*10  --> see below (80,C0)
  01+#*10  MOV1 saddr.#,CY         81+#*10  MOV1 [HL].#,CY
  02+#*10  SET1 saddr.#            82+#*10  SET1 [HL].#
  03+#*10  CLR1 saddr.#            83+#*10  CLR1 [HL].#
  04+#*10  MOV1 CY,saddr.#         84+#*10  MOV1 CY,[HL].#
  05+#*10  AND1 CY,saddr.#         85+#*10  AND1 CY,[HL].#
  06+#*10  OR1  CY,saddr.#         86+#*10  OR1  CY,[HL].#
  07+#*10  XOR1 CY,saddr.#         87+#*10  XOR1 CY,[HL].#
  08+#*10  CLR1 !addr16.#          88+#*10  --> see below (88)
  09+#*10  MOV1 sfr.#,CY           89+#*10  MOV1 A.#,CY
  0A+#*10  SET1 sfr.#              8A+#*10  SET1 A.#
  0B+#*10  CLR1 sfr.#              8B+#*10  CLR1 A.#
  0C+#*10  MOV1 CY,sfr.#           8C+#*10  MOV1 CY,A.#
  0D+#*10  AND1 CY,sfr.#           8D+#*10  AND1 CY,A.#
  0E+#*10  OR1  CY,sfr.#           8E+#*10  OR1  CY,A.#
  0F+#*10  XOR1 CY,sfr.#           8F+#*10  XOR1 CY,A.#
  80       SET1 CY                 90,A0,B0             reserved
  88       CLR1 CY                 D0,E0,F0             reserved
  C0       NOT1 CY                 98,A8,B8,C8,D8,E8,F8 reserved
```



## Instruction Map (4th MAP) (with prefix byte 31h)


```
  00+#*10  BTCLR saddr.#,$addr20 ;\
  01+#*10  BTCLR A.#,    $addr20 ;
  80+#*10  BTCLR sfr.#,  $addr20 ;
  81+#*10  BTCLR [HL].#, $addr20 ;
  02+#*10  BT    saddr.#,$addr20 ; #=0..7
  03+#*10  BT    A.#,    $addr20 ;
  82+#*10  BT    sfr.#,  $addr20 ;
  83+#*10  BT    [HL].#, $addr20 ;
  04+#*10  BF    saddr.#,$addr20 ;
  05+#*10  BF    A.#,    $addr20 ;
  84+#*10  BF    sfr.#,  $addr20 ;
  85+#*10  BF    [HL].#, $addr20 ;/
  06+#*10  -                     ;-#=N/A (0..15=reserved)
  07+#*10  SHL   C,#             ;\
  08+#*10  SHL   B,#             ;
  09+#*10  SHL   A,#             ; #=1..7 (0,8..15=reserved)
  0A+#*10  SHR   A,#             ;
  0B+#*10  SAR   A,#             ;/
  0C+#*10  SHLW  BC,#            ;\
  0D+#*10  SHLW  AX,#            ; #=1..15 (0=reserved)
  0E+#*10  SHRW  AX,#            ;
  0F+#*10  SARW  AX,#            ;/
```



## Pseudo Opcodes


```
  EI         71 7A FA         ;SET1 SFR(FAh).7  (PSW.bit7 enable interrupts)
  DI         71 7B FA         ;CLR1 SFR(FAh).7  (PSW.bit7 disable interrupts)
  TRAP       FF               ;invalid opcode FF (triggers Reset vector)
```

Extra MUL opcodes (unknown if these are supported on 3DS):

```
  MULHU      CE FB 01         ;MOV SFR(FBh),#01h    Note
  MULH       CE FB 02         ;MOV SFR(FBh),#02h    Note
  DIVHU      CE FB 03         ;MOV SFR(FBh),#03h    Note
  DIVWU      CE FB 0B         ;MOV SFR(FBh),#0Bh    Note
  MACHU      CE FB 05         ;MOV SFR(FBh),#05h    Note
  MACH       CE FB 06         ;MOV SFR(FBh),#06h    Note
```

Others:

```
  "saddr.#" and "sfr.#" with #=8..15 could be implemented as "addr+1.#-8".
  "callt [nn]" can be seen as 2-byte alias for "call nnnn" (via the ROM table)
```




# <a name="3dsi2cmcurl78cpuregistersandflags"></a>3DS I2C MCU - RL78 CPU Registers and Flags




## Registers


```
  PC   20bit   Program Counter
  PSW  8bit    Program Status Word (flags)
  SP   16bit   Stack Pointer (bit0=always 0, bit1-15=used)
  AX   16bit   aka A:X   ;\these can be used as 16bit (eg. AX) or two 8bit
  BC   16bit   aka B:C   ; registers (eg. A and X).
  DE   16bit   aka D:E   ; all of these registers exist in 4 banks (the
  HL   16bit   aka H:L   ;/active bank is selected via "SEL RBn" opcode)
  ES   4bit    Data Bank ;-used only for PREFIX'ed opcode, otherwise bank=0Fh
  CS   4bit    Code Bank ;-MSBs of destination for JMP/CALL AX/BC/DE/HL
```

Note: All registers (except PC) are mapped to the SFR register area, and can be
also used by accessing that memory. In case of the banked AX/BC/DE/HL
registers, observe that direct memory access won't recurse the current "bank"
selection (that weird feature/problem is same as for 8051 CPUs).



## RL78 Memory Map


```
  00000h 80h    Code Vector Table                                     ;\
  00080h 40h    Code Callt Table                                      ;
  000C0h 4      Code Option byte area (4 bytes)                       ; Code
  000C4h 0Ah    Code On-chip debug security ID setting area           ; FLASH
  000CEh F32h   Code                                                  ; memory
  01000h 1000h  Code (can be hardware-swapped with 00000h..00FFFh?)   ;
  02000h 3000h  Code                                                  ;
  05000h 3000h  Code (3DS uses this area as firmware backup copy)     ;/
  08000h 8000h  Unused, FFh-filled (does NOT seem to be flash)
  10000h DD800h Unused, 00h-filled
  ED800h 2800h  ROM area (or A4h,FBh,5Ah,FAh-filled when disabled)    ;\
  EFFD0h 2      ROM data, FLASH (size-1)/100h   ;007Fh=32Kbyte        ; ROM
  EFFF8h 4      ROM code, jump vector for flash functions (c=func)    ;/
  F0000h 7E0h   Special-function registers (2nd SFRs)
  F07E0h 620h   Hidden RAM (for use by ROM) (or 00h-filled when disabled) ;-RAM
  F0E00h 200h   Mirror of RAM at FF900h     (or 00h-filled when disabled)
  F1000h 7000h  Mirror of FLASH ROM code area at 01000h (for [Fxxxxh] data)
  F8000h 78F0h  Mirror of unused FFh-filled area at 08000h
  FF8F0h 10h    Hidden RAM (for use by ROM) (or FFh-filled when disabled) ;-?
  FF900h 520h   RAM
  FFE20h C0h    RAM (C0h bytes, short-addressable)         ;short addr 20h..DFh
  FFEE0h 20h    Registers AX,BC,DE,HL (in four banks)      ;short addr E0h..FFh
  FFF00h 20h    SFRs (Port 0-15, etc.)  ;SFR addr 00h..1Fh ;short addr 00h..1Fh
  FFF20h D8h    SFRs                    ;SFR addr 20h..F7h
  FFFF8h 8      Registers SP,PSW,etc.   ;SFR addr F8h..FFh
```



## RL78 Program Status Word (PSW aka Flags)


```
     S1    S2/S3
  0  CY    CY    Carry flag (0=No, 1=Carry/borrow)
  1  ISP0  ISP0  In-service Priority bit0
  2  ISP1  ISP1  In-service Priority bit1
  3  0     RBS0  Register Bank Select bit0   (RL78-S2/S3 only) (used on 3DS)
  4  AC    AC    Auxilliary Carry flag (aka carry on 4bit nibble)
  5  0     RBS1  Register Bank Select bit1   (RL78-S2/S3 only) (used on 3DS)
  6  Z     Z     Zero flag             (0=No, 1=Zero/Equal)
  7  IE    IE    Interrupt Enable flag (0=Disable, 1=Enable)
```



## RL78 Opcode flags


```
  Opcode                                ZHC
  ADD/ADDC/SUB/SUBC/CMP/CMPS            XXX
  ADDW/SUBW/CMPW ;with dst<>SP          XXX
  ADDW/SUBW      ;with dst=SP           ---
  CMP0                                  X00
  AND/OR/XOR                            X--
  INC/DEC                               XX-
  INCW/DECW                             ---
  MOVS                                  X-X
  SHR/SHRW/SHL/SHLW/SAR/SARW            --X
  ROR/RORC/ROL/ROLC/ROLWC               --X
  AND1/OR1/XOR1/NOT1                    --X
  MOV1                                  ---
  MOV/XCH/ONEB/CLRB                     ---
  MOVW/XCHW/ONEW/CLRW                   ---
  MULU                                  ---
  SET1/CLR1                             ---
  CALL/CALLT/BRK/RET/PUSH/POP           ---
  BR/Bcond/SKcond/BTCLR                 ---
  SEL/NOP/DI/EI/HALT/STOP               ---
  RETI/RETB                             old
```

Note: Opcodes that use PSW or PSW.n or CY as destination operand do of course
also affect the corresponding flags.



## RL78 Conditional Opcodes


The CPU supports conditional branch/skip opcodes. Skip does skip the next
opcode if the condition is true (unknown if that is any faster, especially in
case of large 5-byte opcodes). Combining conditional SKx+BT/BF is possible.

```
  Native    Mocash
  BC  SKC   JC/JB   SKC/SKB   CY=1 (carry, unsigned below)
  BNC SKNC  JNC/JAE SKNC/SKAE CY=0 (no carry, unsigned above or equal)
  BZ  SKZ   JZ/JE   SKZ/SKE   Z=1 (zero/equal)
  BNZ SKNZ  JNZ/JNE SKNZ/SKNE Z=0 (nonzero/not equal)
  BH  SKH   JA      SKA       CY=0 and Z=0 (unsigned above/higher)
  BNH SKNH  JBE     SKBE      CY=1 or Z=1 (unsigned below or equal, not higher)
  BF        JZ                bit=0 (bit false/zero)
  BT        JNZ               bit=1 (bit true/nonzero)
  BTCLR     JNZCLR            bit=1 (bit true/nonzero, and auto-clear bit)
```

There are no conditions for signed overflow/less/greater. Signed
positive/negative can be tested via BF/BT on result.bit7/bit15.

The skip feature could be used as prefix for making conditional opcodes, eg.
"ADD.Z" could be made of "SKNZ+ADD" (to add if zero).



## Stack


```
  PUSH/POP rp/PSW --> 2 bytes
  CALL/CALLT/RET  --> 4 bytes
  Interrupt/RETI  --> 4 bytes
  BRK/RETB        --> 4 bytes
```




# <a name="3dsi2cmcurl78sfrregistersspecialfunctionregistersioports"></a>3DS I2C MCU - RL78 SFR Registers (Special Function Registers) (I/O ports)




## Datasheets


SFRs are documented in RL78 Hardware Manuals. However, the SFRs aren't 100%
same for all RL78 chips. The "78K0R/KC3-L, 78K0R/KE3-L" datasheet appears to be
pretty close to the 3DS hardware (aside from the F0500h-F07FFh area).



## SFR List


```
  Addr   Access  Reset Symbol     Special Function Register (SFR)
  FFF00h R/W 1B- 00h   P0         Port data 0
  FFF01h R/W 1B- 00h   P1         Port data 1
  FFF02h R/W 1B- 00h   P2         Port data 2
  FFF03h R/W 1B- 00h   P3         Port data 3
  FFF04h R/W 1B- 00h   P4         Port data 4
  FFF05h R/W 1B- 00h   P5         Port data 5
  FFF06h R/W 1B- 00h   P6         Port data 6
  FFF07h R/W 1B- 00h   P7         Port data 7
  FFF08h R/W 1B- 00h   P8         Port data 8   (N/A)
  FFF09h R/W 1B- 00h   P9         Port data 9   (N/A)
  FFF0Ah R/W 1B- 00h   P10        Port data 10  (N/A)
  FFF0Bh R/W 1B- 00h   P11        Port data 11  (78K0R/K E3-L)
  FFF0Ch R/W 1B- Undef P12        Port data 12
  FFF0Dh R/W 1B- 00h   P13        Port data 13  (78K0R/K E3-L)
  FFF0Eh R/W 1B- 00h   P14        Port data 14
  FFF0Fh R/W 1B- 00h   P15        Port data 15  (N/A)
  FFF10h R/W -BW 0000h SDR00      Serial data 00 (TXD0/SIO00)
  FFF12h R/W -BW 0000h SDR01      Serial data 01 (RXD0/SIO01)
  FFF14h R/W -BW 0000h SDR12      Serial data 12 (TXD3/SIO30)
  FFF16h R/W -BW 0000h SDR13      Serial data 13 (RXD3/SIO31)
  FFF18h R/W --W 0000h TDR00      Timer data 00
  FFF1Ah R/W -BW 0000h TDR01(L/H) Timer data 01     (NOT L/H)
  FFF1Eh R   --W 0000h ADCR       10-bit A/D conversion result
  FFF1Fh R   -B- 00h   ADCRH      8-bit A/D conversion result
  FFF20h R/W 1B- FFh   PM0        Port mode 0
  FFF21h R/W 1B- FFh   PM1        Port mode 1
  FFF22h R/W 1B- FFh   PM2        Port mode 2
  FFF23h R/W 1B- FFh   PM3        Port mode 3
  FFF24h R/W 1B- FFh   PM4        Port mode 4
  FFF25h R/W 1B- FFh   PM5        Port mode 5
  FFF26h R/W 1B- FFh   PM6        Port mode 6
  FFF27h R/W 1B- FFh   PM7        Port mode 7
  FFF28h R/W 1B- FFh   PM8        Port mode 8  (N/A)
  FFF29h R/W 1B- FFh   PM9        Port mode 9  (N/A)
  FFF2Ah R/W 1B- FFh   PM10       Port mode 10 (N/A)
  FFF2Bh R/W 1B- FFh   PM11       Port mode 11 (78K0R/K E3-L)
  FFF2Ch R/W 1B- FFh   PM12       Port mode 12
  FFF2Dh -   --- -     PM13       Port mode 13 (N/A)
  FFF2Eh R/W 1B- FFh   PM14       Port mode 14
  FFF2Fh R/W 1B- FFh   PM15       Port mode 15 (N/A) (3DS)
  FFF30h R/W 1B- 00h   ADM0       A/D converter mode 0
  FFF31h R/W 1B- 00h   ADS        Analog input channel specification
  FFF32h R/W 1B- 00h   ADM1       A/D converter mode 1                  (N/A)
  FFF37h R/W 1B- 00h   KRM        Key return mode
  FFF38h R/W 1B- 00h   EGP0       External interrupt rising edge enable 0
  FFF39h R/W 1B- 00h   EGN0       External interrupt falling edge enable 0
  FFF3Ah R/W 1B- 00h   EGP1       External int rising edge enable 1    (E3-L)
  FFF3Bh R/W 1B- 00h   EGN1       External int falling edge enable 1   (E3-L)
  FFF3Ch R/W 1B- 00h   ISC        Input switch control register (!)
  FFF3Eh R/W 1B- 00h   TIS0       Timer input select register 0 (!)
  FFF44h R/W -BW 0000h SDR02      Serial data 02 (TXD1/SIO10)
  FFF46h R/W -BW 0000h SDR03      Serial data 03 (RXD1/SIO11)
  FFF48h R/W -BW 0000h SDR10      Serial data 10 (TXD2/SIO20)  (78K0R/K E3-L)
  FFF4Ah R/W -BW 0000h SDR11      Serial data 11 (RXD2/SIO21)  (78K0R/K E3-L)
  FFF50h R/W -B- 00h   IICA0      I2C IICA shift 0
  FFF51h R   1B- 00h   IICS0      I2C IICA status 0
  FFF52h R/W 1B- 00h   IICF0      I2C IICA flag 0
 ;FFF54h R/W -B- 00h   IICA1      I2C IICA shift 1  (N/A)
 ;FFF55h R   1B- 00h   IICS1      I2C IICA status 1 (N/A)
 ;FFF56h R/W 1B- 00h   IICF1      I2C IICA flag 1   (N/A)
  FFF64h R/W --W 0000h TDR02      Timer data 02
  FFF66h R/W -BW 0000h TDR03(L/H) Timer data 03     (NOT L/H)
  FFF68h R/W --W 0000h TDR04      Timer data 04
  FFF6Ah R/W --W 0000h TDR05      Timer data 05
  FFF6Ch R/W --W 0000h TDR06      Timer data 06
  FFF6Eh R/W --W 0000h TDR07      Timer data 07
  FFF70h R/W --W 0000h TDR10      Timer data 10     (N/A)
  FFF72h R/W -BW 0000h TDR11(L/H) Timer data 11     (N/A)
  FFF74h R/W --W 0000h TDR12      Timer data 12     (N/A)
  FFF76h R/W -BW 0000h TDR13(L/H) Timer data 13     (N/A)
  FFF78h R/W --W 0000h TDR14      Timer data 14     (N/A)
  FFF7Ah R/W --W 0000h TDR15      Timer data 15     (N/A)
  FFF7Ch R/W --W 0000h TDR16      Timer data 16     (N/A)
  FFF7Eh R/W --W 0000h TDR17      Timer data 17     (N/A)
```


```
  FFF80h                          Undoc:
  FFF81h                          Undoc:
  FFF82h                          Undoc:
  FFF83h                          Undoc:
  FFF84h                          Undoc:
  FFF85h                          Undoc:
  FFF86h                          Undoc:
  FFF87h                          Undoc:
  FFF88h                          Undoc:
  FFF89h                          Undoc: something?
  FFF8Ah                          Undoc: something?
  FFF8Bh                          Undoc: Serial TOOL0 stat/ack
  FFF8Ch                          Undoc: Serial TOOL0 control
  FFF8Dh                          Undoc: Serial TOOL0 bauds.lsb
  FFF8Eh                          Undoc: Serial TOOL0 bauds.msb
  FFF8Fh                          Undoc: Serial TOOL0 data
```


```
  FFF90h R/W --W 0000h RSUBC      Sub-count register (!)   (3DS)  ;\either
 (FFF90h)R/W --W 0FFFh ITMC       Interval timer control   (N/A)  ;/or
  FFF92h R/W -B- 00h   SEC        Second count
  FFF93h R/W -B- 00h   MIN        Minute count
  FFF94h R/W -B- 12h   HOUR       Hour count (12 AM upon reset)
  FFF95h R/W -B- 00h   WEEK       Week count (uh, week??????)
  FFF96h R/W -B- 01h   DAY        Day count
  FFF97h R/W -B- 01h   MONTH      Month count
  FFF98h R/W -B- 00h   YEAR       Year count
  FFF99h R/W -B- 00h   SUBCUD     Watch error correction
  FFF9Ah R/W -B- 00h   ALARMWM    Alarm minute
  FFF9Bh R/W -B- 12h   ALARMWH    Alarm hour
  FFF9Ch R/W -B- 00h   ALARMWW    Alarm week
  FFF9Dh R/W 1B- 00h   RTCC0      Real-time clock control 0
  FFF9Eh R/W 1B- 00h   RTCC1      Real-time clock control 1
  FFF9Fh R/W 1B- 00h   RTCC2      Real-time clock control 2 (!)
  FFFA0h R/W -B- 00h   CMC        Clock operation mode control
  FFFA1h R/W 1B- C0h   CSC        Clock operation status control
  FFFA2h R   1B- 00h   OSTC       Osc stabilization time counter status
  FFFA3h R/W -B- 07h   OSTS       Osc stabilization time select
  FFFA4h R/W 1B- 00h   CKC        System clock control
  FFFA5h R/W 1B- 00h   CKS0       Clock output select 0
  FFFA6h R/W 1B- 00h   CKS1       Clock output select 1 (N/A) (Old3DS)
  FFFA8h R   -B- Undef RESF       Reset control flag
  FFFA9h R/W 1B- 00h   LVIM       Low-Voltage detection
  FFFAAh R/W 1B- var   LVIS       Low-Voltage detection level (reset=xxh)
  FFFABh R/W -B- var   WDTE       Watchdog timer enable   (reset=1Ah/9Ah)
  FFFACh R/W -B- 00h   CRCIN      CRC input            (N/A)
  FFFB0h R/W -B- 00h   DSA0       DMA SFR address 0
  FFFB1h R/W -B- 00h   DSA1       DMA SFR address 1
  FFFB2h R/W -BW 0000h DRA0(L/H)  DMA RAM address 0
  FFFB4h R/W -BW 0000h DRA1(L/H)  DMA RAM address 1
  FFFB6h R/W -BW 0000h DBC0(L/H)  DMA byte count 0
  FFFB8h R/W -BW 0000h DBC1(L/H)  DMA byte count 1
  FFFBAh R/W 1B- 00h   DMC0       DMA mode control 0
  FFFBBh R/W 1B- 00h   DMC1       DMA mode control 1
  FFFBCh R/W 1B- 00h   DRC0       DMA operation control 0
  FFFBDh R/W 1B- 00h   DRC1       DMA operation control 1
  FFFBEh R/W 1B- 00h   BECTL      Background event control register (!)
  FFFBFh     1                    Undoc:
  FFFC0h -   --- Undef PFCMD      (used in the self programming library) (!)
  FFFC1h     1B                   Undoc:
  FFFC2h -   --- 00h   PFS        (used in the self programming library) (!)
  FFFC4h -   --- 00h   FLPMC      (used in the self programming library) (!)
  FFFC5h     1                    Undoc:
  FFFC6h      B                   Undoc:
  FFFC7h      B                   Undoc:
  FFFC8h       W                  Undoc:
  FFFCAh      B                   Undoc:
  FFFCBh      B                   Undoc:
  FFFCCh       W                  Undoc:
  FFFCEh       W                  Undoc:
  FFFD0h R/W 1BW 0000h IF2(L/H)   Interrupt request flag 2
  FFFD2h R/W 1BW 00h   IF3(L)     Interrupt request flag 3L       (N/A)
  FFFD4h R/W 1BW FFFFh MK2(L/H)   Interrupt mask flag 2
  FFFD6h R/W 1BW FFh   MK3(L)     Interrupt mask flag 3L          (N/A)
  FFFD8h R/W 1BW FFFFh PR02(L/H)  Priority specification flag 02
  FFFDAh R/W 1BW FFh   PR03(L)    Priority specification flag 03L (N/A)
  FFFDCh R/W 1BW FFFFh PR12(L/H)  Priority specification flag 12
  FFFDEh R/W 1BW FFh   PR13(L)    Priority specification flag 13L (N/A)
  FFFE0h R/W 1BW 0000h IF0(L/H)   Interrupt request flag 0
  FFFE2h R/W 1BW 0000h IF1(L/H)   Interrupt request flag 1
  FFFE4h R/W 1BW FFFFh MK0(L/H)   Interrupt mask flag 0
  FFFE6h R/W 1BW FFFFh MK1(L/H)   Interrupt mask flag 1
  FFFE8h R/W 1BW FFFFh PR00(L/H)  Priority specification flag 00
  FFFEAh R/W 1BW FFFFh PR01(L/H)  Priority specification flag 01
  FFFECh R/W 1BW FFFFh PR10(L/H)  Priority specification flag 10
  FFFEEh R/W 1BW FFFFh PR11(L/H)  Priority specification flag 11
  FFFF0h R/W --W 0000h MDAL       Multiplication/division data A (L) (MULA)
  FFFF2h R/W --W 0000h MDAH       Multiplication/division data A (H) (MULB)
  FFFF4h R/W --W 0000h MDBH       Multiplication/division data B (H) (MULOH)
  FFFF6h R/W --W 0000h MDBL       Multiplication/division data B (L) (MULOL)
  FFFF8h ??? ??? ????h SP(L/H)    CPU Stack Pointer                 ;\
  FFFFAh R/W ??? ??h   PSW        CPU Program Status Word           ;
  FFFFBh W   -B- --    -          CPU Reserve (for MUL/DIV opcodes) ; Fixed
  FFFFCh ??? ??? 00h   CS         CPU Program Counter Bank          ; SFRs
  FFFFDh ??? ??? ??h   ES         CPU Data Bank                     ;
  FFFFEh R/W 1B- 00h   PMC        CPU Processor mode control        ;
  FFFFFh ??? ??? ??h   MEM        CPU ... whatever?                 ;/
```



## Extended SFR (2nd SFR) List


```
  F0010h R/W 1B- 00h   ADM2      A/D converter mode 2                     (N/A)
  F0011h R/W -B- FFh   ADUL      A/D result comparison upper limit setting(N/A)
  F0012h R/W -B- 00h   ADLL      A/D result comparison lower limit setting(N/A)
  F0013h R/W -B- 00h   ADTES     A/D test                                 (N/A)
  F0017h R/W -B- 10h   ADPC      A/D port configuration register (!)
  F0030h R/W 1B- 00h   PU0       Pull-up resistor option 0        ;\
  F0031h R/W 1B- 00h   PU1       Pull-up resistor option 1        ;
  F0032h -   --- -     PU2       Pull-up resistor option 2  (N/A) ;
  F0033h R/W 1B- 00h   PU3       Pull-up resistor option 3        ;
  F0034h R/W 1B- 01h   PU4       Pull-up resistor option 4        ;
  F0035h R/W 1B- 00h   PU5       Pull-up resistor option 5        ;
  F0036h R/W 1B- 00h   PU6       Pull-up resistor option 6  (N/A) ;
  F0037h R/W 1B- 00h   PU7       Pull-up resistor option 7        ;
  F0038h R/W 1B- 00h   PU8       Pull-up resistor option 8  (N/A) ;
  F0039h R/W 1B- 00h   PU9       Pull-up resistor option 9  (N/A) ;
  F003Ah R/W 1B- 00h   PU10      Pull-up resistor option 10 (N/A) ;
  F003Bh R/W 1B- 00h   PU11      Pull-up resistor option 11 (78K0R/K E3-L)
  F003Ch R/W 1B- 00h   PU12      Pull-up resistor option 12       ;
  F003Dh -   --- -     PU13      Pull-up resistor option 13 (N/A) ;
  F003Eh R/W 1B- 00h   PU14      Pull-up resistor option 14       ;
  F003Fh -   --- -     PU15      Pull-up resistor option 15 (N/A) ;/
  F0040h R/W 1B- 00h   PIM0      Port input mode 0                ;\
  F0041h R/W 1B- 00h   PIM1      Port input mode 1                ;
  F0042h -   --- -     PIM2      Port input mode 2  (N/A)         ;
  F0043h -   --- -     PIM3      Port input mode 3  (N/A)         ;
  F0044h R/W 1B- 00h   PIM4      Port input mode 4  (N/A)         ;
  F0045h R/W 1B- 00h   PIM5      Port input mode 5  (N/A)         ;
  F0046h -   --- -     PIM6      Port input mode 6  (N/A)         ;
  F0047h -   --- -     PIM7      Port input mode 7  (N/A)         ;
  F0048h R/W 1B- 00h   PIM8      Port input mode 8  (N/A)         ;
  F0049h -   --- -     PIM9      Port input mode 9  (N/A)         ;
  F004Ah -   --- -     PIM10     Port input mode 10 (N/A)         ;
  F004Bh -   --- -     PIM11     Port input mode 11 (N/A)         ;
  F004Ch -   --- -     PIM12     Port input mode 12 (N/A)         ;
  F004Dh -   --- -     PIM13     Port input mode 13 (N/A)         ;
  F004Eh R/W 1B- 00h   PIM14     Port input mode 14 (78K0R/K E3-L);
  F004Fh -   --- -     PIM15     Port input mode 15 (N/A)         ;/
  F0050h R/W 1B- 00h   POM0      Port output mode 0               ;\
  F0051h R/W 1B- 00h   POM1      Port output mode 1               ;
  F0052h -   --- -     POM2      Port output mode 2  (N/A)        ;
  F0053h -   --- -     POM3      Port output mode 3  (N/A?) (3DS!);
  F0054h R/W 1B- 00h   POM4      Port output mode 4  (N/A)        ;
  F0055h R/W 1B- 00h   POM5      Port output mode 5  (N/A)        ;
  F0056h -   --- -     POM6      Port output mode 6  (N/A)        ;
  F0057h R/W 1B- 00h   POM7      Port output mode 7  (N/A)        ;
  F0058h R/W 1B- 00h   POM8      Port output mode 8  (N/A)        ;
  F0059h R/W 1B- 00h   POM9      Port output mode 9  (N/A)        ;
  F005Ah -   --- -     POM10     Port output mode 10 (N/A)        ;
  F005Bh -   --- -     POM11     Port output mode 11 (N/A)        ;
  F005Ch -   --- -     POM12     Port output mode 12 (N/A)        ;
  F005Dh -   --- -     POM13     Port output mode 13 (N/A)        ;
  F005Eh R/W 1B- 00h   POM14     Port output mode 14 (78K0R/K E3-L);
  F005Fh -   --- -     POM15     Port output mode 15 (N/A)        ;/
```


```
  F0060h R/W 1B- 00h   NFEN0     Noise filter enable 0 (!)               ;\(!)
  F0061h R/W 1B- 00h   NFEN1     Noise filter enable 1 (!)               ;/
```


```
 ;F0060h R/W 1B- FFh   PMC0      Port mode control 0              ;\     ;\
 ;F0061h -   --- -     PMC1      Port mode control 1  (N/A)       ;      ;
 ;F0062h -   --- -     PMC2      Port mode control 2  (N/A)       ;      ;
 ;F0063h R/W 1B- FFh   PMC3      Port mode control 3              ;      ;
 ;F0064h -   --- -     PMC4      Port mode control 4  (N/A)       ;      ;
 ;F0065h -   --- -     PMC5      Port mode control 5  (N/A)       ;      ;
 ;F0066h -   --- -     PMC6      Port mode control 6  (N/A)       ;      ;
 ;F0067h -   --- -     PMC7      Port mode control 7  (N/A)       ;      ; N/A
 ;F0068h -   --- -     PMC8      Port mode control 8  (N/A)       ;      ; !!!
 ;F0069h -   --- -     PMC9      Port mode control 9  (N/A)       ;      ;
 ;F006Ah R/W 1B- FFh   PMC10     Port mode control 10             ;      ;
 ;F006Bh R/W 1B- FFh   PMC11     Port mode control 11             ;      ;
 ;F006Ch R/W 1B- FFh   PMC12     Port mode control 12             ;      ;
 ;F006Dh -   --- -     PMC13     Port mode control 13 (N/A)       ;      ;
 ;F006Eh R/W 1B- FFh   PMC14     Port mode control 14             ;      ;
 ;F006Fh -   --- -     PMC15     Port mode control 15 (N/A)       ;/     ;
 ;F0070h R/W 1B- 00h   NFEN0     Noise filter enable 0                   ;
 ;F0071h R/W 1B- 00h   NFEN1     Noise filter enable 1                   ;
 ;F0072h R/W 1B- 00h   NFEN2     Noise filter enable 2                   ;
 ;F0073h R/W 1B- 00h   ISC       Input switch control                    ;
 ;F0074h R/W -B- 00h   TIS0      Timer input select 0                    ;
 ;F0076h R/W -B- 00h   ADPC      A/D port configuration                  ;
 ;F0077h R/W -B- 00h   PIOR      Peripheral I/O redirection              ;
 ;F0078h R/W -B- 00h   IAWCTL    Invalid memory access detection control ;
 ;F007Dh R/W 1B- 00h   GDIDIS    Global digital input disable            ;
 ;F0090h R/W 1B- 00h   DFLCTL    Data flash control                      ;
 ;F00A0h R/W -B- opt.  HIOTRM    High-speed on-chip oscillator trimming  ;
 ;F00A8h R/W -B- opt.  HOCODIV   High-speed on-chip oscillator frequency ;/
```


```
  F00C0h                         ?? flash?        (!)(!)(!)          ;-3DS
```


```
  F00C0h      B                   Undoc:
  F00C1h      B                   Undoc:
  F00C2h       W                  Undoc:
  F00C4h       W                  Undoc:
  F00C8h       W                  Undoc:
```


```
  F00E0h R/W --W 0000h MDCL      Multiplication/division data C (L)
  F00E2h R/W --W 0000h MDCH      Multiplication/division data C (H)
  F00E8h R/W 1B- 00h   MDUC      Multiplication/division control
  F00F0h R/W 1B- 00h   PER0      Peripheral enable 0
  F00F2h                         Timer? (!)(!)(!)                    ;-3DS
  F00F3h R/W -B- 00h   OSMC      Subsystem clock supply mode control
  F00F4h R/W -B- 00h   RMC       Regulator mode control register (!)
  F00F5h R/W 1B- 00h   RPECTL    RAM parity error control (!)
  F00F6h R/W 1B- 00h   DSCCTL    20 MHz internal high-speed osc. control (!)
  F00FEh R   -B- Undef BCDADJ    BCD adjust result
  F0100h R   -BW 0000h SSR00(L)  Serial status 00
  F0102h R   -BW 0000h SSR01(L)  Serial status 01
  F0104h R   -BW 0000h SSR02(L)  Serial status 02
  F0106h R   -BW 0000h SSR03(L)  Serial status 03
  F0108h R/W -BW 0000h SIR00(L)  Serial flag clear trigger 00
  F010Ah R/W -BW 0000h SIR01(L)  Serial flag clear trigger 01
  F010Ch R/W -BW 0000h SIR02(L)  Serial flag clear trigger 02
  F010Eh R/W -BW 0000h SIR03(L)  Serial flag clear trigger 03
  F0110h R/W --W 0020h SMR00     Serial mode 00
  F0112h R/W --W 0020h SMR01     Serial mode 01
  F0114h R/W --W 0020h SMR02     Serial mode 02
  F0116h R/W --W 0020h SMR03     Serial mode 03
  F0118h R/W --W 0087h SCR00     Serial communication operation setting 00
  F011Ah R/W --W 0087h SCR01     Serial communication operation setting 01
  F011Ch R/W --W 0087h SCR02     Serial communication operation setting 02
  F011Eh R/W --W 0087h SCR03     Serial communication operation setting 03
  F0120h R   1BW 0000h SE0(L)    Serial channel enable status 0
  F0122h R/W 1BW 0000h SS0(L)    Serial channel start 0
  F0124h R/W 1BW 0000h ST0(L)    Serial channel stop 0
  F0126h R/W -BW 0000h SPS0(L)   Serial clock select 0
  F0128h R/W --W 0F0Fh SO0       Serial output 0
  F012Ah R/W 1BW 0000h SOE0(L)   Serial output enable 0
  F0134h R/W -BW 0000h SOL0(L)   Serial output level 0
  F0138h R/W -BW 0000h SSC0(L)   Serial standby control 0 (N/A)
  F0140h R   -BW 0000h SSR10(L)  Serial status 10 (78K0R/K E3-L)
  F0142h R   -BW 0000h SSR11(L)  Serial status 11 (78K0R/K E3-L)
  F0144h R   -BW 0000h SSR12(L)  Serial status 12
  F0146h R   -BW 0000h SSR13(L)  Serial status 13
  F0148h R/W -BW 0000h SIR10(L)  Serial flag clear trigger 10 (78K0R/K E3-L)
  F014Ah R/W -BW 0000h SIR11(L)  Serial flag clear trigger 11 (78K0R/K E3-L)
  F014Ch R/W -BW 0000h SIR12(L)  Serial flag clear trigger 12
  F014Eh R/W -BW 0000h SIR13(L)  Serial flag clear trigger 13
  F0150h R/W --W 0020h SMR10     Serial mode 10 (78K0R/K E3-L)
  F0152h R/W --W 0020h SMR11     Serial mode 11 (78K0R/K E3-L)
  F0154h R/W --W 0020h SMR12     Serial mode 12
  F0156h R/W --W 0020h SMR13     Serial mode 13
  F0158h R/W --W 0087h SCR10     Serial communication operation setting 10 (E3)
  F015Ah R/W --W 0087h SCR11     Serial communication operation setting 11 (E3)
  F015Ch R/W --W 0087h SCR12     Serial communication operation setting 12
  F015Eh R/W --W 0087h SCR13     Serial communication operation setting 13
  F0160h R   1BW 0000h SE1(L)    Serial channel enable status 1
  F0162h R/W 1BW 0000h SS1(L)    Serial channel start 1
  F0164h R/W 1BW 0000h ST1(L)    Serial channel stop 1
  F0166h R/W -BW 0000h SPS1(L)   Serial clock select 1
  F0168h R/W --W 0F0Fh SO1       Serial output 1
  F016Ah R/W 1BW 0000h SOE1(L)   Serial output enable 1
  F0174h R/W -BW 0000h SOL1(L)   Serial output level 1
  F0178h R/W -BW 0000h SSC1(L)   Serial standby control 1 (N/A)
  ...                            - - -       ?
  F0180h R   --W FFFFh TCR00     Timer counter 00
  F0182h R   --W FFFFh TCR01     Timer counter 01
  F0184h R   --W FFFFh TCR02     Timer counter 02
  F0186h R   --W FFFFh TCR03     Timer counter 03
  F0188h R   --W FFFFh TCR04     Timer counter 04
  F018Ah R   --W FFFFh TCR05     Timer counter 05
  F018Ch R   --W FFFFh TCR06     Timer counter 06
  F018Eh R   --W FFFFh TCR07     Timer counter 07
  F0190h R/W --W 0000h TMR00     Timer mode 00
  F0192h R/W --W 0000h TMR01     Timer mode 01
  F0194h R/W --W 0000h TMR02     Timer mode 02
  F0196h R/W --W 0000h TMR03     Timer mode 03
  F0198h R/W --W 0000h TMR04     Timer mode 04
  F019Ah R/W --W 0000h TMR05     Timer mode 05
  F019Ch R/W --W 0000h TMR06     Timer mode 06
  F019Eh R/W --W 0000h TMR07     Timer mode 07
  F01A0h R   -BW 0000h TSR00(L)  Timer status 00
  F01A2h R   -BW 0000h TSR01(L)  Timer status 01
  F01A4h R   -BW 0000h TSR02(L)  Timer status 02
  F01A6h R   -BW 0000h TSR03(L)  Timer status 03
  F01A8h R   -BW 0000h TSR04(L)  Timer status 04
  F01AAh R   -BW 0000h TSR05(L)  Timer status 05
  F01ACh R   -BW 0000h TSR06(L)  Timer status 06
  F01AEh R   -BW 0000h TSR07(L)  Timer status 07
  F01B0h R   1BW 0000h TE0(L)    Timer channel enable status 0
  F01B2h R/W 1BW 0000h TS0(L)    Timer channel start 0
  F01B4h R/W 1BW 0000h TT0(L)    Timer channel stop 0
  F01B6h R/W --W 0000h TPS0      Timer clock select 0
  F01B8h R/W -BW 0000h TO0(L)    Timer output 0
  F01BAh R/W 1BW 0000h TOE0(L)   Timer output enable 0
  F01BCh R/W -BW 0000h TOL0(L)   Timer output level 0
  F01BEh R/W -BW 0000h TOM0(L)   Timer output mode 0
 ;F01C0h R   --W FFFFh TCR10     Timer counter 10               ;\
 ;F01C2h R   --W FFFFh TCR11     Timer counter 11               ;
 ;F01C4h R   --W FFFFh TCR12     Timer counter 12               ;
 ;F01C6h R   --W FFFFh TCR13     Timer counter 13               ;
 ;F01C8h R   --W FFFFh TCR14     Timer counter 14               ;
 ;F01CAh R   --W FFFFh TCR15     Timer counter 15               ;
 ;F01CCh R   --W FFFFh TCR16     Timer counter 16               ;
 ;F01CEh R   --W FFFFh TCR17     Timer counter 17               ;
 ;F01D0h R/W --W 0000h TMR10     Timer mode 10                  ;
 ;F01D2h R/W --W 0000h TMR11     Timer mode 11                  ;
 ;F01D4h R/W --W 0000h TMR12     Timer mode 12                  ; N/A !!!
 ;F01D6h R/W --W 0000h TMR13     Timer mode 13                  ;
 ;F01D8h R/W --W 0000h TMR14     Timer mode 14                  ;
 ;F01DAh R/W --W 0000h TMR15     Timer mode 15                  ;
 ;F01DCh R/W --W 0000h TMR16     Timer mode 16                  ;
 ;F01DEh R/W --W 0000h TMR17     Timer mode 17                  ;
 ;F01E0h R   -BW 0000h TSR10(L)  Timer status 10                ;
 ;F01E2h R   -BW 0000h TSR11(L)  Timer status 11                ;
 ;F01E4h R   -BW 0000h TSR12(L)  Timer status 12                ;
 ;F01E6h R   -BW 0000h TSR13(L)  Timer status 13                ;
 ;F01E8h R   -BW 0000h TSR14(L)  Timer status 14                ;
 ;F01EAh R   -BW 0000h TSR15(L)  Timer status 15                ;
 ;F01ECh R   -BW 0000h TSR16(L)  Timer status 16                ;
 ;F01EEh R   -BW 0000h TSR17(L)  Timer status 17                ;
 ;F01F0h R   1BW 0000h TE1(L)    Timer channel enable status 1  ;
 ;F01F2h R/W 1BW 0000h TS1(L)    Timer channel start 1          ;
 ;F01F4h R/W 1BW 0000h TT1(L)    Timer channel stop 1           ;
 ;F01F6h R/W --W 0000h TPS1      Timer clock select 1           ;
 ;F01F8h R/W -BW 0000h TO1(L)    Timer output 1                 ;
 ;F01FAh R/W 1BW 0000h TOE1(L)   Timer output enable 1          ;
 ;F01FCh R/W -BW 0000h TOL1(L)   Timer output level 1           ;
 ;F01FEh R/W -BW 0000h TOM1(L)   Timer output mode 1            ;
 ;F0200h R/W -B- 00h   DSA2      DMA SFR address 2              ;
 ;F0201h R/W -B- 00h   DSA3      DMA SFR address 3              ;
 ;F0202h R/W -BW 0000h DRA2(L/H) DMA RAM address 2              ;
 ;F0204h R/W -BW 0000h DRA3(L/H) DMA RAM address 3              ;
 ;F0206h R/W -BW 0000h DBC2(L/H) DMA byte count 2               ;
 ;F0208h R/W -BW 0000h DBC3(L/H) DMA byte count 3               ;
 ;F020Ah R/W 1B- 00h   DMC2      DMA mode control 2             ;
 ;F020Bh R/W 1B- 00h   DMC3      DMA mode control 3             ;
 ;F020Ch R/W 1B- 00h   DRC2      DMA operation control 2        ;
 ;F020Dh R/W 1B- 00h   DRC3      DMA operation control 3        ;/
  F0230h R/W 1B- 00h   IICCTL00  I2C IICA control 00
  F0231h R/W 1B- 00h   IICCTL01  I2C IICA control 01
  F0232h R/W -B- FFh   IICWL0    I2C IICA low-level width setting 0
  F0233h R/W -B- FFh   IICWH0    I2C IICA high-level width setting 0
  F0234h R/W -B- 00h   SVA0      I2C Slave address 0
 ;F0238h R/W 1B- 00h   IICCTL10  I2C IICA control 10                  (N/A)
 ;F0239h R/W 1B- 00h   IICCTL11  I2C IICA control 11                  (N/A)
 ;F023Ah R/W -B- FFh   IICWL1    I2C IICA low-level width setting 1   (N/A)
 ;F023Bh R/W -B- FFh   IICWH1    I2C IICA high-level width setting 1  (N/A)
 ;F023Ch R/W -B- 00h   SVA1      I2C Slave address 1                  (N/A)
 ;F02F0h R/W 1B- 00h   CRC0CTL   Flash memory CRC control          (N/A)
 ;F02F2h R/W --W 0000h PGCRCL    Flash memory CRC operation result (N/A)
 ;F02FAh R/W --W 0000h CRCD      CRC data                          (N/A)
 For 78K0R...
  F0540h..   ..  ..    UF0..     UF0 stuff.. etc.. (not present in 3DS)
 Below are 3DS specific...
  F0501h     ?   ?               ??   Peripheral enable 1 for I2C ?  ;-3DS
  F0510h     ?   ?               Port data X ?                       ;\
  F0511h     ?   ?               Port mode X                         ; 3DS
  F0512h     ?   ?               Pull-up resistor option X           ;/
  F0538h     ?   ?               ??                                  ;-3DS
  F0540h R/W -B- 00h   IICA1     I2C IICA shift 1                    ;\
  F0541h R   1B- 00h   IICS1     I2C IICA status 1                   ; 3DS
  F0542h R/W 1B- 00h   IICF1     I2C IICA flag 1                     ;/
  F0550h R/W 1B- 00h   IICCTL10  I2C IICA control 10                 ;\
  F0551h R/W 1B- 00h   IICCTL11  I2C IICA control 11                 ;
  F0552h R/W -B- FFh   IICWL1    I2C IICA low-level width setting 1  ; 3DS
  F0553h R/W -B- FFh   IICWH1    I2C IICA high-level width setting 1 ;
  F0554h R/W -B- 00h   SVA1      I2C Slave address 1                 ;/
```


```
  F0746h      B                   Undoc:                                  ;-??
  F07E0h       W                  Undoc: Saved AX               ;\        ;\
  F07E2h       W                  Undoc: Saved BC               ;         ;
  F07E4h       W                  Undoc: Saved DE               ; debug   ; RAM
  F07E6h       W                  Undoc: Saved HL               ; stack?  ;
  F07E8h       W                  Undoc: Saved pop (maybe PSW?) ;         ;
  F07EAh      B                   Undoc: Saved CS               ;         ;
  F07EBh      B                   Undoc: Saved ES               ;/        ;
  F07ECh      B                   Undoc: Security okay flag (55h=yes)     ;
  F07EDh      B                   Undoc: Saved A ?                        ;
  F07EEh      B                   Undoc: Reply value ?                    ;
  F07F0h      B                   Undoc: RET opcode (or custom vector)    ;
                                                                          ;
  F0800h R/W  B  ?               FLASH related                       ;\   ;
  F0801h   W  B  ?               FLASH related                       ;    ;
  F0802h   W  B  ?               FLASH related                       ; 3DS;
  F0803h   W  B  ?               FLASH related                       ;    ;
  F0804h R/W  BW ?               FLASH related address?              ;    ;
  F0806h R/W  B  ?               FLASH related                       ;/   ;/
```



## CPU Register Banks & short-addressable RAM


```
  FFE20h R/W 1BW ??    RAM[C0h]  (can be accessed with "short" address)
  FFEE0h R/W 1BW ??    AX3(X3/A3) AX Bank 3 aka RP0(3) aka R0(3)/R1(3) ;\
  FFEE2h R/W 1BW ??    BC3(C3/B3) BC Bank 3 aka RP1(3) aka R2(3)/R3(3) ; Bank 3
  FFEE4h R/W 1BW ??    DE3(E3/D3) DE Bank 3 aka RP2(3) aka R4(3)/R5(3) ;
  FFEE6h R/W 1BW ??    HL3(L3/H3) HL Bank 3 aka RP3(3) aka R6(3)/R7(3) ;/
  FFEE8h R/W 1BW ??    AX2(X2/A2) AX Bank 2 aka RP0(2) aka R0(2)/R1(2) ;\
  FFEEAh R/W 1BW ??    BC2(C2/B2) BC Bank 2 aka RP1(2) aka R2(2)/R3(2) ; Bank 2
  FFEECh R/W 1BW ??    DE2(E2/D2) DE Bank 2 aka RP2(2) aka R4(2)/R5(2) ;
  FFEEEh R/W 1BW ??    HL2(L2/H2) HL Bank 2 aka RP3(2) aka R6(2)/R7(2) ;/
  FFEF0h R/W 1BW ??    AX1(X1/A1) AX Bank 1 aka RP0(1) aka R0(1)/R1(1) ;\
  FFEF2h R/W 1BW ??    BC1(C1/B1) BC Bank 1 aka RP1(1) aka R2(1)/R3(1) ; Bank 1
  FFEF4h R/W 1BW ??    DE1(E1/D1) DE Bank 1 aka RP2(1) aka R4(1)/R5(1) ;
  FFEF6h R/W 1BW ??    HL1(L1/H1) HL Bank 1 aka RP3(1) aka R6(1)/R7(1) ;/
  FFEF8h R/W 1BW ??    AX0(X0/A0) AX Bank 0 aka RP0(0) aka R0(0)/R1(0) ;\
  FFEFAh R/W 1BW ??    BC0(C0/B0) BC Bank 0 aka RP1(0) aka R2(0)/R3(0) ; Bank 0
  FFEFCh R/W 1BW ??    DE0(E0/D0) DE Bank 0 aka RP2(0) aka R4(0)/R5(0) ;
  FFEFEh R/W 1BW ??    HL0(L0/H0) HL Bank 0 aka RP3(0) aka R6(0)/R7(0) ;/
```


The "1BW" column indicates support for Bit/Byte/Word access.

Words with (L) or (L/H) symbol suffix can be alternately accessed as low and/or
high byte.




# <a name="3dsi2cmcurl78misc"></a>3DS I2C MCU - RL78 Misc




## Overlapping


```
  ADDW AX,saddrp   can also be used for first some SFR's FFF00..FFF1F
  CLRB saddr       can also be used for first some SFR's FFF00..FFF1F
  addr16           can be used for further SFRs          FFF20..FFFFF
  SFR_SP/PSW/ES   can be used as alias for SP/PSW/ES
  SFR_AX/BC/DE/HL can be used as alias for AX/BC/DE/HL - but banked!
  SFR_CS    ... can be manually changed BEFORE JMP/CALL AX to make FAR-JMP... ?
```



## Nocash Syntax


```
  Native                      Nocash
  CLRB/CLRW/CMP0 op           MOV/MOVW/CMP op,0
  ONEB/ONEW op                MOV/MOVW op,1
  ADDC/SUBC/ROLC/RORC/ROLWC   ADC/SBC/RCL/RCR/RCRW/RCLW
  BR/BF/BT/Bcond/BTCLR        JMP/JZ/JNZ/Jcond/JNZCLR
  CALLT                       CALL
  MULU X                      MULU AX,A,X    ;optional alias
```


```
 @@def Vbyte            #byte
 @@def Vword            #word
 @@def sfr              sfr        SFR name aka FFF00h..FFFFFh
 @@def sfrp             sfrp       16-bit-manipulatable SFR name (even address)
 @@def saddr            saddr      8bit data addr at FFE20h to FFF1Fh
 @@def saddrp           saddrp     same as saddr, but even-address only
 @@def $addr20          $addr20    probably 8bit reljump
 @@def $Xaddr20         $!addr20   probably 16bit reljump
 @@def XXaddr20_code    !!addr20   20bit jumpdest (3 bytes) (CALL/BR) to CS=x
 @@def Xaddr16_code     !addr16    16bit jumpdest (2 bytes) (CALL/BR) to CS=0!
 @@def Xaddr16          !addr16    16bit data addr                    at ES=F
 @@def IhlI             [HL]           ;[HL]        ;\
 @@def IdeI             [DE]           ;[DE]        ; maybe can also use ES:?
 @@def Ihl_bI           [HL+B]         ;[HL+B]      ;
 @@def Ihl_cI           [HL+C]         ;[HL+C]      ;/
 @@def wordIbcI         word[BC]       ;[BC+nnnn]   ;\
 @@def wordIbI          word[B]        ;[B+nnnn]    ;
 @@def wordIcI          word[C]        ;[C+nnnn]    ; can use ES:
 @@def Ihl_byteI        [HL+byte]      ;[HL+nn]     ;
 @@def Ide_byteI        [DE+byte]      ;[DE+nn]     ;/
 @@def Isp_byteI        [SP+byte]      ;[SP+nn]     ;\shouldn't/can't use ES:?
 @@def I00nnI           [00nn]         ;[000nn]     ;/
```

Caution: 16bit MOVW/ADDW/etc with memory operand must use even addresses (this
is documented only for [sfrp] and [saddrp], but does also apply for [nnnn],
which does actually read/write memory at [nnnn and FFFEh]).


Identifier Description

```
  ?  [HL + byte], [DE + byte], [SP + byte] (only the space from F0000H
      to FFFFFH is specifiable)
  ?  word[B], word[C] (only the space from F0000H to FFFFFH is specifiable)
  ?  word[BC] (only the space from F0000H to FFFFFH is specifiable)
  ?  ES:[HL + byte], ES:[DE + byte] (higher 4-bit addresses are specified by
      the ES register)
  ?  ES:word[B], ES:word[C] (higher 4-bit addresses are specified by
      the ES register)
  ?  ES:word[BC] (higher 4-bit addresses are specified by the ES register)
```



MCU-FIRM

```
  00001F02 MCU    v0, v1026, v2048, v3072, v4102, v5122, v6145, v7168, v8192
  20001F02 New_3DS MCU            v8192, v9216(New2DSXL)
  00001F03 SAFE_MODE MCU          v0
  20001F03 New_3DS SAFE_MODE MCU  v9217
```




## RL78/G13 - Memory Map (R5F100xA, R5F101xA (x = 6 to 8, A to C, E to G))


```
  00000h Boot Cluster 0
  01000h Boot Cluster 1     ;<-- hence the gap
```




# <a name="3dsi2cgyroscopeoldversion"></a>3DS I2C Gyroscope (old version)



CAUTION: This is for a reportedly existing gyroscope that doesn't actually
exist, at least not in New3DS. New3DS returns only FFh's when trying to read
below registers.



## GYRO Register Map - InvenSense ITG-3200 gyroscope


```
  Hex     Register Name R/W
  00h     WHO_AM_I      R/W Device ID (aka Who Am I)
  15h     SMPLRT_DIV    R/W Sample Rate Divider (reset=00h)
  16h     DLPF_FS       R/W Low Pass Filter and Full Scale Config (reset=00h)
  17h     INT_CFG       R/W Interrupt Configuration (reset=00h)
  1Ah     INT_STATUS    R   Interrupt Status (reset=00h)
  1Bh/1Ch TEMP_OUT_H/L  R   signed 16bit Temperature data (R)
  1Dh/1Eh GYRO_XOUT_H/L R   signed 16bit Gyro X output data (R)
  1Fh/20h GYRO_YOUT_H/L R   signed 16bit Gyro Y output data (R)
  21h/22h GYRO_ZOUT_H/L R   signed 16bit Gyro Y output data (R)
  3Eh     PWR_MGM       R/W Power Management (reset=00h)
  xxh-FFh Undocumented (unknown)
```

Note: The 16bit H/L values are in BIG-ENDIAN format.



## Register Description


The register space allows single-byte reads and writes, as well as burst reads
and writes. When performing burst reads or writes, the memory pointer will
increment until reading or writing is terminated by the master, or until the
memory pointer reaches "certain reserved registers between 21h and 3Ch" (uh,
that would include GYRO\_ZOUT at 21h and/or 22h?).

Note that any bit that is not defined should be set to zero.



## GYRO[00h] - WHO\_AM\_I - Device ID (R/W)


```
  0    Reserved ("may be 0 or 1") (maybe ID.bit1, maybe R/W, or what?)    (?)
  1-6  I2C Device ID bit2-7 (initially 34h on power-up, aka D0h/4)        (R/W)
  7    Reserved ("should be 0")                                           (?)
```

Contains the upper 6bit of the 8bit I2C Device ID, can be used for detection,
the value is also write-able and can be changed after power-on.



## GYRO[15h] - SMPLRT\_DIV - Sample Rate Divider (R/W)


```
  0-7  Sample Rate Divider (00h..FFh=Divide by 1..100h) (initially 00h)
```

The gyros outputs are sampled internally at either 1kHz or 8kHz, determined by
the DLPF\_CFG setting (see register 22). This sampling is then filtered
digitally and delivered into the sensor registers after the number of cycles
determined by this register. The sample rate is given by the following formula:

```
  Fsample = Finternal / (divider+1)   ;where Finternal is either 1kHz or 8kHz
```

As an example, if the internal sampling is at 1kHz, then setting this register
to 7 would give the following:

```
  Fsample = 1kHz / (7 + 1) = 125Hz, or 8ms per sample
```



## GYRO[16h] - DLPF\_FS - Low Pass Filter and Full Scale Config (R/W)


```
  0-2  DLPF_CFG  Digital low pass filter bandwidth & internal sample rate
  3-4  FS_SEL    Full scale selection for gyro sensor data
  5-7  Reserved (should be 0)
```

FS\_SEL Gyro Full-Scale Range:

```
  0 Reserved (despite of being power-up default)
  1 Reserved
  2 Reserved
  3 +/-2000/sec (this should be used)
```

DLPF\_CFG, Low Pass Filter Bandwidth, Internal Sample Rate:

```
  0 Internal Sample Rate=8kHz, Low Pass Filter Bandwidth=256Hz
  1 Internal Sample Rate=1kHz, Low Pass Filter Bandwidth=188Hz
  2 Internal Sample Rate=1kHz, Low Pass Filter Bandwidth=98Hz
  3 Internal Sample Rate=1kHz, Low Pass Filter Bandwidth=42Hz
  4 Internal Sample Rate=1kHz, Low Pass Filter Bandwidth=20Hz
  5 Internal Sample Rate=1kHz, Low Pass Filter Bandwidth=10Hz
  6 Internal Sample Rate=1kHz, Low Pass Filter Bandwidth=5Hz
  7 Reserved
```



## GYRO[17h] - Interrupt Enable and INT Pin Configuration (R/W)


```
  0  Enable interrupt when new sample data is available           (1=Enable)
  1  -
  2  Enable interrupt when PLL ready ;after changing clock source (1=Enable)
  3  -
  4  Latch clear method (0=Status register read only, 1=Any register read);\
  5  Latch mode         (0=50us pulse, 1=latch until interrupt is cleared); INT
  6  Drive type for INT output pin  (0=push-pull, 1=open drain)           ; pin
  7  Logic level for INT output pin (0=active high, 1=active low)         ;/
```

Unknown what the PLL ready IRQ is good for, maybe the whole I2C bus becomes
unstable/inactive and shouldn't be used until receiving the IRQ?



## GYRO[1Ah] - Interrupt Status (R)


```
  0   New sample data is ready          (0=No, 1=Yes/IRQ)
  1   -
  2   PLL clock source change ready     (0=No, 1=Yes/IRQ)
  3-7 -
```

If the interrupt is not enabled, the associated status bit will NOT get set!

Interrupt Status bits are cleared after reading GYRO[1Ah] (or optionally, if
GYRO[17h].bit4=1, after reading any GYRO[xxh] register).



## GYRO[1Bh/1Ch] - TEMP\_OUT\_H/L signed 16bit Temperature data (R)



## GYRO[1Dh/1Eh] - GYRO\_XOUT\_H/L signed 16bit Gyro X output data (R)



## GYRO[1Fh/20h] - GYRO\_YOUT\_H/L signed 16bit Gyro Y output data (R)



## GYRO[21h/22h] - GYRO\_ZOUT\_H/L signed 16bit Gyro Y output data (R)


Sensor Registers. These values can be read at any time; however it is best to
use the interrupt function to determine when new data is available.



## GYRO[3Eh] - Power Management (R/W)


```
  0-2 CLK_SEL  Select device clock source  (see below)
  3   STBY_ZG  Gyro Z standby mode  (0=Normal, 1=Standby)  ;\eg. disable
  4   STBY_YG  Gyro Y standby mode  (0=Normal, 1=Standby)  ; unused axis
  5   STBY_XG  Gyro X standby mode  (0=Normal, 1=Standby)  ;/to save power
  6   SLEEP    Enable low power sleep mode (0=Normal, 1=Very low power sleep)
  7   H_RESET  Reset device and internal registers to power-up-default settings
```

The CLK\_SEL setting determines the device clock source as follows:

```
  0 Internal oscillator (default on power-up, but unreliable, PLLs are better)
  1 PLL with X Gyro reference
  2 PLL with Y Gyro reference
  3 PLL with Z Gyro reference
  4 PLL with external 32.768kHz reference  ;\unknown if available in 3DS,
  5 PLL with external 19.2MHz reference    ;/maybe from 32KHz RTC output?
  6 Reserved
  7 Reserved
```



## Gyro Datasheets


```
  Hardware: ITG-3200-Datasheet.pdf    ITG-3200 Product Specification (v1.7)
  Software: ITG-3200-Register-Map.pdf ITG-3200 Register Map (v1.0)
```

Older versions did include the Register Map in the Product Specification.




# <a name="3dsi2cgyroscopenewversion"></a>3DS I2C Gyroscope (new version)




## NEW\_GYRO Register Map - InvenSense ITG-1010


```
  04h/05h XG_OFFS_TC_H/L R/W Temperature Compensation X (10bit)
  07h/08h YG_OFFS_TC_H/L R/W Temperature Compensation Y (10bit)
  0Ah/0Bh ZG_OFFS_TC_H/L R/W Temperature Compensation Z (10bit)
  13h/14h XG_OFFS_USRH/L R/W User DC Bias Compensation X (16bit)
  15h/16h YG_OFFS_USRH/L R/W User DC Bias Compensation Y (16bit)
  17h/18h ZG_OFFS_USRH/L R/W User DC Bias Compensation Z (16bit)
  19h     SMPLRT_DIV     R/W Sample Rate Divider
  1Ah     CONFIG         R/W Configuration
  1Bh     GYRO_CONFIG    R/W Gyroscope Configuration
  23h     FIFO_EN        R/W FIFO Channel Enable
  37h     INT_PIN_CFG    R/W INT Pin / Bypass Enable Configuration
  38h     INT_ENABLE     R/W Interrupt Enable
  3Ah     INT_STATUS     R   Interrupt Status
  41h/42h TEMP_OUT_H/L   R   Temperature Measurement  TEMP_OUT  (16bit)
  43h/44h GYRO_XOUT_H/L  R   Gyroscope Measurements X GYRO_XOUT (16bit)
  45h/46h GYRO_YOUT_H/L  R   Gyroscope Measurements Y GYRO_YOUT (16bit)
  47h/48h GYRO_ZOUT_H/L  R   Gyroscope Measurements Z GYRO_ZOUT (16bit)
  6Ah     USER_CTRL      R/W User Control
  6Bh     PWR_MGMT_1     R/W Power Management 1
  6Ch     PWR_MGMT_2     R/W Power Management 2
  72h/73h FIFO_COUNTH/L  R/W FIFO Count Register (10bit)
  74h     FIFO_R_W       R/W FIFO Read/Write Data
  75h     WHO_AM_I       R   Device ID       - WHO_AM_I[6:1] -
  80h-FFh Undocumented (in New3DSXL these are same as 00h-7Fh)
```

Note: The 16bit H/L values are in BIG-ENDIAN format.



## NEW\_GYRO[04h/05h] - XG\_OFFS\_TC\_H/L - Temperature Compensation X (10bit, R/W)



## NEW\_GYRO[07h/08h] - YG\_OFFS\_TC\_H/L - Temperature Compensation Y (10bit, R/W)



## NEW\_GYRO[0Ah/0Bh] - ZG\_OFFS\_TC\_H/L - Temperature Compensation Z (10bit, R/W)


Unknown if these registers are implemented in 3DS (register 00h..0Bh contain
"garbage" that rather doesn't look like 10bit values).

```
  0-9   Signed 10bit, in 2.52 mdps/C steps (default=factory programmed)
  10-15 Unused (should be 0)
```

Writing 0000h disables temperature compensation (this doesn't affect the
factory values, which will be restored upon reset/power-up).



## NEW\_GYRO[13h/14h] - XG\_OFFS\_USRH/L - User DC Bias Compensation X (16bit, R/W)



## NEW\_GYRO[15h/16h] - YG\_OFFS\_USRH/L - User DC Bias Compensation Y (16bit, R/W)



## NEW\_GYRO[17h/18h] - ZG\_OFFS\_USRH/L - User DC Bias Compensation Z (16bit, R/W)


```
  0-15  Signed 16bit, subtracted from the sensor values
```



## NEW\_GYRO[19h] - SMPLRT\_DIV - Sample Rate Divider (R/W)


```
  0-7  Sample Rate Divider (00h..FFh=Divide by 1..100h) (initially 00h)
```

This register specifies the divider from the gyroscope output rate that can be
used to generate a reduced Sample Rate.

```
  When FCHOICE_B=0 and DLPF_CFG=1..6   --> Sample Rate Divider IS USED
  When FCHOICE_B=0 and DLPF_CFG=0 or 7 --> Sample Rate is fixed at 8kHz ???
  When FCHOICE_B=1..3                  --> Sample Rate is fixed at 32kHz
```

The sensor register output and FIFO output are both based on the Sample Rate.

When this register is effective under the FCOICE\_B and DLPF\_CFG settings, the
reduced Sample Rate is generated by the formula below:

```
  Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
```

where Gyroscope Output Rate = 1kHz.



## NEW\_GYRO[1Ah] - CONFIG - Configuration (R/W)


```
  0-2 DLPF_CFG      Configures the Digital Low Pass Filter DLPF setting
  3-5 EXT_SYNC_SET  Configures the Frame Sync FSYNC pin sampling
  6   FIFO_MODE     FIFO Mode (0=Overwrite oldest data, 1=Stop when full)
  7   -             Reserved
```

Please note that the DLPF can only be used when FCHOICE\_B=0 (Register 27).

An external signal connected to the FSYNC pin can be sampled by configuring
EXT\_SYNC\_SET.

Signal changes to the FSYNC pin are latched so that short strobes may be
captured. The latched FSYNC signal will be sampled at the Sampling Rate, as
defined in register 25. After sampling, the latch will reset to the current
FSYNC signal state.

The sampled value will be reported in place of the least significant bit in a
sensor data register determined by the value of EXT\_SYNC\_SET according to the
following table.

```
  EXT_SYNC_SET  FSYNC Bit Location
  0             Input disabled
  1             TEMP_OUT_L.bit0
  2             GYRO_XOUT_L.bit0
  3             GYRO_YOUT_L.bit0
  4             GYRO_ZOUT_L.bit0
```

The DLPF is configured by DLPF\_CFG, when FCHOICE\_B=0. The gyroscope and
temperature sensor are filtered according to the value of DLPF\_CFG and
FCHOICE\_B as shown in the table below.

```
  FCHOICE_B  DLPF_CFG   <---Gyroscope------->   <--Temperature Sensor-->
  <1> <0>               Bandwidth Delay   Fs    Bandwidth  Delay
  0   0      0          250Hz     0.97ms  8kHz  4000Hz     0.04ms
  0   0      1          184Hz     2.9ms   1kHz  188Hz      1.9ms
  0   0      2          92Hz      3.9ms   1kHz  98Hz       2.8ms
  0   0      3          41Hz      5.9ms   1kHz  42Hz       4.8ms
  0   0      4          20Hz      9.9ms   1kHz  20Hz       8.3ms
  0   0      5          10Hz      17.85ms 1kHz  10Hz       13.4ms
  0   0      6          5Hz       33.48ms 1kHz  5Hz        18.6ms
  0   0      7          3600Hz    0.17ms  8kHz  4000Hz     0.04ms
  -   1      -          8800Hz    0.064ms 32kHz 4000Hz     0.04ms
  1   0      -          3600Hz    0.11ms  32kHz 4000Hz     0.04ms
```



## NEW\_GYRO[1Bh] - GYRO\_CONFIG - Gyroscope Configuration (R/W)


```
  0-1 FCHOICE_B Choose the gyroscope output setting
  2   -         Reserved
  3-4 FS_SEL    Gyroscope Full Scale range select
  5   ZG_ST     Gyroscope X self test (0=Normal, 1=Perform test)
  6   YG_ST     Gyroscope Y self test (0=Normal, 1=Perform test)
  7   XG_ST     Gyroscope Z self test (0=Normal, 1=Perform test)
```

The electro/mechanical self test bits will move the sensor's proof masses, the
result can be then seen in sensor registers [43h..48h].

```
  FS_SEL Full Scale Range
  0      +/-250 /s
  1      +/-500 /s
  2      +/-1000 /s
  3      +/-2000 /s
```

FCHOICE\_B, in conjunction with DLPF\_CFG (Register 1Ah), is used to choose the
gyroscope output setting. For further information regarding the operation of
FCHOICE\_B, please refer to Section 4.2.



## NEW\_GYRO[23h] - FIFO\_EN - R/W FIFO Channel Enable (R/W)


```
  0-3 -            Reserved
  4   ZG_FIFO_EN   Output Gyroscope Z to FIFO (0=No, 1=Yes)
  5   YG_FIFO_EN   Output Gyroscope Y to FIFO (0=No, 1=Yes)
  6   XG_FIFO_EN   Output Gyroscope X to FIFO (0=No, 1=Yes)
  7   TEMP_FIFO_EN Output Temperature to FIFO (0=No, 1=Yes)
```



## NEW\_GYRO[37h] - INT\_PIN\_CFG - INT Pin / Bypass Enable Configuration (R/W)


```
  0-1 -                 Reserved
  2   FSYNC_INT_MODE_EN FSYNC Pin Enable  (0=Disable, 1=Enable FSYNC IRQ)
  3   FSYNC_INT_LEVEL   FSYNC Pin Act Low (0=Active High, 1=Active Low)
  4   INT_RD_CLEAR     Interrupt Clear (0=Upon IntStatus read, 1=Upon Any read)
  5   LATCH_INT_EN     INT Pin Hold       (0=50us pulse, 1=Hold until ack)
  6   INT_OPEN         INT Pin Open Drain (0=Push-pull, 1=Open drain)
  7   INT_LEVEL        INT Pin Active Low (0=Active High, 1=Active Low)
```

FSYNC\_INT\_MODE\_EN: When bit2 is equal to 1, the FSYNC pin will trigger an
interrupt when it transitions to the level specified by FSYNC\_INT\_LEVEL. When a
FSYNC interrupt is triggered, the FSYNC\_INT bit in Register 58 will be set to
1. An interrupt is sent to the host processor if the FSYNC interrupt is enabled
by the FSYNC\_INT\_EN bit in Register 56.



## NEW\_GYRO[38h] - INT\_ENABLE - Interrupt Enable (R/W)


```
  0   DATA_RDY_EN   Enable Data Ready interrupt           (0=Disable, 1=Enable)
  1-2 -             Reserved
  3   FSYNC_INT_EN  Enable FSYNC pin interrupt (0=Disable, 1=Use FSYNC as IRQ)
  4   FIFO_OFLOW_EN Enable FIFO buffer overflow interrupt (0=Disable, 1=Enable)
  5-7 -             Reserved
```

The Data Ready interrupt is triggered when all the sensor registers have been
written with the latest gyro sensor data.



## NEW\_GYRO[3Ah] - INT\_STATUS - Interrupt Status (R)


```
  0   DATA_RDY_INT   Data Ready (sample rate) interrupt (0=No, 1=Yes/IRQ)
  1-2 -              Reserved
  3   FSYNC_INT      FSYNC Frame Sync interrupt         (0=No, 1=Yes/IRQ)
  4   FIFO_OFLOW_INT FIFO Overrun interrupt             (0=No, 1=Yes/IRQ)
  5-7 -              Reserved
```

Each bit will clear after the register is read.



## NEW\_GYRO[41h/42h] - TEMP\_OUT\_H/L - Temperature Measurement (R, 16bit)



## NEW\_GYRO[43h/44h] - GYRO\_XOUT\_H/L - Gyroscope Measurements X (R, 16bit)



## NEW\_GYRO[45h/46h] - GYRO\_YOUT\_H/L - Gyroscope Measurements Y (R, 16bit)



## NEW\_GYRO[47h/48h] - GYRO\_ZOUT\_H/L - Gyroscope Measurements Z (R, 16bit)


```
  0-15  Most recent sensor value, signed 16bit, updated at sample rate
```

These sensor registers [41h..48h], are composed of two sets of registers: an
internal register set and a user-facing read register set.

- The internal register set is always updated at the Sample Rate.
- The user-facing read register set duplicates the internal register set's
- data values whenever the serial interface is idle. This guarantees that a
- burst read of sensor registers will read measurements from the same sampling
- instant.

Note that if burst reads are not used, the user is responsible for ensuring a
set of single byte reads correspond to a single sampling instant by checking
the Data Ready interrupt.

Temperature: The scale factor and offset for the temperature sensor are found
in the Electrical Specifications table in Product Specification document.



## NEW\_GYRO[6Ah] - USER\_CTRL - User Control (R/W)


```
  0   Reset Gyro/Temp sensor signal paths (0=No/ready, 1=Reset/busy?)
  1   Reserved
  2   FIFO Reset (clear fifo)             (0=No/ready, 1=Reset/busy?)
  3   Reserved
  5   Reserved
  4   Primary Interface select            (0=I2C/normal, 1=SPI/instead)
  6   FIFO Read Enable                    (0=Disable, 1=Enable)
  7   Reserved
```

It is "recommended" to have FIFO Read disabled when doing FIFO Reset.



## NEW\_GYRO[6Bh] - PWR\_MGMT\_1 - Power Management 1 (R/W)


```
  0-2 CLKSEL       Clock source select (see below)
  3   TEMP_DIS     Temperature sensor disable   (0=Normal, 1=Disable)
  4-5 -            Reserved
  6   SLEEP        Sleep Mode                   (0=Normal, 1=Sleep)
  7   DEVICE_RESET Reset all internal registers (0=No/ready, 1=Reset/busy?)
```

CLKSEL Clock Source

```
  00h = Internal 20MHz oscillator
  01h = PLL  ;\
  02h = PLL  ; gyroscope based clock (PLL)
  03h = PLL  ;
  04h = PLL  ;
  05h = PLL  ;/
  06h = Internal 20MHz oscillator
  07h = Reserved
```

The PLL is the default clock source upon power up (uh, but all registers except
WHO\_AM\_I are said to be zero on power-up). In order for the gyroscope to
perform to spec, the PLL must be selected as the clock source.

When the internal 20MHz oscillator is chosen as the clock source, the device
can operate while having the gyroscopes disabled. However, this is only
recommended if the user wishes to use the internal temperature sensor in this
mode.

For further information regarding the device clock source, please refer to the
relevant "Product Specification document" (uh, but this sentence comes from the
Product Specification) and the Power Mode Transition Descriptions section in
the Appendix (uh, but there is no Appendix).

Reset: The default values for each register can be found in "Section 3", uh?



## NEW\_GYRO[6Ch] - PWR\_MGMT\_2 - Power Management 2 (R/W)


```
  0   STBY_ZG Gyro Z standby mode  (0=Normal, 1=Standby)
  1   STBY_YG Gyro Y standby mode  (0=Normal, 1=Standby)
  2   STBY_XG Gyro X standby mode  (0=Normal, 1=Standby)
  3-5 -       Reserved bit(s)
  6-7 -       Reserved bit-pair?
```

To activate any gyro axis again, all three gyro axes must first be put into
standby mode, and then be turned on simultaneously.

If the user wishes to put all three gyro axes into standby mode, the internal
oscillator must be selected as the clock source.

If all three gyro axes are put into standby mode while the clock source of the
device is set to the PLL (with the gyro drive generating the reference clock),
the chip will hang due to an absence of a clock.

As long as one gyro axis is enabled, the drive circuit will remain active and
the PLL will provide a clock.



## NEW\_GYRO[72h/73h] - FIFO\_COUNTH/L - FIFO Count Register (10bit) (R/W)


```
  0-9   Number of bytes stored in the FIFO buffer (max=?)
  10-15 Reserved
```

The count value is latched when reading the High byte (ie. one can read
H-then-L without risking carry-outs from L to H during reading).



## NEW\_GYRO[74h] - FIFO\_R\_W - FIFO Read/Write Data (R/W)


```
  0-7   FIFO Data
```

This register is used to read and write(?) data from the FIFO buffer.

Data is written to the FIFO in order of register number, (from lowest to
highest). If all the FIFO enable flags (see below) are enabled, the contents of
NEW\_GYRO[41h..48h] will be written in order.



## NEW\_GYRO[75h] - WHO\_AM\_I - Device ID (always 68h) (R)


```
  0   Reserved ("Hard coded to 0")                               (R)
  1-6 I2C Device ID bit2-7 (always 34h, aka D0h/4 or D2h/4)      (R)
  7   Reserved ("Hard coded to 0")                               (R)
```

The device address D0h or D2h can be selected via AD0 pin (the AD0 pin is not
reflected in this register). This register is read-only (unlike as OLD\_GYRO).



## NEW\_GYRO[00h..0Dh] - Reserved/Undocumented


Reading these fourteen registers returns following weird values:

```
  BD DB D1 29 9C 1D 20 67 F4 1A 8C 08 B1 71
```

There should be 10bit temperature calibration values, but 9C1Dh,67F4h,8C08h
exceed 10bit range.

The first two bytes (BDh,DBh) seem to resemble the 1st/2nd bytes of older RS232
gyroscope protocols.




# <a name="3dsi2cinfraredreceivertransmitterirda"></a>3DS I2C Infrared Receiver/Transmitter (IrDA)



NXP SC16IS750

Single UART with I2C-bus/SPI interface, 64 bytes of transmit and receive FIFOs,
IrDA SIR built-in support - Rev. 06 - 13 May 2008 Product data sheet



## Register address byte (I2C)


```
  7    Unused (0)
  6-3  UART's internal register select
  2-1  Channel select (0) ;other values are reserved and should not be used.
  0    Unused (0)
```



## Register set


- Normal register set (default mapping)
  - 00h.DLAB=0.R     RHR       Receive Holding Register
  - 00h.DLAB=0.W     THR       Transmit Holding Register
  - 08h.DLAB=0.R/W   IER       Interrupt Enable Register
  - 10h.W            FCR       FIFO Control Register
  - 10h.R            IIR       Interrupt Identification Register
  - 18h.R/W          LCR       Line Control Register
  - 20h.R/W          MCR       Modem Control Register
  - 28h.R            LSR       Line Status Register
  - 30h.normal.R     MSR       Modem Status Register
  - 38h.normal.R/W   SPR    Scratchpad Register
  - 40h.R            TXLVL     Transmitter FIFO Level
  - 48h.R            RXLVL     Receiver FIFO Level
  - 50h.R/W          IODir     Programmable I/O pins Direction  ;\IO only on
  - 58h.R/W          IOState   Programmable I/O pins State      ; SC16IS750
  - 60h.R/W          IOIntEna  I/O Interrupt Enable Register    ; and
  - 68h              reserved  Reserved (00h)                   ; SC16IS760
  - 70h.R/W          IOControl I/O Control register             ;/
  - 78h.R/W          EFCR      Extra Features Control Register
- Special/Enhanced registers (mapped depending on LCR/MCR/EFR bits):
  - 00h.DLAB=1.R/W   DLL       Baudrate Divisor Latch Low    ;\when LCR.bit7=1
  - 08h.DLAB=1.R/W   DLH       Baudrate Divisor Latch High   ;/and LCR\<>BFh
  - 10h.LCR=BFh.R/W  EFR       Enhanced Features Register               ;\
  - 20h.LCR=BFh.R/W  XON1   Xon1 word                                   ; when
  - 28h.LCR=BFh.R/W  XON2   Xon2 word                                   ; LCR=BFh
  - 30h.LCR=BFh.R/W  XOFF1  Xoff1 word (whatever, maybe OUTGOING char?) ;
  - 38h.LCR=BFh.R/W  XOFF2  Xoff2 word (compare for INCOMING chars)     ;/
  - 30h.special.R/W  TCR       Transmission Control Register ;\when MCR.bit2=1
  - 38h.special.R/W  TLR       Trigger Level Register        ;/and EFR.bit4=1

[2] These bits in can only be modified if register bit EFR[4] is enabled.

[5] After Receive FIFO or Transmit FIFO reset (through FCR[1:0]), the user must
wait at least 2' ??? Tclk of XTAL1 before reading or writing data to RHR and
THR, respectively.

[8] IrDA mode slow/fast for SC16IS760, slow only for SC16IS750.



## IR[00h.DLAB=0.R] - RHR - Receive Holding Register (R)


The receiver section consists of the Receiver Holding Register (RHR) and the
Receiver Shift Register (RSR). The RHR is actually a 64-byte FIFO. The RSR
receives serial data from the RX pin. The data is converted to parallel data
and moved to the RHR. The receiver section is controlled by the Line Control
Register. If the FIFO is disabled, location zero of the FIFO is used to store
the characters.



## IR[00h.DLAB=0.W] - THR - Transmit Holding Register (W)


The transmitter section consists of the Transmit Holding Register (THR) and the
Transmit Shift Register (TSR). The THR is actually a 64-byte FIFO. The THR
receives data and shifts it into the TSR, where it is converted to serial data
and moved out on the TX pin. If the FIFO is disabled, the FIFO is still used to
store the byte. Characters are lost if overflow occurs.



## IR[10h.W] - FCR - FIFO Control Register (W)


```
  7-6  Trigger level for the RX FIFO (0..3 = 8,16,56,60 chars)
  5-4  Trigger level for the TX FIFO (0..3 = 8,16,32,56 spaces)
  3    Reserved
  2    TX FIFO Reset (0=No change, 1=Clear TX FIFO)
  1    RX FIFO Reset (0=No change, 1=Clear RX FIFO)
  0    RX/TX FIFO enable (0=Disable, 1=Enable)
```

Bit1,2: FIFO reset requires at least two XTAL1 clocks, therefore, they cannot
be reset without the presence of the XTAL1 clock.

Bit4-5: Can only be modified and enabled when EFR[4] is set. This is because
the transmit trigger level is regarded as an enhanced function.



## IR[18h] - LCR - Line Control Register (R/W)


```
  7    Divisor latch access enable (DLAB) (0=Normal, 1=Access DLL/DLH)
  6    Break control bit   (0=Off/Normal, 1=Break/Force TX to logic 0)
  5-4  Parity Type         (0=Odd, 1=Even, 2=Forced1, 3=Forced0)
  3    Parity Enable       (0=Disable, 1=Enable)
  2    Number of stop bits (0=1bit, 1=2bit, or 1.5bit in 5bit mode)
  1-0  Word length         (0=5bit, 1=6bit, 2=7bit, 3=8bit)
```



## IR[28h.R] - LSR - Line Status Register (R)


```
  7    FIFO data error (0=None, 1=At least one Error/Break anywhere in RX FIFO)
  6    THR and TSR empty   (0=Not empty, 1=Empty)  (TX FIFO and TX shift reg)
  5    THR empty           (0=Not empty, 1=Empty)  (TX FIFO)
  4    Break interrupt     (0=No, 1=Break, next RX FIFO char reads as 00h)
  3    Framing Error       (0=No, 1=Error; bad stop bit in data from RX FIFO)
  2    Parity Error        (0=No, 1=Error; in data being read from RX FIFO)
  1    Overrun Error       (0=No, 1=Error; overrun has occurred)
  0    Data in Receiver    (0=No, 1=At least one character in the RX FIFO)
```

Bit2-4 reflect the error bits (BI, FE, PE) of the character at the top of the
RX FIFO (next character to be read). Therefore, errors in a character are
identified by reading the LSR and then reading the RHR.



## IR[20h] - MCR - Modem Control Register (R/W)


```
  7    Clock Divisor    (0=Div1 clock input, 1=Div4 clock input)
  6    IrDA mode enable (0=Normal UART mode, 1=IrDA mode) (aka pulse RX/TX?)
  5    Xon Any function (0=Disable, 1=Enable)
  4    Enable Loopback  (0=Normal, 1=local Loopback mode, internal)
        In this mode the MCR[1:0] signals are looped back into MSR[4:5] and
        the TX output is looped back to the RX input internally.
  3    Reserved
  2    TCR/TLR register access enable (0=Disable, 1=Enable)
  1    RTS output (if Auto RTS disabled)        (0=High/Inactive, 1=Low/Active)
        In Loopback mode, controls MSR[4].
  0    DTR output (GPIO5) (if IOControl.bit1=1) (0=High/Inactive, 1=Low/Active)
        Writing to IOState bit 5 will not have any effect on this pin.
```

Bit2,5-7 can only be modified when EFR[4] is set, ie. EFR[4] is a write enable.

Bit0: Only available on SC16IS750/SC16IS760.



## IR[30h.normal.R] - MSR - Modem Status Register (R)


```
  7    CD input state (inverted, 1=Not HIGH, or so)     ;\only if modem mode
  6    RI input state (inverted, 1=Not HIGH, or so)     ; (IOControl.bit1=1)
  5    DSR input state (inverted, 1=Not HIGH, or so)    ;/
  4    CTS input state (inverted, 1=Not HIGH, or so)
  3    CD input changed state                  (0=No, 1=Yes)    ;\
  2    RI input changed state from LOW to HIGH (0=No, 1=Yes)    ; cleared
  1    DSR input changed state                 (0=No, 1=Yes)    ; on read
  0    CTS input changed state                 (0=No, 1=Yes)    ;/
```

Bit1-3,5-7: Only available on SC16IS750/SC16IS760.

Remark: The primary inputs RI, CD, CTS, DSR are all active LOW.

Reading IOState bit 6,6,4 does not reflect the true state of CD,RI,DSR pin, uh?



## IR[08h] - IER - Interrupt Enable Register (R/W)


```
  7    CTS change interrupt enable          (0=Disable, 1=Enable)
  6    RTS change interrupt enable          (0=Disable, 1=Enable)
  5    Xoff received interrupt              (0=Disable, 1=Enable)
  4    Sleep mode                           (0=Disable, 1=Sleep Mode)
  3    Modem Status Interrupt               (0=Disable, 1=Enable)
  2    Receive Line Status error interrupt  (0=Disable, 1=Enable)
  1    Transmit Holding Register interrupt  (0=Disable, 1=Enable)
  0    Receive Holding Register interrupt   (0=Disable, 1=Enable)
```

Bit4-7 can only be modified if EFR[4] is set, that is, EFR[4] is a write
enable. Re-enabling IER[1] will not cause a new interrupt if the THR is below
the threshold.

Bit3: Only available on the SC16IS750/SC16IS760.

Bit3: See IOControl.bit1 for the description of how to program the pins as
modem pins.



## IR[10h.R] - IIR - Interrupt Identification Register (R)


```
  7    Mirror of FCR.bit0: RX/TX FIFO enable (0=Disable, 1=Enable) ;\both same
  6    Mirror of FCR.bit0: RX/TX FIFO enable (0=Disable, 1=Enable) ;/
  5-1  Interrupt source (5bit encoded, see below) (valid when bit0=0)
  0    Interrupt status (0=IRQ pending, 1=No IRQ pending)
```

Interrupt sources:

```
  Src Prio Expl.
  03h 1    Receiver Line Status error
  06h 2    Receiver time-out interrupt
  02h 2    RHR interrupt
  01h 3    THR interrupt
  00h 4    MSR Modem interrupt           (SC16IS750/SC16IS760 only)
  18h 5    IOState GPIO input pin change (SC16IS750/SC16IS760 only)
  08h 6    received Xoff signal/special character
  10h 7    CTS, RTS change state from active(LOW) to inactive(HIGH)
```

Burst reads on the serial interface should not be performed on the IIR register
(ie. don't read multiple elements on the I2C-bus without a STOP or repeated
START condition, and don't read multiple elements on the SPI bus without
de-asserting the CS pin).



## IR[10h.LCR=BFh] - EFR - Enhanced Features Register (R/W)


```
  7    CTS flow control enable (0=Disable, 1=Enable; stop TX upon CTS=HIGH)
  6    RTS flow control enable (0=Disable, 1=Enable; change RTS upon TCR)
         RTS pin goes HIGH when RX FIFO halt trigger level TCR[3:0] is reached
         RTS pin goes LOW when RX FIFO resume trigger level TCR[7:4] is reached
  5    Special character detect (0=Disable, 1=Enable, compare with Xoff2)
         If a Xoff2 match occurs, the received data is transferred to FIFO and
         IIR.bit4 is set to 1 to indicate a special character has been detected
  4    Enhanced functions enable bit (0=Disable, 1=Enable)
         Enables writing to IER[7:4], FCR[5:4], MCR[7:5]
  3-0  Combinations of software flow control can be selected by programming
         these bits. See Table 3 "Software flow control options (EFR[3:0])".
```



## IR[00h.DLAB=1] - DLL - Baudrate Divisor Latch Register Low, bit0-7 (R/W)



## IR[08h.DLAB=1] - DLH - Baudrate Divisor Latch Register High, bit8-15 (R/W)


```
  15-0  16bit divisor for generation of the clock in the baudrate generator
```

Remark: DLL and DLH can only be written to before Sleep mode is enabled, that
is, before IER[4] is set.



## IR[30h.MCR[2]=1 and EFR[4]=1] - TCR - Transmission Control Register (R/W)


```
  7-4  RX FIFO flow control resume trigger level  (N*4) (0..14 = 0..56 chars)
  3-0  RX FIFO flow control halt trigger level    (N*4) (1..15 = 4..60 chars)
```

RX FIFO threshold levels to stop/start transmission during hardware/software
flow control (ie. for RTS pin, or Xon/Xoff chars).

Remark: TCR can only be written to when EFR[4]=1 and MCR[2]=1.

The programmer must program the TCR such that Halt>Resume, aka
TCR[3:0]>TCR[7:4]. There is no built-in hardware check to make sure this
condition is met.

Also, the TCR must be programmed with this condition before auto RTS or
software flow control is enabled to avoid spurious operation of the device.



## IR[38h.MCR[2]=1 and EFR[4]=1] - TLR - Trigger Level Register (R/W)


```
  7-4  RX FIFO interrupt trigger level (N*4) (1..15 = 4..60 chars available)
  3-0  TX FIFO interrupt trigger level (N*4) (1..15 = 4..60 spaces available)
```

Remark: TLR can only be written to when EFR[4]=1 and MCR[2]=1. If TLR[3:0] or
TLR[7:4] are logical 0, the selectable trigger levels via the FIFO Control
Register (FCR) are used for the transmit and receive FIFO trigger levels.
Trigger levels from 4 characters to 60 characters are available with a
granularity of four. The TLR should be programmed for N4, where N is the
desired trigger level.

When the trigger level setting in TLR is zero, the SC16IS740/750/760 uses the
trigger level setting defined in FCR. If TLR has non-zero trigger level value,
the trigger level defined in FCR is discarded. This applies to both transmit
FIFO and receive FIFO trigger level setting.

When TLR is used for RX trigger level control, FCR[7:6] should be left at the
default state, that is, '00'.



## IR[40h.R] - TXLVL - Transmitter FIFO Level register (R)


```
  7    Unused (0)
  6-0  Number of spaces available in TX FIFO (00h..40h; 00h=Full, 40h=Empty)
```



## IR[48h.R] - RXLVL - Receiver FIFO Level register (R)


```
  7    Unused (0)
  6-0  Number of characters stored in RX FIFO (00h..40h; 00h=Empty, 40h=Full)
```



## IR[50h] - IODir - Programmable I/O pins Direction register (R/W)


This register is only available on the SC16IS750 and SC16IS760.

```
  7-0  IODir set GPIO pins [7:0] to input or output (0=Input, 1=Output)
```

Remark: If there is a pending input (GPIO) interrupt and IODir is written, this
pending interrupt will be cleared, that is, the interrupt signal will be
negated.



## IR[58h] - IOState - Programmable I/O pins State Register (R/W)


```
  7-0  IOState Write this register: set the logic level on the output pins
          0=set output pin to zero
          1=set output pin to one
        Read this register: return states of all pins
```

This register is only available on the SC16IS750 and SC16IS760.

When read, this register returns the actual state of all I/O pins.

When write, each register bit will be transferred to the corresponding IO pin
programmed as output.



## IR[60h] - IOIntEna - I/O Interrupt Enable Register (R/W)


```
  7-0  Input change interrupt enable (0=Disable, 1=Enable)
```

This register is only available on the SC16IS750 and SC16IS760.

This register enables the interrupt due to a change in the I/O configured as
inputs. If GPIO[7:4] are programmed as modem pins, their interrupt generation
must be enabled via IER register bit3. In this case bit4-7  of IOIntEna will
have no effect on GPIO[7:4].



## IR[70h] - IOControl - I/O Control register (R/W)


```
  7-4  Reserved
  3    Software reset (0=No change, 1=Reset)                    (W)
  2    Reserved
  1    Use GPIO[7:4] as GPIO or as modem pins (0=GPIO, 1=RI,CD,DTR,DSR)
  0    IOLATCH enable/disable inputs latching
        0 = input values are not latched. A change in any input generates an
         interrupt. A read of the input register clears the interrupt. If the
         input goes back to its initial logic state before the input register
         is read, then the interrupt is cleared.
        1 = input values are latched. A change in the input generates an
         interrupt and the input logic value is loaded in the bit of the
         corresponding input state register (IOState). A read of the IOState
         register clears the interrupt. If the input pin goes back to its
         initial logic state before the interrupt register is read, then the
         interrupt is not cleared and the corresponding bit of the IOState
         register keeps the logic value that initiates the interrupt.
```

This register is only available on the SC16IS750 and SC16IS760.

Remark: As I/O pins, the direction, state, and interrupt of GPIO4 to GPIO7 are
controlled by the following registers: IODir, IOState, IOIntEna, and IOControl.
The state of CD, RI, DSR pins will not be reflected in MSR[7:5] or MSR[3:1],
and any change of state on these three pins will not trigger a modem status
interrupt (even if enabled via IER[3]), and the state of the DTR pin cannot be
controlled by MCR[0].

As modem CD, RI, DSR pins, the status at the input of these three pins can be
read from MSR[7:5] and MSR[3:1], and the state of DTR pin can be controlled by
MCR[0]. Also, if modem status interrupt bit is enabled, IER[3], a change of
state of RI, CD, DSR pins will trigger a modem interrupt. Bit[7:4] of the
IODir, IOState, and IOIntEna registers will not have any effect on these three
pins.



## IR[78h] - EFCR - Extra Features Control Register (R/W)


```
  7    IrDA pulse mode (0=Max115kbit/s, ratio 3/16, 1=Max1152kbit/s, ratio 1/4)
  6    Reserved
  5    Invert RTS signal in RS-485 mode (0=RTS=0 during TX, 1=RTS=1 during TX)
  4    Enable the transmitter to control the RTS pin (0=Disable, 1=Enable)
  3    Reserved
  2    Disable transmitter  (0=Normal, 1=Disable; stop forwarding THR to TSR)
        UART does not send serial data out on the transmit pin, but the
        transmit FIFO will continue to receive data from host until full.
        Any data in the TSR will be sent out before the transmitter goes into
        disable state.
  1    Disable receiver     (0=Normal, 1=Disable)
        UART will stop receiving data immediately once this bit set to 1, and
        any data in the TSR?? will be sent to the receive FIFO.
        User is advised not to set this bit during receiving.
  0    Enable 9bit or Multidrop mode  (0=Normal RS-232, 1=Enable RS-485)
```

Bit7 is SC16IS760 only.


```
 ____________________________ Infrared IrDA Notes ____________________________
```



## Infrared Usage in 3DS


The 3DS doesn't have any expansion connector, and it's instead using the IrDA
port for expansion hardware (with external batteries):

- - Circle Pad Pro (a second Circle Pad, attached right of the A/B/X/Y buttons)
- - NFC Near-field communication (for Amiibo figures)

For the NFC thing, see here:

- [3DS NFC Adapter](#3dsnfcadapter)
That add-on hardware exists for Old3DS only. The New3DS does have equivalent
hardware built-in, and thus doesn't need that add-ons.

The IrDA port could theoretically communicate with old NDS pedometers (Activity
Meter and P-Walker), there isn't any known 3DS software supporting that though
(and the 3DS has its own pedometer built-in anyways, although it's a bit clumsy
to carry the whole console).

Additionally, IrDA could be reportedly used for things like file transfers,
unknown if there are 3DS tools supporting such things?



## Infrared Signals


The SC16IS750 UART/IrDA SIR datasheet does mainly describe the UART part, and
barely mentions infrared at all (apart from saying that the chip is IrDA SIR
compatible, and that IrDA can be enabled in MCR.bit6).

Going by other sources, IrDA SIR works like "UART over infrared". In lack of
further details, here some guesses on how it might work (and how far it is (or
isn't) compatible with regular cable-based UARTs):

- - RX/TX are probably using pulsed signals instead of constant LOW/HIGH levels?
- - RTS/CTS/DTR/DSR are probably not implemented at all?
- - Simultaneous RX+TX might work in opposite light-direction, if no reflection?
- - Infrared interruptions and noise may require additional error checking?
- - Infrared at less than 10mm (as in Circle Pad Pro) may work 100% error-free?



## Infrared Protocol


Specifications for the IrDA standard aren't available for free, and there's
little known about the protocol:

- - IrDA protocol supports file transfers from one device to another
- - IrDA protocol must include some sort of packet headers and checksums
- - And probably much stuff

However, it's unknown if Nintendo did bother to follow the IrDA standard in
their Circle Pad Pro and NFC add-ons. It's also possible that they have just
used a custom UART-like transfer protocol for that hardware.



## Infrared Range


IrDA is supposed for short-range transfers (about 20cm - 100cm) in binary
format. As such, it isn't intended to use the hardware for things like classic
TV remote controls (although... maybe it could be tweaked to output TV remote
signals on TX pin... possibly in UART mode with IrDA disabled?).




# <a name="3dsi2clcdscreencontrollers"></a>3DS I2C LCD Screen Controllers




## I2C Bus/Device 1:2Ch - Upper LCD screen (lcd0)



## I2C Bus/Device 1:2Eh - Lower LCD screen (lcd1)


LCD controllers for top/bottom screen.



## I2C Access


I2C writing works as for most other I2C chips:

```
  I2cWriteCmd (Device+0, Index, Data)
```

However, I2C reading works uncommon:

```
  I2cWriteCmd (Device+0, 40h, ReadIndex)
  I2cReadCmd  (Device+1, ReadIndex, Data)
```

Ie. the LCD chips distinguish between WriteIndex and ReadIndex, with the
ReadIndex being set by writing to register 40h. The ReadIndex value in the
response can be ignored (or verified to be same as the written ReadIndex
value).



## I2C Registers


```
  00h      Zero                                                        (-)
  01h      Display on/off (10h=Display on, 11h=Display black) ;bit0,4 is R/W
  02h      Usually 01h, but bit0 is R/W
  03h      Usually 00h, but bit0-7 is R/W
  04h..10h Zero                                                        (-)
  11h      Whatever (set to 10h during init, maybe bit4=reset?)
  12h..3Fh Zero                                                        (-)
  40h      Read Index for I2C read (00h..FFh)
  41h..4Fh Zero                                                        (-)
  50h      Bit0 is R/W  (set to 1 for top-screen; left 0 on bottom-screen)
  51h..53h Zero                                                        (-)
  54h      Usually 00h, but bit0 is R/W
  55h      Usually 00h, but bit0-1 is R/W
  56h..5Fh Zero                                                        (-)
  60h      Whatever (set to 00h during init)  ;bit0 is R/W ?
  61h      Status (initially B4h=Top Screen, F8h=Bottom Screen)        (R?)
  62h      Status (01h=Ready)  (except, broken top screen reads 00h?)  (R?)
  63h      Zero                                                        (-)
  64h      Whatever/Fixed 03h                                          (R)
  65h..AEh Zero                                                        (-)
  AFh      Usually 00h, but bit0-7 is R/W
  B0h..D3h Zero                                                        (-)
  D4h      Usually 00h, but lower 4bit are R/W
  D5h      Usually 00h, but bit0-7 is R/W
  D6h..FDh Zero                                                        (-)
  FEh      Usually 00h, but bit0-7 is R/W
  FFh      Maybe Chip ID (10h=Top Screen, C7h=Bottom Screen)           (R)
```

Odd effect observed during testing: Setting LCD[AFh]=AAh causes MANY more
registers to become nonzero; this doesn't happen for other values like
LCD[AFh]=0Fh,F0h,FFh.



## bootrom error screen init sequence for the I2C registers:


```
  LCD[11h]=10h     ;whatever
  LCD[50h]=01h     ;whatever, this one done for TOP screen only
  LCD[60h]=00h     ;whatever
  LCD[01h]=10h/11h ;on/off (10h=display on, 11h=display black)
```

The bootrom additionally checks if status LCD[62h]=01h=Ready.




# <a name="3dsi2cnew3dsnearfieldcommunicationnfc"></a>3DS I2C New3DS Near-Field Communication (NFC)




## I2C Bus/Device 1:EEh - Near-Field Communication (NFC) (New3DS-only)


This device is transferring command/response packets on the I2C bus (so one
must only transfer Device+Data bytes; without any register Index values).



## Datasheets and Specs


The NFC controller appears to be a 32pin Broadcom BCM20791 chip, there is no
datasheet for that chip, however, a datasheet for 34pin BCM20793S chip does
exist, but unfortunately without any specs on the transfer protocol.

Specifications for the lower-level transfer protocol (and maybe even the I2C
bus protocol?) are made by the "NFC Forum" (a non-profit organization that
charges lots of money for a copy of those specs).

There is some android open source code for "bcm2079x" available.



## New3DS Transfer Protocol...


Command request / response structure:

```
  00h 1     Normally 10h?
  01h 1     Command source / destination
  02h 1     CmdID
  03h 1     Payload size (LEN)
  04h LEN   Data/parameters
```


The command response payload is usually at least 1-byte, where that byte
appears to be normally 00h. For command requests the payload data is the
command parameters.


For command requests sent to the NFC tag itself, Cmd[1]=0x0 and CmdID=0x0. The
command request payload data here is the actual command request data for the
NFC tag, starting with the CmdID u8 at payload+0.


During NFC module startup, a certain command (?) is sent to the controller
which eventually (after various cmd-reply headers etc) returns the following
after the first byte in the payload:

```
  000000: 44 65 63 20 32 32 20 32 30 31 32 31 34 3a 35 33  Dec 22 201214:53
  000010: 3a 35 30 01 05 0d 46 05 1b 79 20 07 32 30 37 39  :50...F..y .2079
  000020: 31 42 35                                         1B5
```

Or that is: "Dec 22 201214:53:50\<binary>20791B5". Therefore, this appears
to return the part-number of the NFC controller (other command request(s) /
response(s) use this part-number value too).

Actually, 20791B5 seems to be NFC certification number for an unspecified
Broadcom product (or possibly 20791B5 is the product name itself... yes,
apparently it's Broadcom BCM20791).

Protocol = NFC Forum NFC Controller Interface (NCI) for host interface



## NFC controller commands


```
  CmdRequest[1, uh?]  CmdID   Payload data for parameters
  2Eh                 2Fh     Firmware image for this chunk, size varies.
```

This is used during NFC module startup to upload the firmware image to the NFC
controller. This is used repeatedly to upload multiple chunks of the image.



## Power-up


After power-up, the NFC chip automatically sends these bytes upon I2C reads:

```
  10 60 00 02 00 01     ;followed by endless FF bytes
```

That seems to be a 4-byte header, with 2-byte data, as indicated in hdr[3]=02h.



## NFC Interrupt


Triggers when there is data available for reading. Unknown if there is also a
way for determining if the thing is ready for writing a new command... maybe
one should simply wait for a response packet after sending any command packets?



## Old3DS Version


The Old3DS did have an external NFC Adapter add-on, accessed via IrDA.

- [3DS NFC Adapter](#3dsnfcadapter)
The 3DS OS is supposedly having backwards/forwards compatible NFC functions,
but the underlying transfer protocol seems to be completely different (relying
on IrDA to communicate with the adpater firmare, instead of directly accessing
the BCM20791 chip).




# <a name="3dsnfcadapter"></a>3DS NFC Adapter



The Nintendo NFC adapter, formally Nintendo NFC Reader/Writer and codenamed
Fangate, is an external device which adds NFC capabilities for amiibos to old
Nintendo 3DS and Nintendo 2DS consoles, using the infrared port on the back of
the console.


It launched simultaneously with Animal Crossing Happy Home Designer, with which
it's optionally bundled; it can also be bought standalone at a nominal(?) price
of 21 EUR.



## Technical details


Based on analysis of the fangate\_updater.bin file, which is part of the old
Nintendo 3DS operating system since 9.3.0-21 and contains the firmware running
on the external adapter; and analysis of the NFC Services running on old 3DS.

```
  SOC inside the adapter: Broadcom BCM20791B1
                          or ST proprietary "MCU-FGT/rev.A/GH24S VQ"
                            uh, either or? or rather both?
                            is that guessed from fangate_updater.bin,
                            or seen on photos of the actual pcb/hardware?
  CPU:            ARM Cortex M0
```


Memory map:

```
  Address    Size    Description
  08008000h  256KB?  Firmware (fangate_updater.bin)
  20000000h  128KB?  RAM
  40023C00h  1Ch     FLASH ROM control
  E000ED00h  104h    ARM Cortex system control block
```



## Layer 1 - IR communications framing format


Packets are sent using IrDA-SIR (using ir:USER) at 115200 bps 8N1 (eight data
bits, no parity, one stop bit).

- IR framing format - short frame (max 3Fh data bytes):
  - 00h   1  Synchronization byte (A5h)
  - 01h   1  Reserved for future use (00h)
  - 02h   1  bit7:RFU (0), bit6:Short frame (0), bit0-5:Payload size
  - 03h   N  Payload
  - 03h+N 1  CRC-8-CCITT for whole packet [00h..N+02h]  ;uh, before/after XORing?
- IR framing format - long frame (max 3FFFh data bytes):
  - 00h   1  Synchronization byte (A5h)
  - 01h   1  Reserved for future use (???)
  - 02h   1  bit7:RFU (0), bit6:Long frame (1), bit0-5: Payload size upper bits
  - 03h   1  Payload size (lower 8 bits)
  - 04h   N  Payload (XOR-encrypted)
  - 04h+N 1  CRC-8-CCITT for whole packet [00h..N+03h]  ;uh, before/after XORing?

The payload is encrypted using a XOR-based encryption:

```
    halfCount = size/2          ;Divide by 2 rounding towards zero
    xorval = htobe16(0xE963)    ;that is, BIG-ENDIAN ?
    for (i = 0; i < halfCount; i++)
      xorval = xorval XOR = src[i]
      dst[i] = xorval
```



## Layer 2 - "ircom"


ircom is a simple stateful point-to-point master-slave communication protocol
built on top of IR layer 1.

```
  00h 4   Random (makes the whole packet look random after XOR encryption)
  04h 1   bit4-7:RFU?, bit0-3:Protocol version (01h)
  05h 1   Connection ID of master (3DS), value determined by master
  06h 1   Connection ID of slave (NFC adapter), value determined by slave
  07h 1   bit4-7:???, bit0-3: Operation code
  08h N-8 Payload (if any)
```

Operation codes:

```
  Code  Name                          Has payload     Direction
  00h = Layer 3 command               Yes             Master to slave
  01h = ???
  02h = ???
  03h = ???
  04h = ???
  05h = ???
  06h = ???
  07h = ???
  08h = ???
  09h = ???
  0Ah = Disconnect request            No              Master to slave
  0Bh = Disconnection acknowledgment  No              Slave to master
  0Ch = Handshake                     No              Master to slave
  0Dh = Handshake acknowledgement     No              Slave to master
  0Eh = ???
  0Fh = ???
```

NFC adapter will ignore packets whose protocol version is not 1. It will not
even reply.

Connection identifier is a random byte the 3DS assigns to identify the
connection should there be several connections in range at once. Slave devices
must save this value from the initial handshake packet and use it for replies.
The 3DS will also save the connection identifier byte of the slave which is
also random. The 3DS must also ignore packets whose connection ID does not
match.



## Layer 3


Layer 3 is the payload of layer 2. A lot is unknown of this layer and thus a
lot of assumptions were made in the following tables.


Layer 3 contains the following data:

```
  00h    bit4-7:Request identifier nibble, bit0-3: Always 01h
  01h    Slave/master identifier byte
  02h    Request type code upper byte
  03h    Request type code lower byte
  04h+   Payload (if any)
```


Request identifier nibble is incremented by 0x1 at every new request by the
master, the same value for this byte is also sent by the slave in response to
the request of the master

Slave/master identifier byte is 0x1 for a message from the master and 0x10 for
a message from the slave



## Request type codes


```
  Code    Request description                           Direction   Has payload
  0000h = ACK                                           Slave to master  Yes
  0003h = Get firmware version and battery level        Master to slave  No
  0004h = Firmware version and battery level            Slave to master  Yes
  0100h = Unknown, slave always responds with ACK       Master to slave  Yes
  0202h = Request to stop communication with NFC tag    Master to slave  No
  0204h = Get dumped data from NFC tag                  Master to slave  No
  0205h = Data from NFC tag                             Slave to master  Yes
  0206h = Request to start communication with NFC tag   Master to slave  Yes
  0207h = Request to write data to NFC tag              Master to slave  Yes
```



## 0000h


Acknowledgement message always send by slave. Payload always contains
000000AAh.



## 0004h


Payload contains firmware version and battery level of NFC adapter. Payload has
a size of 6 bytes.

```
  00h    Upper or lower byte of version number, newest firmware is 01h
  01h    Upper or lower byte of version number, newest firmware is 06h
  02h    Padding byte? Always 00h
  03h    Padding byte? Always 00h
  04h    Battery level (03h=Full, 00h=Empty)
  05h    Padding byte? Always 00h
```

NFC reader LED already turns red when the battery level byte is 02h, this will
also trigger a low battery level warning on the 3DS.



## 0100h


The purpose of this request by the master is unknown. Slave always responds
with ACK. Payload of this request is always 0003E8AAh.



## 0205h


Payload contains data regarding NFC communication. The first byte of the
payload means the following:

```
  Code   Description
  00h =  NFC communication is stopped as result of a 0202h request from master
  01h =  No NFC tag on top of the reader
  02h =  Busy dumping NFC tag
  03h =  NFC tag dump after write by master
  04h =  NFC tag fully dumped
  05h =  NFC tag dump after write by master
  07h =  NFC tag not a NTAG215 or contains no Amiibo compatible data
  08h =  NFC tag removed from reader
```

After the tag is written by the master and dumped again, the first few dumps
start with 03h, this changes to 05h after a few dumps. The reason for this is
unknown.



## 0206h


Request from master to start NFC communication. Payload always contains 19 00h
padding bytes, followed by C80300393A737486000001h and another 26 00h padding
bytes.



## 0207h


Request from master to write to NFC tag. The request packet already contains
the desired data to be written to the tag. Payload start with two 00h padding
bytes followed by the 7 ID bytes of the tag. These ID bytes are used by the NFC
adapter to check if same Amiibo is placed on the NFC adapter again.



## Samples


NFC handshake beacons:

```
  Layer 1 packet                          Layer 2 packet       Layer 3 packet
  A5 00 08 73 FE A5 C4 A4 2C A4 20 F5     9A 9D D6 3A 01 E8 00 0C         ?
  A5 00 08 D1 3E B7 7B B6 91 B6 9D 87     38 5D 66 45 01 EA 00 0C         ?
  A5 00 08 09 58 23 36 22 DA 22 D6 AE     E0 3B 2A 6E 01 EC 00 0C         ?
  A5 00 08 5E DD A4 A0 A5 4E A5 42 A8     B7 BE FA 7D 01 EE 00 0C         ?
  A5 00 08 BC 19 C6 37 C7 C7 C7 CB 8B     55 7A 7A 2E 01 F0 00 0C         ?
  A5 00 08 C9 15 F6 63 F7 91 F7 9D B2     20 76 3F 76 01 F2 00 0C         ?
  A5 00 08 6E 48 47 1A 46 EE 46 E2 C7     87 2B 29 52 01 F4 00 0C         ?
  A5 00 08 A2 8C E5 C3 E4 35 E4 39 74     4B EF 47 4F 01 F6 00 0C         ?
  A5 00 08 26 1C 07 10 06 E8 06 E4 64     CF 7F 21 0C 01 F8 00 0C         ?
  A5 00 08 7E 73 A2 3F A3 C5 A3 C9 FD     97 10 DC 4C 01 FA 00 0C         ?
  A5 00 08 75 00 F3 B8 F2 44 F2 48 63     9C 63 86 B8 01 FC 00 0C         ?
  A5 00 08 8D AC 0F D5 0E 2B 0E 27 72     64 CF 82 79 01 FE 00 0C         ?
  A5 00 08 A3 55 7C 53 7D 52 7D 5E B2     4A 36 DF 06 01 01 00 0C         ?
  A5 00 08 15 06 43 C0 42 C3 42 CF 85     FC 65 56 C6 01 03 00 0C         ?
  A5 00 08 66 E0 9A 17 9B 12 9B 1E A0     8F 83 FC F7 01 05 00 0C         ?
  A5 00 08 A4 35 09 97 08 90 08 9C 25     4D 56 AD A2 01 07 00 0C         ?
  A5 00 08 73 E2 BD AF BC A6 BC AA 60     9A 81 CE 4D 01 09 00 0C         ?
  A5 00 08 02 57 D7 B0 D6 BB D6 B7 28     EB 34 D5 E7 01 0B 00 0C         ?
  A5 00 08 0D 79 01 AA 00 A7 00 AB 22     E4 1A 0C D3 01 0D 00 0C         ?
  A5 00 08 14 91 04 B9 05 B6 05 BA B2     FD F2 10 28 01 0F 00 0C         ?
  A5 00 08 2C 86 B1 49 B0 58 B0 54 C0     C5 E5 9D CF 01 11 00 0C         ?
  A5 00 08 D5 1D DE DB DF C8 DF C4 F9     3C 7E 0B C6 01 13 00 0C         ?
  A5 00 08 AF 75 DE 5C DF 49 DF 45 9C     46 16 71 29 01 15 00 0C         ?
  A5 00 08 C8 E2 5B C6 5A D1 5A DD B5     21 81 93 24 01 17 00 0C         ?
  A5 00 08 9B 51 68 2D 69 34 69 38 41     72 32 F3 7C 01 19 00 0C         ?
  A5 00 08 13 7B 9F EF 9E F4 9E F8 32     FA 18 8C 94 01 1B 00 0C         ?
  A5 00 08 A7 62 02 9C 03 81 03 8D BD     4E 01 A5 FE 01 1D 00 0C         ?
  A5 00 08 39 06 94 36 95 29 95 25 09     D0 65 AD 30 01 1F 00 0C         ?
  A5 00 08 32 4C D7 C0 D6 E1 D6 ED 92     DB 2F E5 8C 01 21 00 0C         ?
  A5 00 08 83 BE F2 8F F3 AC F3 A0 B1     6A DD 71 31 01 23 00 0C         ?
  A5 00 08 83 5E A0 57 A1 72 A1 7E F0     6A 3D 23 09 01 25 00 0C         ?
  A5 00 08 6E C8 AD 69 AC 4E AC 42 D1     87 AB C3 A1 01 27 00 0C         ?
  A5 00 08 C7 33 A1 2C A0 05 A0 09 FC     2E 50 66 1F 01 29 00 0C         ?
```



## External links


BCM2079x brief on Broadcom's website

Python scripts to sniff and spoof IR communication between the NFC reader and
3DS using an IrDA adapter




# <a name="3dsi2cnew3dscstickandzlzrbuttons"></a>3DS I2C New3DS C-Stick and ZL/ZR-Buttons




## I2C Bus/Device 2:54h - C-Stick and ZL/ZR-Buttons


This is a New3DS-only device (the Old3DS does have a similar add-on: Circle Pad
Pro, connected to the infrared expansion port).

Oberseve that the bootrom doesn't initialized I2C\_BUS2\_CNTEX/SCL (especially
CNTEX is required to have "Wait if SCL held low" enabled, else the C-stick
replies are garbage).

The chip triggers ARM11 IRQ 68h (aka GPIO\_DATA3.bit0=0) when moving the analog
input or buttons. Reading the I2C data changes GPIO back to bit0=1.

Maybe this is the HUGE 44pin HF374 chip on button board, but if it's merely
used for ZL/ZR and C-stick, why is that chip so huge?



## I2C Read(Device+1,Byte0,Byte1,Byte2,Byte3,...)


Reading returns some kind of array, always starting with the status value in
byte0, there is no need to write an index value before reading.

The array has useful info stored in first 4-7 bytes; and internal/garbage when
reading further bytes, up to including something that looks like a CPU stack).

- The array entries are...
  - 00h       Status byte (80h..83h, or FFh) (power-up default=80h)
  - 01h       Button byte (00h=None, bit2=ZL, ?=ZR)
  - 02h       Analog X (00h=Center, -1xh=Left, +1xh=Right) ;\if enabled
  - 03h       Analog Y (00h=Center, -1xh=Down, +1xh=Up)    ;/
- Following bytes aren't needed, except for better 8bit X/Y resolution...
  - 04h       Fixed FFh
  - 05h       Analog X (00h=Center, -7xh=Left, +7xh=Right) ;\hires
  - 06h       Analog Y (00h=Center, -7xh=Down, +7xh=Up)    ;/
- Following bytes aren't actually useful...
  - 07h       Fixed 00h
  - 08h       Analog X (7xh=Center, FEh=Left, 00h=Right)   ;\unsigned/uncentered
  - 09h       Analog Y (7xh=Center, FEh=Down, 00h=Up)      ;/
  - 0Ah       Fixed 00h
  - 0Bh       Analog X (7xh=Center, FEh=Left, 00h=Right)   ;\same as [08h,09h]
  - 0Ch       Analog Y (7xh=Center, FEh=Down, 00h=Up)      ;/
  - 0Dh       Fixed 00h
  - 0Eh       Center X (7xh)  ;\auto-calibrating, with minor changes
  - 0Fh       Center Y (7xh)  ;/every some seconds
  - 10h       Fixed 00h
  - 11h..15h  Analog stuff
  - 16h       Flag (00h=Idle, 80h=Analog is/was recently touched)
  - 17h       Analog stuff
  - 18h       Flag (01h=Idle, 02h=Analog is/was recently left or down)
  - 19h       Analog stuff
- Following bytes can crash the chip upon reading (see below for details):
  - 1Ah       Flag (01h=Idle, 00h/02h=Analog is/was recently somehow moved)
  - 1Bh       Fixed 01h
  - 1Ch       Fixed 11h
  - 1Dh       Historic X (7xh)  ;\updated every some seconds
  - 1Eh       Historic Y (7xh)  ;/(same as center when idle)
  - 1Fh..27h  Fixed 00h-filled
  - 28h..2Ch  Fixed 07h,06h,06h,03h,01h
  - 2Dh..3Bh  Fixed 00h-filled
  - 3Ch       Fixed 01h
  - 3Dh..46h  Fixed 00h-filled
  - 47h..4Bh  Fixed 04h,C0h,00h,00h,03h
  - 4Ch       Whatever, changes
  - 4Dh       Flag (00h=Idle, 01h=Analog is/was recently moved)
  - 4Eh..54h  Fixed 01h,00h,06h,01h,A5h,00h,00h
  - 55h       Initially random xxh, becomes 00h/01h after button/analog
  - 56h       Flag 00h/10h/20h
  - 57h       Analog X (00h=Center, -1xh=Left, +1xh=Right) ;\same as [02h,03h]
  - 58h       Analog Y (00h=Center, -1xh=Down, +1xh=Up)    ;/
  - 59h       Analog
  - 5Ah       Analog
  - 5Bh..65h  Fixed 07h,00h,08h,04h,00h,00h,00h,09h,22h,71h,00h
  - 66h       Fast Timer (00h..1xh or so)
  - 67h       Fixed 15h ;maybe update period in ms, maybe limit for above timer?
  - 68h       Slow Timer (00h..08h, increasing)
  - 69h..6Ch  Fixed 09h,03h,00h,00h         ;maybe 09h is limit for above timer?
  - 6Dh       Up/down Timer (00h=Idle, increases-then-decreases upon analog move)
  - 6Eh..6Fh  Fixed 00h,00h
  - 70h       Button byte (00h=None, bit4=ZL, ?=ZR)
  - 71h       Usually 00h (sometimes shortly 10h or so)
  - 72h..74h  Fixed 00h-filled
  - 75h       Fixed FFh
  - 76h..7Bh  Fixed 00h-filled
  - 7Ch..82h  Fixed 7Fh,15h,09h,03h,54h,28h,10h
  - 83h..BDh  Fixed 00h-filled
- Following bytes might be CPU stack, first some bytes maybe random/garbage?
  - BEh       7Ah,02h,1Dh,D9h,C7h,93h,31h,CCh,7Eh,A9h,BEh,86h,B3h,93h,6Dh,07h
  - CEh       C7h,82h,E7h,00h,10h,00h,00h,10h,00h,10h,00h,10h,xxh,xxh,xxh,xxh
  - DEh       xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh,xxh
- Following bytes seem to be used...
  - EEh..xxxx Fixed FFh-filled (somewhat endless repeating)

Caution: The chip hangs after some seconds when reading more than 1Ah bytes; at
that point all values get frozen (except, the "stack" at DDh..EDh does keep
changing).



## I2C Write(Device,Mode)


Writing does set a mode value, eg. write(Device,Mode). There is no need to
write anything, the analog input and irq are automatically enabled on power-up.
Effects for different mode values are:

```
  None      Default is Status=80h at power-up
  00h..51h  Set Status=80h
  52h..F4h  Set Status=81h
  F5h       Set Status=82h
  F6h..F9h  Set Status=83h
  FAh..FBh  Set Status=81h
  FCh..FDh  Set Status=FFh
  FEh       Set Status=80h with long 1 second I2C-clk-hold delay?
  FFh       Set Status=80h
```

Unknown what those mode/status values are meaning exactly. Maybe some can
change polling interval or enable/disable interrupts, or maybe even do
dangerous stuff like reflashing the firmware?

Some of the mode values disable the Analog bytes at index 02h/03h (causing that
bytes to become always 00h, or maybe actually divide them by a large value,
causing them to be always NEAR 00h?)

Trying to write more bytes (eg. write(Device,xx,yy) seems to apply the last
written byte as mode value.



## Operating System


The 3DS OS does access the C-stick via IR:RST service (probably for backwards
compatibility with Circle Pad Pro, which was accessed via infrared).

The OS can reportedly change the update period in range of 10..21ms (aka
0Ah..15h), maybe via whatever I2C write.

The OS does reportedly return analog values in range -9Ch..+9Ch, maybe that are
the I2C values scaled for Circle Pad Pro compatibility, or maybe a sum of
multiple I2C values?




# <a name="3dsi2cnew3ds16bitioexpanderakaqtm"></a>3DS I2C New3DS 16bit IO Expander (aka QTM)




## TCA6416A 16bit IO Expander I2C Registers (I2C Bus/Device: 0:40h)


```
  00h Input Port 0                    (R) (reset: var, reads as 05h on New3DS)
  01h Input Port 1                    (R) (reset: var, reads as 00h on New3DS)
  02h Output Port 0                   (R/W) (reset: FFh)
  03h Output Port 1                   (R/W) (reset: FFh)
  04h Input Polarity Inversion 0      (R/W) (reset: 00h=normal)
  05h Input Polarity Inversion 1      (R/W) (reset: 00h=normal)
  06h Configuration (aka Direction) 0 (R/W) (reset: FFh=input)
  07h Configuration (aka Direction) 1 (R/W) (reset: FFh=input)
  08h..FFh Reserved                   (-)   (FFh's)
```



## Port Usage in New3DS


Unknown. The IO Expander chip is close to the top-screen connectors, as such it
does probably connect to components in the top-screen unit (which might include
upper camera; or reportedly-existing head-tracking related stuff).

Unknown how a 16bit IO could do head-tracking, maybe it does opposite: receive
the tracking RESULT from ARM side, and then OUTPUT something to parallax
barrier?

Unknown if this can be reverse-engineered by people with broken top-screen
connectors. Note: Below "usually set/cleared" assumes that the connector for
upper backlight is broken, unknown if an intact console behaves the same.

```
  P0.0  Unknown (usually set)  ;DANGER: power-off when set to Output/Low
  P0.1  Unknown (usually 0)
  P0.2  Unknown (usually set)  ;DANGER: power-off when set to Output/Low
  P0.3  Unknown (usually 0)
  P0.4  Unknown (usually 0)
  P0.5  Unknown (usually 0)
  P0.6  Unknown (usually 0)
  P0.7  Unknown (usually 0)
  P1.0  Unknown (usually 0)
  P1.1  Unknown (usually 0)
  P1.2  Unknown (usually 0)
  P1.3  Unknown (usually 0)
  P1.4  Unknown (usually 0)
  P1.5  Unknown (usually 0)
  P1.6  Unknown (usually 0)
  P1.7  Unknown (usually 0)
```



## 00h - Input Port 0 (reset: var, reads as 05h on New3DS) (R)



## 01h - Input Port 1 (reset: var, reads as 00h on New3DS) (R)


```
  0-7  Input level (0=Low, 1=High; or vice-versa when using Polarity Inversion)
```



## 02h - Output Port 0 (reset: FFh) (R/W)



## 03h - Output Port 1 (reset: FFh) (R/W)


```
  0-7  Output level (0=Low, 1=High) (no effect if direction is Input)
```



## 04h - Polarity Inversion 0 (reset: 00h) (R/W)



## 05h - Polarity Inversion 1 (reset: 00h) (R/W)


```
  0-7  Polarity of Inputs (0=Normal, 1=Invert)
```



## 06h - Configuration 0 (reset: FFh) (R/W)



## 07h - Configuration 1 (reset: FFh) (R/W)


```
  0-7  Direction (0=Output, 1=Input)
```



## Interrupt Pin


The IO Expander can trigger interrupts on any changes on any input pins.
Unknown if the Interrupt signal is connected in New3DS.




# <a name="3dsi2cotherunuseddebugdevices"></a>3DS I2C Other/Unused/Debug Devices




## Device 7 (Bus/device 1:40h) "i2c::DEB" Debug?



## Device 8 (Bus/device 1:44h) "i2c::DEB" Debug?


Unknown.



## Device 9 (Bus/device 2:A6h/D6h) "i2c::HID" Debug??


Unknown.

Device Address changed from A6h to D6h in 8.0.0-18.



## Device 12 (Bus/device 2:A4h) "DebugPad"


```
  Register   Width   Description
  00h        21      DebugPad state.
```

This is the DebugPad device, see here.



## Device 14 (Bus/device 2:A0h) "eeprom?"


Used by Cfg-sysmodule via the i2c::EEP service. This is presumably EEPROM going
by the service name.

The Cfg-module code which loads the CCAL (nandro:/sys/{HWCAL0.dat/HWCAL1.dat})
file from NAND will load it from I2C instead, if a certain state flag is
non-zero. Likewise for the function which writes CCAL to NAND. HMAC/hash
verification after loading is skipped when the CCAL was loaded from I2C.



## Bus/device 0:00h-0Eh - Mirrors to BPTWL for whatever reason



## Bus/device 0:F0h-FEh - Mirrors to BPTWL for whatever reason


These are special broadcast/reserved device ids (defined in I2C protocol). The
MCU chip apparently includes a hardware feature for decoding these IDs; and
accidentally mirrors the BPTWL registers to them.



## Bus/device 2:00h - Unknown, something responds here with ACK and FFh's


This is a special broadcast address (defined in I2C protocol). One (or more) of
the devices on I2C Bus 2 do apparently respond to it... and perhaps even
support some broadcast commands?




# <a name="3dsvideo"></a>3DS Video




## LCD Registers


These registers are used to configure the LCD screens.

- [3DS Video LCD Registers](#3dsvideolcdregisters)
Moreover, each screen is having an I2C-bus controller for further
configuration.

- [3DS I2C LCD Screen Controllers](#3dsi2clcdscreencontrollers)
And, the MCU has several LCD/backlight enable flags... and a GPU flag?



## GPU Memory and I/O Map


- [3DS GPU Memory and I/O Map](#3dsgpumemoryandiomap)
- [3DS GPU External Register List Summary](#3dsgpuexternalregisterlistsummary)
- [3DS GPU Internal Register List Summary](#3dsgpuinternalregisterlistsummary)


## GPU External Registers (for memory transfers, and framebuf to LCD output)


- [3DS GPU External Registers - Memory Control/Status Registers](#3dsgpuexternalregistersmemorycontrolstatusregisters)
- [3DS GPU External Registers - Top/Bottom Screen and Framebuffer Setup](#3dsgpuexternalregisterstopbottomscreenandframebuffersetup)
- [3DS GPU External Registers - Memfill and Memcopy](#3dsgpuexternalregistersmemfillandmemcopy)


## GPU Internal Registers (PICA200) (for drawing polygons to colorbuf/depthbuf)


- [3DS GPU Internal Register Overview](#3dsgpuinternalregisteroverview)
- [3DS GPU Internal Registers - Command Lists](#3dsgpuinternalregisterscommandlists)
- [3DS GPU Internal Registers - Finalize Interrupt registers](#3dsgpuinternalregistersfinalizeinterruptregisters)
- [3DS GPU Internal Registers - Geometry Pipeline registers](#3dsgpuinternalregistersgeometrypipelineregisters)
- [3DS GPU Internal Registers - Shader registers](#3dsgpuinternalregistersshaderregisters)
- [3DS GPU Internal Registers - Rasterizer registers](#3dsgpuinternalregistersrasterizerregisters)
- [3DS GPU Internal Registers - Framebuffer registers](#3dsgpuinternalregistersframebufferregisters)
- [3DS GPU Internal Registers - Texturing registers (Generic Textures)](#3dsgpuinternalregisterstexturingregistersgenerictextures)
- [3DS GPU Internal Registers - Texturing registers (Procedural Texture)](#3dsgpuinternalregisterstexturingregistersproceduraltexture)
- [3DS GPU Internal Registers - Texturing registers (Environment)](#3dsgpuinternalregisterstexturingregistersenvironment)
- [3DS GPU Internal Registers - Fragment Lighting registers](#3dsgpuinternalregistersfragmentlightingregisters)
- [3DS GPU Internal Registers - Unknown/Unused/Undocumented Registers](#3dsgpuinternalregistersunknownunusedundocumentedregisters)
- [3DS GPU Shader Instruction Set - Opcode Summary](#3dsgpushaderinstructionsetopcodesummary)
- [3DS GPU Shader Instruction Set - Blurp](#3dsgpushaderinstructionsetblurp)
Misc notes...

- [3DS GPU Geometry Pipeline](#3dsgpugeometrypipeline)
- [3DS GPU Fragment Lighting](#3dsgpufragmentlighting)
- [3DS GPU Pitfalls](#3dsgpupitfalls)
- [3DS GPU Primitive Engine and Shaders](#3dsgpuprimitiveengineandshaders)
There is also some 3DS GPU open source driver called citro3d, but it's mostly
higher level stuff and would require a lot of reverse engineering to extract to
lower level functionality from it.



## Sample Code


- [3DS GPU Triangle Drawing Sample Code](#3dsgputriangledrawingsamplecode)


## Camera and Video Data Conversion


- [3DS Video CAM Registers (Camera Input)](#3dsvideocamregisterscamerainput)
- [3DS Video Y2R Registers (YUV-to-RGBA Converter)](#3dsvideoy2rregistersyuvtorgbaconverter)
- [3DS Video L2B Registers (RGB-to-RGBA Converter) (New3DS)](#3dsvideol2bregistersrgbtorgbaconverternew3ds)
- [3DS Video MVD Registers (Movie Decoder or so?) (New3DS)](#3dsvideomvdregistersmoviedecoderorsonew3ds)
- [3DS Video LGY Registers (Legacy GBA/NDS Video to Framebuffer)](#3dsvideolgyregisterslegacygbandsvideotoframebuffer)



# <a name="3dsvideolcdregisters"></a>3DS Video LCD Registers



This seems to be an interface between GPU video output and actual LCD screens.
The registers allow to control backlight brightness and to set a forced blank
color. Some other registers seem to be also affect backlight brightness (or
pixel brightness?); and maybe some do affect internal voltages or internal
backlight PWM timings?


The bootrom error screen initializes only a few of these registers (and leaves
the others at their power-up defaults). Many of the uninitialized registers
seem to have no effect on the visible picture, even when setting/clearing all
bits; some of them affect the brightness of the pixels or backlight (but only
if CtrlFlags.bit0=1).



## General LCD Control Registers (ARM11 only)


```
  Physical  Size R/W       Name
  10202000h 4    00070007h reportedly Parallax barrier enable (uh, in 2x3bit?)
  10202004h 4    FFFFFFFFh Whatever, should be 0A390A39h
  10202008h 4    (R)       Whatever, readonly (R) (bit0=top screen mode?)
  1020200Ch 4    00010001h Video Disable Bits (bit0/16=top/bottom disable?)
  10202010h 4    00001F0Fh Whatever, usually 00000900h
  10202014h 4    00000001h Video Enable Bit (bit0)
  10202018h 1E8h (0)       Unused (0) ?
  10202200h 600h ...       LCD Configuration for Top Screen (see below)
  10202800h 200h (0)       Unused (0) ?
  10202A00h 600h ...       LCD Configuration for Bottom Screen (see below)
 (10203200h)40h  (0) uh??  reportedly LCD related, but actually DSP-mirror
```



## LCD Configuration for Top/Bottom Screen


```
  Top/Bottom Addr     Size R/W
  10202200h/10202A00h 4    00000301h CtrlFlags
  10202204h/10202A04h 4    01FFFFFFh Forced Blank Color
  10202208h/10202A08h 8    (0)       Unused (0) ?
  10202210h/10202A10h 4    000003FFh ? (default=0)    ;\
  10202214h/10202A14h 4    000003FFh ? (default=3FFh) ; darker when all zero
  10202218h/10202A18h 4    000003FFh ? (default=0)    ; (if CtrlFlags.bit0=1)
  1020221Ch/10202A1Ch 4    000003FFh ? (default=3FFh) ;/
  10202220h/10202A20h 4    000001FFh ? (default=100h) ;-
  10202224h/10202A24h 4    000000FFh ? (default=0)    ;\
  10202228h/10202A28h 4    000000FFh ? (default=0)    ;
  1020222Ch/10202A2Ch 4    000000FFh ? (default=0)    ;/
  10202230h/10202A30h 4    001F000Fh ? (default=4)    ;-
  10202234h/10202A34h 4    (0)       Unused (0) ?
  10202238h/10202A38h 4    000000FFh Last same entry in 10202400h (FFh=AllSame)
  1020223Ch/10202A3Ch 4    000000FFh ? (default=FFh)
  10202240h/10202A40h 4    000003FFh Backlight ;based on register 244h.low10bit
  10202244h/10202A44h 4    FFFFF3FFh Backlight?;LSBs: backlight? MSBs=flags?
  10202248h/10202A48h 8    (0)       Unused (0) ?
  10202250h/10202A50h 4    00FFFFFFh ? (default=0)    ;\brighter if 2nd=FFFFFFh
  10202254h/10202A54h 4    00FFFFFFh ? (default=0)    ;/(if CtrlFlags.bit0=1)
  10202258h/10202A58h 8    (0)       Unused (0) ?
  10202260h/10202A60h 4    0000CCCCh ? (default=0C84h);\
  10202264h/10202A64h 4    (0)       Unused (0) ?     ;
  10202268h/10202A68h 4    0000CCCCh ? (default=840Ch); DITHER alike Y2R ?
  1020226Ch/10202A6Ch 4    (0)       Unused (0) ?     ;
  10202270h/10202A70h 4    0000CCCCh ? (default=48C0h);
  10202274h/10202A74h 4    (0)       Unused (0) ?     ;
  10202278h/10202A78h 4    0000CCCCh ? (default=C048h);
  1020227Ch/10202A7Ch 4    (0)       Unused (0) ?     ;/
  10202280h/10202A80h 24h  000000FFh ? (default=0)    ;-9 words (8th=brighter)
  102022A4h/10202AA4h 4Ch  (0)       Unused (0) ?
  102022F0h/10202AF0h 4    (-R-)     ? (R)            ;\initially 00h, but can
  102022F4h/10202AF4h 4    (-R-)     ? (R)            ; be FFh when screens
  102022F8h/10202AF8h 4    (-R-)     ? (R)            ;/are on?
  102022FCh/10202AFCh 4    (0)       Unused (0) ?
  10202300h/10202B00h 100h 00FFFFFFh New3DS only: LCD calibration array?
  10202400h/10202C00h 400h 000003FFh Backlight related array, used by bootrom
```


```
 ______________________________ General Control ______________________________
```



## 10202000h - Parallax barrier enable (uh, in 2x3bit?) (R/W)


```
  0-2    Unknown (0..7)
  3-15   Unused (0)
  16-18  Unknown (0..7)
  19-31  Unused (0)
```

No visible effect, at least not on bottom screen.



## 10202004h - Whatever, should be 0A390A39h (R/W)


```
  0-15   Unknown
  16-31  Unknown
```

Usually set to 0A390A39h. But there's no visible effect when set to 0 or
FFFFFFFFh.



## 10202008h - Whatever, readonly (R)


```
  0      Indicates current horizontal resolution of top screen?
  1-31   Unknown or unused
```



## 1020200Ch - Video Disable Bits (R/W)


```
  0      Unknown (maybe same as bit16, for top screen?)
  1-15   Unused (0)
  16     Disable Bottom Screen (0=Normal/On, 1=Screen fades out)
  17-31  Unused (0)
```



## 10202010h - Whatever, usually 00000900h (R/W)


```
  0-3    Unknown (0..0Fh)
  4-7    Unused (0)
  8-12   Unknown (0..1Fh)
  13-31  Unused (0)
```

No visible effect. Power-up value is 00000900h. Bootrom doesn't change that
setting.



## 10202014h - Video Enable Bit (R/W)


```
  0      Video enable (0=Off/Black, 1=On/Picture)
  1-31   Unused (0)
```

Bottom (and top?) screen goes black when off (though backlight is kept on).


```
 _____________________________ Top/Bottom Screen _____________________________
```



## 10202200h/10202A00h - CtrlFlags (R/W)


```
  0      Enables custom settings when set?
  1-7    Unused (0)
  8-9    Unknown (0..3)
  10-31  Unused (0)
```

Bit0 should be copied to 10202244h/10202A44h.bit17?

Bit0 seems to enable custom settings in 1020221xh/10202A1xh,
10202254h/10202A54h, and in the eighth word at 10202280h/10202A80h.



## 10202204h/10202A04h - Forced Blank Color (R/W)


```
  0-7    Blank Color Red     (00h..FFh)
  8-15   Blank Color Green   (00h..FFh)
  16-23  Blank Color Blue    (00h..FFh)
  24     Blank Color Enable  (0=Normal/Picture, 1=Force Blank Color)
  25-31  Unused (0)
```

The blank color overrides the whole picture (including the Screen Border area).



## 10202210h/10202A10h 4    000003FFh ? (default=0)    ;\



## 10202214h/10202A14h 4    000003FFh ? (default=3FFh) ;



## 10202218h/10202A18h 4    000003FFh ? (default=0)    ;



## 1020221Ch/10202A1Ch 4    000003FFh ? (default=3FFh) ;/


```
  0-9    Unknown (0..3FFh)
  10-31  Unused (0)
```

Screen gets darker when set to all zeroes (but only if CtrlFlags.bit0=1).



## 10202220h/10202A20h 4    000001FFh ? (default=100h) ;-


```
  0-8    Unknown (0..1FFh)
  9-31   Unused (0)
```



## 10202224h/10202A24h 4    000000FFh ? (default=0)    ;\



## 10202228h/10202A28h 4    000000FFh ? (default=0)    ;



## 1020222Ch/10202A2Ch 4    000000FFh ? (default=0)    ;/


```
  0-7    Unknown (0..FFh)
  8-31   Unused (0)
```



## 10202230h/10202A30h 4    001F000Fh ? (default=4)    ;-


```
  0-3    Unknown (0..0Fh)
  4-15   Unused (0)
  16-20  Unknown (0..1Fh)
  21-31  Unused (0)
```



## 10202238h/10202A38h 4    000000FFh Last same entry in 10202400h/10202C00h


```
  0-7    Index of last SAME entry in 10202400h/10202C00h (0..FFh) (FFh=AllSame)
  8-31   Unused (0)
```



## 1020223Ch/10202A3Ch 4    000000FFh ? (default=FFh)


```
  0-7    Unknown (0..FFh)
  8-31   Unused (0)
```



## 10202240h/10202A40h 4    000003FFh Backlight ;based on register 244h.low10bit


```
  0-9    Backlight related (0..3FFh)
  10-31  Unused (0)
```



## 10202244h/10202A44h 4    FFFFF3FFh Backlight?;LSBs: backlight? MSBs=flags?


```
  0-9    Backlight related? (0..3FFh)
  10-11  Unused (0)
  12-15  Unknown (should be 0 or 6, depending on MCU?)
  16     Unknown
  17     Unknown
  18-31  More unknown bits/values...
```



## 10202250h/10202A50h 4    00FFFFFFh ? (default=0)



## 10202254h/10202A54h 4    00FFFFFFh ? (default=0)


```
  0-23   Unknown (0..FFFFFFh)
  24-31  Unused (0)
```

Two 24bit values. Screen gets brighter when setting the SECOND value to FFFFFFh
(but only if CtrlFlags.bit0=1).



## 10202260h/10202A60h 4    0000CCCCh ? (default=0C84h)



## 10202268h/10202A68h 4    0000CCCCh ? (default=840Ch)



## 10202270h/10202A70h 4    0000CCCCh ? (default=48C0h)



## 10202278h/10202A78h 4    0000CCCCh ? (default=C048h)


```
  0-15   Unknown (R/W Mask CCCCh)
  16-31  Unused (0)
```

DITHER alike Y2R?



## 10202280h/10202A80h 24h  000000FFh ? (default=0)    ;-(9 words)


```
  0-7    Unknown (0..FFh)
  8-31   Unused (0)
```

Unknown... 9 words (with 8bit used each) at 10202280h/10202A80h and up.

Screen gets brighter when setting the EIGHTH value to FFh (but only if
CtrlFlags.bit0=1).



## 102022F0h/10202AF0h - Readonly (R)



## 102022F4h/10202AF4h - Readonly (R)



## 102022F8h/10202AF8h - Readonly (R)


```
  0-xx   Unknown (initially 00h, but can be FFh when screens are on?)  (R)
  xx-31  Unused (0)
```



## 10202300h/10202B00h 100h 00FFFFFFh New3DS only: LCD calibration? (40 words)


```
  0-23   Unknown (0..FFFFFFh) (initially random)
  24-31  Unused (0)
```

40h words (100h bytes) at 10202300h/10202B00h and up.

Reportedly initialized from nand:/ro/sys/HWCAL0.dat offset 77Ch.

On Old3DS: Unused (0)

On New3DS: R/W (even in Old3DS mode)

Bootrom doesn't init these values (so they are apparently initially disabled
somewhere).



## 10202400h/10202C00h 400h 000003FFh Whatever array, used by bootrom!!!


```
  0-9    Unknown (0..3FFh) (initially random)
  10-31  Unused (0)
```

100h words (400h bytes) at 10202400h/10202C00h and up.

The bootrom error screen has some complicated function that initializes this
array with scaled/interpolated values, somehow related to backlight level and
screen type; although, with the used parameters... it seems to be just settings
all 100h table entries to the same value.

Alongsides, the number of leading entries with SAME value should be stored in
register 10202238h/10202A38h (ie. store N-1 if the first N table entries are
all same).




# <a name="3dsgpumemoryandiomap"></a>3DS GPU Memory and I/O Map




## GPU Overall Memory and I/O Map


All registers at 10202xxxh, 10400xxxh, 10401xxxh can be read/written by ARM11
opcodes, the 10401xxxh registers can be also written via command numbers
0000h..03FFh in PICA command lists.

```
  10202000h 18h     LCD Config/flags                               ;\
  10202018h 1E8h    Unused (0) ?                                   ;
  10202200h 600h    LCD Configuration for Top Screen               ; LCD
  10202800h 200h    Unused (0) ?                                   ;
  10202A00h 600h    LCD Configuration for Bottom Screen            ;/
  10400000h 10h     GPU Memory Control/Status Registers (part 1)   ;\
  10400010h 10h     DMA Memory Fill 0 DMA "PSC0"                   ;
  10400020h 10h     DMA Memory Fill 1 DMA "PSC1"                   ;
  10400030h D0h     GPU Memory Control/Status Registers (part 2)   ; External
  10400100h 300h    Unused (mirrors of above 100h bytes)           ;
  10400400h 100h    LCD Framebuffer Setup "PDC0" (top screen)      ;
  10400500h 100h    LCD Framebuffer Setup "PDC1" (bottom screen)   ;
  10400600h 200h    Unknown/DANGER (hangs when reading?)           ;
  10400800h 400h    Unknown/Unused (data abort)                    ;
  10400C00h 100h    DMA Memory Copy DMA Transfer Engine "DMA"      ;
  10400D00h 300h    Unused (mirrors of above 100h bytes)           ;/
  10401000h 1000h   Internal Command Registers PICA(0000h..03FFh)  ;-Internal
  10402000h 2000h   Unused (data abort)
  10404000h 1C000h  Write-only mirrors of above 4000h bytes (read=data abort)
  18000000h 300000h VRAM area, usually VRAM_A (3Mbyte)
  18300000h 300000h VRAM area, usually VRAM_B (3Mbyte)
  18600000h 600000h VRAM area, usually empty/zerofilled (6Mbyte)
```

Apart from VRAM, the GPU can also access other memory like FCRAM, AXI, QTM (but
that's most probably slower; and may be problematic when using virtual memory
allocation on ARM11 side).




# <a name="3dsgpuexternalregisterlistsummary"></a>3DS GPU External Register List Summary




## GPU Memory Control/Status Registers - Misc


```
  10400000h  GPU_FIXED_00010002h (always 00010002h, maybe ChipID/Version?) (R)
  10400004h  GPU_VRAM_CNT (reset=0, bootrom=300h) (R/W)
  10400008h  GPU_UNKNOWN_2BIT (R/W)
  1040000Ch  Unused (0)
```


## GPU Memory Fill Unit 0 and 1


```
  10400010h  GPU_MEMFILL_DST_ADDR0     ;\
  10400014h  GPU_MEMFILL_DST_END0      ; GPU_MEMFILL_0
  10400018h  GPU_MEMFILL_DATA0         ;
  1040001Ch  GPU_MEMFILL_CNT0          ;/
  10400020h  GPU_MEMFILL_DST_ADDR1     ;\
  10400024h  GPU_MEMFILL_DST_END1      ; GPU_MEMFILL_1
  10400028h  GPU_MEMFILL_DATA1         ;
  1040002Ch  GPU_MEMFILL_CNT1          ;/
```


## GPU Memory Control/Status Registers - Misc


```
  10400030h  GPU_VRAM_POWER (R/W)
  10400034h  GPU_STAT_IRQ_FLAGS (R)
  10400038h  GPU_STAT_SOMETHING (R)
  1040003Ch  GPU_MAKE_SOMETHING (R/W)
  10400040h  GPU_STAT_BACKLIGHT_OR_SO (R)
  10400044h  GPU_UNKNOWN_CAN_BE_7F80h (R)
  10400048h  GPU_UNKNOWN_32BIT (reset=0) (R/W)
  1040004Ch  Unused (0)
  10400050h  GPU_TIMING_CNT1 (R/W=FFFFFFFFh) (res=1111EF00h) ;init=22221200h
  10400054h  GPU_TIMING_CNT2 (R/W=FFFFFFFFh) (res=00000112h) ;init=00000FF2h
  10400058h  GPU_STAT_BUSY_FLAGS (R)
  1040005Ch  GPU_MAKE_WHATEVER_MESS (R/W)
  10400060h  GPU_STAT_WHATEVER_MESS (R)
  10400064h  GPU_UNKNOWN_1BIT (R/W=00000001h) (res=0)
  10400068h  GPU_UNKNOWN_INITIALLY_00A80000h (res=00A80000h) (R/W)
  1040006Ch  Unused (0)
```


## GPU Memory Control/Status Registers - Read-only memory traffic counters...


```
  10400070h  GPU_STAT_TOTAL_NON_VRAM_READS      ;\Non-VRAM (eg. AXI,QTM,FCRAM)
  10400074h  GPU_STAT_TOTAL_NON_VRAM_WRITES     ;/
  10400078h  GPU_STAT_TOTAL_VRAM_A_READS        ;\1st 3Mbyte VRAM block
  1040007Ch  GPU_STAT_TOTAL_VRAM_A_WRITES       ;/
  10400080h  GPU_STAT_TOTAL_VRAM_B_READS        ;\2nd 3Mbyte VRAM block
  10400084h  GPU_STAT_TOTAL_VRAM_B_WRITES       ;/
  10400088h  GPU_STAT_POLYGON_ARRAY_READS       ;-ATTR_BUF, INDEX_LIST
  1040008Ch  GPU_STAT_POLYGON_TEXTURE_READS     ;-cache misses only
  10400090h  GPU_STAT_POLYGON_DEPTHBUFFER_READS
  10400094h  GPU_STAT_POLYGON_DEPTHBUFFER_WRITES
  10400098h  GPU_STAT_POLYGON_COLORBUFFER_READS
  1040009Ch  GPU_STAT_POLYGON_COLORBUFFER_WRITES
  104000A0h  GPU_STAT_LCD_UPPER_SCREEN_READS    ;\for both left+right buffer
  104000A4h  GPU_STAT_LCD_LOWER_SCREEN_READS    ;/
  104000A8h  GPU_STAT_MEMCOPY_SRC_READS         ;\GPU_MEMCOPY
  104000ACh  GPU_STAT_MEMCOPY_DST_WRITES        ;/
  104000B0h  GPU_STAT_MEMFILL_0_DST_WRITES      ;\GPU_MEMFILL 0/1
  104000B4h  GPU_STAT_MEMFILL_1_DST_WRITES      ;/
  104000B8h  GPU_STAT_CPU_READS_FROM_VRAM_A_B   ;\counted by GPU because the
  104000BCh  GPU_STAT_CPU_WRITES_TO_VRAM_A_B    ;/GPU must forward vram to cpu
```


## GPU Memory Control/Status Registers - Misc


```
  104000C0h  GPU_BACKLIGHT_OR_SO_1 (reset=20000000h) (R/W)
  104000C4h  GPU_BASE_ADDR_VRAM_A (reset=18000000h) (R/W)
  104000C8h  GPU_BASE_ADDR_VRAM_B (reset=18300000h) (R/W)
  104000CCh  GPU_BACKLIGHT_OR_SO_2 (reset=20000000h) (R/W)
  104000D0h  GPU_UNKNOWN_4BIT (reset=0) (R/W)
  104000D4h  Unused (2Ch bytes, zerofilled)
  10400100h  Unused (300h bytes, mirrors of above 100h bytes)
```


## GPU Display Contollers


```
  10400400h  LCD Framebuffer Setup "PDC0" (100h bytes) (top screen)
  10400500h  LCD Framebuffer Setup "PDC1" (100h bytes) (bottom screen)
  10400600h  Unused? (200h bytes, Unknown/DANGER, hangs when reading?)
  10400800h  Unused? (400h bytes, Unknown/Unused, data abort)
```


## GPU Memory Copy Unit


```
  10400C00h  GPU_MEMCOPY_SRC_ADDR - Memcopy Input physical address (R/W)
  10400C04h  GPU_MEMCOPY_DST_ADDR - Memcopy Output physical address (R/W)
  10400C08h  GPU_MEMCOPY_DISPLAY_SIZE - DisplayTransfer width/height (R/W)
  10400C0Ch  GPU_MEMCOPY_DISPLAY_GAP - DisplayTransfer Input height+gap (R/W)
  10400C10h  GPU_MEMCOPY_FLAGS - Memcopy Transfer flags (R/W)
  10400C14h  GPU_MEMCOPY_UNKNOWN_21BIT - Memcopy (R/W)
  10400C18h  GPU_MEMCOPY_CNT - Memcopy Start/Busy (R/W)
  10400C1Ch  GPU_MEMCOPY_REMAIN_IRQ - Memcopy Remain IRQ (R/W)
  10400C20h  GPU_MEMCOPY_TEX_SIZE - TextureCopy total amount
  10400C24h  GPU_MEMCOPY_TEX_SRC_WIDTH - TextureCopy input line width/gap
  10400C28h  GPU_MEMCOPY_TEX_DST_WIDTH - TextureCopy output line width/gap
  10400C2Ch  GPU_MEMCOPY_UNKNOWN_FLAG - Memcopy Unknown (R/W)
  10400C30h  Unused (D0h bytes, zerofilled)
  10400D00h  Unused (300h bytes, mirrors of above 100h bytes)
```




# <a name="3dsgpuinternalregisterlistsummary"></a>3DS GPU Internal Register List Summary




## 3DS GPU Internal Registers - Finalize Interrupt registers


```
  10401000h+i   - PICA(N/A)       - GPUREG_IRQ_ACK(0..63) (R/W)
  10401040h+i   - PICA(0010h+i/4) - GPUREG_IRQ_REQ(0..63) (R/W)
  10401080h+i   - PICA(N/A)       - GPUREG_IRQ_CMP(0..63) (R/W)
  104010C0h     - PICA(N/A)       - GPUREG_IRQ_MASK_LOW (R/W)
  104010C4h     - PICA(N/A)       - GPUREG_IRQ_MASK_HIGH (R/W)
  104010C8h     - PICA(N/A)       - GPUREG_IRQ_STAT_LOW (R)
  104010CCh     - PICA(N/A)       - GPUREG_IRQ_STAT_HIGH (R)
  104010D0h     - PICA(N/A)       - GPUREG_IRQ_AUTOSTOP (R/W)
  104010D4h     - PICA(N/A)       - GPUREG_FIXED_00010002h (R)
```


## 3DS GPU Internal Registers - Rasterizer registers


```
  10401100h     - PICA(0040h)   - GPUREG_FACECULLING_CONFIG (R/W)
  10401104h     - PICA(0041h)   - GPUREG_VIEWPORT_V_SCALE (R/W)
  10401108h     - PICA(0042h)   - GPUREG_VIEWPORT_V_STEP (R/W)
  1040110Ch     - PICA(0043h)   - GPUREG_VIEWPORT_H_SCALE (R/W)
  10401110h     - PICA(0044h)   - GPUREG_VIEWPORT_H_STEP (R/W)
  10401114h     - PICA(0045h)   - GPUREG_undoc_10401114h (R/W=00FFFFFFh)
  10401118h     - PICA(0046h)   - GPUREG_undoc_10401118h (R/W=00FFFFFFh)
  1040111Ch     - PICA(0047h)   - GPUREG_FRAGOP_CLIP (R/W)
  10401120h+i*4 - PICA(0048h+i) - GPUREG_FRAGOP_CLIP_DATAi (i=0..3) (R/W)
  10401130h     - PICA(004Ch)   - GPUREG_undoc_10401130h (R/W=00000001h)
  10401134h     - PICA(004Dh)   - GPUREG_DEPTHMAP_SCALE (R/W)
  10401138h     - PICA(004Eh)   - GPUREG_DEPTHMAP_OFFSET (R/W)
  1040113Ch     - PICA(004Fh)   - GPUREG_SH_OUTMAP_TOTAL (R/W)
  10401140h+i*4 - PICA(0050h+i) - GPUREG_SH_OUTMAP_Oi (i=0..6) (R/W)
  10401160h     - PICA(0058h)   - GPUREG_undoc_10401160h (R/W=00000101h)
  10401164h     - PICA(0059h)   - GPUREG_undoc_10401164h (R/W=00000001h)
  10401168h     - PICA(005Ah)   - GPUREG_STAT_NUM_VERTICES_RECEIVED (R)
  1040116Ch     - PICA(005Bh)   - GPUREG_STAT_NUM_TRIANGLES_RECEIVED (R)
  10401170h     - PICA(005Ch)   - GPUREG_STAT_NUM_TRIANGLES_DISPLAYED (R)
  10401180h     - PICA(0060h)   - GPUREG_undoc_10401180h (R/W=00000301h)
  10401184h     - PICA(0061h)   - GPUREG_EARLYDEPTH_FUNC (R/W)
  10401188h     - PICA(0062h)   - GPUREG_EARLYDEPTH_TEST1 (R/W)
  1040118Ch     - PICA(0063h)   - GPUREG_EARLYDEPTH_CLEAR (W)
  10401190h     - PICA(0064h)   - GPUREG_SH_OUTATTR_MODE (R/W)
  10401194h     - PICA(0065h)   - GPUREG_SCISSORTEST_MODE (R/W)
  10401198h     - PICA(0066h)   - GPUREG_SCISSORTEST_POS1 (R/W)
  1040119Ch     - PICA(0067h)   - GPUREG_SCISSORTEST_POS2 (R/W)
  104011A0h     - PICA(0068h)   - GPUREG_VIEWPORT_XY (R/W)
  104011A4h     - PICA(0069h)   - GPUREG_undoc_104011A4h (R/W=FFFF0001h)
  104011A8h     - PICA(006Ah)   - GPUREG_EARLYDEPTH_DATA (R/W)
  104011ACh     - PICA(006Bh)   - GPUREG_undoc_104011ACh (R/W=00000FFFh)
  104011B0h     - PICA(006Ch)   - GPUREG_undoc_104011B0h (hangs when reading)
  104011B4h     - PICA(006Dh)   - GPUREG_DEPTHMAP_ENABLE (R/W)
  104011B8h     - PICA(006Eh)   - GPUREG_RENDERBUFFER_DIM_1 (R/W)
  104011BCh     - PICA(006Fh)   - GPUREG_SH_OUTATTR_CLOCK (R/W)
```


## 3DS GPU Internal Registers - Texturing registers (Generic Textures)


```
  10401200h     - PICA(0080h)   - GPUREG_TEXUNIT_CONFIG (R/W)        ;-CONFIG
  10401204h     - PICA(0081h)   - GPUREG_TEXUNIT0_BORDER_COLOR (R/W) ;\
  10401208h     - PICA(0082h)   - GPUREG_TEXUNIT0_DIM (R/W)          ;
  1040120Ch     - PICA(0083h)   - GPUREG_TEXUNIT0_PARAM (R/W)        ; UNIT0
  10401210h     - PICA(0084h)   - GPUREG_TEXUNIT0_LOD (R/W)          ;
  10401214h     - PICA(0085h)   - GPUREG_TEXUNIT0_ADDR1 (R/W)        ;
  10401218h     - PICA(0086h)   - GPUREG_TEXUNIT0_ADDR2 (R/W)        ;
  1040121Ch     - PICA(0087h)   - GPUREG_TEXUNIT0_ADDR3 (R/W)        ;
  10401220h     - PICA(0088h)   - GPUREG_TEXUNIT0_ADDR4 (R/W)        ;
  10401224h     - PICA(0089h)   - GPUREG_TEXUNIT0_ADDR5 (R/W)        ;
  10401228h     - PICA(008Ah)   - GPUREG_TEXUNIT0_ADDR6 (R/W)        ;
  1040122Ch     - PICA(008Bh)   - GPUREG_TEXUNIT0_SHADOW (R/W)       ;
  10401230h     - PICA(008Ch)   - GPUREG_undoc_10401230h (R/W=FFFF00FFh)
  10401234h     - PICA(008Dh)   - GPUREG_undoc_10401234h (R/W=000000FFh)
  10401238h     - PICA(008Eh)   - GPUREG_TEXUNIT0_TYPE (R/W)         ;/
  1040123Ch     - PICA(008Fh)   - GPUREG_LIGHTING_ENABLE (R/W)       ;-
  10401244h     - PICA(0091h)   - GPUREG_TEXUNIT1_BORDER_COLOR (R/W) ;\
  10401248h     - PICA(0092h)   - GPUREG_TEXUNIT1_DIM (R/W)          ;
  1040124Ch     - PICA(0093h)   - GPUREG_TEXUNIT1_PARAM (R/W)        ; UNIT1
  10401250h     - PICA(0094h)   - GPUREG_TEXUNIT1_LOD (R/W)          ;
  10401254h     - PICA(0095h)   - GPUREG_TEXUNIT1_ADDR (R/W)         ;
  10401258h     - PICA(0096h)   - GPUREG_TEXUNIT1_TYPE (R/W)         ;/
  10401264h     - PICA(0099h)   - GPUREG_TEXUNIT2_BORDER_COLOR (R/W) ;\
  10401268h     - PICA(009Ah)   - GPUREG_TEXUNIT2_DIM (R/W)          ;
  1040126Ch     - PICA(009Bh)   - GPUREG_TEXUNIT2_PARAM (R/W)        ; UNIT2
  10401270h     - PICA(009Ch)   - GPUREG_TEXUNIT2_LOD (R/W)          ;
  10401274h     - PICA(009Dh)   - GPUREG_TEXUNIT2_ADDR (R/W)         ;
  10401278h     - PICA(009Eh)   - GPUREG_TEXUNIT2_TYPE (R/W)         ;/
```


## 3DS GPU Internal Registers - Texturing registers (Procedural Texture)


```
  104012A0h     - PICA(00A8h)   - GPUREG_TEXUNIT3_PROCTEX0 (R/W)
  104012A4h     - PICA(00A9h)   - GPUREG_TEXUNIT3_PROCTEX1 (R/W)
  104012A8h     - PICA(00AAh)   - GPUREG_TEXUNIT3_PROCTEX2 (R/W)
  104012ACh     - PICA(00ABh)   - GPUREG_TEXUNIT3_PROCTEX3 (R/W)
  104012B0h     - PICA(00ACh)   - GPUREG_TEXUNIT3_PROCTEX4 (R/W)
  104012B4h     - PICA(00ADh)   - GPUREG_TEXUNIT3_PROCTEX5_LOW (R/W)
  104012B8h     - PICA(00AEh)   - GPUREG_TEXUNIT3_PROCTEX5_HIGH (R/W)
  104012BCh     - PICA(00AFh)   - GPUREG_PROCTEX_LUT_INDEX (R/W)
  104012C0h+i*4 - PICA(00B0h+i) - GPUREG_PROCTEX_LUT_DATA(0..7) (R/W)
```


## 3DS GPU Internal Registers - Texturing registers (Environment)


```
  10401300h     - PICA(00C0h)   - GPUREG_TEXENV0_SOURCE (R/W)       ;\
  10401304h     - PICA(00C1h)   - GPUREG_TEXENV0_OPERAND (R/W)      ;
  10401308h     - PICA(00C2h)   - GPUREG_TEXENV0_COMBINER (R/W)     ; ENV0
  1040130Ch     - PICA(00C3h)   - GPUREG_TEXENV0_COLOR (R/W)        ;
  10401310h     - PICA(00C4h)   - GPUREG_TEXENV0_SCALE (R/W)        ;/
  1040131Ch     - PICA(00C7h)   - GPUREG_undoc_1040131Ch (R/W=00000007h)
  10401320h     - PICA(00C8h)   - GPUREG_TEXENV1_SOURCE (R/W)       ;\
  10401324h     - PICA(00C9h)   - GPUREG_TEXENV1_OPERAND (R/W)      ;
  10401328h     - PICA(00CAh)   - GPUREG_TEXENV1_COMBINER (R/W)     ; ENV1
  1040132Ch     - PICA(00CBh)   - GPUREG_TEXENV1_COLOR (R/W)        ;
  10401330h     - PICA(00CCh)   - GPUREG_TEXENV1_SCALE (R/W)        ;/
  10401340h     - PICA(00D0h)   - GPUREG_TEXENV2_SOURCE (R/W)       ;\
  10401344h     - PICA(00D1h)   - GPUREG_TEXENV2_OPERAND (R/W)      ;
  10401348h     - PICA(00D2h)   - GPUREG_TEXENV2_COMBINER (R/W)     ; ENV2
  1040134Ch     - PICA(00D3h)   - GPUREG_TEXENV2_COLOR (R/W)        ;
  10401350h     - PICA(00D4h)   - GPUREG_TEXENV2_SCALE (R/W)        ;/
  10401360h     - PICA(00D8h)   - GPUREG_TEXENV3_SOURCE (R/W)       ;\
  10401364h     - PICA(00D9h)   - GPUREG_TEXENV3_OPERAND (R/W)      ;
  10401368h     - PICA(00DAh)   - GPUREG_TEXENV3_COMBINER (R/W)     ; ENV3
  1040136Ch     - PICA(00DBh)   - GPUREG_TEXENV3_COLOR (R/W)        ;
  10401370h     - PICA(00DCh)   - GPUREG_TEXENV3_SCALE (R/W)        ;/
  10401380h     - PICA(00E0h)   - GPUREG_TEXENV_UPDATE_BUFFER (R/W)
  10401384h     - PICA(00E1h)   - GPUREG_FOG_COLOR (R/W)
  10401388h     - PICA(00E2h)   - GPUREG_undoc_10401388h (R/W=0000FFFFh)
  1040138Ch     - PICA(00E3h)   - GPUREG_undoc_1040138Ch (R/W=0000FFFFh)
  10401390h     - PICA(00E4h)   - GPUREG_GAS_ATTENUATION (R/W)
  10401394h     - PICA(00E5h)   - GPUREG_GAS_ACCMAX (R/W)
  10401398h     - PICA(00E6h)   - GPUREG_FOG_LUT_INDEX (R/W)
  104013A0h+i*4 - PICA(00E8h+i) - GPUREG_FOG_LUT_DATA(0..7) (R/W)
  104013C0h     - PICA(00F0h)   - GPUREG_TEXENV4_SOURCE (R/W)       ;\
  104013C4h     - PICA(00F1h)   - GPUREG_TEXENV4_OPERAND (R/W)      ;
  104013C8h     - PICA(00F2h)   - GPUREG_TEXENV4_COMBINER (R/W)     ; ENV4
  104013CCh     - PICA(00F3h)   - GPUREG_TEXENV4_COLOR (R/W)        ;
  104013D0h     - PICA(00F4h)   - GPUREG_TEXENV4_SCALE (R/W)        ;/
  104013E0h     - PICA(00F8h)   - GPUREG_TEXENV5_SOURCE (R/W)       ;\
  104013E4h     - PICA(00F9h)   - GPUREG_TEXENV5_OPERAND (R/W)      ;
  104013E8h     - PICA(00FAh)   - GPUREG_TEXENV5_COMBINER (R/W)     ; ENV5
  104013ECh     - PICA(00FBh)   - GPUREG_TEXENV5_COLOR (R/W)        ;
  104013F0h     - PICA(00FCh)   - GPUREG_TEXENV5_SCALE (R/W)        ;/
  104013F4h     - PICA(00FDh)   - GPUREG_TEXENV_BUFFER_COLOR (R/W)  ;-
```


## 3DS GPU Internal Registers - Framebuffer registers


```
  10401400h     - PICA(0100h)   - GPUREG_COLOR_OPERATION (R/W)
  10401404h     - PICA(0101h)   - GPUREG_BLEND_FUNC (R/W)
  10401408h     - PICA(0102h)   - GPUREG_LOGIC_OP (R/W)
  1040140Ch     - PICA(0103h)   - GPUREG_BLEND_COLOR (R/W)
  10401410h     - PICA(0104h)   - GPUREG_FRAGOP_ALPHA_TEST (R/W)
  10401414h     - PICA(0105h)   - GPUREG_STENCIL_TEST (R/W)
  10401418h     - PICA(0106h)   - GPUREG_STENCIL_OP (R/W)
  1040141Ch     - PICA(0107h)   - GPUREG_DEPTH_COLOR_MASK (R/W)
  10401434h     - PICA(010Dh)   - GPUREG_undoc_10401434h (R/W=00000001h)
  10401438h     - PICA(010Eh)   - GPUREG_undoc_10401438h (R/W=FFFFFFFFh)
  1040143Ch     - PICA(010Fh)   - GPUREG_undoc_1040143Ch (R/W=FFFFFFFFh)
  10401440h     - PICA(0110h)   - GPUREG_RENDERBUFFER_INVALIDATE (forget) (W)
  10401444h     - PICA(0111h)   - GPUREG_RENDERBUFFER_FLUSH (writeback) (W)
  10401448h     - PICA(0112h)   - GPUREG_COLORBUFFER_READING (R/W)
  1040144Ch     - PICA(0113h)   - GPUREG_COLORBUFFER_WRITING (R/W)
  10401450h     - PICA(0114h)   - GPUREG_DEPTHBUFFER_READING (R/W)
  10401454h     - PICA(0115h)   - GPUREG_DEPTHBUFFER_WRITING (R/W)
  10401458h     - PICA(0116h)   - GPUREG_DEPTHBUFFER_FORMAT (R/W)
  1040145Ch     - PICA(0117h)   - GPUREG_COLORBUFFER_FORMAT (R/W)
  10401460h     - PICA(0118h)   - GPUREG_EARLYDEPTH_TEST2 (R/W)
  10401464h     - PICA(0119h)   - GPUREG_undoc_10401464h (R/W=FFFFFFFFh)
  10401468h     - PICA(011Ah)   - GPUREG_undoc_10401468h (R/W=FFFFFFFFh)
  1040146Ch     - PICA(011Bh)   - GPUREG_RENDERBUFFER_BLOCK32 (R/W)
  10401470h     - PICA(011Ch)   - GPUREG_DEPTHBUFFER_LOC (R/W)
  10401474h     - PICA(011Dh)   - GPUREG_COLORBUFFER_LOC (R/W)
  10401478h     - PICA(011Eh)   - GPUREG_RENDERBUFFER_DIM_0 (R/W)
  1040147Ch     - PICA(011Fh)   - GPUREG_undoc_1040147Ch (R/W=7FFFFFFFh)
  10401480h     - PICA(0120h)   - GPUREG_GAS_LIGHT_XY - Planar Shading (R/W)
  10401484h     - PICA(0121h)   - GPUREG_GAS_LIGHT_Z - View Shading (R/W)
  10401488h     - PICA(0122h)   - GPUREG_GAS_LIGHT_Z_COLOR (R/W)
  1040148Ch     - PICA(0123h)   - GPUREG_GAS_LUT_INDEX (W)
  10401490h     - PICA(0124h)   - GPUREG_GAS_LUT_DATA (R/W)
  10401494h     - PICA(0125h)   - GPUREG_undoc_10401494h (R/W=0000FFFFh)
  10401498h     - PICA(0126h)   - GPUREG_GAS_DELTAZ_DEPTH (R/W)
  104014C0h     - PICA(0130h)   - GPUREG_FRAGOP_SHADOW (R/W)
  104014FCh     - PICA(013Fh)   - GPUREG_undoc_104014FCh (R/W=0000000Fh)
```


## 3DS GPU Internal Registers - Fragment Lighting registers


```
  10401500h+i*40h - PICA(0140h+10h*(0..7)) - GPUREG_LIGHTi_SPECULAR0 (R/W)
  10401504h+i*40h - PICA(0141h+10h*(0..7)) - GPUREG_LIGHTi_SPECULAR1 (R/W)
  10401508h+i*40h - PICA(0142h+10h*(0..7)) - GPUREG_LIGHTi_DIFFUSE (R/W)
  1040150Ch+i*40h - PICA(0143h+10h*(0..7)) - GPUREG_LIGHTi_AMBIENT (R/W)
  10401510h+i*40h - PICA(0144h+10h*(0..7)) - GPUREG_LIGHTi_VECTOR_LOW (R/W)
  10401514h+i*40h - PICA(0145h+10h*(0..7)) - GPUREG_LIGHTi_VECTOR_HIGH (R/W)
  10401518h+i*40h - PICA(0146h+10h*(0..7)) - GPUREG_LIGHTi_SPOTDIR_LOW (R/W)
  1040151Ch+i*40h - PICA(0147h+10h*(0..7)) - GPUREG_LIGHTi_SPOTDIR_HIGH (R/W)
  10401524h+i*40h - PICA(0149h+10h*(0..7)) - GPUREG_LIGHTi_CONFIG (R/W)
  10401528h+i*40h - PICA(014Ah+10h*(0..7)) - GPUREG_LIGHTi_ATTENUATION_BIAS
  1040152Ch+i*40h - PICA(014Bh+10h*(0..7)) - GPUREG_LIGHTi_ATTENUATION_SCALE
  10401700h       - PICA(01C0h)   - GPUREG_LIGHTING_AMBIENT (R/W)
  10401708h       - PICA(01C2h)   - GPUREG_LIGHTING_NUM_LIGHTS (R/W)
  1040170Ch       - PICA(01C3h)   - GPUREG_LIGHTING_CONFIG0 (R/W)
  10401710h       - PICA(01C4h)   - GPUREG_LIGHTING_CONFIG1 (R/W)
  10401714h       - PICA(01C5h)   - GPUREG_LIGHTING_LUT_INDEX (R/W)
  10401718h       - PICA(01C6h)   - GPUREG_LIGHTING_DISABLE (R/W)
  10401720h+i*4   - PICA(01C8h+i) - GPUREG_LIGHTING_LUT_DATA(0..7) (R/W)
  10401740h       - PICA(01D0h)   - GPUREG_LIGHTING_LUTINPUT_ABS (R/W)
  10401744h       - PICA(01D1h)   - GPUREG_LIGHTING_LUTINPUT_SELECT (R/W)
  10401748h       - PICA(01D2h)   - GPUREG_LIGHTING_LUTINPUT_SCALE (R/W)
  10401764h       - PICA(01D9h)   - GPUREG_LIGHTING_LIGHT_PERMUTATION (R/W)
```


## 3DS GPU Internal Registers - Geometry Pipeline registers


```
  10401800h       - PICA(0200h)   - GPUREG_ATTR_BUF_BASE (R/W)
  10401804h       - PICA(0201h)   - GPUREG_ATTR_BUF_FORMAT_LOW (R/W)
  10401808h       - PICA(0202h)   - GPUREG_ATTR_BUF_FORMAT_HIGH (R/W)
  1040180Ch+i*0Ch - PICA(0203h+3*(0..11)) - GPUREG_ATTR_BUFi_OFFSET (R/W)
  10401810h+i*0Ch - PICA(0204h+3*(0..11)) - GPUREG_ATTR_BUFi_CONFIG_LOW (R/W)
  10401814h+i*0Ch - PICA(0205h+3*(0..11)) - GPUREG_ATTR_BUFi_CONFIG_HIGH (R/W)
  1040189Ch       - PICA(0227h)   - GPUREG_ATTR_BUF_INDEX_LIST (R/W)
  104018A0h       - PICA(0228h)   - GPUREG_ATTR_BUF_NUMVERTICES (R/W)
  104018A4h       - PICA(0229h)   - GPUREG_GEOSTAGE_CONFIG (R/W)
  104018A8h       - PICA(022Ah)   - GPUREG_ATTR_BUF_FIRST_INDEX (R/W)
  104018B4h       - PICA(022Dh)   - GPUREG_POST_VERTEX_CACHE_NUM (R/W)
  104018B8h       - PICA(022Eh)   - GPUREG_ATTR_BUF_DRAWARRAYS (W)
  104018BCh       - PICA(022Fh)   - GPUREG_ATTR_BUF_DRAWELEMENTS (W)
  104018C4h       - PICA(0231h)   - GPUREG_VTX_FUNC (W)
  104018C8h       - PICA(0232h)   - GPUREG_FIXEDATTRIB_INDEX (W)
  104018CCh+i*4   - PICA(0233h+i) - GPUREG_FIXEDATTRIB_DATA(0..2) (W)
  104018E0h       - PICA(0238h)   - GPUREG_CMDBUF_SIZE0 (R/W)
  104018E4h       - PICA(0239h)   - GPUREG_CMDBUF_SIZE1 (R/W)
  104018E8h       - PICA(023Ah)   - GPUREG_CMDBUF_ADDR0 (aka entrypoint) (R/W)
  104018ECh       - PICA(023Bh)   - GPUREG_CMDBUF_ADDR1 (aka entrypoint) (R/W)
  104018F0h       - PICA(023Ch)   - GPUREG_CMDBUF_JUMP0 (jump to ADDR0) (W)
  104018F4h       - PICA(023Dh)   - GPUREG_CMDBUF_JUMP1 (jump to ADDR1) (W)
  10401908h       - PICA(0242h)   - GPUREG_VSH_NUM_ATTR (R/W)
  1040190Ch       - PICA(0243h)   - GPUREG_undoc_1040190Ch (R/W=00000037h)
  10401910h       - PICA(0244h)   - GPUREG_VSH_COM_MODE (R/W)
  10401914h       - PICA(0245h)   - GPUREG_START_DRAW_FUNC0 (R/W)
  10401928h       - PICA(024Ah)   - GPUREG_VSH_OUTMAP_TOTAL1 (R/W)
  10401944h       - PICA(0251h)   - GPUREG_VSH_OUTMAP_TOTAL2 (R/W)
  10401948h       - PICA(0252h)   - GPUREG_GSH_MISC0 (R/W)
  1040194Ch       - PICA(0253h)   - GPUREG_GEOSTAGE_CONFIG2 (R/W)
  10401950h       - PICA(0254h)   - GPUREG_GSH_MISC1 (R/W)
  10401954h       - PICA(0255h)   - GPUREG_undoc_10401954h (R/W=00000001h)
  10401978h       - PICA(025Eh)   - GPUREG_PRIMITIVE_CONFIG (R/W)
  1040197Ch       - PICA(025Fh)   - GPUREG_RESTART_PRIMITIVE (R/W)
```


## 3DS GPU Internal Registers - Shader 0 (Geometry Shader)


```
  10401A00h       - PICA(0280h)   - GPUREG_GSH_BOOLUNIFORM (R/W)
  10401A04h+i*4   - PICA(0281h+i) - GPUREG_GSH_INTUNIFORM_I0..I3 (R/W)
  10401A24h       - PICA(0289h)   - GPUREG_GSH_INPUTBUFFER_CONFIG (R/W)
  10401A28h       - PICA(028Ah)   - GPUREG_GSH_ENTRYPOINT (R/W)
  10401A2Ch       - PICA(028Bh)   - GPUREG_GSH_ATTR_PERMUTATION_LOW (R/W)
  10401A30h       - PICA(028Ch)   - GPUREG_GSH_ATTR_PERMUTATION_HIGH (R/W)
  10401A34h       - PICA(028Dh)   - GPUREG_GSH_OUTMAP_MASK (R/W)
  10401A3Ch       - PICA(028Fh)   - GPUREG_GSH_CODETRANSFER_END (W)
  10401A40h       - PICA(0290h)   - GPUREG_GSH_FLOATUNIFORM_INDEX (W)
  10401A44h+i*4   - PICA(0291h+i) - GPUREG_GSH_FLOATUNIFORM_DATA(0..7) (W)
  10401A6Ch       - PICA(029Bh)   - GPUREG_GSH_CODETRANSFER_INDEX (W)
  10401A70h+i*4   - PICA(029Ch+i) - GPUREG_GSH_CODETRANSFER_DATA(0..7) (W)
  10401A94h       - PICA(02A5h)   - GPUREG_GSH_OPDESCS_INDEX (W)
  10401A98h+i*4   - PICA(02A6h+i) - GPUREG_GSH_OPDESCS_DATA(0..7) (W)
```


## 3DS GPU Internal Registers - Shader 1 (Vertex Shader)


```
  10401AC0h       - PICA(02B0h)   - GPUREG_VSH_BOOLUNIFORM (R/W)
  10401AC4h+i*4   - PICA(02B1h+i) - GPUREG_VSH_INTUNIFORM_I0..I3 (R/W)
  10401AE4h       - PICA(02B9h)   - GPUREG_VSH_INPUTBUFFER_CONFIG (R/W)
  10401AE8h       - PICA(02BAh)   - GPUREG_VSH_ENTRYPOINT (R/W)
  10401AECh       - PICA(02BBh)   - GPUREG_VSH_ATTR_PERMUTATION_LOW (R/W)
  10401AF0h       - PICA(02BCh)   - GPUREG_VSH_ATTR_PERMUTATION_HIGH (R/W)
  10401AF4h       - PICA(02BDh)   - GPUREG_VSH_OUTMAP_MASK (R/W)
  10401AFCh       - PICA(02BFh)   - GPUREG_VSH_CODETRANSFER_END (W)
  10401B00h       - PICA(02C0h)   - GPUREG_VSH_FLOATUNIFORM_INDEX (W)
  10401B04h+i*4   - PICA(02C1h+i) - GPUREG_VSH_FLOATUNIFORM_DATA(0..7) (W)
  10401B2Ch       - PICA(02CBh)   - GPUREG_VSH_CODETRANSFER_INDEX (W)
  10401B30h+i*4   - PICA(02CCh+i) - GPUREG_VSH_CODETRANSFER_DATA(0..7) (W)
  10401B54h       - PICA(02D5h)   - GPUREG_VSH_OPDESCS_INDEX (W)
  10401B58h+i*4   - PICA(02D6h+i) - GPUREG_VSH_OPDESCS_DATA(0..7) (W)
```


## 3DS GPU Internal Registers - Shader 2 (Unknown purpose)


```
  10401B80h       - PICA(02E0h)   - GPUREG_VSH2_BOOLUNIFORM (R/W)
  10401B84h+i*4   - PICA(02E1h+i) - GPUREG_VSH2_INTUNIFORM_I0..I3 (R/W)
  10401BA4h       - PICA(02E9h)   - GPUREG_VSH2_INPUTBUFFER_CONFIG (R/W)
  10401BA8h       - PICA(02EAh)   - GPUREG_VSH2_ENTRYPOINT (R/W)
  10401BACh       - PICA(02EBh)   - GPUREG_VSH2_ATTR_PERMUTATION_LOW (R/W)
  10401BB0h       - PICA(02ECh)   - GPUREG_VSH2_ATTR_PERMUTATION_HIGH (R/W)
  10401BB4h       - PICA(02EDh)   - GPUREG_VSH2_OUTMAP_MASK (R/W)
  10401BBCh       - PICA(02EFh)   - GPUREG_VSH2_CODETRANSFER_END (W)
  10401BC0h       - PICA(02F0h)   - GPUREG_VSH2_FLOATUNIFORM_INDEX (W)
  10401BC4h+i*4   - PICA(02F1h+i) - GPUREG_VSH2_FLOATUNIFORM_DATA(0..7) (W)
  10401BECh       - PICA(02FBh)   - GPUREG_VSH2_CODETRANSFER_INDEX (W)
  10401BF0h+i*4   - PICA(02FCh+i) - GPUREG_VSH2_CODETRANSFER_DATA(0..7) (W)
  10401C14h       - PICA(0305h)   - GPUREG_VSH2_OPDESCS_INDEX (W)
  10401C18h+i*4   - PICA(0306h+i) - GPUREG_VSH2_OPDESCS_DATA(0..7) (W)
```


## 3DS GPU Internal Registers - Shader 3 (Unknown purpose)


```
  10401C40h       - PICA(0310h)   - GPUREG_VSH3_BOOLUNIFORM (R/W)
  10401C44h+i*4   - PICA(0311h+i) - GPUREG_VSH3_INTUNIFORM_I0..I3 (R/W)
  10401C64h       - PICA(0319h)   - GPUREG_VSH3_INPUTBUFFER_CONFIG (R/W)
  10401C68h       - PICA(031Ah)   - GPUREG_VSH3_ENTRYPOINT (R/W)
  10401C6Ch       - PICA(031Bh)   - GPUREG_VSH3_ATTR_PERMUTATION_LOW (R/W)
  10401C70h       - PICA(031Ch)   - GPUREG_VSH3_ATTR_PERMUTATION_HIGH (R/W)
  10401C74h       - PICA(031Dh)   - GPUREG_VSH3_OUTMAP_MASK (R/W)
  10401C7Ch       - PICA(031Fh)   - GPUREG_VSH3_CODETRANSFER_END (W)
  10401C80h       - PICA(0320h)   - GPUREG_VSH3_FLOATUNIFORM_INDEX (W)
  10401C84h+i*4   - PICA(0321h+i) - GPUREG_VSH3_FLOATUNIFORM_DATA(0..7) (W)
  10401CACh       - PICA(032Bh)   - GPUREG_VSH3_CODETRANSFER_INDEX (W)
  10401CB0h+i*4   - PICA(032Ch+i) - GPUREG_VSH3_CODETRANSFER_DATA(0..7) (W)
  10401CD4h       - PICA(0335h)   - GPUREG_VSH3_OPDESCS_INDEX (W)
  10401CD8h+i*4   - PICA(0336h+i) - GPUREG_VSH3_OPDESCS_DATA(0..7) (W)
```




# <a name="3dsgpuexternalregistersmemorycontrolstatusregisters"></a>3DS GPU External Registers - Memory Control/Status Registers



The 3DS bootrom error screen initializes only 10400004h and 10400030h (VRAM
control/power). The 3DS OS does reportedly also initialize 10400050h and
10400054h (timings?).



## 10400000h - GPU\_FIXED\_00010002h (always 00010002h, maybe ChipID/Version) (R)


```
  0-31  Always 00010002h (maybe ChipID/Version)
```

Note: Register 104010D4h seems to contain the same readonly value.



## 10400004h - GPU\_VRAM\_CNT (reset=0, bootrom=300h) (R/W)


```
  0-31  Unknown (0..FFFFFFFFh)
```

Seems to have no effect on LCD output. However, value FFFFFFFFh does mess up
the polygon renderer (or MEMCOPY unit), causing each 4 scanlines to be drawn
twice.



## 10400008h - GPU\_UNKNOWN\_2BIT (reset=0) (R/W)


```
  0-1   Unknown (0..03h)
  2-31  Unused (0)
```



## 10400030h - GPU\_VRAM\_POWER (R/W)


```
  0-7   Unknown (0..FFh)
  8     Power off VRAM_A data.bit0-63   (0=On, 1=Power Off)
  9     Power off VRAM_A data.bit64-127 (0=On, 1=Power Off)
  10    Power off VRAM_B data.bit0-63   (0=On, 1=Power Off) ;\later uses VRAM_A
  11    Power off VRAM_B data.bit64-127 (0=On, 1=Power Off) ;/when VRAM_B=off?
  12-31 Unknown (0..FFFFFh)
```

Seems to disable VRAM power, VRAM\_A/B are 3Mbyte each, and each of them seems
to have separate sections for data bit0-63 and 64-127 (ie. the first and second
8 bytes within 16 byte snippets).

After writing to 10400030h, one should issue a dummy read from 10400030h.

Even when disabled only for a short moment, the VRAM does immediately forget
it's data and gets filled with random values; this can be seen after
re-enabling the memory (the CPU hangs when reading VRAM while it is disabled).



## 10400034h - GPU\_STAT\_IRQ\_FLAGS (R)


Contains IRQ flags (normally IRQ handling/polling should work fine without
needing this register; except, polling GPU\_MEMCOPY\_CNT can apparently hang the
CPU, whilst polling GPU\_STAT\_IRQ\_FLAGS.bit30 does work better).

```
  0     Unknown, usually set ;\get cleared when setting GPU_MAKE_SOMETHING.bit0
  1     Unknown, usually set ;/(unknown if/when the flags can get set again)
  2-25  Unused (0)
  26    IRQ 28h PSC0 aka GPU_MEMFILL 0 ready ;mirror of GPU_MEMFILL_CNT0.bit1
  27    IRQ 29h PSC1 aka GPU_MEMFILL 1 ready ;mirror of GPU_MEMFILL_CNT1.bit1
  28    IRQ 2Ah PDC0 aka GPU H/V-IRQ for top screen
  29    IRQ 2Bh PDC1 aka GPU H/V-IRQ for bottom screen
  30    IRQ 2Ch PPF  aka GPU_MEMCOPY ready   ;mirror of GPU_MEMCOPY_CNT.bit8
  31    IRQ 2Dh P3D  aka GPUREG_IRQ_CMP/REQ match (commonly at end of cmdlist)
```

Bit26,27,30 can be cleared in the corresponding mirrored registers.

Bit28,29 are automatically set/cleared during LCD output (usually once per
frame).

Bit31 can be cleared by setting IRQ\_REQ and IRQ\_CMP to different values.



## 10400038h - GPU\_STAT\_SOMETHING (R)


```
  0-31  Can be 00000000h, 10400800h, 10402000h, or 10410000h
```

Unknown, initially 10402000h on reset, 10400800h after LCD init or so, and
becomes 00000000h after setting GPU\_MAKE\_SOMETHING.bit0, and (thereafter?)
changes to 10410000h. No idea if 104xxxxxh is related to the address of the GPU
I/O area.



## 1040003Ch - GPU\_MAKE\_SOMETHING (R/W)


```
  0     Unknown (0=Normal, 1=GPU_STAT_SOMETHING changes after a while)
  1-31  Unknown (0..7FFFFFFFh)
```

Unknown, setting bit0 (even only for a short moment) will later on cause
GPU\_STAT\_SOMETHING to become 10410000h. Also affects GPU\_STAT\_IRQ\_FLAGS.bit0-1.



## 10400040h - GPU\_STAT\_BACKLIGHT\_OR\_SO (R)


```
  0-1   Unknown (usually 0, but can be 3 when [104000C0h]=0 or [104000CCh]=0)
  2-31  Unused (0)
```



## 10400044h - GPU\_UNKNOWN\_CAN\_BE\_7F80h (R)


```
  0-31  Texture related...? (usually 0, but sometimes 7F80h, and once 1200h)
```

Unknown. Usually zero, but can contain other values after rendering with
GPUREG\_TEXUNIT\_CONFIG=nonzero (even then, it does often stay zero, but
sometimes changes to 7F80h, and once changed to 1200h). Whether the register
does change seems to depend on power-up state of other uninitialized
registers/memory and/or whatever timings (if nonzero values did occur then they
do usually reappear upon next rendering even after reset, but that behaviour
can change on next power-up).

Note: Value 1200h occurred after changing GPUREG\_COLORBUFFER\_LOC and
GPUREG\_DEPTHBUFFER\_LOC to dummy address zero (but that couldn't be reproduced).



## 10400048h - GPU\_UNKNOWN\_32BIT (reset=0) (R/W)


```
  0-31  Unknown (0..FFFFFFFFh)
```



## 10400050h - GPU\_TIMING\_CNT1 (R/W=FFFFFFFFh) (res=1111EF00h) ;init=22221200h


```
  0-31  Unknown (0..FFFFFFFFh) (affects GPU_MEMCOPY timings and maybe others)
```

Somehow affects timings. Different values can make timings about 10% faster or
slower (or, some values seem to make no difference at all). For example,

```
  10101010h or 20202020h --> slower MEMCOPY
  1111EF00h or 22221200h --> normal MEMCOPY
  FFFFFFFFh              --> faster MEMCOPY
```



## 10400054h - GPU\_TIMING\_CNT2 (R/W=FFFFFFFFh) (res=00000112h) ;init=00000FF2h


```
  0-31  Unknown (0..FFFFFFFFh) (probably affects whatever timings)
```



## 10400058h - GPU\_STAT\_BUSY\_FLAGS (R)


```
  10    Unknown, seems to be set on power-up, but later cleared?
  17    Often set after writing GPU_VRAM_POWER
  18    Sometimes set after writing GPU_VRAM_POWER
  19    GPU_MEMFILL_0/1 Busy (0=No, 1=Busy)
  20    GPU_MEMCOPY Busy     (0=No, 1=Busy; gets set some cycles after start)
```



## 1040005Ch - GPU\_MAKE\_WHATEVER\_MESS (R/W)


```
  0     Whatever, gets copied to bit8                   (W)
  8     Whatever, contains value written to bit0        (R)
  16-21 Whatever, 00h..3Fh                              (R/W)
  24-29 Whatever, 00h..3Fh                              (R/W)
```

Affects the 30h-word pattern returned when reading below register.



## 10400060h - GPU\_STAT\_WHATEVER\_MESS (R)


```
  0-6   Unused? (0)
  7-22  Whatever Mess
  23    Unused? (0)
  24-29 Whatever Mess
  30-31 Unused? (0)
```

Repeatly reading returns a mess, repeated every 30h words, for example:

```
  08002400h, 01404180h, 04002000h, 00020000h, 20000200h, 02080000h, 00080000h,
  0041A000h, 11006100h, 00041000h, 00242000h, 00100880h, 1200A000h, 08000000h,
  10042080h, 04082400h, 00002400h, 00000000h, 1040C500h, 03000000h, ...
```

The same values as above are also returned when inserting delays in the read
loop. So it's either random generated... or a FIFO that reads junk from an
uninitialized array?

Changing 1040005Ch (eg. writing FFFFFFFFh) causes above to return different
garbage values (also reapeating each 30h words, but containing a more regular
pattern with fewer bits set).



## 10400068h  GPU\_UNKNOWN\_INITIALLY\_00A80000h (res=00A80000h) (R/W)


```
  0-31  Unknown (0..FFFFFFFFh) (initially 00A80000h on reset)
```



## 10400070h - Read-only memory traffic counters (R)


```
  10400070h  GPU_STAT_TOTAL_NON_VRAM_READS      ;\Non-VRAM (eg. AXI,QTM,FCRAM)
  10400074h  GPU_STAT_TOTAL_NON_VRAM_WRITES     ;/
  10400078h  GPU_STAT_TOTAL_VRAM_A_READS        ;\1st 3Mbyte VRAM block
  1040007Ch  GPU_STAT_TOTAL_VRAM_A_WRITES       ;/
  10400080h  GPU_STAT_TOTAL_VRAM_B_READS        ;\2nd 3Mbyte VRAM block
  10400084h  GPU_STAT_TOTAL_VRAM_B_WRITES       ;/
  10400088h  GPU_STAT_POLYGON_ARRAY_READS       ;-ATTR_BUF, INDEX_LIST
  1040008Ch  GPU_STAT_POLYGON_TEXTURE_READS     ;-cache misses only
  10400090h  GPU_STAT_POLYGON_DEPTHBUFFER_READS
  10400094h  GPU_STAT_POLYGON_DEPTHBUFFER_WRITES
  10400098h  GPU_STAT_POLYGON_COLORBUFFER_READS
  1040009Ch  GPU_STAT_POLYGON_COLORBUFFER_WRITES
  104000A0h  GPU_STAT_LCD_UPPER_SCREEN_READS    ;\for both left+right buffer
  104000A4h  GPU_STAT_LCD_LOWER_SCREEN_READS    ;/
  104000A8h  GPU_STAT_MEMCOPY_SRC_READS         ;\GPU_MEMCOPY
  104000ACh  GPU_STAT_MEMCOPY_DST_WRITES        ;/
  104000B0h  GPU_STAT_MEMFILL_0_DST_WRITES      ;\GPU_MEMFILL 0/1
  104000B4h  GPU_STAT_MEMFILL_1_DST_WRITES      ;/
  104000B8h  GPU_STAT_CPU_READS_FROM_VRAM_A_B   ;\counted by GPU because the
  104000BCh  GPU_STAT_CPU_WRITES_TO_VRAM_A_B    ;/GPU must forward vram to cpu
```



## 104000C4h - GPU\_BASE\_ADDR\_VRAM\_A (reset=18000000h) (R/W)



## 104000C8h - GPU\_BASE\_ADDR\_VRAM\_B (reset=18300000h) (R/W)


```
  0-31  Base address for VRAM_A/B blocks (0..FFFFFFFFh) (any alignment needed?)
```

The 3DS contains two 3MByte VRAM blocks (ie. 6Mbyte in total). These registers
allow to swap the base address of those two blocks, or to map them to other
locations within the following 12Mbyte region:

```
  18000000h..182FFFFFh  Usually VRAM_A (3Mbyte)
  18300000h..185FFFFFh  Usually VRAM_B (3Mbyte)
  18600000h..18BFFFFFh  Usually empty/zerofilled (6Mbyte)
```

Trying to map VRAM outside of that 12Mbyte region might work, but the ARM CPU
will trigger data aborts when trying to access that memory.



## 104000C0h - GPU\_BACKLIGHT\_OR\_SO\_1 (reset=20000000h) (R/W)



## 104000CCh - GPU\_BACKLIGHT\_OR\_SO\_2 (reset=20000000h) (R/W)


```
  0-31  Unknown (0..FFFFFFFFh)
```

Reportedly 104000C0h does "Writes 0 to allow backlights to turn off, 20000000h
to force them always on."

Unknown what that means. Default is 20000000h (and backlights CAN be switched
off in that state). Maybe "allow" means that they can switch off
automatically... upon GPU inactivity... or upon blank screen... or upon screen
saver timeouts... or whatever? Or maybe 20000000h is FCRAM base, completely
unrelated to backlights?

Note: Setting [104000C0h] or [104000CCh] to zero can cause [10400040h] to get
nonzero.



## 104000D0h - GPU\_UNKNOWN\_4BIT (reset=0) (R/W)


```
  0-3   Unknown (0..0Fh)
  4-31  Unused (0)
```




# <a name="3dsgpuexternalregisterstopbottomscreenandframebuffersetup"></a>3DS GPU External Registers - Top/Bottom Screen and Framebuffer Setup



104004xxh = Framebuffer Setup "PDC0" (top screen)

104005xxh = Framebuffer Setup "PDC1" (bottom screen)

PDC = "PICA Display Control" or so?



## Top/Bottom Screen Setup Register Summary


```
  10400400h/10400500h 4   V-Total-1                 ;1C2h       ;\
  10400404h/10400504h 4   V-Lower-border-end        ;0D1h       ;
  10400408h/10400508h 4   V-Upper-border-middle     ;1C1h       ;
  1040040Ch/1040050Ch 4   V-Upper-border-end        ;1C1h       ; V
  10400410h/10400510h 4   V-Sync-start              ;000h/0CDh  ;
  10400414h/10400514h 4   V-Sync-end                ;0CFh       ;
  10400418h/10400518h 4   V-Lower-border-start      ;0D1h       ;
  1040041Ch/1040051Ch 2   V-IRQ-start               ;1C1h       ;
  1040041Eh/1040051Eh 2   V-IRQ-end                 ;1C5h       ;/
  10400420h/10400520h 2   V-Pre-padding fetch start?;000h       ;\V
  10400422h/10400522h 2   V-??   ;must be <=1C2h    ;001h       ;/
  10400424h/10400524h 4   H-Total-1                 ;19Dh       ;\
  10400428h/10400528h 4   H-Left-border-end         ;002h/052h  ;
  1040042Ch/1040052Ch 4   H-Right-border-middle     ;192h       ;
  10400430h/10400530h 4   H-Right-border-end        ;192h       ; H
  10400434h/10400534h 4   H-Sync-Start              ;192h/04Fh  ;
  10400438h/10400538h 4   H-Sync-End                ;001h/050h  ;
  1040043Ch/1040053Ch 4   H-Left-border-start       ;002h/052h  ;
  10400440h/10400540h 2   H-IRQ-start (or end)      ;192h       ;
  10400442h/10400542h 2   H-IRQ-end (or start)      ;193h       ;/
  10400444h/10400544h 4   V-Increment-H             ;000h       ;-V
  10400448h/10400548h 4   Screen Vsync/Hsync type
  1040044Ch/1040054Ch 4   Screen Border color
  10400450h/10400550h 4   V-Current position (R)
  10400454h/10400554h 4   H-Current position (R)
  10400458h/10400558h 04h Unused (0)
  1040045Ch/1040055Ch 2   V-Picture size            ;0F0h       ;-V
  1040045Eh/1040055Eh 2   H-Picture size (no effect);190h/140h  ;-H
  10400460h/10400560h 2   V-Lower-border-middle     ;0D1h       ;\V
  10400462h/10400562h 2   V-Upper-border-start      ;1C1h       ;/
  10400464h/10400564h 2   H-Left-border-middle      ;002h/052h  ;\H
  10400466h/10400566h 2   H-Right-border-start      ;192h       ;/
  10400468h/10400568h 4   Framebuffer 0 address for Left eye (or both eyes)
  1040046Ch/1040056Ch 4   Framebuffer 1 address for Left eye (or both eyes)
  10400470h/10400570h 4   Framebuffer format
  10400474h/10400574h 4   Interrupt type
  10400478h/10400578h 4   Framebuffer Select and Request/Ack
  1040047Ch/1040057Ch 4   Screen Status flags (R)
  10400480h/10400580h 4   Color Lookup Table index (R/W)
  10400484h/10400584h 4   Color Lookup Table data (R/W)
  10400488h/10400588h 08h Unused (0)
  10400490h/10400590h 4   Framebuffer Horizontal Address Step
  10400494h/10400594h 4   Framebuffer 0 address for Right eye (or unused
  10400498h/10400598h 4   Framebuffer 1 address for Right eye (or unused
  1040049Ch/1040059Ch 2   V-Latching-Point          ;000h       ;-V
  1040049Eh/1040059Eh 2   H-Latching-Point          ;192h       ;-H
  104004A0h/104005A0h 60h Unused (0)
```

Most of the registers do have internal copies (the H/V registers, and Border
color, and maybe some others), changing these registers doesn't have any effect
on the visible picture & timings - until reaching the H/V-Latching Point
(which does forward the registers to their internal copies).


```
 __________________________ Control/Status Registers __________________________
```



## 10400474h/10400574h - Interrupt Type (R/W)


```
  0      Display Enable (should be 1) (0=Off/screen fades out, 1=On/normal)
  1-7    Unused (0)
  8-10   Interrupt Mode (5=OncePerFrame, 7=None, 0..4,6=Special) (see below)
  7-11   Unused (0)
  16     Unknown...?    (0=???, 1=Normal)
  17-31  Unused (0)
```

The default is Interrupt Mode 5 (which acts as normal framerate interrupt).

Interrupt Mode 0,1,2,3 do require manually acknowledging/requesting the next
IRQ via Request register bit18 (and bit17 in some cases).

```
  Interrupt Mode 0:
  - Triggers here or there depending on H/V settings
  Interrupt Mode 1:
  - Triggers at V=[10400544h], H=[10400540h]               ;irq point
  - Triggers at V=[10400504h], H=[10400528h]..[10400566h]  ;picture area
  Interrupt Mode 2:
  - Triggers here or there depending on H/V settings
  Interrupt Mode 3:
  - Triggers at V=[10400504h], H=[10400528h]..[10400566h]  ;picture area
  Interrupt Mode 4 (in selected H's)
  - Triggers at V=[1040051Ch], and H=[10400542h]..[10400540h]
  Interrupt Mode 5 (framerate interrupt, usually at H=Hblank)
  - Triggers at V=[10400544h] and H=[10400540h]
  Interrupt Mode 6 (once on every H)
  - Triggers at V=[1040051Ch], and H=any
  Interrupt Mode 7 (interrupts disabled)
  - Doesn't trigger any IRQs.
```

For all IRQ H/V timings, mind that the display is drawn from left to right
(unlike normal top-to-bottom displays).

Note: Most of the H positions do actually trigger at H+1 (and perhaps similar
for V positions, though those are more difficult to measure).



## 10400478h/10400578h - Framebuffer Select and Request/Ack (R/W)


```
  0      Display Framebuffer (0=Buffer 0, 1=Buffer 1)
  1-3    Unused (0)
  4      Request STAT.bit4 to get triggered (0=No, 1=Request/Busy)
  5-7    Unused (0)
  8      Unknown...?   (0=Normal, 1=???)
  9-15   Unused (0)
  16     Unknown...?   (0=Normal, 1=???)
  17     Unknown...?   (0=Normal, 1=???, set in bootrom IRQ handler, but why?)
  18     Acknowledge STAT.bit15? resurrect after ONESHOT irq (unless,
           bit18/ack works ONLY if OUTSIDE of display area?)
  19-31  Unused (0)
```

Apart from bit0, all bits in the register are kind of "Request/Busy" flags (and
get cleared once when the request is handled).

```
  bit4:          cleared at H=[10400540h]..[10400542h]
  bit8,16,17,18: cleared after a handful of clock cycles
```

Request.bit4 does soemhow relate to the framebuffer selection in bit0 (see
STAT.bit4 for details)... Guess: maybe bit4 prevents bit0 from being internally
applied until hblank?



## 1040047Ch/1040057Ch - Screen Status flags (R)


```
  0      H-IRQ-area, when H=[10400540h]..[10400542h]
  1      V-IRQ-area, when H=[1040051Ch]..[1040051Eh]
  2-3    Unused (0)
  4      Can get set if [10400578h].bit4=1, and depending on [10400578h].bit0:
           if [10400578h].bit4=0: at H=[10400540h]..[10400528h]  ;ONCE
           if [10400578h].bit4=1: at H=[10400528h]..FOREVER      ;FOREVER
           that, happening at V=[10400544h] (in both of the above two cases)
           note: ONCE means that the bit goes ON-and-OFF once (and stays off)
           note: FOREVER means that the bit goes ON (and stays on)
  5-7    Unused (0)
  8      H-Sync,    H=[10400534h]..[10400538h]
  9      H-Blank,   H=[10400530h]..[1040053Ch] (between borders)
  10     H-Picture, H=[10400528h]..[10400566h] (between borders)
  11     Unused (0)
  12     V-Sync,    H=[10400510h]..[10400514h]
  13     V-Blank,   H=[1040050Ch]..[10400518h] (between borders)
  14     V-Picture, H=[10400504h]..[10400562h] (between borders)
  15     Normally 0, but can be set, if interrupts enabled IRQ request?
           bit15: set at H/V-picture start, sticky bit?
           but, WHY is bit15 is never set with bootrom default settings?
           related to 1040059Ch,1040059Eh !!!
  16-31  Unused (0)
```



## 10400448h/10400548h - Screen Vsync/Hsync type (R/W)


```
  0      Seems to disable HSync (or Vsync?), or sync mode/polarity or so?
  1-7    Unused (0)
  8      Seems to disable VSync (or Hsync?), or sync mode/polarity or so?
  9-31   Unused (0)
```

Should be 00h/11h for top/bottom screen. Maybe selects using /SYNC signals or
types like "DE only" with sync on Display Enable? The pinout for bottom screen
is said to include /HSYNC and /VSYNC pins. The pinout for top screen is
unknown.


```
 ___________________________ Framebuffer Registers ___________________________
```



## 10400468h/10400568h - Framebuffer 0 address for Left eye (or both eyes)



## 1040046Ch/1040056Ch - Framebuffer 1 address for Left eye (or both eyes)



## 10400494h/10400594h - Framebuffer 0 address for Right eye (or unused)



## 10400498h/10400598h - Framebuffer 1 address for Right eye (or unused)


```
  0-3    Unused (0)
  4-31   Address, in 16-byte units
```



## 10400490h/10400590h - Framebuffer Horizontal Address Step (R/W)


```
  0-3    Unused (0)
  4-31   Address step, in 16-byte units (usually 3Ch, aka 240pix*4byte/16)
```



## 10400470h/10400570h - Framebuffer format (R/W)


```
  0-2    Framebuffer RGBA Format (0=8888, 1=8880, 2=5650, 3=5551, 4..?=4444)
           Note: The alpha in RGBA types is just skipped/ignored.
  3      Unused (0)
  4-5    Horizontal Zoom (0=Normal/HiRes, 1=Double/LowRes, 2/3=LeftRightBuffer)
  6      Vertical Zoom   (0=Normal/HiRes, 1=Double/LowRes)
  7      Unused (0)
  8-9    Unknown (0..3) (should be 0)
           00h = Normal (should be normally used)
           01h = Unknown "get rid of rainbow strip on top of screen" uh? mess!
           02h = Unknown                (actually distorted display?)
           03h = Unknown "black screen" (actually normal display?)
  10-15  Unused (0)
  16-31  Unknown (0..FFFFh) (should be 8)
            (FFFFh=slow horizontal drawing?)
            maybe... dotclk divider (and perhaps multiplier in other bits)
            hmmm, but, very large values cause vram-misaddressing?
```

Obscure Color Format Notes:

Color components are laid out in reverse byte order, with the most significant
bits used first (ie. non-24bit pixels are stored as a little-endian values).
For instance, a raw data stream of two GL\_RGB565\_OES pixels looks like GGGBBBBB
RRRRRGGG GGGBBBBB RRRRRGGG. uh, that are TWO pixels, but which one is shown
first/bottom? uh, and that's for non-24bit, so, how does 24bit look like?


```
 ______________________________ Color Registers  ______________________________
```



## 10400480h/10400580h - Color Lookup Table index (R/W)


```
  0-7    Index        ;reportedly write-only (uh, but actually, it is R/W)
  8-31   Unused (0)
```



## 10400484h/10400584h - Color Lookup Table data (R/W)


```
  0-7    Red[index]  ;\
  8-15   Green[index]; is that always RGB, or could it be swapped to BGR or so?
  16-23  Blue[index] ;/
  24-31  Unused (0)
```

Contains the value of the color lookup table indexed by the above register.
Accessing this register will increase the index register by one.

For RGBA 8888/8880, the table should be usually filled with linear increasing
values: 000000h, 010101h, 020202h, 030303h, .., FFFFFFh. Or alternately with
non-linear values if the displays require 'gamma' adjustments.

Unknown which indices are used in RGBA 5650, 5551, and 4444 modes.



## 1040044Ch/1040054Ch - Screen Border color (R/W)


```
  0-7    Red    (00h..FFh)
  8-15   Green  (00h..FFh)
  16-23  Blue   (00h..FFh)
  24-31  Unused (0)
```

The screen border isn't used for fullscreen pictures, but it could be used if
the picture is smaller than the actual screen. To disable the border, set
border start/end registers to the same value.

There are also "border middle" registers (with unknown purpose and without
visible effect, except, the middle values for vertical border MUST be within
border start/end range, otherwise the screen dies with fading out).


```
 _______________________________ H/V-Registers _______________________________
```



## Vertical Position Registers


```
  10400444h/10400544h 4   V-Increment-H             ;000h
  1040049Ch/1040059Ch 2   V-Latching-Point          ;000h
  10400420h/10400520h 2   V-Pre-padding fetch start?;000h
  10400422h/10400522h 2   V-??   ;must be <=1C2h    ;001h
  10400410h/10400510h 4   V-Sync-start              ;000h/0CDh
  10400414h/10400514h 4   V-Sync-end                ;0CFh
  10400418h/10400518h 4   V-Lower-border-start      ;0D1h
  10400460h/10400560h 2   V-Lower-border-middle     ;0D1h
  10400404h/10400504h 4   V-Lower-border-end        ;0D1h
  1040045Ch/1040055Ch 2   V-Picture size            ;0F0h
  10400462h/10400562h 2   V-Upper-border-start      ;1C1h
  10400408h/10400508h 4   V-Upper-border-middle     ;1C1h
  1040040Ch/1040050Ch 4   V-Upper-border-end        ;1C1h
  1040041Ch/1040051Ch 2   V-IRQ-start               ;1C1h
  1040041Eh/1040051Eh 2   V-IRQ-end                 ;1C5h
  10400400h/10400500h 4   V-Total-1                 ;1C2h
  10400450h/10400550h 4   V-Current position (R)    ;000h..1C2h
```

These are usually using same values for top/bottom screen (with 240pix height
each), except that Nintendo has used different Sync length for some reason.



## Horizontal Position Registers


```
  10400434h/10400534h 4   H-Sync-Start              ;192h/04Fh
  10400438h/10400538h 4   H-Sync-End                ;001h/050h
  1040043Ch/1040053Ch 4   H-Left-border-start       ;002h/052h
  10400464h/10400564h 2   H-Left-border-middle      ;002h/052h
  10400428h/10400528h 4   H-Left-border-end         ;002h/052h
  1040045Eh/1040055Eh 2   H-Picture size (no effect);190h/140h
  10400466h/10400566h 2   H-Right-border-start      ;192h
  1040042Ch/1040052Ch 4   H-Right-border-middle     ;192h
  10400430h/10400530h 4   H-Right-border-end        ;192h
  1040049Eh/1040059Eh 2   H-Latching-Point          ;192h
  10400440h/10400540h 2   H-IRQ-start (or end)      ;192h
  10400442h/10400542h 2   H-IRQ-end (or start)      ;193h
  10400424h/10400524h 4   H-Total-1                 ;19Dh
  10400454h/10400554h 4   H-Current position (R)    ;000h..19Dh
```

These are using the same Htotal for top/bottom screen, but different
picture/blanking widths (for top/bottom screens with 400pix/320pix width). The
top screen does also support a 800pix hires mode (which should use double
Htotal, and adjust other registers accordingly).


Note: The values in the H/V registers are 12bit wide, 0..FFFh (the upper
4bit/20bit of the 16bit/32bit registers are unused, always zero).


Wrong H/V values may cause various effects - which may differ depending on the
display type. New3DS bottom screen tends to output a stable image (with fading
upper/right areas if it is too small), or no picture at all (with whole screen
fading). However, other screens are said to lose sync or misalign lines and
such stuff.


Setting the V-pre-padding bigger than V-lower-border end causes the bottom-most
picture lines to display the most recent pixel color instead of fetching new
pixels from VRAM. A Similar effect occurs in upper picture area when setting
V-picture-size too small.


```
 _________________________________ Misc Notes _________________________________
```



## Framebuffers


These LCD framebuffers normally contain the last rendered frames from the GPU.
The framebuffers are drawn from left-to-right, instead of top-to-bottom. Thus
the beginning of the framebuffer is drawn starting at the left side of the
screen.


Both of the 3D screen left/right framebuffers are displayed regardless of the
3D slider's state, however when the 3D slider is set to "off" the 3D effect is
disabled. Normally when the 3D slider's state is set to "off" the left/right
framebuffer addresses are set to the same physical address. When the 3D effect
is disabled and the left/right framebuffers are set to separate addresses, the
LCD seems to alternate between displaying the left/right framebuffer each
frame.

Uh, it can alternate left/right buffers each frame? I have NEVER seen that
effect when testing register settings (and it would have caused massive flicker
because I didn't had initialized the right buffer). What it can do is alternate
left/right buffer after each pixel horizontally (including on bottom screen).



## Init Values from nngxInitialize for Top Screen


Unknown if below values are "better" than bootrom, or if they are typos.

```
  10400400h = 1C2h
  10400404h = D1h
  10400408h = 1C1h
  1040040Ch = 1C1h
  10400410h = 0
  10400414h = CFh
  10400418h = D1h
  1040041Ch = 1C501C1h
  10400420h = 10000h
  10400424h = 19Dh
  10400428h = 2
  1040042Ch = 1C2h ??? ;bootrom: 192h ?
  10400430h = 1C2h ??? ;bootrom: 192h ?
  10400434h = 1C2h ??? ;bootrom: 192h ?
  10400438h = 1
  1040043Ch = 2
  10400440h = 1960192h ;bootrom: 1930192h ?
  10400444h = 0
  10400448h = 0
  1040045Ch = 19000F0h   ;msbs=width=400, lsbs=height=240
  10400460h = 1C100D1h
  10400464h = 1920002h
  10400470h = 80340h   ;bootrom: 80040h ?
  1040049Ch = 0        ;bootrom: 1920000h ?
```



## More Init Values from nngxInitialize for Top Screen


```
  10400468h = 18300000h  ;\later changed by GSP module when updating state,
  1040046Ch = 18300000h  ;/framebuffer
  10400494h = 18300000h
  10400498h = 18300000h
  10400478h = 1          ;-doesn't stay 1, read as 0
  10400474h = 10501h
```

Reportedly 10400478h/10400578h.bit0 "doesn't stay 1, read as 0", uh, actually
that applies for ALL OTHER bits in that register, but NOT for bit0.



## Further Registers


Apart from above GPU registers, the screens do also need initialization of the
"LCD" registers,

- [3DS Video LCD Registers](#3dsvideolcdregisters)
plus, initialization of whatever I2C registers for each screen. Plus some
MCU/I2C registers for backlight or so.




# <a name="3dsgpuexternalregistersmemfillandmemcopy"></a>3DS GPU External Registers - Memfill and Memcopy



```
 ________________________________ Memory Fill ________________________________
```



## 10400010h/10400020h - GPU\_MEMFILL\_DST\_ADDR0/1 - Memfill 0/1 Start Address



## 10400014h/10400024h - GPU\_MEMFILL\_DST\_END0/1 - Memfill 0/1 End Address


```
  0      Unused (0)
  1-28   Physical Memory Address, in 16-byte units
  29-31  Unused (0)
```



## 10400018h/10400028h - GPU\_MEMFILL\_DATA0/1 - Memfill 0/1 Fill Value


```
  0-31   Fill Value
```



## 1040001Ch/1040002Ch - GPU\_MEMFILL\_CNT0/1 - Memfill 0/1 Control


```
  0      Start/Busy   (0=Idle/Ready, 1=Start/Busy)                        (R/W)
  1      Ready IRQ    (0=No, 1=Ready, IRQ 28h/29h) (write 0 to clear)   (R/ack)
  2-7    Unused (0)
  8-9    Fill-width   (0=16bit, 1=24bit, 2=32bit, 3=Same as 1)            (R/W)
  10-15  Unused (0)
  16-20  Unknown, 5bit, R/W                                               (R/W)
  21-31  Unused (0)
```

A memory fill is triggered by setting bit0 in the control register. Doing so
aborts any running memory fills on that filling unit. Upon completion, the
hardware clears bit0 and sets bit1 and fires interrupt PSC0/PSC1 (IRQ 28h/29h).


```
 ________________________________ Memory Copy ________________________________
```



## 10400C00h - GPU\_MEMCOPY\_SRC\_ADDR - Memcopy Input physical address (R/W)



## 10400C04h - GPU\_MEMCOPY\_DST\_ADDR - Memcopy Output physical address (R/W)


```
  0      Unused (0)
  1-28   Physical Memory Address, in 16-byte units
  29-31  Unused (0)
```



## 10400C08h - GPU\_MEMCOPY\_DISPLAY\_SIZE - DisplayTransfer width/height(R/W)


```
  0-2    Unused (0)
  3-15   Input Height (in 8-pixel units, usually 240/8 for 3DS)
  16-18  Unused (0)
  19-31  Input Width  (in 8-pixel units, usually 320/8 or 400/8 for 3DS)
```

Input size before downscale (the output size is the same, unless downscale was
used).



## 10400C0Ch - GPU\_MEMCOPY\_DISPLAY\_GAP - DisplayTransfer Input height+gap (R/W)


```
  0-2    Unused (0)
  3-15   Input Height+Gap (in 8-pixel units, usually (240+0)/8 for 3DS)
  16-31  Unused (0)
```

Allows to skip input pixels, used only if GPU\_MEMCOPY\_FLAGS.bit2=1.



## 10400C10h - GPU\_MEMCOPY\_FLAGS - Memcopy Transfer flags (R/W)


```
  0      Horizontal Flip    (0=Normal, 1=Mirror)
  1      Conversion Mode    (0=TiledToLinear, 1=LinearToTiled)
  2      Input Gap          (0=Use raw height, 1=Use height+gap)
  3      Copy Mode          (0=DisplayCopy/Pixels, 1=TextureCopy/RawBytes)
  4      Unused (0)
  5      Conversion Disable (0=Convert as specified in bit1, 1=TiledToTiled)
  6-7    Unused (0)
  8-10   Input RGBA Format  (0=8888, 1=8880, 2=5650, 3=5551, 4..7=4444)
  11     Unused (0)
  12-14  Output RGBA Format (0=8888, 1=8880, 2=5650, 3=5551, 4..7=4444)
  15     Unused (0)
  16     Block Tiling Size  (0=Normal/8x8 pixels, 1=32x32 pixels)
  17-23  Unused (0)
  24-25  Output Downscale   (0=No, 1=Height/2, 2=WidthAndHeight/2, 3=Invalid)
  26-31  Unused (0)
```

The transfer hangs on some Input/Output RGBA combinations:

```
  32bit Input (8888) works with all output formats
  24bit Input (8880) works only if output is also 24bit
  16bit Input (5650/5551/4444) works only if output is also 16bit
```



## 10400C14h - GPU\_MEMCOPY\_UNKNOWN\_21BIT - Memcopy (R/W)


```
  0-20   Unknown, R/W
  21-31  Unused (0)
```

"GSP module writes value 0 here prior to writing to 10400C18h, for cmd3."



## 10400C18h - GPU\_MEMCOPY\_CNT - Memcopy Start/Busy (R/W)


```
  0      Start/Busy (0=Idle/Ready, 1=Start/Busy)                          (R/W)
  1-7    Unused (0)
  8      Ready IRQ  (0=No, 1=Ready, "PPF" IRQ 2Ch) (write 0 to clear)   (R/ack)
  9-31   Unused (0)
```

Caution: Polling this register can HANG the ARM11 CPU at end of transfer; when
using polling, it's better to wait for GPU\_STAT\_IRQ\_FLAGS.bit30=1.



## 10400C1Ch - GPU\_MEMCOPY\_REMAIN\_IRQ - Memcopy Remain IRQ (R/W)


```
  0-13   Transfer IRQ position (compare value for below remain counter)   (R/W)
  14-15  Unused (0)
  16-29  Transfer width remain, in 4-pixel units (3FFEh..0, or 3FFFh=done)  (R)
  30-31  Unused (0)
```

The IRQ position should be set to 3FFFh for triggering IRQ flag at transfer
end, otherwise the IRQ would trigger before completion (or never at all).

Example: For width=320pix, remain goes through 4Fh..00h, and does then wrap to
3FFFh.

The 4-pixel unit might be due to decreasing the counter upon both reading &
writing 8-pixel chunks.

Used for DisplayTransfer. And maybe also for TextureCopy?



## 10400C20h - GPU\_MEMCOPY\_TEX\_SIZE - TextureCopy total amount


```
  0-3    Unused (0)
  4-31   Total amount of data to copy, in 16-byte units
```



## 10400C24h - GPU\_MEMCOPY\_TEX\_SRC\_WIDTH - TextureCopy input line width/gap



## 10400C28h - GPU\_MEMCOPY\_TEX\_DST\_WIDTH - TextureCopy output line width/gap


```
 For SRC_WIDTH:
  0-15   Width, in unknown units (maybe 16-byte units, same as below?)
  16-31  Gap, in 16-byte units
 For DST_WIDTH:
  0-31   Width and Gap (probably same 2x16bit format as for above SRC_WIDTH)
```



## 10400C2Ch - GPU\_MEMCOPY\_UNKNOWN\_FLAG - Memcopy Unknown (R/W)


```
  0      Unknown, R/W
  1-31   Unused (0)
```



## Notes...


"The DisplayTransfer registers are only used if FLAGS.bit3=0 and ignored
otherwise. The TextureCopy registers are "likewise" only used if FLAGS.bit3=1,
and ignored otherwise."



## TextureCopy


When FLAGS.bit3=1, the hardware performs a TextureCopy-mode transfer. In this
mode, all other bits of that register are ignored (except for FLAGS.bit2, which
still needs to be set correctly?), and no format conversions are done.

Instead, it performs a raw data copy from the source to the destination, but
with a configurable gap between lines. The total amount of bytes to copy is
specified in the size register, and the hardware loops reading lines from the
input and writing them to the output until this amount is copied. The "gap"
specified in the input/output dimension register is the number of chunks to
skip after each "width" chunks of the input/output, and is NOT counted towards
the total size of the transfer.


By correctly calculating the input and output gap sizes it is possible to use
this functionality to copy arbitrary sub-rectangles between differently-sized
framebuffers or textures, which is one of its main uses over a regular
no-conversion DisplayTransfer. When copying tiled textures/framebuffers it's
important to remember that the contents of a tile are laid out sequentially in
memory, and so this should be taken into account when calculating the transfer
parameters.


Specifying invalid/junk values for the TextureCopy dimensions can result in the
GPU hanging while attempting to process this TextureCopy.




# <a name="3dsgpuinternalregisteroverview"></a>3DS GPU Internal Register Overview




## Aliases


It is possible for multiple register (sequential) IDs to correspond to the same
register. This is done to leverage the consecutive writing mode for GPU
commands, which makes it possible for a single command to write data to
multiple sequential register IDs. For example, register IDs 02C1 through 02C8
all correspond to GPUREG\_VSH\_FLOATUNIFORM\_DATAi so that a consecutively writing
command based at 02C0 will write its first parameter to
GPUREG\_VSH\_FLOATUNIFORM\_INDEX and ever subsequent ones to
GPUREG\_VSH\_FLOATUNIFORM\_DATAi



## Data Types


```
  signed          Signed integer
  unsigned        Unsigned integer
  floatX.Y.Z      Floating-point number with X sign bits, Y exponent bits,
                    and Z mantissa bits
  fixedX.Y.Z      Fixed-point number with X sign bits, Y integer bits,
                    and Z fractional bits
```


float1.5.10  (16bit)

float1.7.12  (20bit) (uncommon, for light attentuation)

float1.7.16  (24bit)

float1.8.23  (32bit)

float1.7.24  (32bit) (uncommon, for viewport)




# <a name="3dsgpuinternalregisterscommandlists"></a>3DS GPU Internal Registers - Command Lists



Commands (aka GPU registers writes) can be done by manually writing parameters
to register 10401000h-10401FFFh, or by using command lists.

With the command lists, the GPU does automatically read parameters and command
numbers from memory (and automatically pauses reading when it is busy).



## 104018E8h - PICA(023Ah) - GPUREG\_CMDBUF\_ADDR0 (aka entrypoint) (R/W)



## 104018ECh - PICA(023Bh) - GPUREG\_CMDBUF\_ADDR1 (aka entrypoint) (R/W)


```
  0      Unused (0)
  1-28   Physical address of 1st/2nd command buffer, in 16-byte units
```



## 104018E0h - PICA(0238h) - GPUREG\_CMDBUF\_SIZE0 (R/W)



## 104018E4h - PICA(0239h) - GPUREG\_CMDBUF\_SIZE1 (R/W)


The size value is required to indicate the end of the command list
(alternately, if GPUREG\_IRQ\_AUTOSTOP is enabled, command list execution will
also terminate when triggering an IRQ via FINALIZE command; which is usually
stored at end of command list).

```
  0      Unused (0)
  1-20   Size of command buffer, in 16-byte units
```

Observe that commands are multiples of 8 bytes (so one may need to append a
dummy 8-byte command for the 16-byte size boundary; unknown if there's a NOP
command for that purpose; reportedly FINALIZE command(s) are used for padding,
though that could trigger multiple IRQs when GPUREG\_IRQ\_AUTOSTOP is disabled).



## 104018F0h - PICA(023Ch) - GPUREG\_CMDBUF\_JUMP0 (jump to ADDR0) (W)



## 104018F4h - PICA(023Dh) - GPUREG\_CMDBUF\_JUMP1 (jump to ADDR0) (W)


```
  0-31   Don't care (writing any value starts CMDBUF execution, at ADDR0/1)
```

Executes the Command List, starting at CMDBUF\_ADDR0/1, until reaching
CMDBUF\_SIZE0/1 (or until FINALIZE+AUTOSTOP).


Unknown why there are two command lists, supposedly they cannot execute
simultaneously... maybe the second list is automatically started at the end of
the other list?



## Command List entries


Each entry in the command list does contain a "Command Header", and one or more
parameter words, the entry size must be a multiple of 8 bytes.

```
  00h 4   1st Parameter word
  04h 4   Command Header (see below)
  08h 4   2nd Parameter word (if any)
  0Ch 4   3rd Parameter word (if any)
  ... ..  Nth Parameter word (if any)
  xxh 4   Padding (zero) (if above wasn't a multiple of 8 bytes)
```

Command Header:

```
  0-15    Command ID, PICA(0000h..03FFh)
  16      Parameter mask, update parameter bit0-7   (0=Don't change, 1=Write)
  17      Parameter mask, update parameter bit8-15  (0=Don't change, 1=Write)
  18      Parameter mask, update parameter bit16-23 (0=Don't change, 1=Write)
  19      Parameter mask, update parameter bit24-31 (0=Don't change, 1=Write)
  20-27   Number of parameter words-1 (0..FFh = 1..256 parameter words)
  28-30   Unused
  31      Consecutive writing mode (0=Fixed Command number, 1=Increasing)
```




# <a name="3dsgpuinternalregistersfinalizeinterruptregisters"></a>3DS GPU Internal Registers - Finalize Interrupt registers




## 10401000h+i - PICA(N/A) - GPUREG\_IRQ\_ACK(0..63) (R/W)



## 10401040h+i - PICA(0010h..001Fh) - GPUREG\_IRQ\_REQ(0..63) (R/W)



## 10401080h+i - PICA(N/A) - GPUREG\_IRQ\_CMP(0..63) (R/W)


```
  0-7     Request/Compare Byte for IRQ#0   ;\
  8-15    Request/Compare Byte for IRQ#1   ; triggers "P3D" IRQ 2Dh if any
  16-23   Request/Compare Byte for IRQ#2   ; of the request/compare bytes
  ..      ..                               ; are same (and enabled in MASK)
  504-511 Request/Compare Byte for IRQ#63  ;/
```

The ACK registers are basically mirrors of the REQ registers (and ARM11 could
write either one, causing IRQ acknowledge or request depending on whether the
written value does match the CMP compare bytes). However, there are at least
two small differences between ACK and REQ registers:

```
  GPU command list's can only write to GPUREG_IRQ_REQ
  ARM11 reads from GPUREG_IRQ_REQ cause ARM11 to wait if GPU is busy
```

Normally, CMP contains constant values, and REQ/ACK are changed to
same/different values when requesting/releasing interrupt requests.



## 104010C0h - PICA(N/A) - GPUREG\_IRQ\_MASK\_LOW (R/W)



## 104010C4h - PICA(N/A) - GPUREG\_IRQ\_MASK\_HIGH (R/W)


```
  0-63   Interrupt Disable flags for IRQ#0..63   (0=Enable, 1=Disable)
```



## 104010C8h - PICA(N/A) - GPUREG\_IRQ\_STAT\_LOW (R)



## 104010CCh - PICA(N/A) - GPUREG\_IRQ\_STAT\_HIGH (R)


```
  0-63   Interrupt Compare flags for IRQ#0..63   (0=Mismatch, 1=Match/IRQ)
```



## 104010D0h - PICA(N/A) - GPUREG\_IRQ\_AUTOSTOP (R/W)


```
  0      Autostop upon REQ=CMP match  (0=IRQ only, 1=IRQ and Stop cmdlist)
  1-31   Unused (0)
```



## 104010D4h - PICA(N/A) - GPUREG\_FIXED\_00010002h (R)


```
  0-31   Unknown, readonly, always 00010002h (some status, or chip id or so?)
```

Maybe related: Port 10400000h contains the same 00010002h readonly value.



## Notes


Nintendo uses the IRQ registers to trigger a "FINALIZE" interrupt at end of
command list, done as so:

```
  GPUREG_IRQ_MASK_LOW=FFFFFFF0h set upon GPU init  ;\enable first four IRQs
  GPUREG_IRQ_MASK_HIGH=FFFFFFFFh set upon GPU init ;/
  GPUREG_IRQ_AUTOSTOP=1                            ;-autostop cmdlist upon IRQ
  GPUREG_IRQ_CMP(0)=12345678h set upon GPU init    ;-first four compare values
  GPUREG_IRQ_ACK(0)=00000000h set upon GPU init and before cmdlist
  GPUREG_IRQ_REQ(0)=12345678h set via PICA(0010h) FINALIZE at end of cmdlist
```

Due to the 32bit writes, that will actually trigger four byte-matches at once.

Caution:

The GPU command list can write to GPUREG\_IRQ\_REQ(n), but all other registers in
range PICA(0000h..003Fh) are writeable by CPU only, not via command lists.




# <a name="3dsgpuinternalregistersgeometrypipelineregisters"></a>3DS GPU Internal Registers - Geometry Pipeline registers




## 10401978h - PICA(025Eh) - GPUREG\_PRIMITIVE\_CONFIG (R/W)


```
  0-3    Number of vertex shader output map registers - 1        ;see OUTMAP
  8-9    Primitive mode (0=Tri's, 1=Tri-Strip, 2=Tri-Fan, 3=Geometry primitive)
  16     UNKNOWN (R/W)
         __       __ ___          __ __ __
   /\   | /     /| /\  /\        /\ | / .'\    ?????????
  /__\  |/     /_|/__\/__\      /__\|/.'___\   ?????????
  0=Triangles, 1=TriangleStrip, 2=TriangleFan, 3=Geometry primitive
```



## 1040197Ch - PICA(025Fh) - GPUREG\_RESTART\_PRIMITIVE (R/W)


```
  0-31   UNKNOWN, usually 1 (writing any value works... but value is R/W)
```

Used to terminate a triangle strip/fan (eg. to start a new strip, instead of
appending further vertices to the old strip) (note: the restart must be issued
at BEGIN of each strip/fan, not at the end).

Restart occurs on writing any value... but the written value is R/W, so it
might have some purpose?


```
 __________________________ Vertex Attribute Arrays ___________________________
```


ATTR\_BUF arrays contain vertex attributes (such like coordinates and colors).
The GPU can automatically transfer data from these arrays to the shader unit
(which does then forward the data to the drawing hardware).

There are up to 12 arrays for up to 12 attributes (one can either store
multiple attributes in one single array, or store different attributes in
separate arrays).



## 10401804h - PICA(0201h) - GPUREG\_ATTR\_BUF\_FORMAT\_LOW (R/W)



## 10401808h - PICA(0202h) - GPUREG\_ATTR\_BUF\_FORMAT\_HIGH (R/W)


```
  0-3    Vertex attribute 0 type/size   ;\these 4bit values contain type/size
  4-7    Vertex attribute 1 type/size   ; type in bit0-1:
  8-11   Vertex attribute 2 type/size   ;  0 = fixed1.0.7  ;Signed byte
  12-15  Vertex attribute 3 type/size   ;  1 = fixed0.0.8  ;Unsigned byte
  16-19  Vertex attribute 4 type/size   ;  2 = fixed1.0.15 ;Signed halfword
  20-23  Vertex attribute 5 type/size   ;  3 = float1.8.23 ;Float32
  24-27  Vertex attribute 6 type/size   ; size in bit2-3:
  28-31  Vertex attribute 7 type/size   ;  0 = X           ;1D
  32-35  Vertex attribute 8 type/size   ;  1 = X,Y         ;2D
  36-39  Vertex attribute 9 type/size   ;  2 = X,Y,Z       ;3D
  40-43  Vertex attribute 10 type/size  ;  3 = X,Y,Z,W     ;4D
  44-47  Vertex attribute 11 type/size  ;/
  48-59  Fixed vertex attribute 0..11 mask flags    (0=Array, 1=Fixed?) ???
  60-63  Number of vertex attributes-1 (0..11 = 1..12 attributes)
```



## 10401800h - PICA(0200h) - GPUREG\_ATTR\_BUF\_BASE (R/W)


```
  0      Unused (0)
  1-28   Base address for ATTR_BUF's and INDEX_LIST, in 16-byte units
  29-31  Unused (0)
```



## 1040180Ch+i\*0Ch - PICA(0203h+3\*(0..11)) - GPUREG\_ATTR\_BUFi\_OFFSET (R/W)


```
  0-27   Vertex array address, with base GPUREG_ATTR_BUF_BASE, in 1-byte units
```

Addressing uses Base+Offset+Index (with Index from FIRST\_INDEX or INDEX\_LIST):

```
  GPUREG_ATTR_BUF_BASE*10h + GPUREG_ATTR_BUFi_OFFSET*1 + Index*ArrayEntrySize
```



## 10401810h+i\*0Ch - PICA(0204h+3\*(0..11)) - GPUREG\_ATTR\_BUFi\_CONFIG\_LOW (R/W)



## 10401814h+i\*0Ch - PICA(0205h+3\*(0..11)) - GPUREG\_ATTR\_BUFi\_CONFIG\_HIGH (R/W)


```
  0-3    Array Component 0      ;\
  4-7    Array Component 1      ; These are mapping the array component(s)
  8-11   Array Component 2      ; to vertex attribute numbers:
  12-15  Array Component 3      ;   00h..0Bh = Vertex attribute 0..11
  16-19  Array Component 4      ;   0Ch      = 4-byte padding
  20-23  Array Component 5      ;   0Dh      = 8-byte padding
  24-27  Array Component 6      ;   0Eh      = 12-byte padding
  28-31  Array Component 7      ;   0Fh      = 16-byte padding
  32-35  Array Component 8      ; Attribute 0..11 do usually refer to vertex
  36-39  Array Component 9      ; shader registers v0..v11 (unless they are
  40-43  Array Component 10     ; renumbered via "PERMUTATION"...?)
  44-47  Array Component 11     ;/
  48-55  Array Entry Size in bytes (0..FFh) ;total size of above component(s)
  56-59  Unused (0)
  60-63  Number of components in this array  (0..12) (0=Disable this array?)
```

Padding: Does "skip" array entries? (maybe useful when having texturing
disabled, whilst still having texture info in the array?).

Reportedly there is some alignment issue/feature for padding. And also an
alignment issue for components or so; maybe halfword/float32 need to be
aligned? There is no alignment restriction for components that consist of bytes
(eg. 3x8bit RGB does work).



## 104018A0h - PICA(0228h) - GPUREG\_ATTR\_BUF\_NUMVERTICES (R/W)


```
  0-31   Number of vertices to render (MUL2 for DRAWELEMENTS)
```

Don't care for FIXEDATTRIB, needed only for ATTR\_BUF's.

Counted TWICE for DRAWELEMENTS (once for index-read, and once for array-read)!

XXX are multiple arrays also counted as multiple reads?



## 104018B8h - PICA(022Eh) - GPUREG\_ATTR\_BUF\_DRAWARRAYS - Increasing Indices (W)



## 104018BCh - PICA(022Fh) - GPUREG\_ATTR\_BUF\_DRAWELEMENTS - With INDEX\_LIST (W)


Writing to either of these registers starts sending the amount of data
specified in NUMVERTICES from ATTR\_BUF's to the vertex shader.

```
  0-31   Don't care (writing any value starts drawing from ATTR_BUF)
```

The only difference between DRAWARRAYS and DRAWELEMENTS are the array indices:

```
  DRAWARRAYS uses increasing indices, starting at GPUREG_ATTR_BUF_FIRST_INDEX.
  DRAWELEMENTS uses array indices from GPUREG_ATTR_BUF_INDEX_LIST.
```



## 104018A8h - PICA(022Ah) - GPUREG\_ATTR\_BUF\_FIRST\_INDEX (R/W)


```
  0-31   Starting index in ATTR_BUF arrays (usually 0, to start with 1st entry)
```

Used only for for DRAWARRAYS (not used for DRAWELEMENTS, which does instead
read indices from the INDEX\_LIST).



## 1040189Ch - PICA(0227h) - GPUREG\_ATTR\_BUF\_INDEX\_LIST (R/W)


```
  0-27   Index List address, with base GPUREG_ATTR_BUF_BASE, in 1-byte units
  31     Index List entry size (0=8bit indices, 1=16bit indices)
```

Used only for DRAWELEMENTS. The index list allows to re-use ATTR\_BUF entries
for multiple vertices (triangle strips are automatically re-using vertices from
the previous triangle, however, with the index list, one can also re-use
vertices from the previous strips; which can save about 50% of memory).

```
     __  __  __  __  __  __  __  __  __
   /\  /\  /\  /\  /\  /\  /\  /\  /\  /\      <-- First Strip
  /__\/__\/__\/__\/__\/__\/__\/__\/__\/__\...
  \  /\  /\  /\  /\  /\  /\  /\  /\            <-- Second Strip
   \/__\/__\/__\/__\/__\/__\/__\/__\...
   /\  /\  /\  /\  /\  /\  /\                  <-- Third Strp
  /__\/__\/__\/__\/__\/__\/__\...
```


```
 __________________________ Fixed Vertex Attributes ___________________________
```


The Fixed Attribute registers can be used in two ways:


```
  1) Setting attribute(s) to fixed settings (similar to FLOATUNIFORM
     registers). For example, one could re-use a shader that was
     programmed to support variable colors with fixed colors.
     Unknown if fixed settings are also working for partial attributes
     (eg. 2D graphics with X,Y coordinates and fixed Z,W values).
  2) Using [GPUREG_FIXEDATTRIB_INDEX]=0Fh does directly send vertex
     attribute(s) to the shader unit (this could be "easier" than setting
     up ATTR_BUF arrays in memory, however, in practice it is extremely
     uncomfortable (due to the weird data format with 4x24bit float values
     sent in reversed 32bit word order).
```



## 104018C8h - PICA(0232h) - GPUREG\_FIXEDATTRIB\_INDEX (W)


```
  0-3    Fixed attribute index (00h-0Bh=Index, 0Fh=immediate-mode submission)
```

Selects the index of the fixed attribute to be input with
GPUREG\_FIXEDATTRIB\_DATAi.



## 104018CCh - PICA(0233h) - GPUREG\_FIXEDATTRIB\_DATA(0) (HIGH) (W)



## 104018D0h - PICA(0234h) - GPUREG\_FIXEDATTRIB\_DATA(1) (MID) (W)



## 104018D4h - PICA(0235h) - GPUREG\_FIXEDATTRIB\_DATA(2) (LOW) (W)


```
  0-23   float1.7.16, Vertex attribute X
  24-47  float1.7.16, Vertex attribute Y
  48-71  float1.7.16, Vertex attribute Z
  72-95  float1.7.16, Vertex attribute W
```

The above 96bit value is split into three 32bit words, and, weirdly,

```
  the word order for writing is HIGH,MID,LOW (aka big endian style)
  the byte order per 32bit word is little endian
```

More uncomfortably, fixed attributes must be in 4x24bit float format (with
X,Y,Z,W, even when needing only X,Y, and with 24bit float, instead of more
comfortable formats like 8bit/16bit integer or 32bit float)

Note: The three DATA registers are mirrors of each other, one could write the
HIGH,MID,LOW words all to DATA0, or to DATA0..2.


```
 ________________________ Shader/Attribute/Mode Config ________________________
```


Below is still rather nebulous, some registers are required to be initialized
as described... and some seem to be bogus (somehow having wrong descriptions
and/or no function at all).



## 10401908h - PICA(0242h) - GPUREG\_VSH\_NUM\_ATTR (required) (R/W)


```
  0-3    Number of vertex shader input attributes - 1
```



## 10401928h - PICA(024Ah) - GPUREG\_VSH\_OUTMAP\_TOTAL1 (required) (R/W)



## 10401944h - PICA(0251h) - GPUREG\_VSH\_OUTMAP\_TOTAL2 (no function?) (R/W)


```
  0-3    Number of vertex shader output map registers - 1
```

Uh, why are there TWO such registers? Is that for each command buffer? Or for
GSH and VSH? Or are that something like total+remaining counts?



## 104018A4h - PICA(0229h) - GPUREG\_GEOSTAGE\_CONFIG (unknown purpose) (R/W)


```
  0-1    Geometry shader in use    (0=Not in use, 2=In use)
  8      Drawing triangle elements (0=Not, 1=Drawing triangle elements)
  9      UNKNOWN "0x0" (R/W)
  16-19  UNKNOWN (R/W)
  31     Use reserved geometry shader subdivision (0=Don't use, 1=Use)
```

"When using vertex buffers and drawing elements in triangles mode, bit8 is set
to 1, else it is set to 0."

Uh, what means drawing triangle elements... does the gpu even support drawing
anything else than triangles?



## 1040194Ch - PICA(0253h) - GPUREG\_GEOSTAGE\_CONFIG2 (parts required) (R/W)


```
  0      Function indicator
            with vertex buffers: 0=Draw elements, 1=Draw arrays     <-- blah?
            without: 0=Not inputting, 1=Inputting vertex attribute data  <--?
  8      Drawing triangle elements (0=Not, 1=Drawing triangle elements)
```

"When using vertex buffers, bit0 is set to 1 before drawing arrays, and cleared
to 0 immediately after.

When using immediate mode to directly input vertex attribute data, bit0 is set
to 1 before inputting vertex attribute data, and cleared to 0 immediately
after. While bit0 is set to 1, some register writes outside of the 0x200-0x254
and 0x280-0x2DF ranges may be processed incorrectly.

When using vertex buffers and drawing elements in triangles mode, bit8 is set
to 1, else it is set to 0."



## 10401948h - PICA(0252h) - GPUREG\_GSH\_MISC0 (R/W)


```
  0-1    Mode?      (0=Normal, 1=WhateverSubdivision?, 2=WhateverParticle?)
  8-22   Something? (0..7FFFh, for the Particle stuff?)
  24     Flag?      (0..1, for the Particle stuff?)
```

Reportedly 00000000h=Normal, 00000001h=Reserved geometry shader subdivision in
use, 01004302h=Particle system in use.



## 10401950h - PICA(0254h) - GPUREG\_GSH\_MISC1 (R/W)


```
  0-4    Reserved geometry shader subdivision type (2=Loop, 3=Catmull-Clark)
```

"Configures the type of reserved geometry shader subdivision in use. The value
is ignored when a subdivision is not in use."



## 104018B4h - PICA(022Dh) - GPUREG\_POST\_VERTEX\_CACHE\_NUM (R/W)


```
  0-7    Number of entries in post-vertex cache (unsigned, usually 04h or 84h)
  8-15   UNKNOWN (R/W)
  16-23  UNKNOWN (R/W)  ;\these two bytes are swapped when reading
  24-31  UNKNOWN (R/W)  ;/(reading mirrors also returns swapped bytes)
```

"Configures the post-vertex cache." Uh, what is that?



## 104018C4h - PICA(0231h) - GPUREG\_VTX\_FUNC (W)


```
  0-31   Trigger (0=Idle???, Non-zero=Clear post-vertex cache)
```

"Triggers clearing the post-vertex cache."

Uh, then, maybe should be called "clear cache" instead "vtx func". And what is
a "post-vertex"? And is it really clearing anything, drawing seems to work
without doing so.



## 10401910h - PICA(0244h) - GPUREG\_VSH\_COM\_MODE (R/W)


```
  0      Geometry shader configuration enable  (0=Disable, 1=Enable)
```

"Sets whether to use the geometry shader configuration or reuse the vertex
shader configuration for the geometry shader shading unit."



## 10401914h - PICA(0245h) - GPUREG\_START\_DRAW\_FUNC0 (R/W)


```
  0      Mode         (0=Drawing, 1=Configuration)
  1-7    UNKNOWN "0x0" (not R/W)
```

"Related to drawing. When the mode value is set to 1, rendering is not
performed properly. When set to 0, changes to the vertex shader configuration
registers are not applied correctly. Because of this, it is usually initialized
to 1, set to 0 immediately before triggering a draw, and set back to 1
immediately after triggering a draw."



## 1040190Ch - PICA(0243h) - GPUREG\_undoc\_1040190Ch (R/W=00000037h)


```
  0-2    UNKNOWN (0..7) (R/W)
  4-6    UNKNOWN (0..3) (R/W)
```

Power-up default is 37h. GPU hangs on several other settings, in some cases
also depending on other registers (for example, 00h hangs only when also
clearing other undocumented registers).



## 10401954h - PICA(0255h) - GPUREG\_undoc\_10401954h (R/W=00000001h)


```
  0      UNKNOWN (0..1) (R/W)
```




# <a name="3dsgpuinternalregistersshaderregisters"></a>3DS GPU Internal Registers - Shader registers



There are four shader units, each having its own set of I/O registers:

```
  10401A00h - PICA(0280h..) - Shader 0 (Geometry Shader, aka GSH)
  10401AC0h - PICA(02B0h..) - Shader 1 (Vertex Shader, aka VSH)
  10401B80h - PICA(02E0h..) - Shader 2 (Unknown purpose)
  10401C40h - PICA(0310h..) - Shader 3 (Unknown purpose)
```

The vertex shader can reportedly use three shader units at once (or all four
units, when not using the geometry shader). Even when using multiple units as
vertex shader, one does only need to initialize the Shader 1 registers.

Unknown if the Shader 2 and 3 registers are having any special purpose for yet
unknown special effects (maybe for the undescribed "reserved geometry shader
subdivision" feature, or maybe for the "procedural texture" unit, or maybe they
are just dummy registers).


```
 ____________________________ Input/Output Config _____________________________
```



## 10401A24h - PICA(0289h) - GPUREG\_GSH\_INPUTBUFFER\_CONFIG (R/W)



## 10401AE4h - PICA(02B9h) - GPUREG\_VSH\_INPUTBUFFER\_CONFIG (R/W)



## 10401BA4h - PICA(02E9h) - GPUREG\_VSH2\_INPUTBUFFER\_CONFIG (R/W)



## 10401C64h - PICA(0319h) - GPUREG\_VSH3\_INPUTBUFFER\_CONFIG (R/W)


```
  0-3    Number of Input vertex attributes - 1
  4-7    Unused (0)
  8      Use reserved geometry shader subdivision (0=Don't use, 1=Use) (uh?)
  9-26   Unused (0)
  27     Whatever, should be 1 for geometry shader (R/W)
  28     Whatever, should be 0                     (R/W)
  29     Whatever, should be 1 for vertex shader   (R/W)
  30     Unused (0)
  31     Whatever, should be 1 for vertex shader   (R/W)
```

Configures the shader unit's input buffer.



## 10401A2Ch - PICA(028Bh) - GPUREG\_GSH\_ATTR\_PERMUTATION\_LOW (R/W)



## 10401A30h - PICA(028Ch) - GPUREG\_GSH\_ATTR\_PERMUTATION\_HIGH (R/W)



## 10401AECh - PICA(02BBh) - GPUREG\_VSH\_ATTR\_PERMUTATION\_LOW (R/W)



## 10401AF0h - PICA(02BCh) - GPUREG\_VSH\_ATTR\_PERMUTATION\_HIGH (R/W)



## 10401BACh - PICA(02EBh) - GPUREG\_VSH2\_ATTR\_PERMUTATION\_LOW (R/W)



## 10401BB0h - PICA(02ECh) - GPUREG\_VSH2\_ATTR\_PERMUTATION\_HIGH (R/W)



## 10401C6Ch - PICA(031Bh) - GPUREG\_VSH3\_ATTR\_PERMUTATION\_LOW (R/W)



## 10401C70h - PICA(031Ch) - GPUREG\_VSH3\_ATTR\_PERMUTATION\_HIGH (R/W)


```
  0-3    Vertex attribute 0 input register index (0..15=v0..v15)
  4-7    Vertex attribute 1 input register index
  8-11   Vertex attribute 2 input register index
  12-15  Vertex attribute 3 input register index
  16-19  Vertex attribute 4 input register index
  20-23  Vertex attribute 5 input register index
  24-27  Vertex attribute 6 input register index
  28-31  Vertex attribute 7 input register index
  32-35  Vertex attribute 8 input register index
  36-39  Vertex attribute 9 input register index
  40-43  Vertex attribute 10 input register index
  44-47  Vertex attribute 11 input register index
  48-51  Vertex attribute 12 input register index  ;\uh, how does one
  52-55  Vertex attribute 13 input register index  ; set attr 12-15?
  56-59  Vertex attribute 14 input register index  ; maybe FROM
  60-63  Vertex attribute 15 input register index  ;/geometry shader?
```

Sets the shader unit input register index which will correspond to each
attribute contained by the input buffer (which in the case of geometry shaders
is the vertex shader output buffer (uh, that says that there is ONE vertex
shader, and MULTIPLE geometry shaders?)) for attributes 0 through 15.

For example, having LOW.bit0-3 set to 5 means that, in the shader program, v5
will contain the input buffer's 1st attribute.

For example, having HIGH.bit0-3 set to 5 means that, in the shader program, v5
will contain the input buffer's 9th attribute.

somewhat semantic?

Uh, ATTR\_PERMUTATION is a scary homebrew slang for ATTR\_IDs?



## 10401A34h - PICA(028Dh) - GPUREG\_GSH\_OUTMAP\_MASK (R/W)



## 10401AF4h - PICA(02BDh) - GPUREG\_VSH\_OUTMAP\_MASK (R/W)



## 10401BB4h - PICA(02EDh) - GPUREG\_VSH2\_OUTMAP\_MASK (R/W)



## 10401C74h - PICA(031Dh) - GPUREG\_VSH3\_OUTMAP\_MASK (R/W)


```
  0      Output register o0  (0=Disable, 1=Enable)
  1      Output register o1  (0=Disable, 1=Enable)
  2      Output register o2  (0=Disable, 1=Enable)
  3      Output register o3  (0=Disable, 1=Enable)
  4      Output register o4  (0=Disable, 1=Enable)
  5      Output register o5  (0=Disable, 1=Enable)
  6      Output register o6  (0=Disable, 1=Enable)
  7      Output register o7  (0=Disable, 1=Enable) (vertex shader only, uh?)
  8      Output register o8  (0=Disable, 1=Enable) (vertex shader only, uh?)
  9      Output register o9  (0=Disable, 1=Enable) (vertex shader only, uh?)
  10     Output register o10 (0=Disable, 1=Enable) (vertex shader only, uh?)
  11     Output register o11 (0=Disable, 1=Enable) (vertex shader only, uh?)
  12     Output register o12 (0=Disable, 1=Enable) (vertex shader only, uh?)
  13     Output register o13 (0=Disable, 1=Enable) (vertex shader only, uh?)
  14     Output register o14 (0=Disable, 1=Enable) (vertex shader only, uh?)
  15     Output register o15 (0=Disable, 1=Enable) (vertex shader only, uh?)
  16-26  UNKNOWN (R/W)
  16-31  UNKNOWN "0x0"  (uh, but only bit27-31 are always 0)
```

Toggles a shader unit's output registers.

See also: GPUREG\_SH\_OUTMAP\_Oi


```
 _____________________________ Uniform Registers ______________________________
```


Uniform registers can contain general purpose constants. That is, they are
usually kept set to constant values throughout sending multiple vertices
(unlike position/texture coordinates or other vertex attributes that differ on
each vertex).



## 10401A00h - PICA(0280h) - GPUREG\_GSH\_BOOLUNIFORM (R/W)



## 10401AC0h - PICA(02B0h) - GPUREG\_VSH\_BOOLUNIFORM (R/W)



## 10401B80h - PICA(02E0h) - GPUREG\_VSH2\_BOOLUNIFORM (R/W)



## 10401C40h - PICA(0310h) - GPUREG\_VSH3\_BOOLUNIFORM (R/W)


```
  0-15   Boolean register b0..b15 value  (0=False, 1=True)
  16-27  For GSH: UNKNOWN (0..0FFFh) (R/W)  ;\unknown, but R/W mask resembles
  16-24  For VSH: UNKNOWN (0..01FFh) (R/W)  ;/GPUREG_xSH_ENTRYPOINT !
  16-31  UNKNOWN "0x7FFF"  (uh, but bit28-31 are always 0?) (for VSH: 25-31)
```

The sixteen 1bit boolean registers (B0..B15) can be used by conditional shader
opcodes. Uh, elsewhere it's claimed that there are only eight bool registers?

Bit15 seems to be automatically set after executing shader code?

Bit16 and up seem to contain an opcode address?



## 10401A04h+i\*4 - PICA(0281h+i) - GPUREG\_GSH\_INTUNIFORM\_I0..I3 (R/W)



## 10401AC4h+i\*4 - PICA(02B1h+i) - GPUREG\_VSH\_INTUNIFORM\_I0..I3 (R/W)



## 10401B84h+i\*4 - PICA(02E1h+i) - GPUREG\_VSH2\_INTUNIFORM\_I0..I3 (R/W)



## 10401C44h+i\*4 - PICA(0311h+i) - GPUREG\_VSH3\_INTUNIFORM\_I0..I3 (R/W)


```
  0-7    unsigned, Integer register ii X value  aka INT.x  Loop count-1
  8-15   unsigned, Integer register ii Y value  aka INT.y  Loop starting index
  16-23  unsigned, Integer register ii Z value  aka INT.z  Loop index step
  24-31  Unused (0)
```

Each of the four integer registers (I0..I3) contains three 8bit integer values
(X,Y,Z). The integers are used to initalize loop counters and indexing.



## 10401A40h - PICA(0290h) - GPUREG\_GSH\_FLOATUNIFORM\_INDEX (W)



## 10401B00h - PICA(02C0h) - GPUREG\_VSH\_FLOATUNIFORM\_INDEX (W)



## 10401BC0h - PICA(02F0h) - GPUREG\_VSH2\_FLOATUNIFORM\_INDEX (W)



## 10401C80h - PICA(0320h) - GPUREG\_VSH3\_FLOATUNIFORM\_INDEX (W)


```
  0-7    Transfer index for FLOATUNIFORM_DATA writes (0..95 = C0..C95)
  31     Transfer mode                  (0=float1.7.16, 1=float1.8.23)
```



## 10401A44h+i\*4 - PICA(0291h+i) - GPUREG\_GSH\_FLOATUNIFORM\_DATA(0..7) (W)



## 10401B04h+i\*4 - PICA(02C1h+i) - GPUREG\_VSH\_FLOATUNIFORM\_DATA(0..7) (W)



## 10401BC4h+i\*4 - PICA(02F1h+i) - GPUREG\_VSH2\_FLOATUNIFORM\_DATA(0..7) (W)



## 10401C84h+i\*4 - PICA(0321h+i) - GPUREG\_VSH3\_FLOATUNIFORM\_DATA(0..7) (W)


Each of the 96 float uniform registers (C0..C95) contains four float values
(X,Y,Z,W). The floats can contain general purpose constants, colors, vectors,
or matrices (eg. when using four such registers as matrix with 4x4 float
values).

"The data format which should be written to it depends on the transfer mode set
with GPUREG\_SH\_FLOATUNIFORM\_INDEX. These registers function as a FIFO queue:
after each time a 4-component uniform register is successfully set, the target
register index is incremented, meaning that groups of uniforms with contiguous
register IDs can be set with only one initial write to
GPUREG\_SH\_FLOATUNIFORM\_INDEX."


## float24 (float1.7.16) transfer mode:


"Data should be sent by writing three words which are the concatenation of the
float24 value of the uniform register's 4 components, in the "reverse order".
Assuming each letter corresponds to 4 bits, the format becomes:"

```
  (uh, is that the aforementioned "reverse order", or is it unreversed here?)
  1st word  : ZZWWWWWW  ;uh, reverse of GPUREG_FIXEDATTRIB_DATA ??
  2nd word  : YYYYZZZZ
  3rd word  : XXXXXXYY
```


## float32 (float1.8.23) transfer mode:


"Data should be sent by writing four words which are each the float32 value of
the uniform register's 4 components, in the reverse order... uh, who/what/how
is that reverse order??? probably alike as shown below (or reverse thereof?):"

```
  1st word  : WWWWWWWW
  2nd word  : ZZZZZZZZ
  3rd word  : YYYYYYYY
  4th word  : XXXXXXXX
```


```
 ____________________________ Opcodes and Opdesc's ____________________________
```



## 10401A28h - PICA(028Ah) - GPUREG\_GSH\_ENTRYPOINT (R/W)



## 10401AE8h - PICA(02BAh) - GPUREG\_VSH\_ENTRYPOINT (R/W)



## 10401BA8h - PICA(02EAh) - GPUREG\_VSH2\_ENTRYPOINT (R/W)



## 10401C68h - PICA(031Ah) - GPUREG\_VSH3\_ENTRYPOINT (R/W)


```
  0-15   Code entry point offset, in 32-bit words
  16-31  0x7FFF      ;maybe max/end address for error-checks?
```

uh, but, for GSH, R/W mask is 0FFF0FFFh.

uh, but, for VSH, R/W mask is 01FF01FFh.



## 10401A6Ch - PICA(029Bh) - GPUREG\_GSH\_CODETRANSFER\_INDEX (W)



## 10401B2Ch - PICA(02CBh) - GPUREG\_VSH\_CODETRANSFER\_INDEX (W)



## 10401BECh - PICA(02FBh) - GPUREG\_VSH2\_CODETRANSFER\_INDEX (W)



## 10401CACh - PICA(032Bh) - GPUREG\_VSH3\_CODETRANSFER\_INDEX (W)


```
  0-11   Target shader code offset, in WHAT units? 4-byte maybe?
```

Offset at which upcoming shader code data transferred through
GPUREG\_SH\_CODETRANSFER\_DATAi should be written.



## 10401A70h+i\*4 - PICA(029Ch+i) - GPUREG\_GSH\_CODETRANSFER\_DATA(0..7) (W)



## 10401B30h+i\*4 - PICA(02CCh+i) - GPUREG\_VSH\_CODETRANSFER\_DATA(0..7) (W)



## 10401BF0h+i\*4 - PICA(02FCh+i) - GPUREG\_VSH2\_CODETRANSFER\_DATA(0..7) (W)



## 10401CB0h+i\*4 - PICA(032Ch+i) - GPUREG\_VSH3\_CODETRANSFER\_DATA(0..7) (W)


```
  0-31   Shader instruction data
```

Used to transfer shader code data. These registers behave as a FIFO queue: each
write to these registers writes the provided value to the GPU shader code
memory bank at the offset initially set by GPUREG\_SH\_CODETRANSFER\_INDEX. The
offset in question is incremented after each write to this register.



## 10401A3Ch - PICA(028Fh) - GPUREG\_GSH\_CODETRANSFER\_END (W)



## 10401AFCh - PICA(02BFh) - GPUREG\_VSH\_CODETRANSFER\_END (W)



## 10401BBCh - PICA(02EFh) - GPUREG\_VSH2\_CODETRANSFER\_END (W)



## 10401C7Ch - PICA(031Fh) - GPUREG\_VSH3\_CODETRANSFER\_END (W)


```
  0-31   Don't care (writing any value works)
```

Unknown what that does. It seems to be needed at least once after first code
upload (but is usually done after each shader code upload). Maybe enables code
execution, or invalidates some cache?



## 10401A94h - PICA(02A5h) - GPUREG\_GSH\_OPDESCS\_INDEX (W)



## 10401B54h - PICA(02D5h) - GPUREG\_VSH\_OPDESCS\_INDEX (W)



## 10401C14h - PICA(0305h) - GPUREG\_VSH2\_OPDESCS\_INDEX (W)



## 10401CD4h - PICA(0335h) - GPUREG\_VSH3\_OPDESCS\_INDEX (W)


```
  0-11   Target shader operand descriptor offset, in WHAT units?
```

Uh, why 12bit wide? There are only max 128 descriptors per shader.

Offset at which upcoming shader operand descriptor data transferred through
GPUREG\_SH\_OPDESCS\_DATAi should be written.



## 10401A98h+i\*4 - PICA(02A6h+i) - GPUREG\_GSH\_OPDESCS\_DATA(0..7) (W)



## 10401B58h+i\*4 - PICA(02D6h+i) - GPUREG\_VSH\_OPDESCS\_DATA(0..7) (W)



## 10401C18h+i\*4 - PICA(0306h+i) - GPUREG\_VSH2\_OPDESCS\_DATA(0..7) (W)



## 10401CD8h+i\*4 - PICA(0336h+i) - GPUREG\_VSH3\_OPDESCS\_DATA(0..7) (W)


```
  0-31   Shader operand descriptor data
```

Used to transfer shader operand descriptor data. These registers behave as a
FIFO queue: each write to these registers writes the provided value to the GPU
shader operand descriptor memory bank at the offset initially set by
GPUREG\_SH\_OPDESCS\_INDEX. The offset in question is incremented after each write
to this register.




# <a name="3dsgpuinternalregistersrasterizerregisters"></a>3DS GPU Internal Registers - Rasterizer registers



```
 ____________________________ Viewport and Scissor ____________________________
```



## 10401104h - PICA(0041h) - GPUREG\_VIEWPORT\_V\_SCALE (3DS: 240/2) (R/W)



## 1040110Ch - PICA(0043h) - GPUREG\_VIEWPORT\_H\_SCALE (3DS: 320/2 or 400/2) (R/W)


```
  0-23   float1.7.16, size/2
```

Used to scale the vertex coordinates (usually in range -1.0 to +1.0) to screen
coordinates (in pixel units). Should be set to "H=width/2" and "V=height/2".
Normally that would be the screen size (or for smaller windows, the scissor
area size).



## 10401108h - PICA(0042h) - GPUREG\_VIEWPORT\_V\_STEP (3DS: 2/240) (R/W)



## 10401110h - PICA(0044h) - GPUREG\_VIEWPORT\_H\_STEP (3DS: 2/320 or 2/400) (R/W)


```
  0-31   float1.7.24, 2/size
```

Used as stepping offsets when interpolating colors (and textures?) between
vertex coordinates. Should be set to same settings as in above SCALE registers,
but with "inverse" division, ie. "H=2/width" and "V=2/height" (instead of
"width/2" and "height/2").

For the odd floating point format, one could adjust one of the more common
formats (assuming sign=0 for the latter two cases):

```
  (float24)*100h                  ;convert float1.7.16 to float1.7.24
  (float32)*2-40000000h           ;convert float1.8.23 to float1.7.24
  (float64)/10000000h-0C0000000h  ;convert float1.11.52 to float1.7.24
```

or it might also work to directly use screen coordinates for vertices (and set
all viewport registers to 1.0).



## 10401194h - PICA(0065h) - GPUREG\_SCISSORTEST\_MODE (R/W)


```
  0-1    Mode (0=Disable, 1=Render Outside, 3=Render Inside, 2=Same as 0)
```

Allows to disable the scissor feature (ie. to render to whole framebuffer), or
to select whether to render only inside, or only outside of the scissor
rectangle. This can be useful if the framebuffer is divided into smaller
windows.



## 10401198h - PICA(0066h) - GPUREG\_SCISSORTEST\_POS1 (R/W)



## 1040119Ch - PICA(0067h) - GPUREG\_SCISSORTEST\_POS2 (R/W)


```
  0-9    Vertical Position   (unsigned, 0..3FFh pixels)  ;0..240-1
  16-25  Horizontal Position (unsigned, 0..3FFh pixels)  ;0..320-1 or 0..400-1
```

Defines the scissor area, ranging from POS1=origin to POS2=origin+size-1
(whereas, coordinate 0,0 is lower-right).



## 104011A0h - PICA(0068h) - GPUREG\_VIEWPORT\_XY (R/W)


```
  0-9    Vertical Position   (signed, -200h..+1FFh pixels)
  16-25  Horizontal Position (signed, -200h..+1FFh pixels)
```

Default is 0,0 (with coordinate 0,0 being at center of framebuffer). Nonzero
values can cause polygons to wrap at the framebuffer edges (unless scissor test
is used, with position plus scissor size being within framebuffer dimensions).


```
 ____________________________________ Misc ____________________________________
```



## 10401100h - PICA(0040h) - GPUREG\_FACECULLING\_CONFIG (R/W)


```
  0-1    Culling (0=Show Front+Back, 1=Show Back, 2=Show Front, 3=Same as 0)
```

Selects whether to show the polygon front/back sides. Normally only the front
side is needed (and it's thus faster not to render the back side).

Note: The hardware detects front/back by checking whether the triangle's
coordinates are arranged clockwise or anti-clockwise on screen.



## 1040111Ch - PICA(0047h) - GPUREG\_FRAGOP\_CLIP (R/W)


```
  0      Enable clipping plane(s?) (0=Disable, 1=Enable)
```



## 10401120h+i\*4 - PICA(0048h+i) - GPUREG\_FRAGOP\_CLIP\_DATAi (i=0..3) (R/W)


```
  0-23   float1.7.16, Clipping plane coefficient i
```

"Used to configure clipping plane coefficients."

Note: There is a similar poorly described feature in OpenGL, but it's unknown
what it does and how to use it. It does somehow add another clipping plane
(additionally to the left/right, top/bottom, and near/far clipping plane).



## 10401134h - PICA(004Dh) - GPUREG\_DEPTHMAP\_SCALE (R/W)


```
  0-23   float1.7.16, Near - Far             ;default would be Z=-0.99999999
```

Used to configure the depth range scale.

Uh, what means map, hmmm, maybe it just means "bitmap" with depth values?

Maybe defines the visible depth range? In Z or W units? But why called scale?

Maybe also "scales" float values to 24bit integers in depth buffer?



## 10401138h - PICA(004Eh) - GPUREG\_DEPTHMAP\_OFFSET (R/W)


```
  0-23   float1.7.16, Near + Polygon Offset  ;default would be Z=+0.0
```

Used to configure the depth range bias.

Probably defines near clipping plane, in Z or W units? Unknown what "Polygon
Offset" refers to.



## 104011B4h - PICA(006Dh) - GPUREG\_DEPTHMAP\_ENABLE (R/W)


```
  0      Enable depth range, uh what? (0=Disable/What??, 1=Enable/Default)
```


```
 ________________________________ Early Depth _________________________________
```


Early Depth is something about drawing only depth values (without computing and
drawing colors/textures) for pre-checking if the polygon is visible... if so,
something is probably required to actually draw the color/texture part...?



## 10401184h - PICA(0061h) - GPUREG\_EARLYDEPTH\_FUNC (R/W)


```
  0-1    Early depth function (0=GreaterEqual, 1=Greater, 2=LessEqual, 3=Less)
```

Configures the early depth test function.



## 10401188h - PICA(0062h) - GPUREG\_EARLYDEPTH\_TEST1 (R/W)



## 10401460h - PICA(0118h) - GPUREG\_EARLYDEPTH\_TEST2 (R/W)


```
  0      Enable early depth test    (0=Disable, 1=Enable)
```



## 1040118Ch - PICA(0063h) - GPUREG\_EARLYDEPTH\_CLEAR (W)


```
  0      Trigger (0=Idle???, 1=Clear) (W)   ;read=Always 0
```

Triggers clearing the early depth data. Whatever that means, probably something
for restarting a new early depth test (whatever, it does NOT memfill the
DEPTHBUFFER).



## 104011A8h - PICA(006Ah) - GPUREG\_EARLYDEPTH\_DATA (R/W)


```
  0-23   Early depth Clear value (unsigned)
```


```
 _______________________________ Shader Output ________________________________
```



## 1040113Ch - PICA(004Fh) - GPUREG\_SH\_OUTMAP\_TOTAL (R/W)


```
  0-2    Number of shader output attributes (1..7)
```



## 10401140h+i\*4 - PICA(0050h+i) - GPUREG\_SH\_OUTMAP\_Oi (i=0..6) (R/W)


```
  0-4    Semantic for the x component of the register (0..1Fh, see below)
  8-12   Semantic for the y component of the register (0..1Fh, see below)
  16-20  Semantic for the z component of the register (0..1Fh, see below)
  24-28  Semantic for the w component of the register (0..1Fh, see below)
```

These registers map components of the corresponding vertex shader output
register (o0..o6) to specific fixed-function semantics.

Semantic values:

```
  00h = position.x         ;\
  01h = position.y         ; Vertex Position
  02h = position.z         ;
  03h = position.w         ;/
  04h = normquat.x         ;\
  05h = normquat.y         ; Quaternion specifying the normal/tangent frame
  06h = normquat.z         ; (for fragment lighting)
  07h = normquat.w         ;/
  08h = color.r            ;\
  09h = color.g            ; Vertex color
  0Ah = color.b            ;
  0Bh = color.a            ;/
  0Ch = texcoord0.u        ;\Texture coordinates for texture 0
  0Dh = texcoord0.v        ;/
  0Eh = texcoord1.u        ;\Texture coordinates for texture 1
  0Fh = texcoord1.v        ;/
  10h = texcoord0.w        ;-Texture coordinate.w for texture 0
  12h = view.x             ;\
  13h = view.y             ; View vector (for fragment lighting)
  14h = view.z             ;/
  16h = texcoord2.u        ;\Texture coordinates for texture 2
  17h = texcoord2.v        ;/
  1Fh = Unused component   ;-for unused components of the output register
```

Observe that the X,Y,Z,W positions require Z,W even for simple 2D graphics (Z
should be -1.0..+0.0 to pass near/far clipping, W should be +1.0 to avoid
perspective division of the X,Y,Z values).



## 104011BCh - PICA(006Fh) - GPUREG\_SH\_OUTATTR\_CLOCK (R/W)


```
  0      'position.z' present                   (0=Absent, 1=Present)
  1      'color' component present              (0=Absent, 1=Present)
  8      'texcoord0' component present          (0=Absent, 1=Present)
  9      'texcoord1' component present          (0=Absent, 1=Present)
  10     'texcoord2' component present          (0=Absent, 1=Present)
  11-15  UNKNOWN (R/W)
  16     'texcoord0.w' present                  (0=Absent, 1=Present)
  17     UNKNOWN (R/W)
  24     'normquat' or 'view' component present (0=Absent, 1=Present)
```

Controls the clock supply to parts relating to certain attributes.

somewhat semantic?



## 10401190h - PICA(0064h) - GPUREG\_SH\_OUTATTR\_MODE (R/W)


```
  0      Use texture coordinates (0=Don't use, 1=Use)
```

Configures the shader output attribute mode, uh?


```
 ________________________________ Undocumented ________________________________
```



## 10401114h - PICA(0045h) - GPUREG\_undoc\_10401114h (R/W=00FFFFFFh)



## 10401118h - PICA(0046h) - GPUREG\_undoc\_10401118h (R/W=00FFFFFFh)


```
  0-23   UNKNOWN (0..FFFFFFh) (R/W)
```



## 10401130h - PICA(004Ch) - GPUREG\_undoc\_10401130h (R/W=00000001h)


```
  0      UNKNOWN (0..1) (R/W)
```



## 10401160h - PICA(0058h) - GPUREG\_undoc\_10401160h (R/W=00000101h)


```
  0      Flat Shading (0=Interpolate Colors, 1=Flat Uni-Color)
  8      UNKNOWN (0..1) (R/W)
```

The Flat Uni-Color mode uses only the third (last) color of each triangle.

Unknown if that does also apply to colors calculated from light vectors.



## 10401164h - PICA(0059h) - GPUREG\_undoc\_10401164h (R/W=00000001h)


```
  0      UNKNOWN (0..1) (R/W)
```



## 10401180h - PICA(0060h) - GPUREG\_undoc\_10401180h (R/W=00000301h)


```
  0      UNKNOWN (0..1) (R/W)
  8-9    Draw pixel(s) (0=All/Normal, 1=Each 2nd, 2=Each 4th, 3=Same as 0)
```

Allows to draw only each 2nd/4th pixel within 2x2 pixel cells (resulting in
striped/dotted output).



## 104011A4h - PICA(0069h) - GPUREG\_undoc\_104011A4h (R/W=FFFF0001h)


```
  0      UNKNOWN (0..1) (R/W)
  16-31  UNKNOWN (0..FFFFh) (R/W)
```



## 104011ACh - PICA(006Bh) - GPUREG\_undoc\_104011ACh (R/W=00000FFFh)


```
  0-11   UNKNOWN (0..FFFh) (R/W)
```



## 104011B0h - PICA(006Ch) - GPUREG\_undoc\_104011B0h (DANGER, hangs when reading)


```
  0-31   UNKNOWN/DANGER, hangs when reading (maybe a fifo, hangs when empty?)
```


```
 ___________________________________ Status ___________________________________
```



## 10401168h - PICA(005Ah) - GPUREG\_STAT\_NUM\_VERTICES\_RECEIVED (R)



## 1040116Ch - PICA(005Bh) - GPUREG\_STAT\_NUM\_TRIANGLES\_RECEIVED (R)



## 10401170h - PICA(005Ch) - GPUREG\_STAT\_NUM\_TRIANGLES\_DISPLAYED (R)


Indicates the number of processed vertices/triangles, the third counter does
increment only on actually displayed triangles (ie. when having passed the
front/back check) (and maybe further checks, like screen/scissor area).

```
  0-xx?  Status counter (incrementing)
```

Note: Reading from these registers (or any other GPU registers at
10401040h..1040107Fh or 10401100h..10401FFFh) does cause ARM11 to wait until
rendering has finished.




# <a name="3dsgpuinternalregistersframebufferregisters"></a>3DS GPU Internal Registers - Framebuffer registers




## 10401400h - PICA(0100h) - GPUREG\_COLOR\_OPERATION (R/W)


```
  0-1    Fragment operation mode    (0=Default, 1=Gas, 2=?, 3=Shadow)
  8      Blend mode                 (0=Logic op, 1=Blend)
  16-23  Unused, reportedly E4h ?   (isn't R/W... maybe write-only?)
  24     Render only each 2nd line  (0=All lines, 1=Only each 2nd line)
  25     Render nothing?            (0=Render, 1=Nothing)
```



## 10401404h - PICA(0101h) - GPUREG\_BLEND\_FUNC (R/W)


```
  0-2    RGB equation   (0=Add, 1=Sub, 2=ReverseSub, 3=Min, 4=Max, 5/6/7=Add)
  8-10   Alpha equation (0=Add, 1=Sub, 2=ReverseSub, 3=Min, 4=Max, 5/6/7=Add)
  16-19  RGB source blending function         (00h..0Fh, see below)
  20-23  RGB destination blending function    (00h..0Fh, see below)
  24-27  Alpha source blending function       (00h..0Fh, see below)
  28-31  Alpha destination blending function  (00h..0Fh, see below)
```

Blending Function values:

```
  0h = Zero
  1h = One
  2h = Source color
  3h = One minus source color
  4h = Destination color
  5h = One minus destination color
  6h = Source alpha                 ;<-- use for source func's?
  7h = One minus source alpha       ;<-- use for dest func's?
  8h = Destination alpha
  9h = One minus destination alpha
  Ah = Constant color               ;<-- aka GPUREG_BLEND_COLOR maybe?
  Bh = One minus constant color
  Ch = Constant alpha
  Dh = One minus constant alpha
  Eh = Source alpha saturate        ;<-- uh?
  Fh = ?
```

Unknown what source/dest means, maybe source=polygon, dest=colorbuf?

Unknown if there's a way to disable blending (other than using ADD+Zero).

Selecting things like "Source alpha" as RGB func seems to mean "color\*alpha"?

Unknown if this (or other registers) allow anti-aliasing.



## 10401408h - PICA(0102h) - GPUREG\_LOGIC\_OP (R/W)


```
  0-3    Logic op (0..0Fh, see below)
```

Logic op values:

```
  0h = Clear
  1h = AND
  2h = Reverse AND
  3h = Copy
  4h = Set
  5h = Inverted copy
  6h = Noop
  7h = Invert
  8h = NAND
  9h = OR
  Ah = NOR
  Bh = XOR
  Ch = Equivalent
  Dh = Inverted AND
  Eh = Reverse OR
  Fh = Inverted OR
```

Uh, what does that crap mean, and when is it used what for?



## 1040140Ch - PICA(0103h) - GPUREG\_BLEND\_COLOR (R/W)


```
  0-7    Red    (unsigned, 00h..FFh)
  8-15   Green  (unsigned, 00h..FFh)
  16-23  Blue   (unsigned, 00h..FFh)
  24-31  Alpha  (unsigned, 00h..FFh)
```



## 10401410h - PICA(0104h) - GPUREG\_FRAGOP\_ALPHA\_TEST (R/W)


```
  0      Alpha Testing Enable     (0=Disable, 1=Enable)
  4-6    Alpha Testing Function   (0-7, see below)
  8-15   Alpha Reference value    (00h..FFh, unsigned)
```

Alpha Testing Function values:

```
  0h = Never
  1h = Always
  2h = Equal
  3h = Not equal
  4h = Less than
  5h = Less than or equal
  6h = Greater than
  7h = Greater than or equal
```



## 10401414h - PICA(0105h) - GPUREG\_STENCIL\_TEST (R/W)


```
  0      Stencil Testing Enable    (0=Disable, 1=Enable)
  4-6    Stencil Testing Function  (0-7, see below)
  8-15   Buffer mask               (unsigned, 00h..FFh)
  16-23  Reference value           (signed, -80h..+7Fh)
  24-31  Mask                      (unsigned, 00h..FFh)
```

Stencil Testing Function values:

```
  0h = Never
  1h = Always
  2h = Equal
  3h = Not equal
  4h = Less than
  5h = Less than or equal
  6h = Greater than
  7h = Greater than or equal
```



## 10401418h - PICA(0106h) - GPUREG\_STENCIL\_OP (R/W)


```
  0-2    Stencil Fail operation   (0..7, see below)
  4-6    Stencil Z-fail operation (0..7, see below)
  8-10   Stencil Z-pass operation (0..7, see below)
```

Operation values:

```
  0h = Keep
  1h = Zero
  2h = Replace
  3h = Increment
  4h = Decrement
  5h = Invert
  6h = Increment and wrap
  7h = Decrement and wrap
```



## 1040141Ch - PICA(0107h) - GPUREG\_DEPTH\_COLOR\_MASK (R/W)


```
  0      Depth test enable   (0=Disable, 1=Enable)  ;\Depth testing
  4-6    Depth function      (0..7, see below)      ;/
  8      Red write enable    (0=Disable, 1=Enable)  ;\
  9      Green write enable  (0=Disable, 1=Enable)  ; Color Buffer writing
  10     Blue write enable   (0=Disable, 1=Enable)  ;
  11     Alpha write enable  (0=Disable, 1=Enable)  ;/
  12     Depth write enable  (0=Disable, 1=Enable)  ;-Depth Buffer writing
```

Depth function values:

```
  0h = Never
  1h = Always (same as when depth test is disabled)
  2h = Equal
  3h = Not equal
  4h = Less than
  5h = Less than or equal
  6h = Greater than
  7h = Greater than or equal
```



## 10401440h - PICA(0110h) - GPUREG\_RENDERBUFFER\_INVALIDATE (forget cache) (W)



## 10401444h - PICA(0111h) - GPUREG\_RENDERBUFFER\_FLUSH (cache writeback) (W)


```
  0      Trigger (0=No change, 1=Trigger) (W)
  1-31   Unused (0)
```

INVALIDATE: Forgets Color/Depth Cache contents (should be used before changing
buffer base addresses, or before externally MEMFILL'ing the Color/Depth
buffers).

FLUSH: Copies Color/Depth Cache to memory (should be used before MEMCOPY'ing
the Color Buffer to LCD Framebuffer).



## 10401448h - PICA(0112h) - GPUREG\_COLORBUFFER\_READING - Allow Read (R/W)



## 1040144Ch - PICA(0113h) - GPUREG\_COLORBUFFER\_WRITING - Allow Write (R/W)


```
  0-3    Allow read/write (00h=Disable, 0Fh=Enable, 01h..0Eh=Same as 0Fh?)
```

Write disable prevents polygon drawing. Unknown what happens on read disable.

Note: Disable stops the counters at 10400098h/1040009Ch.



## 10401450h - PICA(0114h) - GPUREG\_DEPTHBUFFER\_READING - Allow READ (R/W)



## 10401454h - PICA(0115h) - GPUREG\_DEPTHBUFFER\_WRITING - Allow WRITE (R/W)


```
  0      Allow stencil read/write (0=Disable, 1=Enable)
  1      Allow depth read/write   (0=Disable, 1=Enable)
```

Note: Disable stops the counters at 10400090h/10400094h.



## 10401458h - PICA(0116h) - GPUREG\_DEPTHBUFFER\_FORMAT (R/W)


```
  0-1    Format (0=16bitDepth, 1=?, 2=24bitDepth, 3=24bitDepth+8bitStencil)
```

Configures the depth buffer data format.



## 1040145Ch - PICA(0117h) - GPUREG\_COLORBUFFER\_FORMAT (R/W)


```
  0-1    Pixel size (0=16bitColor, 2=32bitColor, 1/3=?)
  16-18  Format     (0=RGBA8/Gas, 2=RGB5A1, 3=RGB565, 4=RGBA4, 1/5/6/7=?)
```

Configures the color buffer data format. Color components are laid out in
reverse byte order in memory, with the most significant bits used first. uh,
maybe that refers to two 16bit pixels within one 32bit word?



## 1040146Ch - PICA(011Bh) - GPUREG\_RENDERBUFFER\_BLOCK32 (R/W)


```
  0      Render buffer block size (0=Normal/8x8 pixels, 1=32x32 pixels)
```

Should be set to 8x8 (the 32x32 pixel mode can be reportedly used with
GPU\_MEMCOPY\_FLAGS.bit16=1, but 32x32 won't match up with the 400x240 and
320x240 pixel 3DS screens)



## 10401470h - PICA(011Ch) - GPUREG\_DEPTHBUFFER\_LOC (R/W)



## 10401474h - PICA(011Dh) - GPUREG\_COLORBUFFER\_LOC (R/W)


```
  0-2    UNKNOWN, seems to have no effect (R/W)
  3-27   Buffer physical address, in 64-byte units
```

These registers configure the depth/color buffer physical addresses. The
buffers are reportedly divided into 8x8 pixel blocks (or optionally 32x32
pixel), that tiled format does supposedly improve cache hits when drawing small
polygons.

The color buffer can contain RGBA values. After rendering, these should be
copied to LCD framebuffer(s) using GPU\_MEMCOPY registers (which can convert the
color format, and convert tiled memory to linear order.

The depth buffer can contain Depth and Stencil values. Unknown if the Depth
values are float or integer values, and unknown if they are Z or W values (or
if either one is selectable).



## 10401478h - PICA(011Eh) - GPUREG\_RENDERBUFFER\_DIM\_0 (R/W)



## 104011B8h - PICA(006Eh) - GPUREG\_RENDERBUFFER\_DIM\_1 (R/W)


```
  0-10   Height     (unsigned, 0..7FFh) (usually 240 on 3DS)
  12-21  Width - 1  (unsigned, 0..3FFh) (usually 320-1 or 400-1 on 3DS)
  24     Negate Y-coordinates  (0=Mirror; horizontally on 3DS, 1=Default)
```

Configures the size of the COLORBUFFER and DEPTHBUFFER. The DIM\_0 and DIM\_1
registers should be usually set to the same value (although DIM\_0 seems to be
needed, DIM\_1 seems to have no effect).



## 10401434h - PICA(010Dh) - GPUREG\_undoc\_10401434h (R/W=00000001h)


```
  0      UNKNOWN (0..1) (R/W)
```



## 10401438h - PICA(010Eh) - GPUREG\_undoc\_10401438h (R/W=FFFFFFFFh)



## 1040143Ch - PICA(010Fh) - GPUREG\_undoc\_1040143Ch (R/W=FFFFFFFFh)


```
  0-31   UNKNOWN (0..FFFFFFFFh) (R/W)
```



## 10401464h - PICA(0119h) - GPUREG\_undoc\_10401464h (R/W=FFFFFFFFh)



## 10401468h - PICA(011Ah) - GPUREG\_undoc\_10401468h (R/W=FFFFFFFFh)


```
  0-31   UNKNOWN (0..FFFFFFFFh) (R/W)
```



## 1040147Ch - PICA(011Fh) - GPUREG\_undoc\_1040147Ch (R/W=7FFFFFFFh)


```
  0-30   UNKNOWN (0..7FFFFFFFh) (R/W)
```

Power-up default is 00020200h, should be set to 00010140h. GPU hangs when set
to 7FFFFFFFh. Value 1FFFFFFFh can cause a few dirt pixels upon polygon
rendering. Guess: Maybe some PLL timing or memory waitstate/cache stuff?



## 10401480h - PICA(0120h) - GPUREG\_GAS\_LIGHT\_XY - Planar Shading (R/W)



## 10401484h - PICA(0121h) - GPUREG\_GAS\_LIGHT\_Z - View Shading (R/W)


```
  0-7    shading minimum intensity   (unsigned, 00h..FFh)
  8-15   shading maximum intensity   (unsigned, 00h..FFh)
  16-23  shading density attenuation (unsigned, 00h..FFh)
```



## 10401488h - PICA(0122h) - GPUREG\_GAS\_LIGHT\_Z\_COLOR (R/W)


```
  0-7    View shading effect in line-of-sight direction (unsigned, 00h..FFh)
  8      Gas color LUT input    (0=Gas density, 1=Light factor)
```

Configures gas light shading in the line-of-sight direction, and the input to
the gas color LUT.



## 1040148Ch - PICA(0123h) - GPUREG\_GAS\_LUT\_INDEX (W)


```
  0-15   Index... uh does that really have 16bit range? (W)
```

Index for writing GPUREG\_GAS\_LUT\_DATAi.



## 10401490h - PICA(0124h) - GPUREG\_GAS\_LUT\_DATA (R/W)


```
  0-31   LUT data
```

These registers behave as a FIFO queue. Each write to these registers writes
the provided value to the gas look-up table, starting at the index selected
with GPUREG\_GAS\_LUT\_INDEX. Uh, how many registers are "these registers"?

Gas Look-Up Table (16 elements):

- First 8 elements:
  - 0-7    Red    (signed, -80h..+7Fh)
  - 8-15   Green  (signed, -80h..+7Fh)
  - 16-23  Blue   (signed, -80h..+7Fh)
- Last 8 elements:
  - 0-7    Red    (unsigned, 00h..FFh)
  - 8-15   Green  (unsigned, 00h..FFh)
  - 16-23  Blue   (unsigned, 00h..FFh)



## 10401494h - PICA(0125h) - GPUREG\_undoc\_10401494h (R/W=0000FFFFh)


```
  0-15   UNKNOWN (0..FFFFh) (R/W)
```



## 10401498h - PICA(0126h) - GPUREG\_GAS\_DELTAZ\_DEPTH (R/W)


```
  0-23   Depth direction attenuation proportion (fixed0.16.8)
  24-25  Depth function (0..3, see below)
```

Configures the gas depth direction attenuation proportion, as well as the gas
depth function.

- Gas depth function values:
  - 0h = Never
  - 1h = Always
  - 2h = Greater than/Greater than or equal            ;uh?
  - 3h = Less than/Less than or equal/Equal/Not equal  ;uh??



## 104014C0h - PICA(0130h) - GPUREG\_FRAGOP\_SHADOW (R/W)


```
  0-15   float1.5.10, Sum of penumbra scale and penumbra bias
  16-31  float1.5.10, Penumbra scale with reversed sign
```

Configures shadow properties.



## 104014FCh - PICA(013Fh) - GPUREG\_undoc\_104014FCh (R/W=0000000Fh)


```
  0-15   UNKNOWN (0..0Fh) (R/W)
```




# <a name="3dsgpuinternalregisterstexturingregistersgenerictextures"></a>3DS GPU Internal Registers - Texturing registers (Generic Textures)




## 10401200h - PICA(0080h) - GPUREG\_TEXUNIT\_CONFIG (R/W)


```
  0      Texture 0 enable      (0=Disable, 1=Enable)                    (R/W)
  1      Texture 1 enable      (0=Disable, 1=Enable)                    (R/W)
  2      Texture 2 enable      (0=Disable, 1=Enable)                    (R/W)
  3      UNKNOWN "0x0" (R/W)                                            (R/W)
  8-9    Texture 3 coordinates (0=Texture0, 1=Texture1, 2=Texture2)     (R/W)
  10     Texture 3 enable      (0=Disable, 1=Enable)                    (R/W)
  12     UNKNOWN "0x1" (R/W)                                            (R/W)
  13     Texture 2 coordinates (0=Texture2, 1=Texture1)                 (R/W)
  16     Clear texture cache   (0=No change, 1=Clear)                   (W)
  17-31  0x0, uh, what???                                               (??)
  24-25  UNKNOWN (R/W)                                                  (R/W)
```



## 10401204h - PICA(0081h) - GPUREG\_TEXUNIT0\_BORDER\_COLOR (R/W)



## 10401244h - PICA(0091h) - GPUREG\_TEXUNIT1\_BORDER\_COLOR (R/W)



## 10401264h - PICA(0099h) - GPUREG\_TEXUNIT2\_BORDER\_COLOR (R/W)


```
  0-7    Border color Red    (unsigned, 00h..FFh)
  8-15   Border color Green  (unsigned, 00h..FFh)
  16-23  Border color Blue   (unsigned, 00h..FFh)
  24-31  Border color Alpha  (unsigned, 00h..FFh)
```



## 10401208h - PICA(0082h) - GPUREG\_TEXUNIT0\_DIM (R/W)



## 10401248h - PICA(0092h) - GPUREG\_TEXUNIT1\_DIM (R/W)



## 10401268h - PICA(009Ah) - GPUREG\_TEXUNIT2\_DIM (R/W)


```
  0-10   Texture dimension Height (unsigned, 0..7FFh)
  11-15  UNKNOWN (R/W)
  16-26  Texture dimension Width  (unsigned, 0..7FFh)
```



## 1040120Ch - PICA(0083h) - GPUREG\_TEXUNIT0\_PARAM (R/W)



## 1040124Ch - PICA(0093h) - GPUREG\_TEXUNIT1\_PARAM (R/W)



## 1040126Ch - PICA(009Bh) - GPUREG\_TEXUNIT2\_PARAM (R/W)


```
  0      UNKNOWN (R/W)
  1      Magnification filter   (0=Nearest, 1=Linear)
  2      Minification filter    (0=Nearest, 1=Linear)
  3      UNKNOWN (R/W)
  4-5    ETC1   (0=NotETC1, 2=ETC1, 1/3=?)  ;note: still 0 for ETC1A4
  6-7    UNKNOWN (R/W)
  8-10   Wrap T (0=ClampToEdge, 1=ClampToBorder, 2=Repeat, 3=MirroredRepeat)
  11     UNKNOWN (R/W)
  12-14  Wrap S (0=ClampToEdge, 1=ClampToBorder, 2=Repeat, 3=MirroredRepeat)
  15     UNKNOWN (R/W)
  16-17  UNKNOWN "0x0" (R/W)
  18-19  UNKNOWN (R/W)
  20     TEXUNIT0 only: Shadow (0=No, 1=Shadow)
  20     TEXUNIT1/2: UNKNOWN (R/W)
  21-23  UNKNOWN (R/W)
  24     Mipmap filter          (0=Nearest, 1=Linear)
  28-30  TEXUNIT0 only: Type   (see below)
  28-30  TEXUNIT1/2: Unused (0)
```

Type values:

```
  0=2D, 1=CubeMap, 2=Shadow2D, 3=Projection, 4=ShadowCube, 5=Disabled
```



## 10401210h - PICA(0084h) - GPUREG\_TEXUNIT0\_LOD (R/W)



## 10401250h - PICA(0094h) - GPUREG\_TEXUNIT1\_LOD (R/W)



## 10401270h - PICA(009Ch) - GPUREG\_TEXUNIT2\_LOD (R/W)


```
  0-12   fixed1.4.8, Bias
  13-15  UNKNOWN (R/W)
  16-19  Max Level of Detail (max LOD) (unsigned, 0..0Fh = ?)
  20-23  UNKNOWN (R/W)
  24-27  Min Level of Detail (min LOD) (unsigned, 0..0Fh = ?)
```



## 10401214h - PICA(0085h) - GPUREG\_TEXUNIT0\_ADDR1 (R/W)



## 10401218h - PICA(0086h) - GPUREG\_TEXUNIT0\_ADDR2 (R/W)



## 1040121Ch - PICA(0087h) - GPUREG\_TEXUNIT0\_ADDR3 (R/W)



## 10401220h - PICA(0088h) - GPUREG\_TEXUNIT0\_ADDR4 (R/W)



## 10401224h - PICA(0089h) - GPUREG\_TEXUNIT0\_ADDR5 (R/W)



## 10401228h - PICA(008Ah) - GPUREG\_TEXUNIT0\_ADDR6 (R/W)



## 10401254h - PICA(0095h) - GPUREG\_TEXUNIT1\_ADDR (R/W)



## 10401274h - PICA(009Dh) - GPUREG\_TEXUNIT2\_ADDR (R/W)


First ADDR register, PICA(0085h,0095h,009Dh):

```
  0-27   Texture physical memory address, in 8-byte units (full 28bits)
```

Subsequent ADDR registers, PICA(0086h..008Ah):

```
  0-21   Texture physical memory address, in 8-byte units (lower 22bits)
         (upper 6bits are reused from first ADDR register)
```

Individual texels in a texture are laid out in memory as a Z-order curve.
Mipmap data is stored directly following the main texture data.

If the texture is a cube:

```
  Register Description
  ADDR1    Positive X
  ADDR2    Negative X
  ADDR3    Positive Y
  ADDR4    Negative Y
  ADDR5    Positive Z
  ADDR6    Negative Z
```

Otherwise, ADDR(1) points to a 2D texture, and the rest are empty.



## 1040122Ch - PICA(008Bh) - GPUREG\_TEXUNIT0\_SHADOW (R/W)


```
  0      Perspective (0=Perspective, 1=Not perspective)
  1-23   fixed0.0.24, Z bias (upper 23 bits) (uh, how can that have 24bit?)
  24-31  UNKNOWN (R/W)
```

"Texture unit's shadow texture properties."



## 10401230h - PICA(008Ch) - GPUREG\_undoc\_10401230h (R/W=FFFF00FFh)


```
  0-7    UNKNOWN (0..FFh) (R/W)
  16-31  UNKNOWN (0..FFFFh) (R/W)
```



## 10401234h - PICA(008Dh) - GPUREG\_undoc\_10401234h (R/W=000000FFh)


```
  0-7    UNKNOWN (0..FFh) (R/W)
```



## 10401238h - PICA(008Eh) - GPUREG\_TEXUNIT0\_TYPE (R/W)



## 10401258h - PICA(0096h) - GPUREG\_TEXUNIT1\_TYPE (R/W)



## 10401278h - PICA(009Eh) - GPUREG\_TEXUNIT2\_TYPE (R/W)


```
  0-3    Texture Data Format
```

Format values:

```
  00h = RGBA8888        GL_RGBA            GL_UNSIGNED_BYTE
  01h = RGB888          GL_RGB             GL_UNSIGNED_BYTE
  02h = RGBA5551        GL_RGBA            GL_UNSIGNED_SHORT_5_5_5_1
  03h = RGB565          GL_RGB             GL_UNSIGNED_SHORT_5_6_5
  04h = RGBA4444        GL_RGBA            GL_UNSIGNED_SHORT_4_4_4_4
  05h = IA8             GL_LUMINANCE_ALPHA GL_UNSIGNED_BYTE
  06h = HILO8
  07h = I8              GL_LUMINANCE       GL_UNSIGNED_BYTE
  08h = A8              GL_ALPHA           GL_UNSIGNED_BYTE
  09h = IA44            GL_LUMINANCE_ALPHA GL_UNSIGNED_BYTE_4_4_EXT
  0Ah = I4
  0Bh = A4              GL_ALPHA           GL_UNSIGNED_NIBBLE_EXT
  0Ch = ETC1            GL_ETC1_RGB8_OES
  0Dh = ETC1A4
```




# <a name="3dsgpuinternalregisterstexturingregistersproceduraltexture"></a>3DS GPU Internal Registers - Texturing registers (Procedural Texture)



These registers are for "Procedural Texture", whatever that means. Probably
something for automatically generating or animating plasma/fire/water textures.

As far as known, these are controlled solely by the parameters in the registers
below (without actually using/supporting custom program code on the shader
units or so).

See GPUREG\_TEXUNIT\_CONFIG.bit8,9,10 for enable flag... and for selecting
coordinates from texture unit 0, 1, or 2. Unknown what those coordinates are
used for... as additional incoming PROCTEX parameters, or maybe the PROCTEX
unit does output coordinates to the selected texture unit?



## 104012A0h - PICA(00A8h) - GPUREG\_TEXUNIT3\_PROCTEX0 (R/W)


```
  0-2    U-direction clamp       ;\clamp, see below
  3-5    V-direction clamp       ;/
  6-9    RGB mapping function    ;\function, see below
  10-13  Alpha mapping function  ;/
  14     Handle alpha separately   (0=Don't separate, 1=Separate)
  15     Noise enable              (0=Disable, 1=Enable)
  16-17  U-direction shift         (0=None, 1=Odd, 2=Even, 3=?)
  18-19  V-direction shift         (0=None, 1=Odd, 2=Even, 3=?)
  20-27  Texture bias (lower 8bit of float1.5.10) (upper 8bit are in PROCTEX4)
```

Clamp values:

```
  00h = Clamp to zero
  01h = Clamp to edge
  02h = Symmetrical repeat
  03h = Mirrored repeat
  04h = Pulse
```

Mapping function values:

```
  00h = U
  01h = U^2
  02h = V
  03h = V^2
  04h = (U + V) / 2
  05h = (U^2 + V^2) / 2
  06h = sqrt(U^2 + V^2)
  07h = Minimum
  08h = Maximum
  09h = Rmax
```



## 104012A4h - PICA(00A9h) - GPUREG\_TEXUNIT3\_PROCTEX1 (R/W)


```
  0-15   fixed1.3.12, U-direction noise amplitude
  16-31  float1.5.10, U-direction noise phase
```

Configures the procedural texture unit's U-direction noise amplitude/phase.



## 104012A8h - PICA(00AAh) - GPUREG\_TEXUNIT3\_PROCTEX2 (R/W)


```
  0-15   fixed1.3.12, V-direction noise amplitude
  16-31  float1.5.10, V-direction noise phase
```

Configures the procedural texture unit's V-direction noise amplitude/phase.



## 104012ACh - PICA(00ABh) - GPUREG\_TEXUNIT3\_PROCTEX3 (R/W)


```
  0-15   float1.5.10, U-direction noise frequency
  16-31  float1.5.10, V-direction noise frequency
```

Configure the procedural texture unit's U-direction and V-direction noise
frequency.



## 104012B0h - PICA(00ACh) - GPUREG\_TEXUNIT3\_PROCTEX4 (R/W)


```
  0-2    Minification filter (see below)
  3-6    Min Level of Detail (Min LOD) (usually 0)
  7-10   Max Level of Detail (Max LOD) (usually 6)
  11-18  Texture width (unsigned, 00h..FFh)
  19-26  Texture bias (upper 8bit of float1.5.10) (lower 8bit are in PROCTEX0)
```

Minification filter values:

```
  00h = Nearest
  01h = Linear
  02h = Nearest, Mipmap Nearest
  03h = Linear, Mipmap Nearest
  04h = Nearest, Mipmap Linear
  05h = Linear, Mipmap Linear
```



## 104012B4h - PICA(00ADh) - GPUREG\_TEXUNIT3\_PROCTEX5\_LOW (R/W)



## 104012B8h - PICA(00AEh) - GPUREG\_TEXUNIT3\_PROCTEX5\_HIGH (R/W)


```
  0-7    Mipmap level 0 base level (usually 00h) (Texture offset)
  8-15   Mipmap level 1 offset     (usually 80h)
  16-23  Mipmap level 2 offset     (usually C0h)
  24-31  Mipmap level 3 offset     (usually E0h)
  32-39  Mipmap level 4 offset     (usually F0h)
  40-47  Mipmap level 5 offset     (usually F8h)
  48-55  Mipmap level 6 offset     (usually FCh)
  56-63  Mipmap level 7 offset     (usually FEh)
```

Usually set to LOW=E0C08000h, HIGH=FEFCF8F0h.

"Sets the procedural texture unit's offset."



## 104012BCh - PICA(00AFh) - GPUREG\_PROCTEX\_LUT\_INDEX (R/W)


```
  0-7    Index           (0..255 or 0..127, depending on selected table)
  8-11   Reference table (0=Noise, 1=?, 2=RGB, 3=Alpha, 4=Color, 5=ColorDiff)
```

Selects look-up table and index for writing via GPUREG\_PROCTEX\_LUT\_DATA(i).



## 104012C0h+i\*4 - PICA(00B0h+i) - GPUREG\_PROCTEX\_LUT\_DATA(0..7) (R/W)


```
  0-31   LUT data
```

These registers behave as a FIFO queue. Each write to these registers writes
the provided value to the table selected with GPUREG\_PROCTEX\_LUT, starting at
the selected index.

Noise Table (128 elements):

```
  0-11   fixed0.0.12, Value
  12-23  fixed0.0.12 with two's complement
           ( [0.5,1.0) mapped to [-1.0,0) ), Difference from next element
```

RGB Mapping Function Table (128 elements):

```
  0-11   fixed0.0.12, Value
  12-23  fixed0.0.12 with two's complement, Difference from next element
```

Alpha Mapping Function Table (128 elements):

```
  0-11   fixed0.0.12, Value
  12-23  fixed0.0.12 with two's complement, Difference from next element
```

Color Table (256 elements):

```
  0-7    Red           (unsigned, 00h..FFh)
  8-15   Green         (unsigned, 00h..FFh)
  16-23  Blue          (unsigned, 00h..FFh)
  24-31  Alpha         (unsigned, 00h..FFh)
```

Color Difference Table (256 elements):

```
  0-7    Half of red   (signed, -80h..+7Fh) ;\
  8-15   Half of green (signed, -80h..+7Fh) ; difference between current
  16-23  Half of blue  (signed, -80h..+7Fh) ; and next color table elements
  24-31  Half of alpha (signed, -80h..+7Fh) ;/
```


```
 ____________________ Procedural Texture Generation Notes _____________________
```



## Overview


Procedural texture generation has four stages:

```
  Noise Module (outputs u',v')
  Repeat Module (outputs u'',v'')
  Base Shape (also notated as G(u'',v''), output g)
  F(g) and Lookup Table
```



## Noise Module


This stage applies noise on the input coordinates. Little is known about this
other than that there are three noise parameters: Amplitude, Frequency, and
Phase.



## Repeat Module


This stage performs basic texture coordinate wrapping on the noised
coordinates. It supports symmetric and mirrored wrapping. They don't seem to be
configurable beyond that.



## Base Shape


The U'' and V'' coordinates are used to generate a scalar value in the range
[0;1] from the wrapped coordinates using one of six functions.

The output of this function is named "g".



## F(g) and Lookup Table


F is a selectable function which transforms g to another scalar value. There
are two known options for F:

```
  the identity function
  a triangle function
```

The final texel color is determined by using the value of F(g) as an index into
a configurable lookup table.




# <a name="3dsgpuinternalregisterstexturingregistersenvironment"></a>3DS GPU Internal Registers - Texturing registers (Environment)



Below are "texture env(ironment?)" registers for "texture combiner's". Unknown
what that means, probably something for merging output from texture units
0,1,2. But unknown why there are six TexEnv's.



## 10401300h - PICA(00C0h) - GPUREG\_TEXENV0\_SOURCE (R/W)



## 10401320h - PICA(00C8h) - GPUREG\_TEXENV1\_SOURCE (R/W)



## 10401340h - PICA(00D0h) - GPUREG\_TEXENV2\_SOURCE (R/W)



## 10401360h - PICA(00D8h) - GPUREG\_TEXENV3\_SOURCE (R/W)



## 104013C0h - PICA(00F0h) - GPUREG\_TEXENV4\_SOURCE (R/W)



## 104013E0h - PICA(00F8h) - GPUREG\_TEXENV5\_SOURCE (R/W)


```
  0-3    RGB source 0
  4-7    RGB source 1
  8-11   RGB source 2
  16-19  Alpha source 0
  20-23  Alpha source 1
  24-27  Alpha source 2
```

Configures a texture combiner's sources.

Source values:

```
  00h = Primary color
  01h = Fragment primary color
  02h = Fragment secondary color
  03h = Texture 0
  04h = Texture 1
  05h = Texture 2
  06h = Texture 3
  0xh = ?
  0Dh = Previous buffer
  0Eh = Constant (from GPUREG_TEXENVi_COLOR)
  0Fh = Previous
```



## 10401304h - PICA(00C1h) - GPUREG\_TEXENV0\_OPERAND (R/W)



## 10401324h - PICA(00C9h) - GPUREG\_TEXENV1\_OPERAND (R/W)



## 10401344h - PICA(00D1h) - GPUREG\_TEXENV2\_OPERAND (R/W)



## 10401364h - PICA(00D9h) - GPUREG\_TEXENV3\_OPERAND (R/W)



## 104013C4h - PICA(00F1h) - GPUREG\_TEXENV4\_OPERAND (R/W)



## 104013E4h - PICA(00F9h) - GPUREG\_TEXENV5\_OPERAND (R/W)


"Configures a texture combiner's operands."

uh, R/W mask is only 00111333h...?

```
  0-3    RGB operand 0    (0..0Dh, see below)     ;\uh, but R/W mask suggest
  4-7    RGB operand 1    (0..0Dh, see below)     ; range 0..3 only
  8-11   RGB operand 2    (0..0Dh, see below)     ;/
  12-14  Alpha operand 0  (0..7, see below)       ;\uh, but R/W mask suggest
  16-18  Alpha operand 1  (0..7, see below)       ; range 0..1 only
  20-22  Alpha operand 2  (0..7, see below)       ;/
```

RGB operand values:

```
  00h = Source color
  01h = One minus source color
  02h = Source alpha
  03h = One minus source alpha
  04h = Source red                    ;\
  05h = One minus source red          ;
  08h = Source green                  ; uh, really? R/W mask is only 2bit
  09h = One minus source green        ;
  0Ch = Source blue                   ;
  0Dh = One minus source blue         ;/
```

Alpha operand values:

```
  0h  = Source alpha
  1h  = One minus source alpha
  2h  = Source red                    ;\
  3h  = One minus source red          ;
  4h  = Source green                  ; uh, really? R/W mask is only 1bit
  5h  = One minus source green        ;
  6h  = Source blue                   ;
  7h  = One minus source blue         ;/
```



## 10401308h - PICA(00C2h) - GPUREG\_TEXENV0\_COMBINER (R/W)



## 10401328h - PICA(00CAh) - GPUREG\_TEXENV1\_COMBINER (R/W)



## 10401348h - PICA(00D2h) - GPUREG\_TEXENV2\_COMBINER (R/W)



## 10401368h - PICA(00DAh) - GPUREG\_TEXENV3\_COMBINER (R/W)



## 104013C8h - PICA(00F2h) - GPUREG\_TEXENV4\_COMBINER (R/W)



## 104013E8h - PICA(00FAh) - GPUREG\_TEXENV5\_COMBINER (R/W)


```
  0-3    RGB combine mode   (0..9, see below)
  16-19  Alpha combine mode (0..9, see below)
```

Combine mode values:

```
  0h = Replace
  1h = Modulate
  2h = Add
  3h = Add signed
  4h = Interpolate
  5h = Subtract
  6h = Dot3 RGB
  7h = Dot3 RGBA
  8h = Multiply then add
  9h = Add then multiply
  Ah..Fh = ?
```



## 1040130Ch - PICA(00C3h) - GPUREG\_TEXENV0\_COLOR (R/W)



## 1040132Ch - PICA(00CBh) - GPUREG\_TEXENV1\_COLOR (R/W)



## 1040134Ch - PICA(00D3h) - GPUREG\_TEXENV2\_COLOR (R/W)



## 1040136Ch - PICA(00DBh) - GPUREG\_TEXENV3\_COLOR (R/W)



## 104013CCh - PICA(00F3h) - GPUREG\_TEXENV4\_COLOR (R/W)



## 104013ECh - PICA(00FBh) - GPUREG\_TEXENV5\_COLOR (R/W)


```
  0-7    Constant color Red    (unsigned, 00h..FFh)
  8-15   Constant color Green  (unsigned, 00h..FFh)
  16-23  Constant color Blue   (unsigned, 00h..FFh)
  24-31  Constant color Alpha  (unsigned, 00h..FFh)
```



## 10401310h - PICA(00C4h) - GPUREG\_TEXENV0\_SCALE (R/W)



## 10401330h - PICA(00CCh) - GPUREG\_TEXENV1\_SCALE (R/W)



## 10401350h - PICA(00D4h) - GPUREG\_TEXENV2\_SCALE (R/W)



## 10401370h - PICA(00DCh) - GPUREG\_TEXENV3\_SCALE (R/W)



## 104013D0h - PICA(00F4h) - GPUREG\_TEXENV4\_SCALE (R/W)



## 104013F0h - PICA(00FCh) - GPUREG\_TEXENV5\_SCALE (R/W)


```
  0-1    RGB scale      (0=1x, 1=2x, 2=4x, 3=?)
  16-17  Alpha scale    (0=1x, 1=2x, 2=4x, 3=?)
```



## 1040131Ch - PICA(00C7h) - GPUREG\_undoc\_1040131Ch (R/W=00000007h)


```
  0-2    UNKNOWN (0..7) (R/W)
```



## 10401380h - PICA(00E0h) - GPUREG\_TEXENV\_UPDATE\_BUFFER (R/W)


```
  0-2    Fog mode                     (0=Disabled, 5=Fog, 7=Gas, other=?)
  3      Shading density source       (0=Plain density, 1=Depth density)
  8      TexEnv 1 RGB buffer input    (0=Previous Buffer, 1=Previous)
  9      TexEnv 2 RGB buffer input    (0=Previous Buffer, 1=Previous)
  10     TexEnv 3 RGB buffer input    (0=Previous Buffer, 1=Previous)
  11     TexEnv 4 RGB buffer input    (0=Previous Buffer, 1=Previous)
  12     TexEnv 1 Alpha buffer input  (0=Previous Buffer, 1=Previous)
  13     TexEnv 2 Alpha buffer input  (0=Previous Buffer, 1=Previous)
  14     TexEnv 3 Alpha buffer input  (0=Previous Buffer, 1=Previous)
  15     TexEnv 4 Alpha buffer input  (0=Previous Buffer, 1=Previous)
  16     Z flip                       (0=Don't flip,1=Flip)
  24-25  UNKNOWN "0x0" (R/W)
```

This register is shared between the gas/fog mode configuration and texture
combiner buffer inputs. Texture combiner buffer inputs are typically written
with a mask of 0x2, and the gas/fog mode configuration is typically written
with a mask of 0x5.



## 10401384h - PICA(00E1h) - GPUREG\_FOG\_COLOR (R/W)


```
  0-7    Fog color Red    (unsigned, 00h..FFh)
  8-15   Fog color Green  (unsigned, 00h..FFh)
  16-23  Fog color Blue   (unsigned, 00h..FFh)
```



## 10401388h - PICA(00E2h) - GPUREG\_undoc\_10401388h (R/W=0000FFFFh)



## 1040138Ch - PICA(00E3h) - GPUREG\_undoc\_1040138Ch (R/W=0000FFFFh)


```
  0-15   UNKNOWN (0..FFFFh) (R/W)
```



## 10401390h - PICA(00E4h) - GPUREG\_GAS\_ATTENUATION (R/W)


```
  0-15   float1.5.10, Gas density attenuation
```



## 10401394h - PICA(00E5h) - GPUREG\_GAS\_ACCMAX (R/W)


```
  0-15   float1.5.10, Gas maximum density accumulation
```



## 10401398h - PICA(00E6h) - GPUREG\_FOG\_LUT\_INDEX (R/W)


```
  0-6    Index for FOG_LUT_DATA (0..7Fh)
```

The index is incremented on FOG\_LUT\_DATA writes (but not incremented on reads).



## 104013A0h+i\*4 - PICA(00E8h+i) - GPUREG\_FOG\_LUT\_DATA(0..7) (R/W)


```
  0-12   fixed1.1.11, Difference from next entry
  13-23  fixed0.0.11, Value
```

These registers behave as a FIFO queue. Each write to these registers writes
the provided value to the fog look-up table, starting at the index selected
with GPUREG\_FOG\_LUT\_INDEX.



## 104013F4h - PICA(00FDh) - GPUREG\_TEXENV\_BUFFER\_COLOR (R/W)


```
  0-7    Texture combiner buffer color Red    (unsigned, 00h..FFh)
  8-15   Texture combiner buffer color Green  (unsigned, 00h..FFh)
  16-23  Texture combiner buffer color Blue   (unsigned, 00h..FFh)
  24-31  Texture combiner buffer color Alpha  (unsigned, 00h..FFh)
```




# <a name="3dsgpuinternalregistersfragmentlightingregisters"></a>3DS GPU Internal Registers - Fragment Lighting registers




## 10401500h+i\*40h - PICA(0140h+10h\*(0..7)) - GPUREG\_LIGHTi\_SPECULAR0 (R/W)



## 10401504h+i\*40h - PICA(0141h+10h\*(0..7)) - GPUREG\_LIGHTi\_SPECULAR1 (R/W)



## 10401508h+i\*40h - PICA(0142h+10h\*(0..7)) - GPUREG\_LIGHTi\_DIFFUSE (R/W)



## 1040150Ch+i\*40h - PICA(0143h+10h\*(0..7)) - GPUREG\_LIGHTi\_AMBIENT (R/W)



## 10401700h - PICA(01C0h) - GPUREG\_LIGHTING\_AMBIENT (R/W)


```
  0-7    unsigned, Blue
  8-9    UNKNOWN (maybe Blue MSBs? if so, is it really unsigned?) (R/W)
  10-17  unsigned, Green
  18-19  UNKNOWN (R/W)
  20-27  unsigned, Red
  28-29  UNKNOWN (R/W)
```

These registers contain the colors of the corresponding lights, usually set to
following values:

```
  GPUREG_LIGHTi_SPECULAR0 = material_specular0*lightX_specular0
  GPUREG_LIGHTi_SPECULAR1 = material_specular1*lightX_specular1
  GPUREG_LIGHTi_DIFFUSE   = material_diffuse*lightX_diffuse
  GPUREG_LIGHTi_AMBIENT   = material_ambient*lightX_ambient
  GPUREG_LIGHTING_AMBIENT = material_ambient*scene_ambient + material_emission
```



## 10401510h+i\*40h - PICA(0144h+10h\*(0..7)) - GPUREG\_LIGHTi\_VECTOR\_LOW (R/W)



## 10401514h+i\*40h - PICA(0145h+10h\*(0..7)) - GPUREG\_LIGHTi\_VECTOR\_HIGH (R/W)


```
  0-15   float1.5.10, X coordinate
  16-31  float1.5.10, Y coordinate
  32-47  float1.5.10, Z coordinate
```

Light position (for a positional light) or the light direction vector (for a
directional light) of the corresponding light.

Uh, does the direction vector need to be normalized? And how does it differ
from SPOTDIR direction vector?



## 10401518h+i\*40h - PICA(0146h+10h\*(0..7)) - GPUREG\_LIGHTi\_SPOTDIR\_LOW (R/W)



## 1040151Ch+i\*40h - PICA(0147h+10h\*(0..7)) - GPUREG\_LIGHTi\_SPOTDIR\_HIGH (R/W)


```
  0-12   fixed1.1.11, X coordinate (negated)
  16-28  fixed1.1.11, Y coordinate (negated)
  32-44  fixed1.1.11, Z coordinate (negated)
```

Spot direction (unitary) vector of the corresponding light.



## 10401524h+i\*40h - PICA(0149h+10h\*(0..7)) - GPUREG\_LIGHTi\_CONFIG (R/W)


```
  0      Light type             (0=Positional light, 1=Directional light)
  1      Two side diffuse       (0=One side, 1=Both sides)
  2      Use geometric factor 0 (0=Don't use, 1=Use)
  3      Use geometric factor 1 (0=Don't use, 1=Use)
```

Configures a light's properties.



## 10401528h+i\*40h - PICA(014Ah+10h\*(0..7)) - GPUREG\_LIGHTi\_ATTENUATION\_BIAS



## 1040152Ch+i\*40h - PICA(014Bh+10h\*(0..7)) - GPUREG\_LIGHTi\_ATTENUATION\_SCALE


```
  0-19   float1.7.12, Distance attenuation value    (R/W)
```

For the odd 20bit floating point format, one could do:

```
  (float24)/10h                ;convert float1.7.16 to float1.7.12
```

Distance attenuation BIAS and SCALE values of the corresponding light.

The attenuation factor is DA(clip(BIAS + SCALE\*distance, 0.0, 1.0)).


```
 _______________________
```



## 1040123Ch - PICA(008Fh) - GPUREG\_LIGHTING\_ENABLE (R/W)


```
  0      Enable Lighting  (0=Disable, 1=Enable)
```

Uh, that is in texture register area... is that texture specific?



## 10401718h - PICA(01C6h) - GPUREG\_LIGHTING\_DISABLE (R/W)


```
  0      Disable (0=Enable, 1=Disable)
```



## 10401708h - PICA(01C2h) - GPUREG\_LIGHTING\_NUM\_LIGHTS (R/W)


```
  0-2    Number of active lights - 1    (0..7 = 1..8 Lights)
```

To use 0 lights, one seems to have to disable lighting... unknown if one can
keep GPUREG\_LIGHTING\_AMBIENT enabled in that state.



## 1040170Ch - PICA(01C3h) - GPUREG\_LIGHTING\_CONFIG0 (R/W)


```
  0      Shadow factor enable  (0=Disable, 1=Enable)
           (usually accompanied by bit 16, 17, or 18)
  2-3    Fresnel selector (0=None, 1=Primary, 2=Secondary, 3=Both alpha's)
  4-7    Light environment configuration (see below)
  8-11   UNKNOWN "0x4" (R/W)
  16     Apply shadow attenuation to primary color   (0=Don't apply, 1=Apply)
  17     Apply shadow attenuation to secondary color (0=Don't apply, 1=Apply)
  18     Invert shadow attenuation                 (0=Don't invert, 1=Invert)
  19     Apply shadow attenuation to alpha component (0=Don't apply, 1=Apply)
  20-21  UNKNOWN (R/W)
  22-23  Bump map texture unit
  24-25  Shadow map texture unit
  26     UNKNOWN (R/W)
  27     Clamp highlights         (0=Disable, 1=Enable)
  28-29  Bump mode (0=Not used, 1=Use as bump map, 2=Use as tangent map)
  30     Recalculate bump vectors (0=Enable, 1=Disable)
           (usually set to 1 when bump mode is not 0)
  31     UNKNOWN "0x1" (R/W)
```

Fresnel selector values:

```
  0h = None
  1h = Primary alpha
  2h = Secondary alpha
  3h = Primary and secondary alpha
```

Light environment configuration values:

```
  Value Description       Available LUTs
  00h = Configuration 0   D0, RR, SP, DA
  01h = Configuration 1   FR, RR, SP, DA
  02h = Configuration 2   D0, D1, RR, DA
  03h = Configuration 3   D0, D1, FR, DA
  04h = Configuration 4   All except for FR
  05h = Configuration 5   All except for D1
  06h = Configuration 6   All except for RB and RG
  08h = Configuration 7   All
```

The light environment configuration controls which LUTs are available for use.
If a LUT is not available in the selected configuration, its value will always
read a constant 1.0 regardless of the enable state in GPUREG\_LIGHTING\_CONFIG1.
If RR is enabled but not RG or RB, the output of RR is used for the three
components; Red, Green and Blue.



## 10401710h - PICA(01C4h) - GPUREG\_LIGHTING\_CONFIG1 (R/W)


```
  0-7   Fragment light source 0-7 shadows              (0=Enable, 1=Disable)
  8-15  Fragment light source 0-7 spot light           (0=Enable, 1=Disable)
  16    Term 0 distribution component D0 LUT           (0=Enable, 1=Disable)
  17    Term 1 distribution component D1 LUT           (0=Enable, 1=Disable)
  18    0x1                                            (1)
  19    Fresnel FR LUT disabled                        (0=Enable, 1=Disable)
  20    Term 1 reflection component RB LUT             (0=Enable, 1=Disable)
  21    Term 1 reflection component RG LUT             (0=Enable, 1=Disable)
  22    Term 1 reflection component RR LUT             (0=Enable, 1=Disable)
  24-31 Fragment light source 0-7 distance attenuation (0=Enable, 1=Disable)
```

Allows to disable various aspects of the light environment.



## 10401714h - PICA(01C5h) - GPUREG\_LIGHTING\_LUT\_INDEX (R/W)


```
  0-7   Starting index       (00h..FFh)    ;\for reading/writing via
  8-12  Look-up table number (see below)   ;/GPUREG_LIGHTING_LUT_DATA(i)
```

Lookup table numbers:

```
  00h     = D0      ;\Distribution, whatever that is?
  01h     = D1      ;/
  03h     = FR      ;-Fresnel, whatever that is?
  04h     = RB      ;\
  05h     = RG      ; Reflection with separate blue/green/red tables?
  06h     = RR      ;/
  08h-0Fh = SP0-7   ;-Spotlight?             ;\maybe for light 0..7 ?
  10h-17h = DA0-7   ;-Distance attenuation?  ;/
```

Note: The index in bit0-7 is auto-incremented when writing (or reading)
LUT\_DATA registers; there is no carry-out to table number in bit8-12.



## 10401720h+i\*4 - PICA(01C8h+i) - GPUREG\_LIGHTING\_LUT\_DATA(0..7) (R/W)


```
  0-11   fixed0.0.12, Entry value
  12-23  fixed1.0.11, Absolute value of the difference between the next
           entry and this entry, used to implement linear interpolation
           uh, how/why is that a ABSOLUTE value WITH SIGN bit?
```

A LUT contains data for the input domain [-1.0, 1.0], which is indexed using a
signed 8bit number [-128, 127]. Therefore a LUT contains 256 entries. The index
of a value is (int)(x/127.0f) & 0xFF.

DA: The input domain is [0.0, 1.0], and the index is an unsigned 8bit number
[0, 255] instead.



## 10401740h - PICA(01D0h) - GPUREG\_LIGHTING\_LUTINPUT\_ABS (R/W)


```
  0      UNKNOWN (R/W)
  1      abs() flag for the input of D0 (0=Enable, 1=Disable)
  4      UNKNOWN (R/W)
  5      abs() flag for the input of D1 (0=Enable, 1=Disable)
  8      UNKNOWN (R/W)
  9      abs() flag for the input of SP (0=Enable, 1=Disable)
  12     UNKNOWN (R/W)
  13     abs() flag for the input of FR (0=Enable, 1=Disable)
  16     UNKNOWN (R/W)
  17     abs() flag for the input of RB (0=Enable, 1=Disable)
  20     UNKNOWN (R/W)
  21     abs() flag for the input of RG (0=Enable, 1=Disable)
  24     UNKNOWN (R/W)
  25     abs() flag for the input of RR (0=Enable, 1=Disable)
```

Controls whether the absolute value of the input is taken before using a LUT.



## 10401744h - PICA(01D1h) - GPUREG\_LIGHTING\_LUTINPUT\_SELECT (R/W)


```
  0-2    Input selector for D0  ;\Input selector values:
  4-6    Input selector for D1  ;  0h = N . H   ;uh, dot symbol?
  8-10   Input selector for SP  ;  1h = V . H   ; ... maybe multiply?
  12-14  Input selector for FR  ;  2h = N . V   ;uh, who is N,H,L,V,P
  16-18  Input selector for RB  ;  3h = L . N   ; and greek symbol?
  20-22  Input selector for RG  ;  4h = -L . P (aka Spotlight aka SP)
  24-26  Input selector for RR  ;/ 5h = cos <greek symbol> (aka CP)
```

Selects the input from LUTs.

```
  N = Normal Vector?
  V = View Vector?
  L = Light Vector?
  H = ?
  P = ?
  cos <greek symbol> = ?
```



## 10401748h - PICA(01D2h) - GPUREG\_LIGHTING\_LUTINPUT\_SCALE (R/W)


```
  0-2    Scaler selector for D0    ;\Scaler selector values:
  4-6    Scaler selector for D1    ;  0h = 1x
  8-10   Scaler selector for SP    ;  1h = 2x
  12-14  Scaler selector for FR    ;  2h = 4x
  16-18  Scaler selector for RB    ;  3h = 8x
  20-22  Scaler selector for RG    ;  6h = 0.25x
  24-26  Scaler selector for RR    ;/ 7h = 0.5x
  28-30  UNKNOWN (R/W)
```

Controls the scaling that is applied to the output of a LUT.



## 1040174Ch - PICA(01D3h) - GPUREG\_undoc\_1040174Ch (R/W=00000001h)


```
  0      UNKNOWN (0..1) (R/W)
```



## 10401750h - PICA(01D4h) - GPUREG\_undoc\_10401750h (R/W=0FFFFF03h)


```
  0-1    UNKNOWN (0..3) (R/W)
  8-31   UNKNOWN (0..FFFFFFh) (R/W)
```



## 10401754h - PICA(01D5h) - GPUREG\_undoc\_10401754h (R/W=1FFF1FFFh)



## 10401758h - PICA(01D6h) - GPUREG\_undoc\_10401758h (R/W=1FFF1FFFh)


```
  0-12   UNKNOWN (0..1FFFh) (R/W)
  16-28  UNKNOWN (0..1FFFh) (R/W)
```



## 1040175Ch - PICA(01D7h) - GPUREG\_undoc\_1040175Ch (R/W=000FFFFFh)



## 10401760h - PICA(01D8h) - GPUREG\_undoc\_10401760h (R/W=000FFFFFh)


```
  0-19   UNKNOWN (0..FFFFFh) (R/W)
```



## 10401764h - PICA(01D9h) - GPUREG\_LIGHTING\_LIGHT\_PERMUTATION (R/W)


```
  0-2    ID of the 1st enabled light (0..7)
  4-6    ID of the 2nd enabled light (0..7)
  8-10   ID of the 3rd enabled light (0..7)
  12-14  ID of the 4th enabled light (0..7)
  16-18  ID of the 5th enabled light (0..7)
  20-22  ID of the 6th enabled light (0..7)
  24-26  ID of the 7th enabled light (0..7)
  28-30  ID of the 8th enabled light (0..7)
```

Sets the IDs of enabled light sources (1st..8th light does refer to the number
of lights in GPUREG\_LIGHTING\_NUM\_LIGHTS).

Uh, LIGHT\_PERMUTATION is a scary homebrew slang for LIGHT\_IDs?




# <a name="3dsgpuinternalregistersunknownunusedundocumentedregisters"></a>3DS GPU Internal Registers - Unknown/Unused/Undocumented Registers




## Unused Registers that Mirror to GPUREG\_RESTART\_PRIMITIVE (R/W)


```
  104011C0h 40h  ;PICA(0070h..007Fh) mirrors to GPUREG_RESTART_PRIMITIVE
  104013F8h 08h  ;PICA(00FEh..00FFh) mirrors to GPUREG_RESTART_PRIMITIVE
  1040149Ch 24h  ;PICA(0127h..012Fh) mirrors to GPUREG_RESTART_PRIMITIVE
  10401780h 80h  ;PICA(01E0h..01FFh) mirrors to GPUREG_RESTART_PRIMITIVE
  10401900h 08h  ;PICA(0240h..0241h) mirrors to GPUREG_RESTART_PRIMITIVE
  10401918h 10h  ;PICA(0246h..0249h) mirrors to GPUREG_RESTART_PRIMITIVE
  1040192Ch 14h  ;PICA(024Bh..024Fh) mirrors to GPUREG_RESTART_PRIMITIVE
  10401960h 18h  ;PICA(0258h..025Dh) mirrors to GPUREG_RESTART_PRIMITIVE
  10401980h 80h  ;PICA(0260h..027Fh) mirrors to GPUREG_RESTART_PRIMITIVE
  10401D00h 300h ;PICA(0340h..03FFh) mirrors to GPUREG_RESTART_PRIMITIVE
```

The mirrors (and GPUREG\_RESTART\_PRIMITIVE itself) are R/W, however, writing
doesn't always work for some reason, or the write is applied only after issuing
another three writes or so?



## Unused or Write-Only Registers that return Garbage/Mirrors when reading


104018BCh..104018DCh and 104018F0h..104018FCh do return mirrors of multiple
other registers ORed together.

```
  104018BCh = 1040183Ch,1040189Ch,104018B4h           ;ATTR_BUF_DRAWELEMENTS
  104018C0h = 10401840h,104018E0h,10401880h           ;unused (or write-only?)
  104018C4h = 10401844h,104018E4h,10401884h           ;VTX_FUNC
  104018C8h = 10401848h,104018E8h,10401888h           ;FIXEDATTRIB_INDEX
  104018CCh = 1040184Ch,104018ECh,1040188Ch,1040189Ch ;FIXEDATTRIB_DATA0
  104018D0h = 10401850h,104018E0h,10401890h           ;FIXEDATTRIB_DATA1
  104018D4h = 10401854h,104018E4h,10401894h           ;FIXEDATTRIB_DATA2
  104018D8h = 10401858h,104018E8h,10401898h           ;unused (or write-only?)
  104018DCh = 1040185Ch,104018ECh                     ;unused (or write-only?)
  104018F0h = 10401870h,104018E0h                     ;GPUREG_CMDBUF_JUMP0
  104018F4h = 10401874h,104018E4h,104018B4h           ;GPUREG_CMDBUF_JUMP1
  104018F8h = 10401878h,104018E8h                     ;unused (or write-only?)
  104018FCh = 1040187Ch,104018ECh,104018B4h,1040189Ch ;unused (or write-only?)
```

10401940h, 10401958h, 1040195Ch seem to mirror to single registers without
ORing multiple values.

```
  10401940h = 10401944h (GPUREG_VSH_OUTMAP_TOTAL2)    ;unused (or write-only?)
  10401958h = 10401950h (GPUREG_GSH_MISC1)            ;unused (or write-only?)
  1040195Ch = 1040194Ch (GPUREG_GEOSTAGE_CONFIG2)     ;unused (or write-only?)
```



## Unused or Write-Only Registers that return Zero when reading


```
  1040118Ch = zero                                    ;EARLYDEPTH_CLEAR
  10401440h = zero                                    ;RENDERBUFFER_INVALIDATE
  10401444h = zero                                    ;RENDERBUFFER_FLUSH
  1040148Ch = zero                                    ;GAS_LUT_INDEX
  104018B8h = zero                                    ;ATTR_BUF_DRAWARRAYS
  10401A14h/10401AD4h/10401B94h/10401C54h     = zero  ;unused (or write-only?)
  10401A18h/10401AD8h/10401B98h/10401C58h     = zero  ;unused (or write-only?)
  10401A1Ch/10401ADCh/10401B9Ch/10401C5Ch     = zero  ;unused (or write-only?)
  10401A20h/10401AE0h/10401BA0h/10401C60h     = zero  ;unused (or write-only?)
  10401A38h/10401AF8h/10401BB8h/10401C78h     = zero  ;unused (or write-only?)
  10401A3Ch/10401AFCh/10401BBCh/10401C7Ch     = zero  ;CODETRANSFER_END
  10401A40h/10401B00h/10401BC0h/10401C80h     = zero  ;FLOATUNIFORM_INDEX
  10401A44h/10401B04h/10401BC4h/10401C84h+i*4 = zero  ;FLOATUNIFORM_DATA0-7
  10401A64h/10401B24h/10401BE4h/10401CA4h     = zero  ;unused (or write-only?)
  10401A68h/10401B28h/10401BE8h/10401CA8h     = zero  ;unused (or write-only?)
  10401A6Ch/10401B2Ch/10401BECh/10401CACh     = zero  ;CODETRANSFER_INDEX
  10401A70h/10401B30h/10401BF0h/10401CB0h+i*4 = zero  ;CODETRANSFER_DATA0-7
  10401A90h/10401B50h/10401B10h/10401CD0h     = zero  ;unused (or write-only?)
  10401A94h/10401B54h/10401C14h/10401CD4h     = zero  ;OPDESCS_INDEX
  10401A98h/10401B58h/10401C18h/10401CD8h+i*4 = zero  ;OPDESCS_DATA0..7
  10401AB8h/10401B78h/10401C38h/10401CF8h     = zero  ;unused (or write-only?)
  10401ABCh/10401B7Ch/10401C3Ch/10401CFCh     = zero  ;unused (or write-only?)
```



## Unused Registers that return Zero when reading


These registers aren't R/W, and they seem to be always zero (though some might
be undocumented read-only or write-only registers).

```
  104010D8h 28h  ;PICA(N/A)          unused (0)            ;-Finalize
  1040115Ch 4    ;PICA(0057h)        unused (0)
  10401174h 0Ch  ;PICA(005Dh..005Fh) unused (0)
  10401240h 4    ;PICA(0090h)        unused (0)   ;XXX used, write-only?
  1040125Ch 4    ;PICA(0097h)        unused (0)   ;XXX used, write-only?
  10401260h 4    ;PICA(0098h)        unused (0)   ;XXX used, write-only?
  1040127Ch 24h  ;PICA(009Fh..00A7h) unused (0)
  104012E0h 20h  ;PICA(00B8h..00BFh) unused (0)
  10401314h 08h  ;PICA(00C5h..00C6h) unused (0)            ;-TexEnv0
  10401334h 0Ch  ;PICA(00CDh..00CFh) unused (0)            ;-TexEnv1
  10401354h 0Ch  ;PICA(00D5h..00D7h) unused (0)            ;-TexEnv2
  10401374h 0Ch  ;PICA(00DDh..00DFh) unused (0)            ;-TexEnv3
  1040139Ch 4    ;PICA(00E7h)        unused (0)
  104013D4h 0Ch  ;PICA(00F5h..00F7h) unused (0)            ;-TexEnv4
  10401420h 14h  ;PICA(0108h..010Ch) unused (0)
  104014C4h 38h  ;PICA(0131h..013Eh) unused (0)
  10401520h 4    ;PICA(0148h)        unused (0)            ;\LIGHT0
  10401530h 10h  ;PICA(014Ch..014Fh) unused (0)            ;/
  10401560h 4    ;PICA(0158h)        unused (0)            ;\LIGHT1
  10401570h 10h  ;PICA(015Ch..015Fh) unused (0)            ;/
  104015A0h 4    ;PICA(0168h)        unused (0)            ;\LIGHT2
  104015B0h 10h  ;PICA(016Ch..016Fh) unused (0)            ;/
  104015E0h 4    ;PICA(0178h)        unused (0)            ;\LIGHT3
  104015F0h 10h  ;PICA(017Ch..017Fh) unused (0)            ;/
  10401620h 4    ;PICA(0188h)        unused (0)            ;\LIGHT4
  10401630h 10h  ;PICA(018Ch..018Fh) unused (0)            ;/
  10401660h 4    ;PICA(0198h)        unused (0)            ;\LIGHT5
  10401670h 10h  ;PICA(019Ch..019Fh) unused (0)            ;/
  104016A0h 4    ;PICA(01A8h)        unused (0)            ;\LIGHT6
  104016B0h 10h  ;PICA(01ACh..01AFh) unused (0)            ;/
  104016E0h 4    ;PICA(01B8h)        unused (0)            ;\LIGHT7
  104016F0h 10h  ;PICA(01BCh..01BFh) unused (0)            ;/
  10401704h 4    ;PICA(01C1h)        unused (0)            ;\
  1040171Ch 4    ;PICA(01C7h)        unused (0)            ; LIGHTING
  10401768h 18h  ;PICA(01DAh..01DFh) unused (0)            ;/
  104018ACh 08h  ;PICA(022Bh..022Ch) unused (0)            ;-VERTEX
```



## Unused command numbers PICA(0000h..000Fh, 0020h..003Fh)


Registers at 10401000h..1040103Fh and 10401080h..104010FFh are writeable by
ARM11 only, not via PICA command numbers 0000h..000Fh, 0020h..003Fh.



## Unused command numbers PICA(0400h..FFFFh)


The PICA command numbers in CMDBUF are said to be 16bit wide, however, values
0400h..FFFFh seem to be unused (and there are no I/O addresses for them;
accessing 10402000h and up triggers data abort).




# <a name="3dsgpushaderinstructionsetopcodesummary"></a>3DS GPU Shader Instruction Set - Opcode Summary




## Shader Instruction Set Summary


```
  Opcode  Fmt  Name    Description
  00h     1    ADD     Add two vectors component by component
  01h     1    DP3     Dot product on two 3-component vectors
  02h     1    DP4     Dot product on two 4-component vectors
  03h     1    DPH     Dot product on a 3-component and a 4-component vector
  04h     1    DST     Equivalent to Microsoft's "dst" instruction
  05h     1u   EX2     Exponent with base 2 on 1st component of SRC1
  06h     1u   LG2     Logarithm with base 2 on 1st component of SRC1
  07h     1u   LITP    Related to Microsoft's "lit" instruction
  08h     1    MUL     Multiply two vectors component by component
  09h     1    SGE     Set output if SRC1>=SRC2
  0Ah     1    SLT     Set output if SRC1<SRC2
  0Bh     1u   FLR     Computes SRC1's floor component by component
  0Ch     1    MAX     Max of two vectors, component by component
  0Dh     1    MIN     Min of two vectors, component by component
  0Eh     1u   RCP     Reciprocal of vector's 1st component
  0Fh     1u   RSQ     Reciprocal of square root of vector's 1st component
  10h-11h ?    ?       ?
  12h     1u   MOVA    Move to address register (float to integer) (to "a0" ?)
  13h     1u   MOV     Move to register
  14h-17h ?    ?       ?
  18h     1i   DPHI    Dot product on a 3-component and a 4-component vector
  19h     1i   DSTI    DST with sources swapped
  1Ah     1i   SGEI    Set output if SRC1>=SRC2
  1Bh     1i   SLTI    Set output if SRC1<SRC2
  1Ch-1Fh ?    ?       ?
  20h     0    BREAK   Break out of LOOP block
  21h     0    NOP     No operation
  22h     0    END     Done (stop execution and set ready flag?)
  23h     2    BREAKC  Break (if condition is true)
  24h     2    CALL    Call (jump to DST, and return after NUM instructions)
  25h     2    CALLC   Call (as above, if condition is true)
  26h     3    CALLU   Call (as above, if BOOL is true)
  27h     3    IFU     Jump if/else BOOL is true
  28h     2    IFC     Jump if/else condition is true
  29h     3    LOOP    Loop start (repeat following opcodes)
  2Ah     0    EMIT    Geometry shader only: Emit vertex (or vertex+primitive)
  2Bh     4    SETEMIT Geometry shader only: Configure type/flags for EMIT
  2Ch     2    JMPC    Jump if condition is true
  2Dh     3    JMPU    Jump if BOOL is true
  2Eh-2Fh 1c   CMP     Compare X and Y components and Set booleans cmp.x/y
  30h-37h 5i   MADI    Multiply and Add vectors, component by component
  38h-3Fh 5    MAD     Multiply and Add vectors, component by component
```



## Shader Opcode/Parameter Encoding Formats


```
  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0| Fmt
  |_Opcode____|__0________________________________________________| 0  ;NoParam
  |_Opcode____|__Dst____|i1_|__Src1_______|__Src2___|______Desc___| 1  ;\
  |_Opcode____|__Dst____|i2_|__Src1___|______Src2___|______Desc___| 1i ; misc
  |_Opcode____|__Dst____|i1_|__Src1_______|__?______|______Desc___| 1u ;/
  |_Opcode__|CmpX_|CmpY_|i1_|__Src1_______|__Src2___|______Desc___| 1c CMP
  |_Opcode____|X|Y|Cnd|________DstOffs________|_?_|__NumInstr_____| 2  ;\JMP
  |_Opcode____|uID____|________DstOffs________|_?_|__NumInstr?____| 3  ;/etc.
  |_Opcode____|vID|P|W|__?________________________________________| 4  ;SETEMIT
  |_Opc_|__Dst____|i2_|__Src1___|__Src2_______|__Src3___|__Desc___| 5  ;MAD
  |_Opc_|__Dst____|i3_|__Src1___|__Src2___|______Src3___|__Desc___| 5i ;MADI
```



## Shader Operand descriptors (OPDESC's)


```
  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0|
  | |s0 |s1 |s2 |s3 |n|s0 |s1 |s2 |s3 |n|s0 |s1 |s2 |s3 |n|X_Y_Z_W|
     <---Source3-----> <---Source2-----> <---Source1-----> <-Dst->
```




# <a name="3dsgpushaderinstructionsetblurp"></a>3DS GPU Shader Instruction Set - Blurp




## Overview


A compiled shader binary is comprised of two parts: the main instruction
sequence and the operand descriptor table. These are both sent to the GPU
around the same time but using separate GPU Commands. Instructions (such as
format 1 instruction) may reference operand descriptors. When such is the case,
the operand descriptor ID is the offset, in words, of the descriptor within the
table. Both instructions and descriptors are coded in little endian. Basic
implementations of the following specification can be found at [1] and [2]. The
instruction set seems to have been heavily inspired by Microsoft's vs\_3\_0 [3]
and the Direct3D shader code [4]. Please note that this page is being written
as the instruction set is reverse engineered; as such it may very well contain
mistakes.


Debug information found in the code.bin of "Ironfall: Invasion" suggests that
there may not be more than 512 instructions and 128 operand descriptors in a
shader.



## Nomenclature


- - opcode names with I appended to them are the same as their non-I version,
        - except they use the inverted instruction format, giving 7 bits to SRC2
        - (and access to uniforms) and 5 bits to SRC1
- - opcode names with U appended to them are the same as their non-U version,
        - except they are executed conditionally based on the value of a uniform
        - boolean.
- - opcode names with C appended to them are the same as their non-C version,
        - except they are executed conditionally based on a logical expression
        - specified in the instruction.



## Instruction formats


```
  Offset  Size (bits)     Description
 Format 1: (used for register operations)
  0x0  0-6    0x7     Operand descriptor ID (DESC)
  0x7  7-11   0x5     Source 2 register (SRC2)
  0xC  12-18  0x7     Source 1 register (SRC1)
  0x13 19-20  0x2     Address register index for SRC1 (IDX_1)
  0x15 21-25  0x5     Destination register (DST)
  0x1A 26-31  0x6     Opcode
 Format 1i: (used for register operations)
  0x0  0-6    0x7     Operand descriptor ID (DESC)
  0x7  7-13   0x7     Source 2 register (SRC2)
  0xE  14-18  0x5     Source 1 register (SRC1)
  0x13 19-20  0x2     Address register index for SRC2 (IDX_2)
  0x15 21-25  0x5     Destination register (DST)
  0x1A 26-31  0x6     Opcode
 Format 1u: (used for unary register operations)
  0x0  0-6    0x7     Operand descriptor ID (DESC)
   7   7-11     5     ?
  0xC  12-18  0x7     Source 1 register (SRC1)
  0x13 19-20  0x2     Address register index for SRC1 (IDX_1)
  0x15 21-25  0x5     Destination register (DST)
  0x1A 26-31  0x6     Opcode
 Format 1c: (used for comparison operations)
  0x0  0-6    0x7     Operand descriptor ID (DESC)
  0x7  7-11   0x5     Source 2 register (SRC2)
  0xC  12-18  0x7     Source 1 register (SRC1)
  0x13 19-20  0x2     Address register index for SRC1 (IDX_1)
  0x15 21-23  0x3     Comparison operator for Y (CMPY)
  0x18 24-26  0x3     Comparison operator for X (CMPX)
  0x1B 27-31  0x5     Opcode (5bit only)
 Format 2: (used for flow control instructions)
  0x0  0-7    0x8     Number of instructions (NUM)
    8  8-9    ?       ?
  0xA  10-21  0xC     Destination offset (in words) (DST)
  0x16 22-23  0x2     Condition boolean operator (CONDOP)
  0x18 24     0x1     Y reference bit (REFY)
  0x19 25     0x1     X reference bit (REFX)
  0x1A 26-31  0x6     Opcode
 Format 3: (used for uniform-based conditional flow control instructions)
  0x0  0-7    0x8     Number of instructions ? (NUM)
    8  8-9    ?       ?
  0xA  10-21  0xC     Destination offset (in words) (DST)
  0x16 22-25  0x4     Uniform ID (BOOL/INT)
  0x1A 26-31  0x6     Opcode
 Format 4: (used for SETEMIT)
    0  0-21   ?       ?
  0x16 22     0x1     Winding flag (FLAG_WINDING)
  0x17 23     0x1     Primitive emit flag (FLAG_PRIMEMIT)
  0x18 24-25  0x2     Vertex ID (VTXID)
  0x1A 26-31  0x6     Opcode
 Format 5: (used for MAD)
  0x0  0-4    0x5     Operand descriptor ID (DESC)
  0x5  5-9    0x5     Source 3 register (SRC3)
  0xA  10-16  0x7     Source 2 register (SRC2)
  0x11 17-21  0x5     Source 1 register (SRC1)
  0x16 22-23  0x2     Address register index for SRC2 (IDX_2)
  0x18 24-28  0x5     Destination register (DST)
  0x1D 29-31  0x3     Opcode (3bit only)
 Format 5i: (used for MADI)
  0x0  0-4    0x5     Operand descriptor ID (DESC)
  0x5  5-11   0x7     Source 3 register (SRC3)
  0xC  12-16  0x5     Source 2 register (SRC2)
  0x11 17-21  0x5     Source 1 register (SRC1)
  0x16 22-23  0x2     Address register index for SRC3 (IDX_3)
  0x18 24-28  0x5     Destination register (DST)
  0x1D 29-31  0x3     Opcode (3bit only)
```



## Instructions


Unless noted otherwise, SRC1 and SRC2 refer to their respectively indexed
float[4] registers (after swizzling). Similarly, DST refers to its indexed
register modulo destination component masking, i.e. an expression like DST=SRC1
might actually just set DST.y to SRC1.y.

```
  Opcode  Format Name    Description
  00h     1      ADD     Adds two vectors component by component
                               DST[i] = SRC1[i]+SRC2[i] for all i
  01h     1      DP3     Computes dot product on 3-component vectors
                               DST = SRC1.SRC2
  02h     1      DP4     Computes dot product on 4-component vectors
                               DST = SRC1.SRC2
  03h     1      DPH     Computes dot product on a 3-component vector
                         with 1.0 appended to it and a 4-component vector
                               DST = SRC1.SRC2 (with SRC1 homogenous)
  04h     1      DST     Equivalent to Microsoft's dst instruction
                               DST = {1, SRC1[1]*SRC2[1], SRC1[2], SRC2[3]}
  05h     1u     EX2     Computes SRC1's first component exponent with base 2
                               DST[i] = EXP2(SRC1[0]) for all i
  06h     1u     LG2     Computes SRC1's first component logarithm with base 2
                               DST[i] = LOG2(SRC1[0]) for all i
  07h     1u     LITP    Appears to be related to Microsoft's lit instruction
                               DST = clamp(SRC1, min={0, -127.9961, 0, 0},
                                     max={inf, 127.9961, 0, inf})
                               ;note: 127.9961 = 0x7FFF / 0x100
  08h     1      MUL     Multiplies two vectors component by component
                               DST[i] = SRC1[i].SRC2[i] for all i
  09h     1      SGE     Sets output if SRC1 is greater than or equal to SRC2
                               DST[i] = (SRC1[i] >= SRC2[i]) ? 1.0 : 0.0
                               "for all i"    ;uh, who/what is "all i"?
  0Ah     1      SLT     Sets output if SRC1 is strictly less than SRC2
                               DST[i] = (SRC1[i] < SRC2[i]) ? 1.0 : 0.0
                               "for all i"
  0Bh     1u     FLR     Computes SRC1's floor component by component
                               DST[i] = FLOOR(SRC1[i])
                               "for all i"
  0Ch     1      MAX     Takes the max of two vectors, component by component
                               DST[i] = MAX(SRC1[i], SRC2[i])
                               "for all i"
  0Dh     1      MIN     Takes the min of two vectors, component by component
                               DST[i] = MIN(SRC1[i], SRC2[i])
                               "for all i"
  0Eh     1u     RCP     Computes the reciprocal of the vector's 1st component
                               DST[i] = 1/SRC1[0]
                               "for all i"
  0Fh     1u     RSQ     Computes the reciprocal of the square root of the
                         vector's first component;
                               DST[i] = 1/sqrt(SRC1[0])
                               "for all i"
  10h-11h ?      ???     ?
  12h     1u     MOVA    Move to address register; Casts the float uniform
                         given by SRC1 to an integer (truncating the fractional
                         part) and assigns the result to (a0.x, a0.y, _, _),
                         respecting the destination component mask.
  13h     1u     MOV     Moves value from one register to another
                               DST = SRC1
  14h-17h ?      ???     ?
  18h     1i     DPHI    Computes dot product on a 3-component vector
                         with 1.0 appended to it and a 4-component vector;
                               DST = SRC1.SRC2 (with SRC1 homogenous)
  19h     1i     DSTI    DST with sources swapped
  1Ah     1i     SGEI    Sets output if SRC1 is greater than or equal to SRC2
                               DST[i] = (SRC1[i] >= SRC2[i]) ? 1.0 : 0.0
                               "for all i"
  1Bh     1i     SLTI    Sets output if SRC1 is strictly less than SRC2
                               DST[i] = (SRC1[i] < SRC2[i]) ? 1.0 : 0.0
                               "for all i"
  1Ch-1Fh ?      ???     ?
  20h     0      BREAK   Breaks out of LOOP block; do not use while in
                         nested IF/CALL block inside LOOP block.
  21h     0      NOP     Does literally nothing.
  22h     0      END     Signals the shader unit that processing for this
                         vertex/primitive is done.
  23h     2      BREAKC  If condition (see below for details) is true, then
                         breaks out of LOOP block.
  24h     2      CALL    Jumps to DST and executes instructions until it
                         reaches DST+NUM instructions
  25h     2      CALLC   If condition (see below for details) is true, then
                         jumps to DST and executes instructions until it
                         reaches DST+NUM instructions, else does nothing.
  26h     3      CALLU   Jumps to DST and executes instructions until it
                         reaches DST+NUM instructions if BOOL is true
  27h     3      IFU     If condition BOOL is true, then executes instructions
                         until DST, then jumps to DST+NUM; else, jumps to DST.
  28h     2      IFC     If condition (see below for details) is true, then
                         executes instructions until DST, then jumps
                         to DST+NUM; else, jumps to DST
  29h     3      LOOP    Loops over the code between itself and DST
                         (inclusive), performing INT.x+1 iterations in total.
                         First, aL is initialized to INT.y. After each
                         iteration, aL is incremented by INT.z.
  2Ah     0      EMIT    (geometry shader only) Emits a vertex (and primitive
                         if FLAG_PRIMEMIT was set in the corresponding
                         SETEMIT). SETEMIT must be called before this.
  2Bh     4      SETEMIT (geometry shader only) Sets VTXID, FLAG_WINDING and
                         FLAG_PRIMEMIT for the next EMIT instruction. VTXID
                         is the ID of the vertex about to be emitted within
                         the primitive, while FLAG_PRIMEMIT is zero if we are
                         just emitting a single vertex and non-zero if are
                         emitting a vertex and primitive simultaneously.
                         FLAG_WINDING controls the output primitive's winding.
                         Note that the output vertex buffer (which holds 4
                         vertices) is not cleared when the primitive is
                         emitted, meaning that vertices from the previous
                         primitive can be reused for the current one. (this
                         is still a working hypothesis and unconfirmed)
  2Ch     2      JMPC    If condition (see below for details) is true, then
                         jumps to DST, else does nothing.
  2Dh     3      JMPU    If condition BOOL is true, then jumps to DST, else
                         does nothing. Having bit 0 of NUM = 1 will invert the
                         test, jumping if BOOL is false instead.
  2Eh-2Fh 1c     CMP     Sets booleans cmp.x and cmp.y based on the operand's
                         x and y components and the CMPX and CMPY comparison
                         operators respectively. See below for details about
                         operators. It's unknown whether CMP respects the
                         destination component mask or not.
  30h-37h 5i     MADI    Multiplies two vectors and adds a third one
                         component by component;
                               DST[i] = SRC3[i] + SRC2[i].SRC1[i]
                               "for all i"
                               "this is not an FMA, the intermediate result is
                               rounded"
  38h-3Fh 5      MAD     Multiplies two vectors and adds a third one
                         component by component;
                               DST[i] = SRC3[i] + SRC2[i].SRC1[i]
                               "for all i"
                               "this is not an FMA, the intermediate result
                               is rounded"
```



## Shader Operand descriptors (OPDESC's)


Below 31bit (or 32bit?) are related to the 5bit/7bit "DESC" id's in opcode
LSBs.

```
  0      Destination component mask W (0=Don't change, 1=Write)
  1      Destination component mask Z (0=Don't change, 1=Write)
  2      Destination component mask Y (0=Don't change, 1=Write)
  3      Destination component mask X (0=Don't change, 1=Write)
  4      Source 1 Negation bit
  5-6    Source 1 Component 3 value   (0..3 = X,Y,Z,W) (usually 3)
  7-8    Source 1 Component 2 value   (0..3 = X,Y,Z,W) (usually 2)
  9-10   Source 1 Component 1 value   (0..3 = X,Y,Z,W) (usually 1)
  11-12  Source 1 Component 0 value   (0..3 = X,Y,Z,W) (usually 0)
  13     Source 2 Negation bit
  14-15  Source 2 Component 3 value   (0..3 = X,Y,Z,W)
  16-17  Source 2 Component 2 value   (0..3 = X,Y,Z,W)
  18-19  Source 2 Component 1 value   (0..3 = X,Y,Z,W)
  20-21  Source 2 Component 0 value   (0..3 = X,Y,Z,W)
  22     Source 3 Negation bit
  23-24  Source 3 Component 3 value   (0..3 = X,Y,Z,W)
  25-26  Source 3 Component 2 value   (0..3 = X,Y,Z,W)
  27-28  Source 3 Component 1 value   (0..3 = X,Y,Z,W)
  29-30  Source 3 Component 0 value   (0..3 = X,Y,Z,W)
  31     unnown/unspecified/unused (usually 0)
```

The component selector (the 8bit fragments with 4x2bits) enables swizzling. For
example, component selector 0x1B is equivalent to .xyzw, while 0x55 is
equivalent to .yyyy.


Depending on the current shader opcode, source components are disabled
implicitly by setting (\*to ZERO\*) the destination component mask. For example,
ADD o0.xy, r0.xyzw, r1.xyzw will not make use of r0's or r1's z/w components,
while DP4 o0.xy, r0.xyzw, r1.xyzw will use all input components regardless of
the used destination component mask.



## Relative addressing


```
  IDX  Address offset
  00h  +0       ;-no offset
  01h  +a0.x    ;\X or Y component of address register (see MOVA)
  02h  +a0.y    ;/
  03h  +lp      ;-loop counter (see LOOP)
```

There are 3 address registers: a0.x, a0.y and aL (loop counter). For format 1
instructions, when IDX != 0, the value of the corresponding address register is
added to SRC1's value. For example, if IDX = 2, a0.y = 3 and SRC1 = c8, then
instead SRC1+a0.y = c11 will be used for the instruction. It is only possible
to use address registers with vector uniform registers, attempting to use them
with input attribute or temporary registers results in the address register
being ignored (i.e. read as zero).


a0.x and a0.y are set manually through the MOVA instruction by rounding a float
value to integer precision. Hence, they may take negative values.


aL can only be set indirectly by the LOOP instruction. It is still accessible
and valid after exiting a LOOP block, though.



## Comparison operator


```
  CMPX/CMPY raw value   Operator name   Expression
  00h                   EQ              src1 == src2
  01h                   NE              src1 != src2
  02h                   LT              src1 < src2
  03h                   LE              src1 <= src2
  04h                   GT              src1 > src2
  05h                   GE              src1 >= src2
  06h                   ??              seems to always return true
  07h                   ??              seems to always return true
```



## Conditions


A number of format 2 instructions are executed conditionally. These conditions
are based on two boolean registers which can be set with CMP: cmp.x and cmp.y.


Conditional instructions include 3 parameters: CONDOP, REFX and REFY. REFX and
REFY are reference values which are tested for equality against cmp.x and
cmp.y, respectively. CONDOP describes how the final truth value is constructed
from the results of the two tests. There are four conditional expression
formats:

```
  CONDOP raw value    Expression                        Description
  00h                 cmp.x == REFX || cmp.y == REFY    OR
  01h                 cmp.x == REFX && cmp.y == REFY    AND
  02h                 cmp.x == REFX                     X
  03h                 cmp.y == REFY                     Y
```



## Registers


Input attribute registers (v0-v7?) store the per-vertex data given by the CPU
and hence are read-only.

Output attribute registers (o0-o6) hold the data to be passed to the later GPU
stages and are write-only. Each of the output attribute register components is
assigned a semantic by setting the corresponding GPU\_Internal\_Registers.

Uniform registers hold user-specified data which is constant throughout all
processed vertices. There are 96 float[4] uniform registers (c0-c95),
eight(???) boolean registers (b0-b7), and four int[4] registers (i0-i3).

Temporary registers (r0-r15) can be used for intermediate calculations and can
both be read and written.

Many shader instructions which take float arguments have only 5 bits available
for the second argument. They may hence only refer to input attributes or
temporary registers. In particular, it's not possible to pass two float[4]
uniforms to these instructions.

It appears that writing twice to the same output register can cause problems
(eg. GPU hangs).


DST mapping:

```
  DST raw value  Register name   Description
  00h-06h?       o0-o6?          Output registers (aka output FIFO) (W)
  10h-1Fh        r0-r15          Temporary registers (R/W)
```


SRC1/SRC2/SRC3 mapping:

```
  SRC raw value  Register name   Description
  00h-07h?       v0-v7?          Input vertex/attribute (aka input FIFO) (R)
  10h-1Fh        r0-r15          Temporary registers
  20h-7Fh        c0-c95          Vector uniform registers (only for 7bit SRC)
```



## Control Flow


Control flow is implemented using four independent stacks:

```
  4-deep CALL stack
  8-deep IF stack
  4-deep LOOP stack
```

All stacks are initially empty. After every instruction but before JMP takes
effect, the PC is incremented and a copy is sent to each stack. Each stack is
checked against its copy of the PC. If an entry is popped from the stack, the
copied PC is updated and used for the next check of this stack, although the
IF/LOOP stacks can each only pop one entry per instruction, whereas the CALL
stack is checked again until it doesn't match or the stack is empty. The
updated PC copy with the highest priority wins: LOOP (highest), IF, CALL, JMP,
original PC (lowest).




# <a name="3dsgpugeometrypipeline"></a>3DS GPU Geometry Pipeline




## Array Attributes (via ARRAY pointers)


The most common way seems to be drawing via GPUREG\_ATTR\_BUF\_xxx and
GPUREG\_ATTR\_BUF\_DRAWARRAYS, the GPU is then automatically reading vertex data
from the array pointers (instead of needing to send all vertices to the command
buffer).



## Fixed Vertex Attributes (fixed attr for ALL vertices)


To use a fixed attribute, set the bit corresponding to the attribute in
GPUREG\_ATTR\_BUF\_FORMAT\_HIGH and ensure that no vertex arrays are configured for
the attribute (any configured arrays will override the fixed value, regardless
of the bit setting). Even if a vertex array isn't being used for the attribute
it still needs to be counted in the number of active attributes specified in
the same register.



## Immediate-Mode Vertex Submission (via GPUREG\_FIXEDATTRIB\_DATA)


Instead of using vertex arrays to supply vertex data, drawing can be done by
directly writing vertex data to a register. This allows vertex data to be
inlined directly in the command buffer. Since this is restricted to 4-component
float data, it is more useful for small draws like UI elements or debug
displays, to avoid using an unreasonable amount of memory and processing time
appending the vertices to the command buffer.


To use this feature, configure the number of attributes per vertex in
GPUREG\_VSH\_NUM\_ATTR. (All settings in the registers related to the vertex
loader are ignored.) Then setup the GPU and shaders the same as if doing a
regular draw call with GPUREG\_ATTR\_BUF\_DRAWARRAYS or
GPUREG\_ATTR\_BUF\_DRAWELEMENTS, but instead of writing to either register, write
the value 0xF to GPUREG\_FIXEDATTRIB\_INDEX and then follow by repeatedly writing
vertex data to GPUREG\_FIXEDATTRIB\_DATA.


Each set of writes to the 3 data registers specifies one attribute and all
attributes (as configured in GPUREG\_VSH\_NUM\_ATTR) need to be written, in order,
to specify a vertex. Drawing happens automatically as vertices are specified.
After finishing specifying vertices, follow with the same writes used after a
draw arrays/elements.




# <a name="3dsgpufragmentlighting"></a>3DS GPU Fragment Lighting



Fragment lighting is a DMP extension to the standard OpenGL pipeline with which
applications can calculate object lighting for each rendered pixel instead of
just per vertex. The fragment lighting algorithm furthermore supports the
shading models Blinn-Phong, Cook-Terrance, Ward, and microfacet-based
BRDF-models. While the lighting calculations take place in a very localized
position of the pixel processing pipeline, the feature interacts with different
other pipeline stages.



## Overview


In general, lighting is calculated at a particular point in space X by
determining the angles (i.e. dot products) between different vectors:

```
  - The face normal vector N, which points from X to the direction
    perpendicular to the lighted object
  - The tangent vector T, which points from X to a direction which is
    tangential to the lighted object
  - The bitangent vector B, which points to a tangential direction such
    that it is orthogonal to both N and T
  - The view vector V, which points from X "into the camera"
  - The light vector L, which points from X to the light source (note that
    lighting is always evaluated separately for each light source; the
    results for multiple light sources can simply be added to each other)
```

For example, in the Blinn-Phong shading model the dot product of L and N
determined the intensity of a lighting type called diffuse lighting. More
generally, the dot products between these vectors (from now on simply referred
to as "dot products") are combined to a lighting equation, which is evaluated
once per light source at each considered point in space.


Before pixel shaders were common, the lighting equation was only considered at
each vertex, and the output color was then interpolated across the triangle. To
achieve higher visual quality, pixel shaders can be used nowadays to evaluate
the lighting equation at each pixel. The PICA200 does not have a programmable
pixel shader, but has a fixed-function pipeline stage to achieve the same
quality.


In any case, per-pixel lighting requires to somehow obtain a normal vector for
each pixel. Theoretically, the vertex shader could output one normal vector per
vertex, and per-pixel normals could then be obtained by interpolating these
vectors in a specific way. This, however, is very inefficient, which is why
vertex shaders on the PICA200 instead output mathematical objects called
quaternions: Quaternions can be computed from normal/tangent vectors, and vice
versa, so no information is lost by doing so. However, quaternion interpolation
is a lot faster (see the "Kuijk and Blake" source below), and so the GPU can
compute per-pixel normals simply using the interpolated quaternion. This is
just the general idea, and the dirty mathematical details are explained below.


In addition to allowing per-pixel calculations, the lighting equation used in
the PICA200 involves using the dot products as indices into configurable lookup
tables. A good example of why this is useful is cell-shading, which can be
achieved simply by setting adjacent lookup table values to the same color.



## Quaternions as Shader Outputs


The shaders are usually the point where normal and tangent vector information
flows in. Usually, the source vertex data will include normal vectors for each
vertex. This need not be the case though; one could also just input raw vertex
positions, and have a geometry shader automatically calculate normal vector
information.


In any case: There is no vertex output attribute semantic for normal or tangent
vectors. To use fragment lighting, the shader must actually output an attribute
with the quaternion semantic. So some sort of conversion needs to happen from
normal and tangent vectors to quaternions. This can be done using the
surface-local matrix.



## Quaternion Interpolation


Quaternion interpolation needs to happen to obtain a per-fragment quaternion,
from which in turn per-fragment normals and tangent vectors can be computed. It
is unknown how quaternions are interpolated on the PICA200. The architecture
suggests that plain linear interpolation is used, but there are also more
sophisticated algorithms like Slerp and Nlerp.



## Quaternions and Normal/Tangent Vectors


Quaternions describe a transformation from surface-local space to eye space. In
surface-local space, by definition (and up to permutation) the normal vector is
(0,0,1), the tangent vector is (1,0,0), and the bitangent vector is (0,1,0).


Alternatively, one may consider quaternions a transformation from eye space to
surface-local space.



## Fragment Lighting Equation


There are two lighting equations: One for the primary color and one for the
secondary color. Both of them are given in section 3.2.2 of the "Kazakov and
Ohbuchi" source below. In addition, the fragment lighting can be set up to
write to the alpha channel of the primary or secondary color depending on a
selectable angle and a LUT. The equations used can be found here: 
- [http://mathb.in/26766](http://mathb.in/26766)

Some common setups include:

```
  ------------------------------------------------
  Model:            Blinn-Phong
  LutD0:            Input: N dot H, Contents: x^s
  LutD1:            --
  ReflectionLuts:   --
  Geometry factors: Disabled
  SpotlightLut      Spotlight setup or no-op
  ------------------------------------------------
  Model:            Cook-Torrance
  LutD0:            --
  LutD1:            Input: N dot H, D(x)
  ReflectionLuts:   Input: V dot H, Contents: F(x)
  Geometry factors: Enabled
  SpotlightLut      Spotlight setup or no-op
  ------------------------------------------------
  Model:            Schlick-like
  LutD0:            --
  LutD1:            Input: N dot H, Contents: Schlick Z(x)
  ReflectionLuts:   Input: V dot H, Contents: F(x)
  Geometry factors: Enabled
  SpotlightLut      Input: cos phi_i, Contents: Schlick A(x)
  ------------------------------------------------
  Model:            Subsurface scattering (?)
  LutD0:            --
  LutD1:            Input: N dot V, Contents: Transmittance by angle
  ReflectionLuts:   Input: L dot N, Contents: Reflectance by angle
  Geometry factors: Disabled
  SpotlightLut      Spotlight setup or no-op
  ------------------------------------------------
```

s is the specularity factor for Blinn-Phong.


Spotlight setup means input -L dot P and contents spotlight falloff.


F and D can be found in 
- [http://inst.cs.berkeley.edu/~cs294-13/fa09/lectures/cookpaper.pdf](http://inst.cs.berkeley.edu/~cs294-13/fa09/lectures/cookpaper.pdf)

Schlick Z and Schlick A are defined in 
- [http://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf](http://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf)

The Fresnel LUT can be used to, for example, blend two colours according to how
oblique the view angle is, or to simply additively blend white onto fragments
with an exponential falloff, resulting in rim lighting.



## Fragment Lighting Output


The fragment lighting results are accessible as two inputs to the texture
combiners (one for the primary color, one for the secondary color).



## Resources


There is public literature available which describes the fragment lighting
feature in more detail:

```
  - Everitt - "Per-Pixel Lighting": A presentation given at the Game
    Developers Conference 2001 about per-pixel lighting. It doesn't have
    anything to do with the PICA200 algorithm, but explains the core ideas
    very well (especially the concepts of surface-local space and how it
    relates to other coordinate systems).
  - Kazakov and Ohbuchi - "Primitive Processing and Advanced Shading
    Architecture for Embedded Space": Provides a general overview over the
    fragment lighting algorithm used by the PICA200 and provides explicit
    formulas for the primary and secondary lighting output. NOTE: There exist
    both a scientific publication and a short presentation with this title.
    Both are useful, but the former goes into much greater detail.
  - Ohbuchi and Unno - "A Real-Time Configurable Shader Based on Lookup
    Tables": Provides a very detailed explanantion of the fragment lighting
    implementation
  - Kuijk and Blake - "Faster Phong Shading via Angular Interpolation":
    Explains in greater detail how quaternions can be used to encode
    information about normals and tangents (and how quaternions are easier to
    interpolate than vectors).
```




# <a name="3dsgpupitfalls"></a>3DS GPU Pitfalls




## Vertex attribute alignment


Vertex components which are defined through GPUREG\_ATTR\_BUFi\_CONFIG\_LOW will be
accessed aligned by the GPU.

Vertex attributes will be aligned to their component element size.

Padding attributes (Component type > 11) will always aligned to 4 byte
offets into the buffer.

The stride which is passed to the GPU should be passed unaligned.



## Vertex stride in GPUREG\_ATTR\_BUFi\_CONFIG\_HIGH


The vertex stride set in GPUREG\_ATTR\_BUFi\_CONFIG\_HIGH must match the actual
size of the vertex contained in the buffer or the PICA will freeze or it won't
draw anything.

If you want to use a different stride you have to pad the data accordingly with
padding attributes.



## Output mapping in GPUREG\_SH\_OUTMAP\_MASK


The output masking in GPUREG\_SH\_OUTMAP\_MASK influences how the registers
starting at GPUREG\_SH\_OUTMAP\_Oi map to outputs in the shader.


If an output is disabled in GPUREG\_SH\_OUTMAP\_MASK it means that no slot in the
GPUREG\_SH\_OUTMAP\_Oi registers is consumed. GPUREG\_SH\_OUTMAP\_TOTAL configures
the number of used consecutive slots in the outmap. Example:

```
  GPUREG_SH_OUTMAP_TOTAL = 0x00000002      ;2 outputs enabled
  GPUREG_SH_OUTMAP_MASK  = 0x00000011      ;o0 enabled, o4 enabled
  GPUREG_SH_OUTMAP_O0    = 0x03020100      ;o0 = pos.xyzw
  GPUREG_SH_OUTMAP_O1    = 0x0B0A0908      ;o4 = color.rgba    ;<-- o4 in "O1"!
  GPUREG_SH_OUTMAP_O2    = ...             ;(unused)
```



## Shaders - Configued Output components must be written exactly once


Each configured output component has to be written exactly once or the PICA
freezes.



## Shaders - MOVA instructions can't be adjacent


Having 2 consecutive MOVA instructions will freeze the PICA. This can be
relaxed by placing a NOP between 2 MOVAs or by rearranging the code.



## Shader - Special cases


JMP overwrites the PC \*after\* the stacks checks (and only if no stack was
popped).

Executing a BREAK on an empty LOOP stack hangs the GPU.

A stack overflow discards the oldest element, so you could think of it as a
queue or a ring buffer.

If the CALL stack is popped four times in a row, the fourth update to its copy
of the PC is missed (the third PC update will be propagated). Probably a
hardware bug.



## Shader - Floating-Point Behavior


The PICA200 is not IEEE-compliant. It has positive and negative infinities and
NaN, but does not seem to have negative 0. Input and output subnormals are
flushed to +0. The internal floating point format seems to be the same as used
in shader binaries: 1 sign bit, 7 exponent bits, 16 (explicit) mantissa bits.
Several instructions also have behavior that differs from the IEEE functions.
Here are the results from some tests done on hardware (s = largest subnormal, n
= smallest positive normal):

```
  Computation     Result  Notes
  inf * 0         0       Including inside MUL, MAD, DP4, etc.
  NaN * 0         NaN
  +inf - +inf     NaN     Indicates +inf is real inf, not FLT_MAX
  rsq(rcp(-inf))  +inf    Indicates that there isn't -0.0.
  rcp(-0)         +inf    no -0 so differs from IEEE where rcp(-0) = -inf
  rcp(0)          +inf
  rcp(+inf)       0
  rcp(NaN)        NaN
  rsq(-0)         +inf    no -0 so differs from IEEE where rsq(-0) = -inf
  rsq(-2)         NaN
  rsq(+inf)       0
  rsq(-inf)       NaN
  rsq(NaN)        NaN
  max(0, +inf)    +inf
  max(0, -inf)    -inf
  max(0, NaN)     NaN     max violates IEEE but match GLSL spec
  max(NaN, 0)     0
  max(-inf, +inf) +inf
  min(0, +inf)    0
  min(0, -inf)    -inf
  min(0, NaN)     NaN     min violates IEEE but match GLSL spec
  min(NaN, 0)     0
  min(-inf, +inf) -inf
  cmp(s, 0)       false   cmp does not flush input subnormals
  max(s, 0)       s       max does not flush input or output subnormals
  mul(s, 2)       0       input subnormals are flushed in arithmetic
                            instructions
  mul(n, 0.5)     0       output subnormals are flushed in arithmetic
                            instructions
```

1.0 can be multiplied 63 times by 0.5 until the result compares equal zero.
This is consistent with a 7-bit exponent and output subnormal flushing.



## Command list related


Invalid GPU command parameters including NaN floats can cause the GPU to hang,
which then causes the "GSP module" to hang as well.




# <a name="3dsgpuprimitiveengineandshaders"></a>3DS GPU Primitive Engine and Shaders



The 3DS seems to have four "shaders", each with there own I/O ports. However,
the vertex shaders seem to be used in parallel (to process 3 or 4 vertices at
once... so it's unknown if one needs to initialize all sets of I/O ports
separately; 3dbrew seems to have only two shaders documented (GSH and VSH),
without even being aware of the VSH2 and VSH3 registers.



## Vertex Shader (VSH)


The Vertex Shader is used to forward incoming vertex data (coordinates, colors,
texcoords) to the drawing engine. Most commonly, the shader would be used to
multiply the incoming coordinates with a Position Matrix and/or Projection
Matrix.



## Geometry Shader (GSH)


The Geometry Shader can be used to do something... but it appears to be unknown
what, and how.

It can probably somehow receive incoming values from somewhere. And probably
output values to somewhere (maybe somehow forwarding them to other GPU
registers, and maybe somehow sending them as response to the CPU).

The "EMIT" opcode might output data from Geometry Shader to Vertex shader?

The "Primitive Engine" section below might refer to the geometry shader?



## Primitive Engine


Primitive Engine (PE) is one of the PICA200's four vertex processor units and
provides some unique features which are used to implement a geometry shader
stage and variable-size primitive rendering.

The full functionality of PE is not yet understood and remains to be
reverse-engineered.

Variable-size primitives are implemented by prefixing each per-primitive
sequence of indices in an index array with a primitive size. This is used for
various effects, for example Catmull-Clark subdivision and Loop subdivision. It
is unknown how this feature is enabled specifically.




# <a name="3dsgputriangledrawingsamplecode"></a>3DS GPU Triangle Drawing Sample Code



```
 _________________________ Triangle Drawing Examples __________________________
```



## gpu\_draw\_triangle\_direct: ;simple, but requires a messy 4x24bit data format


```
  gpu_clear_colorbuf, gpu_init_framebuf, gpu_init_vertex_shader
 ;[GPUREG_GEOSTAGE_CONFIG]=((1 shl 8)+00h) ;not needed
  [GPUREG_GEOSTAGE_CONFIG2]=(0 shl 8)+01h  ;needed
 ;[GPUREG_START_DRAW_FUNC0]=00h  ;not needed, 0=draw, 1=config?
  [GPUREG_FIXEDATTRIB_INDEX]=0Fh  ;mode for directly writing vertex data...
  for i=0 to (4*2)-1
    [GPUREG_FIXEDATTRIB_DATA+0]=[@@array+i*0Ch+8] ;\write 4x24bit as 3x32bit
    [GPUREG_FIXEDATTRIB_DATA+0]=[@@array+i*0Ch+4] ; upper 32bit written first
    [GPUREG_FIXEDATTRIB_DATA+0]=[@@array+i*0Ch+0] ;/
  next i
  gpu_copy_colorbuf_to_lcd_framebuf
  ret
 @@array: ;x______y______z______w______r______g______b______a_____
  .float24 -1.0  ,-1.0  ,0.0   ,1.0   ,1.0   ,0.5   ,0.5   ,1.0 ;\1st triangle
  .float24 1.0   ,0.4   ,0.0   ,1.0   ,0.5   ,1.0   ,0.5   ,0.5 ;  ;\2nd
  .float24 0.2   ,1.0   ,0.0   ,1.0   ,0.5   ,0.5   ,1.0   ,0.5 ;/ ; triangle
  .float24 1.0   ,-0.8  ,-1.0  ,1.0   ,0.5   ,0.5   ,1.0   ,0.5    ;/(of strip)
  ;note: coord.W must be 1.0 (to avoid perspective division)
```



## gpu\_draw\_triangle\_via\_buffer:  ;example with 1-2 arrays, optional index\_list


- @@numattr equ 2 ;configure for two attributes (coordinate and color)
  - gpu\_clear\_colorbuf, gpu\_init\_framebuf, gpu\_init\_vertex\_shader
  - [GPUREG\_ATTR\_BUF\_BASE]=(((@@base)/10h)\*2)
  - [GPUREG\_ATTR\_BUF\_FORMAT\_LOW]=9Ch  ;Signed8bit(x,y,z,w)+Unsigned8bit(r,g,b)
  - [GPUREG\_ATTR\_BUF\_FORMAT\_HIGH]=((@@numattr-1) shl 28)+(000h shl 16)
  - if @@num\_arrays=1      ;both coordinate and color in one array...
    - [GPUREG\_ATTR\_BUFi\_OFFSET+0\*0Ch]=(@@array-@@base)/1
    - [GPUREG\_ATTR\_BUFi\_CONFIG\_LOW+0\*0Ch]=76543210h
    - [GPUREG\_ATTR\_BUFi\_CONFIG\_HIGH+0\*0Ch]=(@@numattr shl 28)+((4+3) shl 16)+BA98h
  - elseif @@num\_arrays=2  ;coordinate and color in separate arrays...
    - [GPUREG\_ATTR\_BUFi\_OFFSET+0\*0Ch]=(@@array0-@@base)/1
    - [GPUREG\_ATTR\_BUFi\_OFFSET+1\*0Ch]=(@@array1-@@base)/1
    - [GPUREG\_ATTR\_BUFi\_CONFIG\_LOW+0\*0Ch]=00000000h
    - [GPUREG\_ATTR\_BUFi\_CONFIG\_LOW+1\*0Ch]=00000001h
    - [GPUREG\_ATTR\_BUFi\_CONFIG\_HIGH+0\*0Ch]=(01h shl 28)+(04h shl 16)+0000h
    - [GPUREG\_ATTR\_BUFi\_CONFIG\_HIGH+1\*0Ch]=(01h shl 28)+(03h shl 16)+0000h
  - endif
- ;[GPUREG\_GEOSTAGE\_CONFIG] =((1 shl 8)+00h)  ;not needed
  - [GPUREG\_GEOSTAGE\_CONFIG2]=(1 shl 8)+01h    ;needed
- ;[GPUREG\_START\_DRAW\_FUNC0]=00h              ;not needed, 0=draw, 1=config?
  - [GPUREG\_ATTR\_BUF\_NUMVERTICES]=4\*(1+@@use\_index\_list)  ;needed, array size
  - if @@use\_index\_list    ;with index list...
      - [GPUREG\_ATTR\_BUF\_INDEX\_LIST]=(0 shl 31)+(@@index\_list-@@base)/1
      - [GPUREG\_ATTR\_BUF\_DRAWELEMENTS]=0   ;start drawing via above index list
  - else                   ;without index\_list...
      - [GPUREG\_ATTR\_BUF\_FIRST\_INDEX]=0    ;first index
      - [GPUREG\_ATTR\_BUF\_DRAWARRAYS]=0     ;start drawing at above index number
  - endif
  - gpu\_copy\_colorbuf\_to\_lcd\_framebuf
  - ret
- align 10h
- @@base:
- if @@use\_index\_list
    - @@index\_list: db 0,1,2,3   ;index to 1st,2nd,3rd,4th entries in arrays
- endif
- if @@num\_arrays=1
  - @@array: ;x\_\_\_\_\_\_y\_\_\_\_\_\_z\_\_\_\_\_\_w\_\_\_\_\_\_r\_\_\_\_\_\_g\_\_\_\_\_\_b\_\_\_\_\_\_a\_\_\_\_\_
    - db       -7fh  ,-7fh  ,0     ,+7fh  ,0ffh  ,0     ,0          ;\1st triangle
    - db       +7fh  ,+40h  ,0     ,+7fh  ,0     ,0ffh  ,0          ;  ;\2nd
    - db       +20h  ,+7fh  ,0     ,+7fh  ,0     ,0     ,0ffh       ;/ ; triangle
    - db       +7fh  ,-60h  ,0     ,+7fh  ,0     ,0ffh  ,0ffh          ;/of strip
- elseif @@num\_arrays=2
  - @@array0: ;x\_\_\_\_\_\_y\_\_\_\_\_\_z\_\_\_\_\_\_w\_\_\_\_
    - db        -7fh  ,-7fh  ,0 -9  ,+7fh  ;\1st triangle
    - db        +7fh  ,+40h  ,0 -9  ,+7fh  ;  ;\2nd
    - db        +20h  ,+7fh  ,0 -9  ,+7fh  ;/ ; triangle
    - db        +7fh  ,-60h  ,-7fh  ,+7fh     ;/of strip
  - @@array1: ;r\_\_\_\_\_\_g\_\_\_\_\_\_b\_\_\_\_\_\_a\_\_\_\_\_
    - db        0ffh  ,0     ,0             ;\1st triangle
    - db        0     ,0ffh  ,0             ;  ;\2nd
    - db        0     ,0     ,0ffh          ;/ ; triangle
    - db        0     ,0ffh  ,0ffh             ;/of strip
- endif


```
 _____________________ Init and Memory Transfer Functions _____________________
```



## gpu\_clear\_colorbuf:


```
  [GPUREG_RENDERBUFFER_INVALIDATE]=1   ;forget cache
  [GPU_MEMFILL_DST_ADDR0]=(MEMORG_COLORBUF+0)/10h*2
  [GPU_MEMFILL_DST_END0]=(MEMORG_COLORBUF+320*240*4)/10h*2
  [GPU_MEMFILL_DATA0]=11441100h
  [GPU_MEMFILL_CNT0]=00000201h
  wait until [GPU_MEMFILL_CNT0].bit0=0
  ret
```



## gpu\_copy\_colorbuf\_to\_lcd\_framebuf:


```
  DummyRead=[GPUREG_STAT_NUM_TRIANGLES_DISPLAYED]  ;waits until rendering done
  [GPUREG_RENDERBUFFER_FLUSH]=1   ;cache writeback
  [GPU_MEMCOPY_SRC_ADDR]=MEMORG_COLORBUF/10h*2
  [GPU_MEMCOPY_DST_ADDR]=MEMORG_SCREEN1/10h*2
  [GPU_MEMCOPY_DISPLAY_SIZE]=(240 shl 0)+(320 shl 16)
  [GPU_MEMCOPY_REMAIN_IRQ]=3FFFh  ;want IRQ flag when done
  [GPU_MEMCOPY_FLAGS]=0
  [GPU_MEMCOPY_CNT]=1
  ;caution: polling GPU_MEMCOPY_CNT can HANG the CPU at transfer end!
  ;instead: poll GPU_STAT_IRQ_FLAGS...
  wait until: [GPU_STAT_IRQ_FLAGS].bit30=1
  ret
```



## gpu\_init\_framebuf:


```
 ;[GPUREG_RENDERBUFFER_INVALIDATE]=1   ;forget cache
  [GPUREG_FACECULLING_CONFIG]=0 ;show front+back
  [GPUREG_RENDERBUFFER_DIM_0]=(1 shl 24)+(320-1)*1000h+240
 ;[GPUREG_RENDERBUFFER_DIM_1]=(1 shl 24)+(320-1)*1000h+240
  [GPUREG_DEPTHBUFFER_LOC]=MEMORG_DEPTHBUF/40h*8
  [GPUREG_COLORBUFFER_LOC]=MEMORG_COLORBUF/40h*8
  [GPUREG_VIEWPORT_V_SCALE]=0045E000h ;240/2 ;.float24 120.0 // db 00h
  [GPUREG_VIEWPORT_H_SCALE]=00464000h ;320/2 ;.float24 160.0 // db 00h
  [GPUREG_VIEWPORT_V_STEP]=38111100h  ;2/240 ;db 00h // .float24 0.008333333
  [GPUREG_VIEWPORT_H_STEP]=37999900h  ;2/320 ;db 00h // .float24 0.006250000
  [GPUREG_VIEWPORT_XY]=(0 shl 16)+0
  [GPUREG_SCISSORTEST_MODE]=0
 ;[GPUREG_SCISSORTEST_POS1]=((0+20) shl 16)+(0+20)
 ;[GPUREG_SCISSORTEST_POS2]=((320-1-20) shl 16)+(240-1-20)
  [GPUREG_COLOR_OPERATION]=00e40100h
  [GPUREG_BLEND_FUNC]=06020000h ;raw drawing
 ;[GPUREG_BLEND_FUNC]=76760000h ;alpha blending
 ;[GPUREG_LOGIC_OP]=00h
  [GPUREG_FRAGOP_ALPHA_TEST]=00h
  [GPUREG_STENCIL_TEST]=00h
  [GPUREG_DEPTH_COLOR_MASK]=1F00h
  [GPUREG_COLORBUFFER_READING]=0Fh
  [GPUREG_COLORBUFFER_WRITING]=0Fh
  [GPUREG_DEPTHBUFFER_READING]=03h
  [GPUREG_DEPTHBUFFER_WRITING]=03h
  [GPUREG_DEPTHBUFFER_FORMAT]=03h
  [GPUREG_COLORBUFFER_FORMAT]=02h
  [GPUREG_RENDERBUFFER_BLOCK32]=0
 ;[GPUREG_EARLYDEPTH_TEST1]=0
 ;[GPUREG_EARLYDEPTH_TEST2]=0
  [GPUREG_DEPTHMAP_ENABLE]=1
  [GPUREG_DEPTHMAP_SCALE]=00bf0000h  ;far z  (-1.0)
  [GPUREG_DEPTHMAP_OFFSET]=00000000h ;near z (0.0)
  ret
```



## gpu\_init\_vertex\_shader:


- @@numattr equ 2 ;configure for two attributes (coordinate and color)
  - [GPUREG\_SH\_OUTMAP\_TOTAL]=@@numattr      ;vertex+color
  - [GPUREG\_SH\_OUTMAP\_O+0\*4]=03020100h      ;vertex.xyzw
  - [GPUREG\_SH\_OUTMAP\_O+1\*4]=0b0a0908h      ;color.rgba
  - [GPUREG\_SH\_OUTATTR\_CLOCK]=3             ;bit0=blah?, bit1=needed for colors
  - [GPUREG\_VSH\_COM\_MODE]=00h               ;GSH/VSH?
  - [GPUREG\_VSH\_NUM\_ATTR]=@@numattr-1       ;needed
  - [GPUREG\_VSH\_OUTMAP\_TOTAL1]=@@numattr-1  ;needed
- ;[GPUREG\_VSH\_OUTMAP\_TOTAL2]=@@numattr-1  ;not needed
  - [GPUREG\_START\_DRAW\_FUNC0]=1             ;needed
  - [GPUREG\_VSH\_INPUTBUFFER\_CONFIG]=(0a0h shl 24)+@@numattr-1
  - [GPUREG\_PRIMITIVE\_CONFIG]=(1 shl 8)+@@numattr-1
  - [GPUREG\_RESTART\_PRIMITIVE]=0  ;required for strips (even BEFORE first strip)
  - [GPUREG\_VSH\_ATTR\_PERMUTATION\_LOW]=076543210h  ;\input
  - [GPUREG\_VSH\_ATTR\_PERMUTATION\_HIGH]=0fedcba98h ;/
  - [GPUREG\_VSH\_OUTMAP\_MASK]=(1 shl @@numattr)-1        ;-output enable's
  - [GPUREG\_VSH\_CODETRANSFER\_INDEX]=000h/4
  - [GPUREG\_VSH\_CODETRANSFER\_DATA+0]=4C000000h  ;MOV o0,v0  ;used for coord xyzw
  - [GPUREG\_VSH\_CODETRANSFER\_DATA+0]=4C201000h  ;MOV o1,v1  ;used for color rgba
  - [GPUREG\_VSH\_CODETRANSFER\_DATA+0]=88000000h  ;END
  - [GPUREG\_VSH\_CODETRANSFER\_END]=0
  - [GPUREG\_VSH\_OPDESCS\_INDEX]=000h
  - [GPUREG\_VSH\_OPDESCS\_DATA+0]=0000036Fh  ;dst=xyzw, src1=xyzw (or rgba)
  - [GPUREG\_VSH\_ENTRYPOINT]=7fff0000h+(000h/4)
  - ret




# <a name="3dsvideocamregisterscamerainput"></a>3DS Video CAM Registers (Camera Input)




## 10120000h - CAM0 (external Right-Eye & internal Self-Facing camera) (as DSi)



## 10121000h - CAM1 (external Left-Eye camera) (extra 3DS camera)


```
  1012x000h 4     R/W mask: 0000ef1ch  ;CAM_CNT alike DSi cameras
  1012x004h 2     R   mask: 8500h      ;CAM_STAT unlike DSi (lsbs=0..500h)
  1012x006h 2     R/W mask: 003fh      ;CAM_???
  1012x010h 4     R/W mask: 01ff03feh  ;CAM_SOFS alike DSi cameras
  1012x014h 4     R/W mask: 01ff03feh  ;CAM_EOFS alike DSi cameras
  1032x000h 80h   R                    ;CAM_DAT fifo (20h-word window)
```

The ARM registers are similar (but not identical) as for DSi cameras,

- [DSi Cameras](ds.html#dsicameras)
The I2C bus camera init does work same as on DSi (for Aptina cameras),

- [DSi I2C Bus](ds.html#dsii2cbus)
Cameras must be enabled in CFG11\_CAMERA\_CNT (Port 10141224h).



## 1012x000h - CAM\_CNT - mask: 0000ef1ch - Control (R/W)


```
  0     Unknown (status, toggles on/off during transfer?)                 (R)
  1     Unknown (status, gets set during transfer?)                       (R)
  2     Unknown (MUST be 0, else picture gets blank?)                     (R/W)
  3     Unknown (0=Normal/YUV422, 1=Some other data format?)              (R/W)
  4     Unknown (MUST be 1, else data transfer hangs, maybe reset?)       (R/W)
  5-7   Unused (0)                                                        (-)
  8     Unknown (no effect?)                                              (R/W)
  9     IRQ Enable      (0=Disable, 1=Enable) (at picture end?)           (R/W)
  10    Unknown (no effect?)                                              (R/W)
  11    Unknown (no effect?)                                              (R/W)
  12    Unused (0)                                                        (-)
  13    Unknown (MUST be 0, else data transfer hangs)                     (R/W)
  14    DMA Data Request enable (0=Disable, 1=Enable)                     (R/W)
  15    Transfer Enable (0=Disable/AllowConfig, 1=Enable/Transfer)        (R/W)
  16-31 Unused (0)                                                        (-)
```



## 1012x004h - CAM\_STAT - Status (R)


```
  0-10  Number of 8-byte units (?) in FIFO (0..500h)                      (R)
  11-14 Unused? (0)                                                       (?)
  15    Overrun error, deadlock   (0=Normal, 1=Overrun)                   (R)
```

Caution: There will be no further data received after overrun. To avoid
overrun, be sure to read data fast enough, and disable CAM\_CNT.bit15 after
reading the camera bitmap.



## 1012x006h - CAM\_??? - Unknown (R/W)


```
  0-5   Unknown (no effect?) (can be set to 0..3Fh)                       (R/W)
  6-14  Unused? (0)                                                       (?)
  15    Clear overrun  (0=No change, 1=Clear; when CAM_CNT.bit15=0)       (W)
```

Unknown, bit0-5 seems to have no direct effect on the camera picture. Maybe
selects timings or amount of words for DMA requests? Or maybe some bits
resemble DSi's CAM\_MCNT register?



## 1012x010h - CAM\_SOFS alike DSi cameras (0..01FF03FEh) (R/W)



## 1012x014h - CAM\_EOFS alike DSi cameras (0..01FF03FEh) (R/W)


```
  0      Unused (0)                                                         (0)
  1-9    X-Offset  (0..1FFh)   in words (ie. 2-pixel units)?         (R or R/W)
  10-15  Unused (0)                                                         (0)
  16-24  Y-Offset  (0..1FFh)   in scanlines?                         (R or R/W)
  25-31  Unused (0)                                                         (0)
```

Looks same as on DSi, but the settings seem to have no effect on 3DS, ie. there
appears to be no way to enable the trimming feature?



## 1032x000h..1032x07Fh - CAM\_DAT - Data FIFO (20h words window) (R)


The FIFO read window is 20h words in size (the actual FIFO is bigger; about
500h or A00h words?). The (default) data format is same as the YUV422 format
for DSi cameras:

```
  0-7   First Pixel Luminance (Y)   (unsigned, 00h..FFh, FFh=white)
  8-15  Both Pixels Blue (Cb aka U) (unsigned, 00h..FFh, 80h=gray)
  16-23 Second Pixel Luminance (Y)  (unsigned, 00h..FFh, FFh=white)
  24-31 Both Pixels Red (Cr aka V)  (unsigned, 00h..FFh, 80h=gray)
```

Caution: It is important to read words from INCREASING addresses at
1032x000h..1032x07Fh (or at least toggle address bit2 after each read) (trying
to read words from FIXED address 1032x000h will return the same word endless
repeated).



## Camera Notes


The "camera in-use" LED for external camera is controlled via MCU (but the LED
exists on DSi/3DS only, New3DS doesn't have that LED installed).

The three 3DS/New3DS cameras have the same Chip IDs (2280h) as found in the two
DSi's Aptina MT9V113 cameras.

However, New3DS is said to have improved picture quality. Unknown what that
means, maybe the I2C registers are simply initialized with better gain settings
at software side, or maybe the camera hardware is actually improved despite of
having the same chip id.

New3DS is also said to support eye-tracking, whatever that means, it is
probably done using the internal camera. And New3DS is said to have an IR-LED
next to the internal camera to assist eye-tracking (yet unknown if/how the
YUV/RGB camera could see IR-light at all).




# <a name="3dsvideoy2rregistersyuvtorgbaconverter"></a>3DS Video Y2R Registers (YUV-to-RGBA Converter)




## Y2R Registers (aka YUV-to-RGB aka YCbCr-to-RGB)


```
  10102000h ARM11/ARM9  Y2R_0 Registers              ;\original Y2R unit
  10302000h ARM11       Y2R_0 FIFOs                  ;/(intended for camera)
  10132000h ARM11/ARM9  Y2R_1 Registers   ;\New3DS   ;\extra New3DS Y2R unit
  10332000h ARM11       Y2R_1 FIFOs       ;/         ;/(intended for MVD)
```

The Y2R unit(s) are general purpose YUV-to-RGB converters for photo/video
decoding. The first Y2R unit was invented for the camera, the second Y2R unit
for MVD on New3DS. The two units appear to be identical.

```
  10102000h/10132000h 4   Y2R_CNT                    R/W: E8C31F07h ;\
  10102004h/10132004h 2   Y2R_WIDTH   ;width (pix)   R/W: 03F8h     ;
  10102006h/10132006h 2   Y2R_HEIGHT  ;height (pix)  R/W: 03FFh     ;
  10102008h/10132008h ??  Y2R_STROBE  ;ack fifo?     dummy r/w?     ;
  10102010h/10132010h 2   Y2R_MULTIPLIER_Y_TO_RGB    R/W: 03FFh     ; Control
  10102012h/10132012h 2   Y2R_MULTIPLIER_V_TO_R      R/W: 03FFh     ; Regs
  10102014h/10132014h 2   Y2R_MULTIPLIER_V_TO_G      R/W: 03FFh     ;
  10102016h/10132016h 2   Y2R_MULTIPLIER_U_TO_G      R/W: 03FFh     ;
  10102018h/10132018h 2   Y2R_MULTIPLIER_U_TO_B      R/W: 03FFh     ;
  1010201Ah/1013201Ah 2   Y2R_OFFSET_R  ;\           R/W: FFFFh     ;
  1010201Ch/1013201Ch 2   Y2R_OFFSET_G  ; signed     R/W: FFFFh     ;
  1010201Eh/1013201Eh 2   Y2R_OFFSET_B  ;/           R/W: FFFFh     ;
  10102020h/10132020h 2   Y2R_ALPHA  ;bit7 for 5551  R/W: 000000FFh ;
  10102100h/10132100h 4   Y2R_DITHER0                R/W: 0000CCCCh ;
  10102108h/10132108h 4   Y2R_DITHER1                R/W: 0000CCCCh ;
  10102110h/10132110h 4   Y2R_DITHER2                R/W: 0000CCCCh ;
  10102118h/10132118h 4   Y2R_DITHER3                R/W: 0000CCCCh ;/
  10302000h/10332000h 80h Y2R_INPUT_Y    ;aka Luma   W:             ;\
  10302080h/10332080h 80h Y2R_INPUT_U    ;aka Cb     W:             ; FIFO's
  10302100h/10332100h 80h Y2R_INPUT_V    ;aka Cr     W:             ; (ARM11)
  10302180h/10332180h 80h Y2R_INPUT_YUYV ;Y1,U,Y2,V  W: (camera)    ;
  10302200h/10332200h 80h Y2R_OUTPUT_RGBA            R: (RGBA)      ;/
```



## 10102000h/10132000h - Y2R\_CNT (R/W)


```
  0-2   Input Format YUV (0-4 = 422'8, 420'8, 422'16, 420'16, 422'BATCH)  (R/W)
  3-7   Unused (0)
  8-9   Output Format RGBA      (0=8888, 1=8880, 2=5551, 3=5650)          (R/W)
  10-11 Output Clockwise Rotate (0=None, 1=90', 2=180', 3=270')           (R/W)
  12    Output Swizzle          (0=LinearFramebuf, 1=MortonSwizzleTexture)(R/W)
  13-14 Unused (0)
  15    Unknown, reportedly used, but always 0 (maybe write-only?)          (?)
  16    Brightness Dither Enable   (0=No, 1=Use Y2R_DITHER0-3)            (R/W)
  17    Brightness Ugly Pulsation? (0=No, 1=Add 0,1,2,3 in frame 0,1,2,3) (R/W)
  18-20 Unused (0)
  21    Unknown, reportedly used, but always 0 (maybe write-only?)          (?)
  22    Input DMA Enable               (0=Disable, 1=Enable CDMA 09h/15h) (R/W)
  23    Output DMA Enable              (0=Disable, 1=Enable CDMA 0Ah/16h) (R/W)
  24    Input DRQ Y?                   (0=No, 1=DRQ) (write 1 to ack?) (R/ack?)
  25    Input DRQ U?                   (0=No, 1=DRQ) (write 1 to ack?) (R/ack?)
  26    Input DRQ V?                   (0=No, 1=DRQ) (write 1 to ack?) (R/ack?)
  27    Input DRQ YUYV (batch)         (0=No, 1=DRQ) (write 1 to ack?) (R/ack?)
  28    Output DRQ RGB, 9th input line (0=No, 1=DRQ) (write 1 to ack?) (R/ack?)
  29    Interrupt upon DRQ(s)?         (0=Disable, 1=Enable IRQ 4Bh/4Eh)  (R/W)
  30    Interrupt upon Transfer done   (0=Disable, 1=Enable IRQ 4Bh/4Eh)  (R/W)
  31    Start/Busy                     (0=Idle/Ready, 1=Start/Busy)       (R/W)
```

Input formats...

```
  INPUT_YUV422_INDIV_8   0     is that 8bit? or 8x8pix? or divide by 8?
  INPUT_YUV420_INDIV_8   1
  INPUT_YUV422_INDIV_16  2     is that 16bit? or 16x16pix? or divide by 16?
  INPUT_YUV420_INDIV_16  3
  INPUT_YUV422_BATCH     4     aka camera YUYV
```

Conversion is done in units of 8 lines. However, the first Input block must be
9 lines (unless the total height is smaller), and the final blocks can be
smaller (depending on amount of remaining lines). For example:

```
  Send 9,8,8,8,8,3 scanlines    ;\for 44 scanlines
  Recv 8,8,8,8,8,4 scanlines    ;/
```

The odd amount of sending 9 lines in 1st block might allow to keep converting
data while receiving responses.

```
  XXX does that 9-lines-input thing also apply to Input Format 0-3 ?
```



## 10102004h/10132004h - Y2R\_WIDTH


```
  0-2   Unused (0)
  3-9   Width, in 8-pixel units (01h..7Fh=8..1016 pix, or 00h=?)
  10-15 Unused (0)
```



## 10102006h/10132006h - Y2R\_HEIGHT


```
  3-9   Height in 1-pixel units (001h..3FFh=1..1023 pix, or 000h=?)
  10-15 Unused (0)
```



## 10102008h/10132008h - Y2R\_STROBE  ;ack fifo?     dummy r/w?


Unknown, there is no read/write-able data here, and the register is normally
left unused, however, reading or writing-any-value seems to
strobe/trigger/ack/reset some internal stuff?



## Standard YUV to RGB Formula (aka YCbCr to RGB)


The standard formula uses the constants shown below. However, one can also
different values in the Y2R\_MULTIPLIER\_xxx and Y2R\_OFFSET\_xxx registers (that
would allow to support other YUV variants, or to adjust more pale or more
colorful output, or even to change RGB to BGR order; if the input FIFOs are
also swapped accordingly).

```
  R = Y*1.00 + (Cr-80h)*1.402
  G = Y*1.00 - (Cr-80h)*0.714)-(Cb-80h)*0.344
  B = Y*1.00 + (Cb-80h)*1.772
  Clip results to MinMax(00h,FFh), and apply final divide by 8 for RGB555.
```

Note: In the standard YUV-to-RGB formula one would usually subtract 80h from
the U/V values before multiplication. However, the 3DS does instead add
variable offsets after multiplication (so those offsets need to be matched to
the multipliers).



## 10102010h/10132010h - Y2R\_MULTIPLIER\_Y\_TO\_RGB (R/W) ;usually (1.000)\*100h



## 10102012h/10132012h - Y2R\_MULTIPLIER\_V\_TO\_R (R/W) ;usually (1.402)\*100h



## 10102014h/10132014h - Y2R\_MULTIPLIER\_V\_TO\_G (R/W) ;usually (0.714)\*100h



## 10102016h/10132016h - Y2R\_MULTIPLIER\_U\_TO\_G (R/W) ;usually (0.344)\*100h



## 10102018h/10132018h - Y2R\_MULTIPLIER\_U\_TO\_B (R/W) ;usually (1.772)\*100h


```
  0-9   Multiplier for the YUV-to-RGB formula (unsigned, 0..3FFh)
  10-15 Unused (0)
```



## 1010201Ah/1013201Ah - Y2R\_OFFSET\_R (R/W) ;usually (-1.402)\*1000h



## 1010201Ch/1013201Ch - Y2R\_OFFSET\_G (R/W) ;usually (+0.714+0.344)\*1000h



## 1010201Eh/1013201Eh - Y2R\_OFFSET\_B (R/W) ;usually (-1.772)\*1000h


```
  0-15  Offset for the YUV-to-RGB formula (signed, -8000h..+7FFFh)
```



## 10102020h/10132020h - Y2R\_ALPHA (R/W)


```
  0-7   Alpha for RGBA output format 8888 and 5551 (the latter uses only bit7)
  8-31  Unused (0)
```



## 10102100h/10132100h - Y2R\_DITHER0 (R/W)



## 10102108h/10132108h - Y2R\_DITHER1 (R/W)



## 10102110h/10132110h - Y2R\_DITHER2 (R/W)



## 10102118h/10132118h - Y2R\_DITHER3 (R/W)


```
  0-31  Dither, R/W-mask 0000CCCCh
```



## 10302000h/10332000h - 80h byte window - Y2R\_INPUT\_Y (aka Luma) (W)



## 10302080h/10332080h - 80h byte window - Y2R\_INPUT\_U (aka Cb) (W)



## 10302100h/10332100h - 80h byte window - Y2R\_INPUT\_V (aka Cr) (W)



## 10302180h/10332180h - 80h byte window - Y2R\_INPUT\_YUYV (camera Y1,U,Y2,V) (W)



## 10302200h/10332200h - 80h byte window - Y2R\_OUTPUT\_RGBA (R)


```
  0-31  FIFO data
```

The FIFOs are mirrored to 80h-byte windows, however, the transfer blocks with 8
or 9 scanlines are much longer than that (so better it's better to use a fixed
FIFO address, instead of increasing addresses in the 80h-byte windows)


For the optional swizzling feature, see

- [3DS Video Texture Swizzling](#3dsvideotextureswizzling)



# <a name="3dsvideol2bregistersrgbtorgbaconverternew3ds"></a>3DS Video L2B Registers (RGB-to-RGBA Converter) (New3DS)




## 10130000h - New3DS - L2B\_0 - First RGB-to-RGBA converter (New3DS only)



## 10131000h - New3DS - L2B\_1 - Second RGB-to-RGBA converter (New3DS only)


```
  10130000h/10131000h 4     L2B_CNT     Control  R/W  e3c00303h
  10130004h/10131004h 2     L2B_WIDTH   Width    R/W  03f8h
  10130006h/10131006h 2     L2B_HEIGHT  Height   R/W  03f8h
  10130020h/10131020h 4     L2B_ALPHA   Alpha    R/W  000000ffh
  10330000h/10331000h 1000h L2B_FIFO (IN and OUT, empty=data_abort) (R+W)
```

These registers appear to be called L2B, which might be short for
Line-to-Block. They are similar to the YUV-to-RGBA converters, but merely
converting from RGB-to-RGBA (and also allowing to convert between 5bit and 8bit
color depths). And, they are always re-ordering the data from scanline format
to swizzled texture format:

- [3DS Video Texture Swizzling](#3dsvideotextureswizzling)


## 10130000h/10131000h - New3DS - L2B\_CNT (R/W)


```
  0-1   Input RGBx Format            (0=8888, 1=8880, 2=5551, 3=5650)     (R/W)
  2-7   Unused (0)
  8-9   Output RGBA Format           (0=8888, 1=8880, 2=5551, 3=5650)     (R/W)
  10-21 Unused (0)
  22    Input DMA Enable             (0=Disable, 1=Enable CDMA 17h/19h)   (R/W)
  23    Output DMA Enable            (0=Disable, 1=Enable CDMA 18h/1Ah)   (R/W)
  24    Input DRQ                    (0=No, 1=DRQ) (write 1 to ack?)   (R/ack?)
  25    Output DRQ, 8th input line   (0=No, 1=DRQ) (write 1 to ack?)   (R/ack?)
  26-28 Unused (0)
  29    Interrupt upon DRQ(s)?       (0=Disable, 1=Enable IRQ 45h/46h)    (R/W)
  30    Interrupt upon Transfer done (0=Disable, 1=Enable IRQ 45h/46h)    (R/W)
  31    Start/Busy                   (0=Idle/Ready, 1=Start/Busy)         (R/W)
```

Send/Recv is done in units of 8 lines (unlike Y2R, which requires sending 9
lines in first block).



## 10130004h/10131004h - New3DS - L2B\_WIDTH (R/W)



## 10130006h/10131006h - New3DS - L2B\_HEIGHT (R/W)


```
  0-2   Unused (0)
  3-9   Width/Height in 8 pixel units (01h..7Fh=8..1016? pixels, or 00h=?)
  10-15 Unused (0)
```



## 10130020h/10131020h - New3DS - L2B\_ALPHA (R/W)


```
  0-7   Alpha value for all pixels    (00h..FFh = Transparent..Solid)
  8-31  Unused (0)
```

Used as alpha for output format 8888 and 5551 (the latter uses only bit7 of the
8bit value).

Note: Any alpha values written to the input fifo are ignored, the alpha value
is always taken from the alpha register, not from the incoming pixels.



## 10330000h/10331000h - New3DS - L2B\_FIFO (R and W) (empty=data\_abort)


```
  0-31  Pixel data
```

The FIFO is mirrored across a 1000h-byte window (but eight large scanlines may
be larger than that, so it's better to used a fixed FIFO address instead of
increasing addresses in that window).




# <a name="3dsvideomvdregistersmoviedecoderorsonew3ds"></a>3DS Video MVD Registers (Movie Decoder or so?) (New3DS)



Unknown. New3DS only. MVD might be short for Movie Decoder or so?

Unknown if there are any FIFOs and CDMA peripheral IDs... there are none known
yet... maybe the thing does have it's own "DMA" hardware for direct memory
access without needing CDMA?



## 10207000h - New3DS: Movie Decoder or so? Rockchip...? (ARM11 only)


```
  10207000h 4    R    67312398h  MVD Registers Chip ID?
  10207004h C4h  R/W  ffffffffh  MVD Registers
  102070C8h 4    R    07b4af80h  MVD Registers
  102070CCh 4    R/W  ffffffffh  MVD Registers
  102070D0h 4    -    00000000h  MVD Registers
  102070D4h 4    -    00000000h  MVD Registers
  102070D8h 4    R    c09a0000h  MVD Registers
  102070DCh 4    R/W  ffffffffh  MVD Registers
  102070E0h 4    -    00000000h  MVD Registers
  102070E4h 4    R    8516ffffh  MVD Registers
  102070E8h 4    -    00000000h  MVD Registers
  102070ECh 40h  R/W  ffffffffh  MVD Registers
  1020712Ch 4    -    00000000h  MVD Registers
  10207130h 4    -    00000000h  MVD Registers
  10207134h 4    -    00000000h  MVD Registers
  10207138h 4    -    00000000h  MVD Registers
  1020713Ch 44h  R/W  ffffffffh  MVD Registers
  10207180h 4    -    00000000h  MVD Registers
  10207184h 4    -    00000000h  MVD Registers
  10207188h 4    -    00000000h  MVD Registers
  1020718Ch 4    R    ffffffffh  MVD Registers
  10207190h 4    R    ff874780h  MVD Registers
  10207194h 6Ch  -    00000000h  Zerofilled
  10207200h E00h Mirrors of above 200h byte area
```

The ID value 67312398h appears to be known as "HW\_ID" for linux/android "VPU
SERVICES". Searching for that two strings gives this source code,

```
  <a href="http://git.jp.linux-rockchip.org/cgit/rk3288_r-box_android4.4.2_sdk/tree"><font color="#808080">http://git.jp.linux-rockchip.org/cgit/rk3288_r-box_android4.4.2_sdk/tree</font></a>

  /kernel/arch/arm/mach-rockchip/vcodec_service.c
```

which defines VPU\_DEC\_ID\_9190=6731h (the upper 16bit of the 67312398h value),
so the "MVD" might be identical to that Rockchip hardware (whatever that is).




# <a name="3dsvideolgyregisterslegacygbandsvideotoframebuffer"></a>3DS Video LGY Registers (Legacy GBA/NDS Video to Framebuffer)



The LGYFB units are for forwarding GBA/NDS/DSi video to 3DS screens with
optional scaling. The input comes directly from the GBA/NDS video controller,
the output must be DMAed to memory.

That is, ARM11 must handle that memory transfers in background while running
GBA/NDS/DSi software on ARM7/ARM9 side.



## 10110000h - LGYFB\_0 (Legacy Framebuffer 0) (NDS bottom screen) (and GBA)



## 10111000h - LGYFB\_1 (Legacy Framebuffer 1) (NDS top screen) (and GBA)


```
  10110000h/10111000h 4     LGYFB_CNT        R/W   mask:00019f37h  ;\
  10110004h/10111004h 4     LGYFB_SIZE       R/W   mask:01ff01ffh  ; Control
  10110008h/10111008h 4     LGYFB_IRQ_STAT   R/ack mask:01f80007h  ; Status
  1011000Ch/1011100Ch 4     LGYFB_IRQ_ENABLE R/W   mask:0007h      ;/
  10110020h/10111020h 4     LGYFB_ALPHA      R/W   mask:000000ffh  ;-Alpha
  101100F0h/101110F0h 4     LGYFB_UNKNOWN    R/W   mask:0000000fh  ;-Unknown?
  10110100h/10111100h 4     LGYFB_DITHER0    R/W   mask:0000cccch  ;\
  10110108h/10111108h 4     LGYFB_DITHER1    R/W   mask:0000cccch  ; Dither
  10110110h/10111110h 4     LGYFB_DITHER2    R/W   mask:0000cccch  ;
  10110118h/10111118h 4     LGYFB_DITHER3    R/W   mask:0000cccch  ;/
  10110200h/10111200h 4     LGYFB_V_LEN      R/W   mask:00000007h  ;\Vertical
  10110204h/10111204h 4     LGYFB_V_PATTERN  R/W   mask:000000ffh  ; Scaling
  10110240h/10111240h 4x30h LGYFB_V_ARRAY    R/W   mask:0000fff0h  ;/
  10110300h/10111300h 4     LGYFB_H_LEN      R/W   mask:00000007h  ;\Horizontal
  10110304h/10111304h 4     LGYFB_H_PATTERN  R/W   mask:000000ffh  ; Scaling
  10110340h/10111340h 4x30h LGYFB_H_ARRAY    R/W   mask:0000fff0h  ;/
  10310000h/10311000h 1000h LGYFB_FIFO       R     CDMA only       ;-Output
```



## 10110000h/10111000h - LGYFB\_CNT (R/W)


```
  0     Start/Enable               (0=Stop, 1=Start)                      (R/W)
  1     Enable Vertical Scaling    (0=Disable, 1=Enable; via LGYFB_V_xxx) (R/W)
  2     Enable Horizontal Scaling  (0=Disable, 1=Enable; via LGYFB_H_xxx) (R/W)
  3     Unused (0)
  4     Brightness Dither Enable   (0=No, 1=Use LGYFB_DITHER0-3)          (R/W)
  5     Brightness Dither, too?    (as above, no Y2R-style Pulsation)     (R/W)
  6-7   Unused (0)
  8-9   Output Format RGBA      (0=8888, 1=8880, 2=5551, 3=5650)          (R/W)
  10-11 Output Clockwise Rotate (0=None, 1=90', 2=180', 3=270')           (R/W)
  12    Output Swizzle          (0=LinearFramebuf, 1=MortonSwizzleTexture)(R/W)
  13-14 Unused (0)
  15    Enable DMA              (0=Off, 1=Enable CDMA 0Dh/0Eh)            (R/W)
  16    Unknown... seems to have no visible effect for GBA/NDS (0=?, 1=?) (R/W)
  17-31 Unused (0)
```

Once when started, the transfer does auto-repeat each frame (although, that may
hang with some/wrong settings; in that case it can help to toggle CNT.bit0
after DMAing the last block of each frame).



## 10110004h/10111004h - LGYFB\_SIZE (R/W)


```
  0-8   Output Width (after scaling), minus 1  (0..1FFh = 1..512 pixels)  (R/W)
  9-15  Unused (0)
  16-24 Output Height (after scaling), minus 1 (0..1FFh = 1..512 pixels)  (R/W)
  25-31 Unused (0)
```

Caution: Must be written via 32bit STR (trying to use 16bit STRH will set BOTH
halfwords to the same value).



## 10110008h/10111008h - LGYFB\_IRQ\_STAT (R/ack)


```
  0     First 8-Line Output Block (0=No, 1=Yes/IRQ) (write 1 to clear)  (R/ack)
  1     Next 8-Line Output Block  (0=No, 1=Yes/IRQ) (write 1 to clear)  (R/ack)
  2     Last Input? Line          (0=No, 1=Yes/IRQ) (write 1 to clear)  (R/ack)
  3-15  Unused (0)
  16-24 Output Block Line Number for IRQ bit0/1 (step 8)                    (R)
  25-31 Unused (0)
```

The Output Block Line Number can be used to compute the destination address for
IRQ bit0/1. The initial line number upon reset is random/garbage (but gets
valid after setting LGYFB\_CNT.bit0).

Overrun can occur when not reading the output FIFO fast enough. After overrun,
bit1 triggers only on each 2nd block, and bit2 won't trigger at all.



## 1011000Ch/1011100Ch - LGYFB\_IRQ\_ENABLE - ? (R/W)


```
  0     First 8-Line Output Block (0=Off, 1=Enable IRQ 4Ch/4Dh)           (R/W)
  1     8-Line Output Blocks      (0=Off, 1=Enable IRQ 4Ch/4Dh)           (R/W)
  2     Last Input? Line          (0=Off, 1=Enable IRQ 4Ch/4Dh?)          (R/W)
  3-31  Unused (0)
```

IRQ enable does also require LGYFB\_CNT.bit0=1 and CFG11\_TWLMODE\_BOOT.bit15=1.

The end of frame irq occurs only if the blocks were actually transferred (via
CDMA).



## 10110020h/10111020h - LGYFB\_ALPHA - (R/W)


```
  0-7   Alpha value for all pixels    (00h..FFh = Transparent..Solid)
  8-31  Unused (0)
```

Used as alpha for output format 8888 and 5551 (the latter uses only bit7 of the
8bit value).



## 101100F0h/101110F0h - LGYFB\_UNKNOWN (R/W)


```
  0-3   Unknown (initially 0Fh on reset)
  4-31  Unused (0)
```

Unknown. IRQ and DMA requests won't occur when using too small values. Without
scaling values 01h..0Fh are working, with 2x vertical scaling only values
06h..0Fh are working.



## 10110100h/10111100h - LGYFB\_DITHER0 (R/W)



## 10110108h/10111108h - LGYFB\_DITHER1 (R/W)



## 10110110h/10111110h - LGYFB\_DITHER2 (R/W)



## 10110118h/10111118h - LGYFB\_DITHER3 (R/W)


```
  0-31  Dither alike Y2R, R/W-mask 0000CCCCh
```



## 10310000h/10311000h - LGYFB\_FIFO (R)


Caution: This FIFO works via CDMA only (unlike most or all other FIFOs, it does
trigger data abort when trying to read via CPU LDR opcodes; even if there is
data in the FIFO).

```
  0-31  Output FIFO (contains 8 output lines per DMA request)
```

Use DMAWFP opcode (Wait for Peripheral) before reading an 8-line block. Or,
wait for LGYFB\_IRQ\_STAT bit0/1, and then manually start the DMA for one 8-line
block (the latter can be useful for transfers with clockwise rotate; where one
may need to patch the destination address for each block).


For the optional swizzling feature, see

- [3DS Video Texture Swizzling](#3dsvideotextureswizzling)

```
 ________________________________ Scaling Unit ________________________________
```



## 10110200h/10111200h - LGYFB\_V\_LEN - Vertical scaling (R/W)



## 10110300h/10111300h - LGYFB\_H\_LEN - Horizontal scaling (R/W)


```
  0-2   Batch size-1  (0..7 = 1..8 dst pixels) (using (1..8)*6 array entries)
  3-31  Unused (0)
```

Selects the number of pattern bits and array entries to be used (before
repeating the scaling pattern).



## 10110204h/10111204h - LGYFB\_V\_PATTERN - Vertical scaling (R/W)



## 10110304h/10111304h - LGYFB\_H\_PATTERN - Horizontal scaling (R/W)


```
  0-7   Read a new src pixel before computing 1st..8th dst pixel (0=No, 1=Yes)
  8-31  Unused (0)
```

"The amount of set bits determine how many pixels are read each batch."

"Any bit indexes past LGYFB\_x\_LEN are ignored."

"This value is 8 bits, but it has to be written with a 32bit write."

Example values:

```
  Len Pattern    Effect
  1   xxxxxxx1b  No scaling    (1 input pixels --> 1 output pixels)
  8   11111111b  No scaling    (8 input pixels --> 8 output pixels)
  5   xxx01111b  Scale by 1.25 (4 input pixels --> 5 output pixels) ;NDS/DSi
  4   xxxx0111b  Scale by 1.33 (3 input pixels --> 4 output pixels)
  3   xxxxx011b  Scale by 1.5  (2 input pixels --> 3 output pixels)
  6   xx011011b  Scale by 1.5  (4 input pixels --> 6 output pixels) ;GBA
  3   xxxxx001b  Scale by 3    (1 input pixels --> 3 output pixels)
  2   xxxxxx01b  Scale by 2    (1 input pixels --> 2 output pixels)
  8   01010101b  Scale by 2    (4 input pixels --> 8 output pixels)
 GBA (240x160) scale by 1.5  = 3DS top screen (360x240)
 GBA (240x160) scale by 1.33 = 3DS bottom screen (320x213)
 NDS (256x192) scale by 1.25 = 3DS either screen (320x240)
```



## 10110240h/10111240h - LGYFB\_V\_ARRAY - Vertical scaling, 6x8 words (R/W)



## 10110340h/10111340h - LGYFB\_H\_ARRAY - Horizontal scaling, 6x8 words (R/W)


This array contains 6x8 words, used to compute up to 8 output pixels, with
brightness multipliers for 6 input pixels each.

```
  0-3   Unused (0) (Nintendo writes 16bit to bit0-15, but bit0-3 are ignored)
  4-15  Brightness per source pixel (signed, -800h..+7FFh; 400h=full/max)
  16-31 Unused (0)
```

The sum of six input values should be 400h (the hardware does automatically
clip results to min/max brightness; clipping can happen when mixing positive
and negative values; with some of them getting multiplied with dark input
pixels).

Note: Multipliers bigger than 400h are glitchy (value 7FFh somehow converts
white pixels to dark gray).



## Default Array for GBA screen (scale by 1.5) (240x160 to 360x240)


This is using Pattern=011011b and Length=6 (minus 1). The array entries are
straight ahead, using pixels with full brightness, and merged pixels with half
brightness:

```
  0000h,0000h,0000h,0000h,0000h,0000h, N/A , N/A  <-- for 1st input pixel
  0000h,0000h,0000h,0000h,0000h,0000h, N/A , N/A  <-- for 2nd input pixel
  0000h,2000h,4000h,0000h,2000h,4000h, N/A , N/A  <-- for 3rd input pixel
  4000h,2000h,0000h,4000h,2000h,0000h, N/A , N/A  <-- for 4th input pixel
  0000h,0000h,0000h,0000h,0000h,0000h, N/A , N/A  <-- for 5th input pixel
  0000h,0000h,0000h,0000h,0000h,0000h, N/A , N/A  <-- for 6th input pixel
    |     |     |     |     |     |
    |                             '-----------------> to 6th output pixel
    '-----------------------------------------------> to 1st output pixel
```

For whatever reason, this is scaling by 6:4 with 6 output pixels (instead of
3:2 with 3 output pixels). Unknown if it's faster that way, or if there's some
other advantage.



## Default Array for NDS/DSi screens (scale by 1.25) (256x192 to 320x240)


This is using Pattern=01111b and Length=5 (minus 1). The array entries contain
positive and negative values, which might raise contrast between bright/dark
pixels:

```
  0000h,004Eh,011Dh,01E3h,01C1h, N/A , N/A , N/A  <-- for 1st input pixel
  0000h,FCA5h,F8D0h,F69Dh,F873h, N/A , N/A , N/A  <-- for 2nd input pixel
  0000h,0D47h,1E35h,2F08h,3B6Fh, N/A , N/A , N/A  <-- for 3rd input pixel
  4000h,3B6Fh,2F08h,1E35h,0D47h, N/A , N/A , N/A  <-- for 4th input pixel
  0000h,F873h,F69Dh,F8D0h,FCA5h, N/A , N/A , N/A  <-- for 5th input pixel
  0000h,01C1h,01E3h,011Dh,004Eh, N/A , N/A , N/A  <-- for 6th input pixel
    |     |     |     |     |
    |                       '-----------------------> to 5th output pixel
    '-----------------------------------------------> to 1st output pixel
```

Weirdly, the values for 2nd-5th output pixel values sum up to 3FDDh/3FAAh
(actually less, because the lower 4bit are ignored), making them a bit darker
than 1st output pixel.




# <a name="3dsvideotextureswizzling"></a>3DS Video Texture Swizzling




## Texture Swizzling


Morton Swizzling, or Z-order Swizzling is done by reading source pixels from a
scanline based bitmap in "Z-shaped" read-direction, and then storing that
pixels at continous VRAM addresses.

In the drawing below, each "Z" represents 2x2 pixels (arranged as a "Z" shape,
ie. upper-left, upper-right, lower-left, lower-right). On a larger scale, each
2x2 Z's are also forming a larger Z, and so on.

```
  Z/Z  /Z/Z
  .-' / .-'
  Z/Z/  Z/Z
      ..--'
  .--'
  Z/Z  /Z/Z
  .-' / .-'
  Z/Z/  Z/Z
```

This can improve cache hits for adjacent pixels. In a large bitmap, pixels in
adjacent scanlines are always located in separate cache entries. With the
swizzling, there is a better chance that they are in the same cache entry.



## Addressing


The swizzling does interleave the x/y address bits. On the 3DS hardware, data
is processed in units of 8 scanlines, so the interleave occurs on lower three
x/y bits only. For example, for 256x256 pixel data:

```
  Scanline-based bitmap -->  YyyyyyyyXxxxxxxx
  Swizzled texture      -->  YyyyyXxxxxyxyxyx
```



## Swizzling Hardware


The 3DS has some hardware for converting scanlines to swizzled textures:

```
  Y2R Registers (YUV-to-RGBA)
  L2B Registers (RGB-to-RGBA) (New3DS only)
  LGYFB Registers (GBA/NDS/DSi-to-3DS-Framebuffer)
```



## Swizzling Examples


Examples for scanline pixels before/after swizzling:

```
  Linear scanlines, 16x8 pixels:                    Linear lines, 8x8 pixels:
  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F   00 01 02 03 04 05 06 07
  10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F   08 09 0A 0B 0C 0D 0E 0F
  20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F   10 11 12 13 14 15 16 17
  30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F   18 19 1A 1B 1C 1D 1E 1F
  40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F   20 21 22 23 24 25 26 27
  50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F   28 29 2A 2B 2C 2D 2E 2F
  60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F   30 31 32 33 34 35 36 37
  70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F   38 39 3A 3B 3C 3D 3E 3F
  Swizzled texture, 2 tiles:                        Swizzled texture, 1 tile:
  00 01 10 11 02 03 12 13  ;\                       00 01 08 09 02 03 0A 0B
  20 21 30 31 22 23 32 33  ;                        10 11 18 19 12 13 1A 1B
  04 05 14 15 06 07 16 17  ;                        04 05 0C 0D 06 07 0E 0F
  24 25 34 35 26 27 36 37  ; left tile              14 15 1C 1D 16 17 1E 1F
  40 41 50 51 42 43 52 53  ;                        20 21 28 29 22 23 2A 2B
  60 61 70 71 62 63 72 73  :                        30 31 38 39 32 33 3A 3B
  44 45 54 55 46 47 56 57  ;                        24 25 2C 2D 26 27 2E 2F
  64 65 74 75 66 67 76 77  ;/                       34 35 3C 3D 36 37 3E 3F
  08 09 18 19 0A 0B 1A 1B  ;\
  28 29 38 39 2A 2B 3A 3B  ;
  0C 0D 1C 1D 0E 0F 1E 1F  ;
  2C 2D 3C 3D 2E 2F 3E 3F  ; right tile
  48 49 58 59 4A 4B 5A 5B  ;
  68 69 78 79 6A 6B 7A 7B  :
  4C 4D 5C 5D 4E 4F 5E 5F  ;
  6C 6D 7C 7D 6E 6F 7E 7F  ;/
```


Note: Z-order refers to the shape of the letter "Z", not to be confused with
Z-axis, and not to be confused with the zigzag-order that is used in JPEGs.




# <a name="3dssoundandmicrophone"></a>3DS Sound and Microphone




## 3DS Sound File Formats


- [3DS Files - Sound Archive (CSAR Format)](#3dsfilessoundarchivecsarformat)
- [3DS Files - Sound SEQ (CSEQ Format)](#3dsfilessoundseqcseqformat)
- [3DS Files - Sound WSD (CWSD Format)](#3dsfilessoundwsdcwsdformat)
- [3DS Files - Sound Bank (CBNK Format)](#3dsfilessoundbankcbnkformat)
- [3DS Files - Sound Wave Archive (CWAR Format)](#3dsfilessoundwavearchivecwarformat)
- [3DS Files - Sound Wave Data (CWAV Format)](#3dsfilessoundwavedatacwavformat)
- [3DS Files - Sound Wave Streams (CSTM Format)](#3dsfilessoundwavestreamscstmformat)
- [3DS Files - Sound Group (CGRP Format)](#3dsfilessoundgroupcgrpformat)
- [3DS Files - Sound IDs (CSID Format)](#3dsfilessoundidscsidformat)
Note: The sound files resemble the older SDAT format used on NDS/DSi (many of
the unknown entries are probably similar to those older files).

Additionally, .aac files are probably AAC audio. And .cdc files contain DSP
program code.

- [3DS Files - Sound DSP Binary (DSP1 aka .cdc)](#3dsfilessounddspbinarydsp1akacdc)

```
 ________________________________ DSP Registers _______________________________
```


Reportedly 10141220h - CFG11\_CODEC\_CNT also has a DSP related bit?



## 10203000h  Teak DSP Registers (ARM11 only)


These registers are disabled by default (always zero), use CFG11\_DSP\_CNT (Port
10141230h) to enable them.

```
  10203000h 2    DSP_PDATA
  10203004h 2    DSP_PADR
  10203008h 2    DSP_PCFG
  1020300Ch 2    DSP_PSTS
  10203010h 2    DSP_PSEM
  10203014h 2    DSP_PMASK
  10203018h 2    DSP_PCLEAR
  1020301Ch 2    DSP_SEM
  10203020h 2    DSP_CMD0
  10203024h 2    DSP_REP0
  10203028h 2    DSP_CMD1
  1020302Ch 2    DSP_REP1
  10203030h 2    DSP_CMD2
  10203034h 2    DSP_REP2
  10203040h FC0h Mirrors of above 40h-byte area
  10203200h 40h  Reportedly "LCD", but actually it's just one of above mirrors
```

These are same as on DSi.

- [DSi XpertTeak (DSP)](ds.html#dsixpertteakdsp)
3DS software is commonly using the DSP to play music recordings in AAC format,
and reportedly there is something called DSP-ADPCM (maybe something similar to
IMA-ADPCM)?


```
 _______________________________ CSND Registers _______________________________
```


The sound hardware works very similar to NDS sound, see there for details about
PCM, IMA-ADPCM and PSG formats.

- [DS Sound](ds.html#dssound)
Differences are twice as many sound channels, some moved control bits, and
simplified volume control (without sound/panning/master volumes).

Unknown if/where BIAS exists on 3DS?



## 10103000h - Sound Control (R/W)


```
  0-15   CSND Master Volume (0..8000h) (8001h..FFFFh=replaced by 8000h) (R/W)
  16     Disable sound output           (0=Enable, 1=Mute)              (R/W)
  17-29  Unused? (0)
  30     Dissonant sound??              (0=Dissonant, 1=Normal)         (R/W)
  31     Makes some register/bits R/W   (0=No, 1=Yes)                   (R/W)
```

When bit31=1:

```
  10103400h+(N*20h).bit15   becomes R/W
  1010340Ch+(N*20h).bit31-2 becomes R/W
  10103800h+(N*10h).bit15   becomes R/W
  1010380Ch+(N*10h).bit31-0 becomes R/W
```


```
 ___________________________ CSND Channel Registers ___________________________
```



## 10103400h+(N\*20h) - Sound Channel 0-31: Control (parts W and R/W)


```
  0-2    Wave Duty   (0..7) ;HIGH=(N+1)*12.5%, LOW=(7-N)*12.5% (PSG only) (R/W)
  3-5    Unused (0)
  6      Linear interpolation on each two samples (0=Disable, 1=Enable)   (R/W)
  7      Hold   (0=Normal, 1=Hold last sample after one-shot sound)       (R/W)
  8-9    Unused (0)
  10-11  Repeat (0=Manual, 1=Loop Infinite, 2=One-shot, 3=Same as 1?)     (R/W)
  12-13  Format (0=PCM8, 1=PCM16, 2=IMA-ADPCM, 3=PSG/Noise)               (R/W)
  14     Pause DMA or so? (0=Pause?, 1=Normal)  ;no effect on PSG?!       (R/W)
  15     Start/Status (0=Stop, 1=Start/Busy)    ;need 10103000h.bit31     (R/W)
  16-31  Sample Rate (0..FFBEh; 0=Slowest, FFBEh=Fastest) (FFBFh..=Hangs)   (W)
```

PSG/Noise: Rectangular waves are supported on channel 8-13, noise on channel
14-15. Rectangular wave Duty is same as for NDS (but 32 samples long instead of
8 samples).

Sample rate is reportedly 4x higher than NDS:

```
  value = 67.027964MHz / samplerate
  uh, that value is NOT negative??? apparently wrong.
  XXX but what is NOISE frequency?
```



## 10103404h+(N\*20h) - Sound Channel 0-31: Output Volume (R/W)


```
  0-15  Volume Right (0..8000h)  ;\writing values 8001h..FFFFh is
  16-31 Volume Left  (0..8000h)  ;/automatically changed to 8000h
```



## 10103408h+(N\*20h) - Sound Channel 0-31: Capture Volume (R/W)


```
  0-15  Capture 0 volume (right?) (0..8000h) ;\writing 8001h..FFFFh gets
  16-31 Capture 1 volume (left?)  (0..8000h) ;/automatically changed to 8000h
```



## 1010340Ch+(N\*20h) - Sound Channel 0-31: Start Address (R/W) (Bit0-1: W)



## 10103414h+(N\*20h) - Sound Channel 0-31: Loop Restart Address (W)


```
  0-31  Physical Memory Address (unused for PSG/noise)
```

The R/W-ability is a mess: Start.bit2-31 are R/W (if enabled in
10103000h.bit31). Start.bit0-1 do also exist, but are write-only.
Restart.bit0-31 are write-only.



## 10103410h+(N\*20h) - Sound Channel 0-31: Total Size (W)


```
  0-26   Size in bytes (0..7FFFFFFh) (unused in manual mode)
  27-31  Unknown/Unused (0)
```

The size value is for the total size from Start to End (or Loop End if looped).
The total size (and size of looped part) semm to be required to be at least
10h. Hardware behaves quirky if the size of the looped part
(total-(restart-start)) is odd and/or(?) less than 10h. And, the quirkyness can
differ depending on whether CNT.bit10-11 is 1 or 3 (which is otherwise same).



## 10103418h+(N\*20h) - Sound Channel 0-31: Start IMA-ADPCM state (W)


```
  0-15   Initial PCM16 Value (Pcm16bit = -7FFFh..+7FFF) (not -8000h)
  16-22  Initial Table Index Value (Index = 0..88)
  23     Uh, reportedly MSB of above 7bit value ???
  ..     Unknown/Unused (0)
```

Equivalent to the IMA-ADPCM header from NDS samples (but, unlike as NDS, the
header must be manually written here; instead being located in the first four
sample bytes).



## 1010341Ch+(N\*20h) - Sound Channel 0-31: Loop Restart IMA-ADPCM state (W)


```
  0-15   Restart PCM16 Value (Pcm16bit = -7FFFh..+7FFF) (not -8000h)
  16-22  Restart Table Index Value (Index = 0..88)
  23     Uh, reportedly MSB of above 7bit value ???
  ..     Unknown/Unused (0)
  31     Reportedly ADPCM state reload at Loop Restart (1=Enable)
```

Allows to force the ADPCM state to the correct (pre-calculated) value upon
looping (or, with bit31=0, samples could drift if the last sample doesn't end
with exact same state as the first loop sample)...?

Uh, that's both weird... on NDS, the hardware did simply latch the correct
value automatically... is that really left unsupported on 3DS?


```
 ___________________________ CSND Capture Registers ___________________________
```


These are probably for left/right channel...

Maybe Capture 0 Left, and Capture 1 right?



## 10103800h+(N\*10h) - Sound Capture 0-1: Control (R/W)


```
  0      Capture Repeat        (0=Loop, 1=One-shot)
  1      Capture Format        (0=PCM16, 1=PCM8)
  2      Unknown ...? maybe something similar as on NDS
  2-14   Unused (0)
  15     Capture Start/Status  (0=Stop, 1=Start/Busy)  ;need 10103000h.bit31
  16-31  Unused (0)
```

There seems to be some extra delay at begin or end of capture: For one-shot,
the bit15=1 duration should depend on rate and length (but takes a bit longer
than it should).



## 10103804h+(N\*10h) - Sound Capture 0-1: Sample Rate (W)


```
  0-15   Sample Rate (0..FFBEh; 0=Slowest, FFBEh=Fastest) (FFBFh..FFFFh=Hangs)
  16-31  Unknown/unused (0)
```



## 1010380Ch+(N\*10h) - Sound Capture 0-1: Length (W)


```
  0-23   Length (in bytes) (1..FFFFFFh) (and oddly: 0=Same as 4)
  24-31  Unknown/unused (0)
```



## 1010380Ch+(N\*10h) - Sound Capture 0-1: Address (R/W)


```
  0-31   Address (in bytes) <--- This is R/W only if enabled in 10103000h.bit31
```

Capture works even if address and size are unaligned (even so for PCM16).


```
 _______________________________ CODEC Registers ______________________________
```



## 10145000h - CODEC\_SNDEXCNT, reportedly "Empty" uh? (R/W)


```
  0-5   DSP sound volume (00h..3Fh) (R/W)
  6-11  GBA sound volume (00h..3Fh) (R/W)
  12    Enable Microphone timing
  13    Sound/Microphone I2S frequency (0=32.73 kHz, 1=47.61 kHz)
  14    Unknown (maybe Mute, alike DSi's SNDEXCNT)
  15    Enable Microphone and Teak BTDMP timing and GBA sound
  16-28 Unused (0)
  29    Unknown                   (R/W)
  30    Unknown, disonnant sound? (R/W)
  31    Master Enable Microphone (and Sound?)
```

Microphone requires bit31 set, and also one or both of bit15/bit12 set.

Teak BTDMP timing requires bit15 set (and is also affected by bit13).

GBA sound requires bit15 set, and nonzero volume in bit6-11.

Maybe some further bits here resemble DSi's SNDEXCNT...?


```
 ________________________________ MIC Registers _______________________________
```



## MIC Registers


```
  10162000h 2  REG_MIC_CNT  Microphone Control
  10162004h 4  REG_MIC_DATA Microphone Data
```

These are about same as for DSi.

- [DSi Microphone and SoundExt](ds.html#dsimicrophoneandsoundext)
The microphone must be unmuted in touchscreen TSC registers.

The microphone must be enabled in Port 10145000h.

Microphone triggers CDMA 00h (requires Port 1014010Ch, CFG11\_CDMA\_CNT.bit0=1).




# <a name="3dscartridgeregisters"></a>3DS Cartridge Registers




## Gamecard related CONFIG9 Registers


```
  1000000Ch 2   CFG9_CARD_CTL           NTRCARD/CTRCARD/SPI controller select
  10000010h 1   CFG9_CARD_POWER         Power On/Off/Reset and Eject detect
  10000012h 2   CFG9_CARD_INSERT_DELAY  Cart insert detection delay
  10000014h 2   CFG9_CARD_PWROFF_DELAY  Cart power off delay
```

- [3DS Config - CONFIG9 Registers](#3dsconfigconfig9registers)

```
 ___________________________ 3DS Cartridge Protocol ___________________________
```


Cartridge detection is done using unencrypted 8-byte NTRCARD commands, 3DS
cartridges have ChipID.bit28=1, if so, command 3Eh is used to switch to 16-byte
CTRCARD mode.

Of these 16-byte commands, the first command/reply (82h) is unencrypted, used
to receive the header with an AES-encrypted encryption constant. The next
command/reply (83h) is encrypted using that constant, used to send a random
value. The following commands are encrypted using a combination of the original
constant and the random value.

```
  Command                          Data  Expl.
  9F00000000000000                 2000h Dummy
  71C93FE9BB0A3B18                 0     Unknown/dummy (hardcoded constant)
  9000000000000000                 4     Get Chip ID, response=9000FEC2
  9000000000000000                 4     Get Chip ID, response=9000FEC2
  A000000000000000                 4     Get Chip Type, response=00000000
  3E00000000000000                 0     Enter 16-byte command mode
  82000000000000000000000000000000 200h  Get header/seed (NCSD[1000h..11FFh])
  8300000000000000rrrrrrrrrrrrrrrr 0     Change Seed (to random)
  A200000000000000rrrrrrrrrrrrrrrr 4     Get Chip ID, response=9000FEC2
  A300000000000000rrrrrrrrrrrrrrrr 4     Get Chip Type, response=00000000
  C500000000000000rrrrrrrrrrrrrrrr 0     Unknown Watchdog?
  A200000000000000rrrrrrrrrrrrrrrr 4     Get Chip ID, response=9000FEC2
  A200000000000000rrrrrrrrrrrrrrrr 4     Get Chip ID, response=9000FEC2
  A200000000000000rrrrrrrrrrrrrrrr 4     Get Chip ID, response=9000FEC2
  A200000000000000rrrrrrrrrrrrrrrr 4     Get Chip ID, response=9000FEC2
  A200000000000000rrrrrrrrrrrrrrrr 4     Get Chip ID, response=9000FEC2
  BF000000000000000000000000000000 200h  Read address 0 (NCSD[0..1FFh])
  BF000000000040000000000000000000 200h  Read address 4000h (maybe partition?)
  C6000000000000000000000000000000 40h   Get Unique ID (on-chip PROM)
  BFaaaaaaaaaaaaaa0000000000000000 200h  Read address aaa...
  C5000000000000000000000000000000 0     Unknown Watchdog (each 10,000 reads)
  BFaaaaaaaaaaaaaa0000000000000000 200h  Read address aaa...
```

On a lower level, the NTRCARD commands are working about as on NDS/DSi (with
hardcoded gaps between command and data). The CTRCARD commands are sending a
status byte instead of gaps (00h bytes when not ready, 01h when ready for data
transfer; the 3DS hardware does automatically wait for that status byte before
transferring data blocks). The data block is reportedly followed by a standard
CRC32 value across unencrypted data. However, cartridges do only seem to output
correct CRC's for command 82h/BFh. And, even then, the CRC doesn't actually
look like a standard CRC32, or maybe the CRC gets garbled by encryption or
status bytes?


The PROM is used for online games, it contains a 16-byte hex number (followed
by 30h-byte FFh-filled area).

Some cards do also have writeable NAND instead of ROM. The NAND is also
accessed via CTRCARD0 registers (not CTRCARD1), the NAND commands are still
unknown.


```
 __________________________ 3DS Cartridge Encryption __________________________
```


The encryption seed is initialized as follows:

```
  CardType = (ReplyFromCommandA0h AND 00000003h)
  send CTRCARD command 82h                      ;-receive NCSD[1000h..11FFh]
  AES.KEYX = as set by bootrom, keyslot 3Bh     ;\
  AES.KEYY = NCSD[1000h..100Fh]                 ; decrypt seed via AES-CCM
  AES.MAC  = NCSD[1020h..102Fh]                 ; (use big-endian input,
  AES.IV   = NCSD[1030h..103Bh]                 ; and little-endian output)
  if CardType=3 then AES.KEY = zerofilled       ;  <--dev card (keyslot 11h)
  AES.DATA.IN  = NCSD[1010h..101Fh]             ;
  ctrcard_seed[00h..0Fh] = AES.DATA.OUT         ;/
  CTRCARD_SECSEED = ctrcard_seed                ;\
  CTRCARD_SECCNT = CardType*100h+8004h          ; apply fixed seed
  wait until CTRCARD_SECCNT.bit14=1             ;/
  random64bit = whatever, can be zero, or same as fixed seed, or random
     cmdRand1 = REG_PRNG[0];
     cmdRand2 = REG_PRNG[4];
  send CTRCARD command 83h + random64bit        ;-send random64bit to card
  ctrcard_seed[00h..07h] = random64bit          ;-change LSBs of fixed seed
  CTRCARD_SECSEED = ctrcard_seed                ;\
  CTRCARD_SECCNT = CardType*100h+8004h          ; apply random seed
  wait until CTRCARD_SECCNT.bit14=1             ;/
  send further CTRCARD commands...              ;-get chip id, read data, etc.
```

The inner workings of the encryption hardware are unknown, it does probably
contain AES hardware with some built-in secret key/iv values. Cart dumping is
possible using the 3DS console hardware, there are also "sky3DS" flashcards
that can run pirate copies on 3DS consoles without needing exploits, but that's
kinda useless and works only for RSA signed official titles with region lock
(the game selection is done via buttons on the cartridge instead of file menu).


```
 _____________________________ NTRCARD Registers ______________________________
```



## NTRCARD Registers (ARM9/ARM11)


These registers are same as the old NDS Cartridge registers, see

- [DS Cartridge I/O Ports](ds.html#dscartridgeioports)
```
  10164000h 2  REG_NTRCARD_MCNT    ;40001A0h 2  Gamecard ROM and SPI Control
  10164002h 2  REG_NTRCARD_MDATA   ;40001A2h 2  Gamecard SPI Bus Data/Strobe
  10164004h 4  REG_NTRCARD_ROMCNT  ;40001A4h 4  Gamecard bus timing/control
  10164008h 8  REG_NTRCARD_CMD     ;40001A8h 8  Gamecard bus 8-byte command out
  10164010h 4  REG_NTRCARD_SEEDX_L ;40001B0h 4  Gamecard Encryption Seed 0 Low
  10164014h 4  REG_NTRCARD_SEEDY_L ;40001B4h 4  Gamecard Encryption Seed 1 Low
  10164018h 1  REG_NTRCARD_SEEDX_H ;40001B8h 2  Gamecard Encryption Seed 0 High
  1016401Ah 1  REG_NTRCARD_SEEDY_H ;40001BAh 2  Gamecard Encryption Seed 1 High
  1016401Ch 4  REG_NTRCARD_FIFO    ;4100010h 4  Gamecard bus 4-byte Data In (R)
```

These registers are usually used on ARM9 side. However, they are mapped to both
ARM11/ARM9, and do support IRQ/DMA on ARM11/ARM9 side (unlike most other
registers in that area, which support IRQ/DMA on ARM11 side only).

Note: ARM11-side CDMA 01h requires Port 1014010Ch, CFG11\_CDMA\_CNT.bit1=1.


```
 _____________________________ CTRCARD Registers ______________________________
```



## CTRCARD Registers (ARM9 only)


- 10004000h - CTRCARD0 - normal cartridge access
- 10005000h - CTRCARD1 - unknown purpose, not used for ROM cards, nor NAND cards
  - 10004000h/10005000h 4   CTRCARD\_CNT
  - 10004004h/10005004h 4   CTRCARD\_BLKCNT
  - 10004008h/10005008h 4   CTRCARD\_SECCNT    ;varies for CARD0/CARD1
  - 1000400Ch/1000500Ch 4   CTRCARD\_LOCK
  - 10004010h/10005010h 4   CTRCARD\_SECSEED      FIFO!!!!!
  - 10004020h/10005020h 16  CTRCARD\_CMD
  - 10004030h/10005030h 4   CTRCARD\_FIFO



## 10004000h/10005000h - CTRCARD\_CNT


```
  0-4   Timeout (0-16=1ms,2ms,4ms,8ms,..,64s; 17-31=64s, too; def=12=4s)  (R/W)
  5     Timeout Error      (0=Okay, 1=Error) (write 0 to ack)           (R/ack)
  6     Timeout Enable     (0=Disable, 1=Enable)                          (R/W)
  7     Unused (0)
  8     CRC Error          (0=Okay, 1=Error) (write 0 to ack)           (R/ack)
  9     CRC Enable         (0=Disable, 1=Enable) (works for cmd 82h/BFh)  (R/W)
  10-14 Unused (0)
  15    DMA Enable         (0=Disable, 1=Enable DMA DRQs, each 8 words)   (R/W)
  16-19 Data Block size    (0-8=0,4,16,64,512,1K,2K,4K,8K; 9-15=8K, too)  (R/W)
  20-23 Unused (0)
  24-26 Transfer Clock     (0-5=67MHz div 4,5,6,8,10,16; 6-7=div16, too)  (R/W)
  27    Data-Word status   (0=Busy, 1=Ready/DRQ)                            (R)
  28    Reset Pin          (0=Low/Reset, 1=High/Release) (SET-ONCE)       (R/W)
  29    Transfer Direction (0=Read, 1=Write)                              (R/W)
  30    Interrupt Enable   (0=Disable, 1=Enable) (ARM9 IF.bit23/24)       (R/W)
  31    Start              (0=Idle, 1=Start/Busy)                         (R/W)
```

With the above Transfer Clock settings, the clock (per byte) can range from
16.7MHz downto 4.2MHz.

Once reset pin is set high, it cannot be changed until controller is reset
(which can be done CFG9\_CARD\_POWER). Setting bit28 does work only when writing
bit31=0.



## 10004004h/10005004h - CTRCARD\_BLKCNT (R or R/W)


```
  0-14  Number of data blocks to read, minus 1   (0..7FFFh=1..8000h)      (R/W)
  15    Unused (0)
  16-28 Number of data blocks to write, minus 1  (0..1FFFh=1..2000h)      (R/W)
  29-31 Unused (0)
```



## 10004008h/10005008h - CTRCARD\_SECCNT (R or R/W)


For CARD0 (10004008h): (R/W mask 0307h, with readonly mask 4000h)

```
  0-1   Crypto Mode   (0=Normal, 1=Unknown, 2=Ignore SEED, 3=same as 0)   (R/W)
  2     Crypto Enable (0=Disable, 1=Enable)                               (R/W)
  3-7   Unused (0)
  8-9   Crypto Key index      (0..3, from A0h command) (3=debug)          (R/W)
  10-14 Unused (0)
  14    Crypto Apply Ready    (0=Busy, 1=Ready)                             (R)
  15    Crypto Apply Seed/Key (0=No, 1=Update Seed, works only if bit2=1)   (W)
  16-31 Unused (0)
```

For CARD1 (10005008h): (R/W mask 9300h, without readonly mask)

```
  0-7   Unused (0)
  8-9   Key index (?)                                                     (R/W)
  10-11 Unused (0)
  12    unknown... ?                                                      (R/W)
  13-14 Unused (0)
  15    unknown... ?                                                      (R/W)
  16-31 Unused (0)
```



## 1000400Ch/1000500Ch - CTRCARD\_LOCK (R or R/W)


```
  0     Write-protect CNT.bit28, SECCNT.bit0-2 (0=No, 1=Lock) (SET-ONCE)  (R/W)
  1-31  Unused (0)
```



## 10004010h/10005010h - CTRCARD\_SECSEED (W)


```
  0-31  Encryption Seed, 4-word FIFO (16 bytes)
```

To apply the four most recent words written to SECSEED, write SECCNT.bit15=1,
then wait for SECCNT.bit14=1.

The seed is usually updated twice: Once after command 82h (using four seed
words from the cart header), and once after command 83h (with two seed words
changed to random values).



## 10004020h/10005020h - CTRCARD\_CMD (W)


```
  0-127 Command (128bit, aka 16 bytes, little endian, transferred MSB first)
```



## 10004030h/10005030h - CTRCARD\_FIFO (R) (maybe also for write-direction?)


```
  0-31  Data (from 8 word FIFO)
```


```
 _____________________________ SPI CARD Registers _____________________________
```


SPI FLASH cartridge savedata is accessed via SPI\_CARD registers, see:

- [3DS SPI Registers](#3dsspiregisters)



# <a name="3dsinterruptsandtimers"></a>3DS Interrupts and Timers




## ARM9


- [3DS ARM9 Interrupts](#3dsarm9interrupts)
- [3DS ARM9 Timers](#3dsarm9timers)


## ARM11


- [3DS ARM11 Interrupts](#3dsarm11interrupts)
- [ARM11 MPCore Private Memory Region Register Summary](#arm11mpcoreprivatememoryregionregistersummary)
- [ARM11 MPCore - Snoop Control Unit (SCU)](#arm11mpcoresnoopcontrolunitscu)
- [ARM11 MPCore - Timer and Watchdog](#arm11mpcoretimerandwatchdog)
- [ARM11 MPCore - Interrupt Configuration](#arm11mpcoreinterruptconfiguration)
- [ARM11 MPCore - Interrupt Handling](#arm11mpcoreinterrupthandling)
- [ARM11 MPCore Distributed Interrupt Controller (Blurb)](#arm11mpcoredistributedinterruptcontrollerblurb)



# <a name="3dsarm9interrupts"></a>3DS ARM9 Interrupts




## ARM9 Interrupts (ARM9 only)


Mostly same as GBA/NDS/DSi, but without IME (only CPSR irq enable), and without
IE2/IF2, and with changed IRQ bits:

10001000h - IRQ\_IE - ARM9 Interrupt Enable

10001004h - IRQ\_IF - ARM9 Interrupt Flags

```
  0-7   NDMA 0..7                                            (Port 10002000h)
  8-11  TIMER 0..3                                           (Port 10003000h)
  12    PXI_SYNC        ;aka IPC Sync                        (Port 10008000h)
  13    PXI_NOT_FULL    ;aka IPC Send FIFO Empty      ?      (Port 10008000h)
  14    PXI_NOT_EMPTY   ;aka IPC Recv FIFO Not Empty  ?      (Port 10008000h)
  15    AES                                                  (Port 10009000h)
  16    SDMMC controller (eMMC and SD/MMC slot)              (Port 10006000h)
  17    SDMMC sdio.irq pin?
  18    SDxx controller?    ;maybe this is SDIO wifi ? or unused 2nd SDMMC?
  19    SDxx sdio.irq pin?
  20    DEBUG_RECV      ;uh?                                 (?)
  21    DEBUG_SEND      ;uh?                                 (?)
  22    RSA                                                  (Port 1000B000h)
  23    CTRCARD0        and/or SPI_CARD ?                    (Port 10004000h)
  24    CTRCARD1                                            (Port 10005000h?)
  25    CGC     Gamecard power off  (CFG9_CARD_PWROFF_DELAY) (Port 10000010h)
  26    CGC_DET Gamecard insert     (CFG9_CARD_INSERT_DELAY) (Port 10000010h)
  27    NTRCARD (used by ARM9, although it's ARM11/ARM9)     (Port 10164000h)
  28    XDMA Event 0..4 (five events sharing one IRQ)        (Port 1000C000h)
  29    XDMA Faulting (eg. CCR=0, or event>11)               (Port 1000C000h)
  30-31 Unused (always 0)
```




# <a name="3dsarm9timers"></a>3DS ARM9 Timers




## Timers (ARM9 only)


10003000h ARM9

Same as GBA/NDS/DSi, except, reportedly faster & with stunning accuracy:

```
  "timers run at a frequency of 67,027,964.0 +/- 2^(-32) Hz"
```

which would be an estimated error of about +/- 1 cycle per century, or +/- 1
second per a few billions of years.

- [GBA Timers](gba.html#gbatimers)



# <a name="3dsarm11interrupts"></a>3DS ARM11 Interrupts




## Private Software Interrupts (can be different for each CPU)


```
  IRQ    Listener      Description
  00h                  MPCore software IRQ, not configured
  01h                  MPCore software IRQ, used by BOOT11 to kickstart Core1
  02h-03h              MPCore software IRQ, seem to be unused
  04h    Kernel        MPCore software IRQ, used to manage performance counter
  05h    Kernel        MPCore software IRQ, does apparently nothing
  06h    Kernel        MPCore software IRQ, extensively used by
                         KernelSetState (and contains most of the actual
                         code of the latter)
  07h    Kernel        MPCore software IRQ, see KCacheMaintenanceInterruptEvent
  08h    Kernel        MPCore software IRQ, used for scheduling
  09h    Kernel        MPCore software IRQ, used when handling
                         exceptions that require termination of a thread or
                         a process, and in some cases by
                         svcSetDebugThreadContext, to store VFP registers
                         in the thread's register storage.
  0Ah    Kernel        TLB operations IRQ, see KTLBOperationsInterruptEvent
  0Bh-0Eh              MPCore software IRQ, not configured
  0Fh    dmnt/debugger MPCore software IRQ, used to abstract FIQ (debug),
                         this interrupt is never sent to New3DS core2/core3
```



## Private Timer Interrupts (has separate timers for each CPU)


```
  10h-1Ch              Hmmmm, these do NOT EXIST (?) in interrupt controller?
  1Dh    Kernel        MPCore Timer0 (Port 17E00600h)
  1Eh    Kernel        MPCore Timer1 (Port 17E00620h) (3DS used on "core 1")
  1Fh                  MPCore Legacy "nIRQ" pin (is that used in 3DS?)
```



## Hardware Interrupts (can be used for all CPUs that are selected as Target)


```
  20h-23h -           Unused?
  24h     spi?        SPI_BUS2 (unused)               (Port 10143000h)
  25h-27h -           Unused?
  28h     gsp, TwlBg  PSC0 (GPU_MEMFILL 0)                 (Port 10400010h)
  29h     gsp, TwlBg  PSC1 (GPU_MEMFILL 1)                 (Port 10400020h)
  2Ah     gsp, TwlBg  PDC0 (GPU H/V-IRQ for top screen)    (Port 10400400h)
  2Bh     gsp, TwlBg  PDC1 (GPU H/V-IRQ for bottom screen) (Port 10400500h)
  2Ch     gsp, TwlBg  PPF  (GPU_MEMCOPY)                   (Port 10400C00h)
  2Dh     gsp, TwlBg  P3D  (GPUREG_IRQ_CMP/REQ)            (Port 10401040h)
  2Eh-2Fh -           Unused?
  30h-38h Kernel      Old CDMA Event 0..8 (nine events with separate IRQs)
  39h     Kernel      Old CDMA Faulting (eg. CCR=0, or event>15)
  3Ah     Kernel      New CDMA Event 0..31 (32 events sharing one IRQ) ;\New3DS
  3Bh     Kernel      New CDMA Faulting (eg. CCR=0)                    ;/
  3Ch-3Fh -           Unused?
  40h     nwm         WIFI SDIO Controller            (Port 10122000h)
  41h     nwm         WIFI SDIO IRQ Pin
  42h     nwm_dev?    Debug WIFI SDIO Controller      (Port 10100000h?)
  43h     -           Unused? Or maybe Debug WIFI SDIO IRQ Pin for above?
  44h     -           NTRCARD                         (Port 10164000h)
  45h     mvd         L2B_0 (First RGB-to-RGBA Converter)  (10130000h) ;\New3DS
  46h     mvd         L2B_1 (Second RGB-to-RGBA Converter) (10131000h) ;/
  47h     -           Unused?
  48h     camera      Camera Bus 0 (DSi cameras)      (Port 10120000h)
  49h     camera      Camera Bus 1 (left-eye)         (Port 10121000h)
  4Ah     dsp         ...probably Teak DSP... ?      (maybe 10203000h)
  4Bh     camera      Y2R_0 (First YUV-to-RGBA Converter)  (10102000h)
  4Ch     TwlBg       LGYFB_0 Legacy GBA/NDS Video    (Port 10110000h)
  4Dh     TwlBg       LGYFB_1 Legacy GBA/NDS Video    (Port 10111000h)
  4Eh     mvd         Y2R_1 (Second YUV-to-RGBA Converter) (10132000h) ;\New3DS
  4Fh     mvd         MVD Registers                   (Port 10207000h) ;/
  50h     pxi, TwlBg  PXI_SYNC.bit29 from ARM9 (commonly used)
  51h     pxi, TwlBg  PXI_SYNC.bit30 from ARM9 (rarely used)
  52h     pxi, TwlBg  PXI Send Fifo Empty
  53h     pxi, TwlBg  PXI Receive Fifo Not Empty
  54h     i2c, TwlBg  I2C_BUS0 (DSi devices)          (Port 10161000h)
  55h     i2c, TwlBg  I2C_BUS1 (3DS devices)          (Port 10144000h)
  56h     spi, TwlBg  SPI_BUS0 (Pwrman,WifiFlash,Tsc) (Port 10160000h)
  57h     spi, TwlBg  SPI_BUS1 (Tsc)                  (Port 10142000h)
  58h     Kernel      CFG11_MPCORE_CLKCNT (clk change)(Port 10141300h) ;-New3DS
  59h     TwlBg       CFG11_TWLMODE_SLEEP             (Port 10141104h)
  5Ah     mic         Microphone maybe?              (maybe 10162000h)
  5Bh     -           HID PAD Controller Buttons      (Port 10146000h)
  5Ch     i2c, TwlBg  I2C_BUS2 (3DS extra gimmicks)   (Port 10148000h)
  5Dh-5Eh -           Unused?
  5Fh     -           NDS-Wifi Registers (aka MP)     (Port 10170000h)
  60h     gpio, TwlBg GPIO_DATA0.bit2?   Shell opened
  61h     -           Unused?
  62h     gpio, TwlBg GPIO_DATA0.bit2?   Shell closed
  63h     gpio, TwlBg GPIO_DATA0.bit1    Touchscreen Pen Down (if enabled)
  64h     gpio, TwlBg GPIO_DATA1.bit0    Headphone jack plugged in/out
  65h     -           Unused?
  66h     gpio, TwlBg GPIO_DATA1.bit1    ?
  67h     -           Unused?
  68h     gpio, TwlBg GPIO_DATA3.bit0    C-stick Interrupt (New3DS)
  69h     gpio, TwlBg GPIO_DATA3.bit1    IrDA Interrupt
  6Ah     gpio, TwlBg GPIO_DATA3.bit2    Gyro Interrupt
  6Bh     gpio, TwlBg GPIO_DATA3.bit3    ?
  6Ch     gpio, TwlBg GPIO_DATA3.bit4    ?
  6Dh     gpio, TwlBg GPIO_DATA3.bit5    ?
  6Eh     gpio, TwlBg GPIO_DATA3.bit6    ?
  6Fh     gpio, TwlBg GPIO_DATA3.bit7    ?
  70h     gpio, TwlBg GPIO_DATA3.bit8    TSC[67h:2Bh] (Headphone connect)
  71h     gpio, TwlBg GPIO_DATA3.bit9    MCU Interrupt (MCU[10h-1Fh])
  72h     gpio, TwlBg GPIO_DATA3.bit10   NFC Interrupt (New3DS)
  73h     TwlBg       GPIO_DATA3.bit11   ??
  74h     ?           CGC Gamecard power off     (CFG9_CARD_PWROFF_DELAY)
  75h     ?           CGC Gamecard insert switch (CFG9_CARD_INSERT_DELAY)
  76h     -           L2C Level 2 Cache Controller    (Port 17E10000h)   New3DS
  77h     -           Unused?
  78h     Kernel      CPU0 cp15 Performance monitor count (any) overflow
  79h     Kernel      CPU1 cp15 Performance monitor count (any) overflow
  7Ah     Kernel      CPU2 cp15 Performance monitor count (any) overflow New3DS
  7Bh     Kernel      CPU3 cp15 Performance monitor count (any) overflow New3DS
  7Ch-7Fh -           Unused?
  80h-3FEh            Don't exist (3DS/New3DS has only 80h IRQ sources)
  3FFh                None, no interrupt (or spurious interrupt)
```

The spurious interrupt (3FFh) might appear in an interrupt handler if the
handler got triggered, but something (eg. another CPU) has cleared the IRQ flag
before the handler got a chance to process it.




# <a name="arm11mpcoreprivatememoryregionregistersummary"></a>ARM11 MPCore Private Memory Region Register Summary




## MPCore private memory region


The MPCore Private Memory Region contains additional ARM control registers
(additionally to the CP15 coprocessor registers). The 3DS does have this region
mapped at address 17E00000h and up.

```
  17E00000h 100h  MPCore SCU (Snoop Control Unit)
  17E00100h 100h  MPCore CPU interrupt interface for LOCAL CPU
  17E00200h 100h  MPCore CPU0 interrupt interface (aliased for debug purposes)
  17E00300h 100h  MPCore CPU1 interrupt interface (aliased for debug purposes)
  17E00400h 100h  MPCore CPU2 interrupt interface (aliased for debug purposes)
  17E00500h 100h  MPCore CPU3 interrupt interface (aliased for debug purposes)
  17E00600h 100h  MPCore CPU timer and watchdog for LOCAL CPU
  17E00700h 100h  MPCore CPU0 timer and watchdog
  17E00800h 100h  MPCore CPU1 timer and watchdog
  17E00900h 100h  MPCore CPU2 timer and watchdog  ;\if enabled in
  17E00A00h 100h  MPCore CPU3 timer and watchdog  ;/10141312h/13h
  17E00B00h 500h  MPCore Reserved (access causes a DECERR abort exception)
  17E01000h 1000h MPCore Global Interrupt distributor
```



## Snoop Control Unit (SCU)


```
  Offset       Type Reset      Name
  17E00000h 4   R/W 00001FFEh  SCU Control Register
  17E00004h 4   R   (var)      SCU Configuration Register
  17E00008h 4   R/W -          SCU CPU Status
  17E0000Ch 4   W   -          SCU Invalidate All
  17E00010h 4   R/W 00000000h  SCU Performance Monitor Control Register
  17E00014h 4   R/W 00000000h  SCU Monitor Counter Events 0
  17E00018h 4   R/W 00000000h  SCU Monitor Counter Events 1
  17E0001Ch 4   R/W 00000000h  SCU Monitor Counter 0
  17E00020h 4   R/W 00000000h  SCU Monitor Counter 1
  17E00024h 4   R/W 00000000h  SCU Monitor Counter 2
  17E00028h 4   R/W 00000000h  SCU Monitor Counter 3
  17E0002Ch 4   R/W 00000000h  SCU Monitor Counter 4
  17E00030h 4   R/W 00000000h  SCU Monitor Counter 5
  17E00034h 4   R/W 00000000h  SCU Monitor Counter 6
  17E00038h 4   R/W 00000000h  SCU Monitor Counter 7
  17E0003Ch C4h -   -          SCU Reserved (0)
```

All SCU registers are byte accessible.



## MP11 CPU Interrupt Interface Registers (for Interrupt Handling)


```
  Address       Type Reset value Function
  17E00100h 4   R/W  00000000h CPU IRQ Control Register
  17E00104h 4   R/W  000000F0h CPU IRQ Priority Mask Register
  17E00108h 4   R/W  00000003h CPU IRQ Binary Point Register
  17E0010Ch 4   R    000003FFh CPU IRQ Interrupt Acknowledge?? Register
  17E00110h 4   W    -         CPU IRQ End of Interrupt Register
  17E00114h 4   R    000000F0h CPU IRQ Running Priority Register
  17E00118h 4   R    000003FFh CPU IRQ Highest Pending Interrupt Register
  17E0011Ch E4h -    -         CPU IRQ Reserved
```

Above registers are for the LOCAL CPU, below are aliases for EACH CPU core.

```
  17E00200h 100h   MPCore CPU0 interrupt interface (aliased for debug purposes)
  17E00300h 100h   MPCore CPU1 interrupt interface (aliased for debug purposes)
  17E00400h 100h   MPCore CPU2 interrupt interface (aliased for debug purposes)
  17E00500h 100h   MPCore CPU3 interrupt interface (aliased for debug purposes)
```

All registers of the MP11 CPU interrupt interfaces must be accessed by 32bit
transactions only.



## Timer and Watchdog registers


```
  Offset       Type Reset     Name
  17E00600h 4   R/W 00000000h MPCore Timer0 Reload Value
  17E00604h 4   R/W 00000000h MPCore Timer0 Counter Value (decrementing)
  17E00608h 4   R/W 00000000h MPCore Timer0 Control Register
  17E0060Ch 4   R/W 00000000h MPCore Timer0 Interrupt Status
  17E00610h 10h -             Reserved
  17E00620h 4   R/W 00000000h MPCore Timer1/Watchdog Reload Value
  17E00624h 4   R/W 00000000h MPCore Timer1/Watchdog Counter Value (decrem.)
  17E00628h 4   R/W 00000000h MPCore Timer1/Watchdog Control Register
  17E0062Ch 4   R/W 00000000h MPCore Timer1/Watchdog Interrupt Status
  17E00630h 4   R/W 00000000h MPCore Timer1/Watchdog Reset Sent Register
  17E00634h 4   W   -         MPCore Timer1/Watchdog Disable Register
  17E00638h C8h -             Reserved
```

Above registers are for the LOCAL CPU, below are aliases for EACH CPU core.

```
  17E00700h 100h              MPCore CPU0 timer and watchdog
  17E00800h 100h              MPCore CPU1 timer and watchdog
  17E00900h 100h              MPCore CPU2 timer and watchdog  ;\if enabled in
  17E00A00h 100h              MPCore CPU3 timer and watchdog  ;/10141312h/13h
```

All timer and watchdog registers are word accessible only.

Note: There's also another ARM11 timer/cycle counter in CP15 registers.



## Distributed Interrupt controller registers (for Interrupt Configuration)


```
  Address   Size  Type Reset     Function
  17E01000h 4     R/W  00000000h Interrupt Distributor Control Register
  17E01004h 4     R    -         Interrupt Controller Type Register
  17E01008h F8h   -    ....      Reserved
  17E01100h 20h   R/W  0000FFFFh Interrupt Enable set Registers ID0-ID31
  17E01104h ()         00000000h Interrupt Enable set Registers ID32 and up
  17E01120h 60h   -    ....      Reserved
  17E01180h 20h   R/W  0000FFFFh Interrupt Enable clear Registers ID0-ID31
  17E01184h ()         00000000h Interrupt Enable clear Registers ID32 and up
  17E011A0h 60h   -    ....      Reserved
  17E01200h 20h   R/W  00000000h Interrupt Pending set Registers
  17E01220h 60h   -    ....      Reserved
  17E01280h 20h   R/W  00000000h Interrupt Pending clear Registers
  17E012A0h 60h   -    ....      Reserved
  17E01300h 20h   R    00000000h Interrupt Active Bit Registers
  17E01320h E0h   -    ....      Reserved
  17E01400h 100h  R/W  00000000h Interrupt Priority Registers
  17E01500h 300h  -    ....      Reserved
  17E01800h 100h  R/W  00000000h Interrupt CPU targets Registers (a.)
  17E01900h 300h  -    ....      Reserved
  17E01C00h 40h   R/W  AAAAAAAAh Interrupt Configuration Registers ID0-ID15
  17E01C04h ()         28000000h Interrupt Configuration Registers ID29-ID31
  17E01C08h ()         00000000h Interrupt Configuration Registers ID32 and up
  17E01C40h C0h   -    ....      Reserved
  17E01D00h 20h   R    00000000h Interrupt Line Level Registers ID0-ID31
  17E01D04h ()         -         Interrupt Line Level Registers ID32 and up
  17E01D20h E0h   -    ....      Oddly: mirrors of above 20h bytes
  17E01E00h 100h  -    ....      Reserved
  17E01F00h 4     W    -         Software Interrupt Register
  17E01F0xh DCh?  -    ....      Reserved
  17E01FE0h 4     R    90h       Peripheral Identification Register 0
  17E01FE4h 4     R    13h       Peripheral Identification Register 1
  17E01FE8h 4     R    04h       Peripheral Identification Register 2
  17E01FECh 4     R    00h       Peripheral Identification Register 3
  17E01FF0h 4     R    0Dh       PrimeCell Identification Register 0
  17E01FF4h 4     R    F0h       PrimeCell Identification Register 1
  17E01FF8h 4     R    05h       PrimeCell Identification Register 2
  17E01FFCh 4     R    B1h       PrimeCell Identification Register 3
    a. Except for address 0x81C. See Interrupt CPU Targets Registers.
```

All Interrupt Distributor Registers are byte accessible.


Official specs: DDI0360F\_arm11\_mpcore\_r2p0\_trm.pdf




# <a name="arm11mpcoresnoopcontrolunitscu"></a>ARM11 MPCore - Snoop Control Unit (SCU)




## Snoop Control Unit (SCU)


Below registers exists only once (not per CPU). However, the performance
counters are somewhat supposed to be used as two counters per CPU.



## 17E00000h - SCU Control Register (R/W)


The SCU Control Register enables the SCU and controls its behavior. It must be
accessed using a read-modify-write sequence.

```
  0     SCU Enable      (0=Disable, 1=Enable)
        (enable: maintain coherency between MP11 CPUs Level 1 data side caches)
        (in single CPU configuration, this bit has no effect and is always 0)
  1-4   Allow CPU0..3 to access SCU at 17E00000h..17E000FFh (0=No, 1=Yes)
  5-8   Allow CPU0..3 to access TMR at 17E00200h..17E005FFh (0=No, 1=Yes)
  9-12  Allow CPU0..3 to access IRQ at 17E00700h..17E00AFFh (0=No, 1=Yes)
  13    Report RAM Parity errors via parity error signals (0=Disable, 1=Enable)
  14-31 Reserved SBZ
```

Bit1-4: There is a mechanism that prevents all bits being cleared at the same
time.

Bit13: Before enabling SCU parity checking, all SCU tag must be invalidated.

This register doesn't seem to allow to disable access to the Global Interrupt
Distributor at 17E01000h-17E01FFFh (however, the MMU can disable the whole
4Kbyte page).



## 17E00004h - SCU Configuration Register (R)


```
  0-1   Number of ARM11 CPU cores   (0..3 = 1,2,3,4 CPU's)
  2-3   Reserved SBZ
  4-7   CPU0..3 Symmetric/Asymmetric Multi-processing (0=SMP/coherent, 1=AMP)
  8-9   CPU0 Tag RAM cache size (0=16KB, 1=32KB, 2=64KB, 3=Reserved)
  10-11 CPU1 Tag RAM cache size (0=16KB, 1=32KB, 2=64KB, 3=Reserved)
  12-13 CPU2 Tag RAM cache size (0=16KB, 1=32KB, 2=64KB, 3=Reserved)
  14-15 CPU3 Tag RAM cache size (0=16KB, 1=32KB, 2=64KB, 3=Reserved)
  16-31 Reserved SBZ
```

Cache size 16KB/32KB/64KB implies 64/128/256 indexes per tag RAM accordingly.

On New3DS this is 00005013h (even in Old3DS mode). But changes to 00005003h
when using fastboot...?



## 17E00008h - SCU CPU Status Register (R/W)


```
  0-1   CPU0 status (0=Normal, 1=Reserved, 2=Dormant, 3=Powered-off)
  2-3   CPU1 status (0=Normal, 1=Reserved, 2=Dormant, 3=Powered-off)
  4-5   CPU2 status (0=Normal, 1=Reserved, 2=Dormant, 3=Powered-off)
  6-7   CPU3 status (0=Normal, 1=Reserved, 2=Dormant, 3=Powered-off)
  8-31  Reserved SBZ
```

Dormant mode and powered-off mode are controlled by an external power
controller.

SCU CPU Status Register bits indicate to the external power controller which
power domains can be powered down.

Before entering any other power mode than Normal, the MP11 CPU must set its
status field to signal to the SCU which mode it is about to enter (so that the
SCU can determine if it still can send coherency requests to the CPU). The MP11
CPU then executes a WFI entry instruction. When in WFI state, the PWRCTLOn bus
is enabled and signals to the power controller what it must do with power
domains.

The SCU CPU Status Register bits are used in conjunction with internal WFI
entry signals to generate PWRCTLOn output pins.

The SCU CPU Status Register bits can also be read by a CPU exiting low-power
mode to determine its state before executing its reset setup.

MP11 CPUs status fields take PWRCTLIn values at reset, except for nonpresent
CPUs.

For nonpresent CPUs writing to this field has no effect.



## 17E0000Ch - SCU Invalidate All Register (W)


```
  0-3   Invalidate CPU0 ways (bit0-3   = Way 0,1,2,3)  (0=No, 1=Invalidate)
  4-9   Invalidate CPU1 ways (bit4-9   = Way 0,1,2,3)  (0=No, 1=Invalidate)
  8-11  Invalidate CPU2 ways (bit8-11  = Way 0,1,2,3)  (0=No, 1=Invalidate)
  12-15 Invalidate CPU3 ways (bit12-15 = Way 0,1,2,3)  (0=No, 1=Invalidate)
  16-31 Reserved SBZ
```

Allows to invalidate the tag RAMs on a per CPU and per way basis. This
operation is atomic, that is, a write transfer to this address only terminates
when all the lines have been invalidated. This register reads as 0.

Uh, what is a "way"?



## 17E00010h - Performance Monitor Control Register (R/W)


```
  0      Enable bit for all counters     (0=Disable, 1=Enable)
  1      Reset all count registers       (0=No, 1=Reset)
  2-7    Reserved SBZ
  8-15   Counter MN0..7 Interrupt Enable (0=Disable, 1=Enable)
  16-23  Counter MN0..7 Interrupt Flag (0=No, 1=Overflow/IRQ) ;write 1 to clear
  24-31  Reserved SBZ/RAZ
```



## 17E00014h - SCU Monitor Counter Events 0, bit0-31 (R/W)



## 17E00018h - SCU Monitor Counter Events 1, bit32-63 (R/W)


```
  0-7     EvCount0  Identifies the event for counter MN0
  8-15    EvCount1  Identifies the event for counter MN1
  16-23   EvCount2  Identifies the event for counter MN2 (if any)
  24-31   EvCount3  Identifies the event for counter MN3 (if any)
  48-55   EvCount6  Identifies the event for counter MN6 (if any)
  56-63   EvCount7  Identifies the event for counter MN7 (if any)
  32-39   EvCount4  Identifies the event for counter MN4 (if any)
  40-47   EvCount5  Identifies the event for counter MN5 (if any)
```

Event source number definitions:

```
  00h     Counter disabled
  01h     CPU0 Miss  ;\
  02h     CPU1 Miss  ; CPUn requested a coherent linefill that misses in all
  03h     CPU2 Miss  ; other CPUs. The request is sent to external memory
  04h     CPU3 Miss  ;/
  05h     CPU0 Hit   ;\
  06h     CPU1 Hit   ; CPUn requested a coherent linefill that hits in another
  07h     CPU2 Hit   ; CPU. The linefill is fetched from the relevant CPU cache
  08h     CPU3 Hit   ;/
  09h     CPU0 Error ;\
  0Ah     CPU1 Error ; CPUn was expected to have a coherent
  0Bh     CPU2 Error ; line in its cache but answers nonpresent.
  0Ch     CPU3 Error ;/
  0Dh     Line migration  ;-A line is directly transferred from one
                          ;  CPU to another on a linefill request instead of
                          ;  switching to SHARED.
  0Eh     Master0 Read port busy
  0Fh     Master1 Read port busy
  10h     Master0 Write port busy
  11h     Master1 Write port busy
  12h     A Read transfer is sent to the external memory
  13h     A Write transfer is sent to the external memory
  14h-1Eh N/A
  1Fh     CycleCount   ;-The counter increments on each CPU clock cycle
  20h-FFh N/A
```



## 17E0001Ch - SCU Monitor Counter MN0 (R/W) ;exists always



## 17E00020h - SCU Monitor Counter MN1 (R/W) ;exists always



## 17E00024h - SCU Monitor Counter MN2 (R/W) ;exists only for two or more CPUs



## 17E00028h - SCU Monitor Counter MN3 (R/W) ;exists only for two or more CPUs



## 17E0002Ch - SCU Monitor Counter MN4 (R/W) ;exists only for three or more CPUs



## 17E00030h - SCU Monitor Counter MN5 (R/W) ;exists only for three or more CPUs



## 17E00034h - SCU Monitor Counter MN6 (R/W) ;exists only for four CPUs



## 17E00038h - SCU Monitor Counter MN7 (R/W) ;exists only for four CPUs


```
  0-31  Counter (incrementing upon selected event)
```

New3DS has eight counters (even in Old3DS mode).




# <a name="arm11mpcoretimerandwatchdog"></a>ARM11 MPCore - Timer and Watchdog




## Timer and Watchdog


Below registers are for the LOCAL CPU core (the other CPU cores have their own
registers, mapped at the same address).



## 17E00600h - MPCore Timer0 Reload Value (R/W)



## 17E00620h - MPCore Timer1/Watchdog Reload Value (R/W)


```
  0-31  Reload Value
```

The Reload value is copied to the Counter in two situations:

1) When the Counter decrements to zero (with Auto-reload enabled).

2) When writing to the Reload register (in watchdog mode this is the only way
to refresh the watchdog, and to prevent it from resetting the CPU).



## 17E00604h - MPCore Timer0 Counter Value (R/W)



## 17E00624h - MPCore Timer1/Watchdog Counter Value (R/W) (R in watchdog mode)


```
  0-31  Counter Value (decrementing)
```

If the MP11 CPU belonging to the timer is in debug state, the counter does not
decrement until the MP11 CPU returns to non debug state.



## 17E00608h - MPCore Timer0 Control Register (R/W)



## 17E00628h - MPCore Timer1/Watchdog Control Register (R/W)


```
  0     Timer Enable     (0=Stop, 1=Enable/Decrement)
  1     Auto-reload      (0=One-shot, stop at zero, 1=Auto-reload at zero)
  2     Interrupt Enable (0=Disable, 1=Trigger Interrupt ID 29/30 at zero)
  3     Timer0: Reserved      (0=Timer, fixed, always 0) (R)
  3     Timer1: Watchdog mode (0=Timer, 1=Watchdog)      (R or R/W)
          Note: Bit3 can be cleared via 17E00634h only
  4-7   Reserved (0)
  8-15  Prescaler (0..255 = CPU_CLK/2 divided by 1..256)
  16-31 Reserved (0)
```



## 17E0060Ch - MPCore Timer0 Interrupt Status (R/ack)



## 17E0062Ch - MPCore Timer1/Watchdog Interrupt Status (R/ack)


```
  0     Event flag (counter reached zero)  (0=No, 1=Event)  ;write 1 to clear
  1-31  Reserved
```

If the timer interrupt is enabled, Interrupt ID 29/30 is set as Pending in the
Interrupt Distributor after the event flag is set.



## 17E00630h - MPCore Timer1/Watchdog Reset Sent Register (R/ack)


```
  0     Reset flag  (0=Normal, 1=Reset caused by Watchdot)  ;write 1 to clear
  1-31  Reserved
```



## 17E00634h - W - MPCore Timer1/Watchdog Disable Register


```
  0-31  Key (write 12345678h, then write 87654321h to disable watchdog)
```

Switches the watchdog back to Timer mode (ie. clears bit3 in Control Register).



## Calculating timer intervals


- The timer interval is calculated using the following equation:
    - (PRESCALER\_value+1)\*(Reload\_value+1)\*2 / CPU\_CLK\_frequency
- This equation can be used to calculate the period between two events out of
- the timers and the watchdog time-out time.

Uh, doesn't that mean that reload occurs on UNDERFLOW (not on ZERO)...?




# <a name="arm11mpcoreinterruptconfiguration"></a>ARM11 MPCore - Interrupt Configuration




## Distributed Interrupt Controller (for Interrupt Configuration)


These registers are mostly used for interrupt configuration (and for internally
maintaining an list of pending/active interrupts).

```
  -- Most of these registers exists only once (not per CPU) --
```

Except, the Priority for Software Interrupts 00h-0Fh can be configured per
LOCAL CPU. And, the Pending and Active flags do \<internally> exist for
each CPU (for Software Interrupts 00h-0Fh, they do even exists for "From each
CPU to each CPU"). However, reading the Pending/Active/Priority flags doesn't
fully represent all of the internal per-CPU states.



## 17E01000h - Interrupt Distributor Control Register (R/W)


```
  0     Global Interrupt Controller Enable    (0=Disable, 1=Enable)
  1-31  Reserved
```

If bit0=0, no interrupts at all are sent to the CPU interrupt interfaces.



## 17E01004h - Interrupt Controller Type Register (R)


```
  0-4   Number of Interrupt IDs   (0-7 = 20h,40h,60h,...,100h) (8-31=Reserved)
  5-7   Number of ARM11 CPU cores (0-3 = 1,2,3,4 CPU's)        (4-7=Reserved)
  8-31  Reserved
```

Note: Interrupt ID 00h-1Fh are internal IRQs, ID 20h-FFh are external IRQs.

On New3DS this 00000063h, 4 CPUs and 80h IRQs (even in Old3DS mode).



## 17E01100h..17E0111Fh - Interrupt Enable Set Registers (256 x 1bit) (R/W)



## 17E01180h..17E0119Fh - Interrupt Enable Clear Registers (256 x 1bit) (R/W)


```
  0-15    Interrupt 00h-0Fh (Read: Always 1=Enabled)      (Write=No effect)
  16-255  Interrupt 10h-FFh (Read: 0=Disabled, 1=Enabled) (Write: 1=Set/Clear)
```

Enable means that pending IRQs will be transmitted to the targeted CPUs.

The enable bit, when set to 0, does not prevent an edge-triggered interrupt
from becoming Pending.

The enable bit, when set to 0, does prevent a level sensitive interrupt from
becoming Pending only if asserted by the hardware pin, INT.

Note: If an interrupt is Pending or Active when its enable bit is set to 0, it
remains in its current state.



## 17E01200h..17E0121Fh - Interrupt Pending set Registers (256 x 1bit) (R/W)



## 17E01280h..17E0129Fh - Interrupt Pending clear Registers (256 x 1bit) (R/W)


```
  0-15   Interrupt 00h-0Fh pending on local CPU (0=No, 1=Pending) (W=??)
  16-31  Interrupt 10h-1Fh pending on local CPU (0=No, 1=Pending) (W=?)
  32-255 Interrupt 20h-FFh pending on CPU(s)??  (0=No, 1=Pending) (W=Set/Clr)
 Bit0-31:   Reading returns 1 if pending on local CPU core
 Bit32-255: Reading returns 1 if pending on one or more ANY CPU cores
             (if it's pending on the LOCAL CPU can be seen only once when
             reading the Acknowledge register?)
             (the Enable and Target bits do also somewhat imply whether
             the interrupt could have become pending on local CPU)
 Bit0-15:   Write/Set is ignored (use 17E01F00h Software Interrupt instead)
 Bit16-31:  Write/Set is...?
 Bit32-255: Write/Set allows to force the state=1 for ALL TARGET CPU cores
 Bit0-15:   Write/Clear is...?
 Bit16-31:  Write/Clear is...?
 Bit32-255: Write/Clear allows to force the state=0 for ALL CPU cores
```



## 17E01300h..17E0131Fh - Active Bit Registers (256 x 1bit) (R)


```
  0-31   Interrupt 00h-1Fh is active on local CPU        (0=No, 1=Active)
  32-255 Interrupt 20h-FFh is active on one or more CPUs (0=No, 1=Active)
```

Active means that the interrupt is being processed on at least one MP11 CPU.



## 17E01400h..17E014FFh - Interrupt Priority Registers (256 x 8bit) (R/W)


The priority determines which interrupt will show up next in the interrupt
interface registers. And, the interface registers can be used to manually
disable lower priority interrupts during 'critical sections'. And, while
processing an interrupt, the hardware will automatically disable interrupts
with same or lower priority (optionally, the "Binary Point" feature allows to
ignore the LSBs of the priorioty, eg. ignoring the lowest bit with allow to
also disable interrupts with slightly higher priority).

```
  0-127     Interrupt 00h-0Fh Priority for local CPU (bit0-3=SBZ, bit4-7=Prio)
  128-231   Interrupt 10h-1Ch Priority for what?     (bit0-3=SBZ, bit4-7=Prio)
  232-255   Interrupt 1Dh-1Fh Priority for local CPU (bit0-3=SBZ, bit4-7=Prio)
  256-2047  Interrupt 20h-FFh Priority for all CPUs  (bit0-3=SBZ, bit4-7=Prio)
```

Priority values are 00h=Highest... E0h=Lowest, or F0h=None (same as interrupt
disabled).

When multiple Pending interrupts have the same priority, the selected interrupt
is the one with lowest ID. If there are multiple Pending software interrupts
with the same ID, the lowest MP11 CPU source is selected.



## 17E01800h..17E018FFh - Interrupt CPU Targets Registers (256 x 8bit) (R/W)


These registers store the list of MP11 CPUs for which an interrupt can be
Pending. Interrupt target registers are ignored in cases of software triggered
interrupts.

```
  0-231     Interrupt 00h-1Ch Target (fixed 00h) (see 17E01F00h instead)  (-)
  232-255   Interrupt 1Dh-1Fh Target (fixed 01h/02h/04h/08h for CPU0..3)  (R)
  256-2047  Interrupt 20h-FFh Target (bit0-3=CPU0..3, bit4-7=SBZ)       (R/W)
```

Modifying a CPU target list has no influence on a Pending or Active interrupt,
but takes effect on a subsequent assertion of the interrupt.



## 17E01C00h..17E01C3Fh - Interrupt Configuration Registers (256 x 2bit) (R/W)


Interrupt Configuration Registers define the assertion condition and the
software model of each interrupt.

```
  0-31     Interrupt 00h-0Fh Condition (can be 2,3) (always rising-edge)
  32-57    Interrupt 10h-1Ch Condition (always 0)
  58-61    Interrupt 1Dh-1Eh Condition (always 2) (always N-N, rising-edge)
  62-63    Interrupt 1Fh     Condition (always 0) (ignored, always low active)
  64-511   Interrupt 20h-FFh Condition (can be 0,1,2,3)
```

Interrupt line encodings for bits 1 and 0:

```
  00h = N-N software model, level high active
  01h = 1-N software model, level high active
  02h = N-N software model, rising edge sensitive
  03h = 1-N software model, rising edge sensitive
```

The N-N and 1-N models are relevant only if more than one CPU is configured as
Target:

```
  1-N model: An interrupt that is taken on any CPU clears the Pending status
    on all CPUs.
  N-N model: All CPUs receive the interrupt independently. The Pending status
    is cleared only for the CPU that takes it, not for the other CPUs. The N-N
    model has been deprecated in the latest interrupt controller architecture.
```

Unknown how 1-N and N-N differ for Interrupt 00h-0Fh (it's said that each CPU
has it's own pending flags for 00h-0Fh, so the model should be always "1-1").

```
  Obscure Notes:
  - With the 1-N software model, the nIRQ input is asserted on all CPUs
    configured in the CPU Targets Register. Uh, but Interrupt 1Fh is fixed?
  - If more than one of these CPUs reads the Interrupt Acknowledge Register
    at the same time, they can all acknowledge the same interrupt. The
    interrupt service routine must ensure that only one of them tries to
    process the interrupt, with the others returning after writing the ID to
    the End of Interrupt Register. Uh, does that apply to nIRQ only? Or to
    all IRQs?
```



## 17E01D00h..17E01D1Fh - Interrupt Line Level Registers (256 x 1bit) (R)


```
  0-31    Dummy line level bits for Internal IRQ 00h..1Fh (always 0)
  32-255  Interrupt line level for External IRQ 20h..FFh  (0=Low, 1=High)
```



## 17E01F00h - Software Interrupt Register (W)


```
  0-9     Interrupt ID (0..FFh? or 0..0Fh/1Fh?) (100h..1FFh=Reserved/ignored)
  10-15   SBZ
  16-19   Send the interrupt to CPU0..3 (0=No, 1=Yes) ;used only if Bit24-25=0
  20-23   SBZ
  24-25   Target list mode (0=Bit16-19, 1=Other CPUs, 2=Local CPU, 3=Reserved)
  26-31   SBZ
```

This can be used to trigger an interrupt (identified with its ID) to a list of
MP11 CPUs.




# <a name="arm11mpcoreinterrupthandling"></a>ARM11 MPCore - Interrupt Handling




## CPU Interrupt Interface Registers (for Interrupt Handling)


Below registers are for the LOCAL CPU core (the other CPU cores have their own
registers, mapped at the same address).



## 17E00100h - CPU Interface Control Register (R/W)


```
  0     Interrupt Enable for local CPU   (0=Disable, 1=Enable)
  1-31  Reserved
```

When disabled: External nIRQ input is still working (and, in that case, nIRQ
should be handled directly; without using the disabled ACK/EOI registers).



## 17E00104h - Priority Mask Register (R/W)


The priority mask is used to prevent interrupts from being sent to the MP11
CPU. The CPU Interface asserts an interrupt request to an MP11 CPU if the
priority of the highest Pending interrupt sent by the Interrupt Distributor is
strictly higher than the mask set in the Priority Mask Register.

```
  0-3  Unused SBZ
  4-7  Priority Mask value
            NOTE: This is a 4bit COMPARE value (not an AND-mask)
               0xF Interrupts with priority 0x0-0xE are not masked.
               0x0 All interrupts are masked.
  8-31 Unused SBZ
```



## 17E00108h - Binary Point Register (R/W)


The Binary Point Register is used to determime whether a new interrupt
pre-empts a currently Active one, using only part, or none of the priority
level.

```
  0-2   Binary Point (see below)
  3-31  Reserved
```

Binary point bit values assignment:

```
  03h = All bits4,5,6,7 of priority are compared for pre-emption
  04h = Only bit5,6,7   of priority are compared for pre-emption
  05h = Only bit6,7     of priority are compared for pre-emption
  06h = Only bit7       of priority is compared for pre-emption
  07h = No bits compared, no pre-emption is performed (no nested IRQs)
  00h,01h,02h = Same as 03h
```

This is related to the "Running Priority Register" (see there for details).



## 17E0010Ch - Interrupt Acknowledge (ACK) Register (R)


```
  0-9     Interrupt ID          (00h..FFh, or 3FFh=None)
  10-12   Source for ID=00h-0Fh (0..3=CPU0..3, or always 0 for ID=10h-3FFh)
  13-31   Unused (0)
```

Reading returns the ID of the next pending interrupt with highest priority, and
automatically switches the interrupt from pending state to active state
(indicating that it is being processed). The CPU should then process the
interrupt, and, thereafer, use End of Interrupt register (to indicate that
processing is done).



## 17E00110h - End of Interrupt (EOI) Register (W)


```
  0-31    Same format as Interrupt Acknowledge Register (see there)
```

Writing clears the Active flag for the corresponding interrupt, indicating that
interrupt processing is done. The written value should be same as the
(memorized) value from the Interrupt Acknowledge Register.



## 17E00114h - Running Priority Register (R)


Indicates the priority of the currently processed interrupt (the last
acknowledged and not yet completed interrupt on the local CPU core).

```
  0-3  Reserved SBZ
  4-7  Priority (0=Highest .. 14=lowest, 15=None/No interrupt being processed)
  8-31 Reserved
```

All interrupts with same or lower priority are automatically disabled until
finishing the current interrupt (by writing to End of Interrupt register).

Optionally, the "Binary Point Register" allows to ignore the priority LSB(s)
when comparing the new Interrupt's priority with the currently "Running
Priority" (for example, ignoring the lower two bits would cause an interrupt
with priority=5 to also disable slighly higher priority interrupts with
priority=6..7).



## 17E00118h - Highest Pending Interrupt Register (R)


```
  0-31    Same format as Interrupt Acknowledge Register (see there)
```

Same as Interrupt Acknowledge Register, except that reading doesn't make the
corresponding interrupt Active.

Uh, and supposedly doesn't clear its Pending state... or does it?




# <a name="arm11mpcoredistributedinterruptcontrollerblurb"></a>ARM11 MPCore Distributed Interrupt Controller (Blurb)




## 10.1.1 Distributed Interrupt Controller clock frequency


The Distributed Interrupt Controller logic is clocked at half the frequency of
the MPCore CPUs because of power and area considerations. Reducing clock speed
reduces dynamic power consumption. The lower clock speed requires less
pipelining in the design. This means that the overall impact of the reduced
clock speed on the Distributed Interrupt Controller is kept to a minimum.

Note

As a consequence, the minimum pulse width of signals driving external interrupt
lines is two CPU clock cycles.



## 10.2 Terminology - From point of view of an MP11 CPU, an interrupt can be:


```
  Inactive: An Inactive interrupt is one that is nonasserted, or which in a
    multi-processing environment has been completely processed by that MP11
    CPU but can still be either Pending or Active in some of the MP11 CPUs to
    which it is targeted, and so might not have been cleared at the interrupt
    source.
  Pending: A Pending interrupt is one that has been asserted, and for which
    processing has not started on that MP11 CPU.
  Active: An Active interrupt is one that has been started on that MP11 CPU,
    but processing is not complete.
```

An interrupt can be Pending and Active at the same time. This can happen in the
case of edge triggered interrupts, when the interrupt is asserted while the
MP11 CPU has not finished handling the first occurrence. For level-sensitive
interrupts it can only happen if software triggers it. See Interrupt
Configuration Registers, 0xC00-0xC3C on page 10-17.

```
  Pre-emption: An Active interrupt can be pre-empted when a new interrupt of
    higher priority interrupts MP11 CPU interrupt processing. For the purpose
    of this document, an Active interrupt can be running if it is actually
    being processed, or pre-empted.
```

The Distributed Interrupt Controller consists of:

Interrupt Distributor:

The Interrupt Distributor handles interrupt detection and interrupt
prioritization.

CPU interrupt interfaces:

There is one CPU interrupt interface per MP11 CPU. The MP11 CPU interrupt
interfaces handle interrupt acknowledgement, interrupt masking, and interrupt
completion acknowledgement.



## 10.3 Interrupt Distributor


The Interrupt Distributor centralizes all interrupt sources for the ARM11
MPCore processor before dispatching the highest priority ones to each
individual MP11 CPU.

All interrupt sources are identified by a unique ID. All interrupt sources have
their own configurable priority and list of targeted CPUs, that is, a list of
CPUs to which the interrupt is sent when triggered by the Interrupt
Distributor.

Note

nFIQ interrupts are not handled by the Distributed Interrupt Controller so that
nFIQ interrupt input pins are directly routed to their respective CPU.

Interrupt sources are of the following types:


## Interprocessor interrupts (IPI)


Each MP11 CPU has private interrupts, ID0-ID15, that can only be triggered by
software. These interrupts are aliased so that there is no requirement for a
requesting MP11 CPU to determine its own ID when it deals with IPIs. The
priority of an IPI depends on the receiving CPU, not the sending CPU.


## Private timer and/or watchdog interrupts.


Each MP11 CPU has its own private timer and watchdog that can generate
interrupts, using ID29 and ID30.


## A legacy nIRQ pin


In legacy IRQ mode the legacy nIRQ pin, on a per CPU basis, bypasses the
Interrupt Distributor logic and directly drives interrupt requests into the
MP11 CPU. In legacy IRQ mode, if bit [0] of the CPU Interface Control Register
is 0, then no interrupts are raised based on input from the Interrupt
Distributor. If bit [0] is 1, then all interrupts are received from the
Interrupt Distributor.

When an MP11 CPU uses the Distributed Interrupt Controller (rather than the
legacy pin in the legacy mode) by enabling its own CPU interface, the legacy
nIRQ pin is treated like other interrupt lines and uses ID31.


## Hardware interrupts


Hardware interrupts are triggered by programmable events on associated
interrupt input lines. MP11 CPUs can support up to 224 interrupt input lines.
The interrupt input lines can be configured to be edge sensitive (posedge) or
level sensitive (high level). Hardware interrupts start at ID32.



## 10.3.1 Interrupt Distributor overview


The Interrupt Distributor holds the list of Pending interrupts for each CPU,
and then selects the highest priority interrupt before issuing it to the CPU
interface. Interrupts of equal priority are resolved by selecting the lowest
ID.

The Interrupt Distributor consists of a register-based list of interrupts,
their priorities and activation requirements (CPU targets). In addition the
state of each interrupt on each CPU is held in the associated state storage.

The prioritization logic is physically duplicated for each CPU to enable the
selection of the highest priority for each CPU.

The Interrupt Distributor holds the central list of interrupts, processors and
activation information, and is responsible for triggering software interrupts
to processors.

The CPU Interface acknowledges interrupts and changes interrupt priority masks.


The Interrupt Distributor transmits to the CPU interrupt interfaces their
highest Pending interrupt. It receives back the information that the interrupt
has been acknowledged, and can then change the status of the corresponding
interrupt. The CPU Interface also transmits End of Interrupt Information (EOI),
which enables the Interrupt Distributor to update the status of this interrupt
from Active to Inactive.

```
                    .-----------.  .------------- Core Acknowledge, and
        .---------->|  Decoder  |  |------------- End Of Interrupt (EOI)
        |           '-----------'  |------------- from CPU Interface
        |              ^       ^   |-------------
        |              |       |   |
        V              V       V   V               Top priority interrupts
     .-----------.----------.--------.---------.
  -->|           | Priority | Status |         |   .--------.------.
  -->|           | Priority | Status |         |-->| Irq.no | Prio |--> CPU0
  -->|           | Priority | Status | Priori- |   '--------'------'
  -->| Interrupt | Priority | Status | zation  |   .--------.------.
  -->| Interface | Priority | Status | and     |-->| Irq.no | Prio |--> CPU1
  -->|           | Priority | Status | Select- |   '--------'------'
  -->|           | Priority | Status | ion     |   .--------.------.
  -->|           | Priority | Status |         |-->| Irq.no | Prio |--> CPU2
  -->|           | Priority | Status |         |   '--------'------'
  -->|           | Priority | Status |         |   .--------.------.
  -->|           | Priority | Status |         |-->| Irq.no | Prio |--> CPU3
  -->|           | Priority | Status |         |   '--------'------'
     '-----------'----------'--------'---------'                    IRQ's to
                     Interrupt List                                 each CPU
```



## 10.3.2 Behavior of the Interrupt Distributor


When the Interrupt Distributor detects an interrupt assertion, it sets the
status of the interrupt for the targeted MP11 CPUs to Pending. Level-triggered
interrupts cannot be marked as Pending if they are already Active for at least
one MP11 CPU.

For each MP11 CPU the prioritization and selection block searches for the
Pending interrupt with the highest priority. This interrupt is then sent with
its priority to the CPU Interface.



The CPU Interface returns information to the Distributor when the CPU
acknowledges (Pending to Active transition) or clears an interrupt (Active to
Inactive transition). With the given interrupt ID, the Interrupt Distributor
updates the status of this interrupt according to the information sent by the
CPU Interface.

When an interrupt is triggered by the Software Interrupt Register or the
Set-pending Register, the status of that interrupt for the targeted CPU or CPUs
is set to Pending. This interrupt then has the same behavior as a hardware
interrupt. The distributor does not differentiate between software and hardware
triggered interrupts.




# <a name="armvectorfloatingpointunitvfp"></a>ARM Vector Floating-point Unit (VFP)



The VFP unit exists on 3DS ARM11.


- [ARM VFP Floating Point Registers](#armvfpfloatingpointregisters)
- [ARM VFP Floating Point Control/Status Registers](#armvfpfloatingpointcontrolstatusregisters)
- [ARM VFP Floating Point Opcode Encoding](#armvfpfloatingpointopcodeencoding)
- [ARM VFP Floating Point Maths Opcodes](#armvfpfloatingpointmathsopcodes)
- [ARM VFP Floating Point Load/Store Opcodes](#armvfpfloatingpointloadstoreopcodes)


## Floating Point


The floating point hardware is called VFPv2 (Vector Floating-point).

- ARM DDI 0100I ARM Architecture Reference Manual (for ARMv6 wirh VFPv2)
- ARM DDI 0360F ARM11 MPCore r2p0, contains more (mostly useless) VFPv2 info

The Fxxxx floating point opcodes are aliases for CP10/CP11 copressor numbers;
CP10 used for single, and CP11 for double precision instructions.




# <a name="armvfpfloatingpointregisters"></a>ARM VFP Floating Point Registers




## Floating point Registers


Registers S0-S31 can contain Single-precision float values, or 32bit Integers
(for conversion to/from float format), or a pair of two Single-precision
registers can contain one Double-precision float value.

```
  Scalar Bank       Vector bank 1       Vector bank 2       Vector bank 3
  S1:S0    D0       S9:S8    D4         S17:S16  D8         S25:S24  D12
  S2:S3    D1       S11:S10  D5         S19:S18  D9         S27:S26  D13
  S5:S4    D2       S13:S12  D6         S21:S20  D10        S29:S28  D14
  S7:S6    D3       S15:S14  D7         S23:S22  D11        S31:S30  D15
```

The VFP supports "Scalar" and "Vector" modes (and a mixed "Vector/Scalar"
mode).

The "Vector" mode can perform simultaneous operations on up to 8 singles, or up
to 4 doubles (via Vector LEN and STRIDE selected in FPSCR register).

The registers are organized in "banks", and vectors cannot cross banks (eg.
using operand S23 with LEN=3, STRIDE=2 would use registers S23,S17,S19).



## Scalar Mode, Fd=Fm \<op> Fn


The "Scalar" mode performs operations on 1 single or double. This done in any
of the following situations:

- - When FPSCR register is set to Vector LEN=1 (and STRIDE=1), or
- - When Destination is S0..S7 or D0..D3 (scalar bank), or
- - When using FCMP comparision opcodes, or
- - When using FCVT or FxxTOxx conversion opcodes, or
- - When using FMxxRxx register transfer opcodes, or
- - When using FLDxx/FSTxx load/store (whereof, FLDM/FSTM can transfer multiple
    - registers in vector-like fashion; regardless of LEN/STRIDE settings)



## Vector Mode, Fd[LEN]=Fm[LEN] \<op> Fn[LEN]


The vector mode does merely perform the selected operation on all array
elements, this is correct for cases like Vector+Vector addition, but incorrect
for Vector\*Vector multiplication (to get the final result one must manually
compute the sum of the results).

- - When FPSCR register is set to Vector LEN=2..8 (and STRIDE=1..2), and
- - When Source and Destination are S8..S31 or D4..D15 (vector banks), and
- - When using FADD, FSUB, FDIV, FCPY, FABS, FNEG, FSQRT, or FxMxx multiply



## Mixed Mode, Fd[LEN]=Fm \<op> Fn[LEN]


This allows to add/multiply/etc. all elements of a vector by a scalar value.
This is done when combining vectors operands with the following:

- - When Source operand Fm is S0..S7 or D0..D3 (scalar bank), and
- - othersise same conditions as for Vector mode



## Integer Format (S0..S31 aka I0..I31)


```
  31-0   Integer (signed or unsigned, depending on FxxTOxx opcode)
```

The VFP can't do integer maths, however, one can load/store integer values in
S0..S31, and then use the FxxTOxx opcodes to convert integers to/from float
format. The integers are always 32bit (no matter if converting Single/Double
precision float values).



## Single Precision Registers (float1.8.23) (S0..S31)


```
  31     1bit  Sign (0=Positive, 1=Negative)
  30-23  8bit  Exponent (01h..FEh=for 2^(N-7Fh), or 00h/FFh=Special)
  22-0   23bit Fraction (0..7FFFFFh)
```



## Double Precision Registers (float1.11.52) (D0..D15)


```
  63     1bit  Sign (0=Positive, 1=Negative)
  62-52  11bit Exponent (001h..7FEh=for 2^(N-3FFh), or 000h/7FFh=Special)
  51-0   52bit Fraction (0..FFFFFFFFFFFFFh)
```



## Exponent 01h..FEh (Single) or 001h..7FEh (Double):


```
  Sign * 2^(exponent-7Fh) * (1.fraction)    ;Single
  Sign * 2^(exponent-3FFh) * (1.fraction)   ;Double
```


## Exponent 00h (Single) or 000h (Double), aka Small Numbers and Zero:


```
  Sign * 2^(-7Eh) * (0.fraction)            ;Single
  Sign * 2^(-3FEh) * (0.fraction)           ;Double
  The above includes 0 being encoded as fraction=0, the sign bit is ignored
  for cases like "compare +/-0", but the sign is used for "divide by +/-0".
  Small numbers in 0.fraction format may require extra clock cycles for
  counting leading zeroes; unknown if that problem does actually exist on
  ARM hardware, however, the "flush to zero" feature (see FPSCR.bit24) can
  be used to avoid that issue; 0.fraction will be then replaced by 0.000.
```


## Exponent FFh (Single) or 7FFh (Double), aka NaN's and Infinite:


```
  fraction=000000h          or 0000000000000h                 +/-Infinite
  fraction=000001h..3FFFFFh or 0000000000001h..7FFFFFFFFFFFFh +/-Signaling NaNs
  fraction=400000h          or 8000000000000h                 +/-Default NaN
  fraction=400000h..7FFFFFh or 8000000000000h..FFFFFFFFFFFFFh +/-Quite NaNs
  NaNs (Not a Number) can be used for abstract non-numeric expressions; this
  isn't useful for normal maths, but may be useful if a database contains
  entries like "Weight=UNKNOWN". If so, one may handle the NaN before passing
  it to the floating point unit, or otherwise the hardware will either trigger
  an exception (Signaling NaNs) or leave the NaN unchanged (Quite NaNs),
  eg. "UNKNOWN*2+3 = UNKNOWN", or replace it by Default NaN (if FPSCR.bit25=1).
  Different NaNs can be compared using integer comparisons, float comparisions
  of NaNs have "unordered" results (even when comparing a NaN with itself).
```



## Multiply Note


When multiplying vector\*vector, the hardware does merely multiply the
components (without computing the sum of the multiply results). To get sum, one
could use FMUL and several FADD's with different strides. Or better, for
multiple vector\*vector multiplications, use FMUL and several FMAC's with source
data rearranged as so:

```
  FMUL (X,X,X,X,X,X,X,X)*(X,X,X,X,X,X,X,X)
  FMAC (Y,Y,Y,Y,Y,Y,Y,Y)*(Y,Y,Y,Y,Y,Y,Y,Y)
  FMAC (Z,Z,Z,Z,Z,Z,Z,Z)*(Z,Z,Z,Z,Z,Z,Z,Z)
  FMAC (W,W,W,W,W,W,W,W)*(W,W,W,W,W,W,W,W)
```

Ie. in that case, the 1st "vector" contains the X components from up to eight
(X,Y,Z,W) vectors.




# <a name="armvfpfloatingpointcontrolstatusregisters"></a>ARM VFP Floating Point Control/Status Registers




## FPSID Register (Floating Point System ID) (R)


```
  31-24  Implementor code (41h=ARM)
  23     Hardware/software implementation (0=Hardware, 1=Software)
  22-21  FSTMX/FLDMX format  (0=Format 1, Other=Reserved)
  20     Supported Precision (0=Single and Double, 1=Single only)
  19-16  Architecture version number (0=VFPv1, 1=VFPv2, 2-15=Reserved)
  15-8   Primary part number of VFP implementation (20h=VFP11) ;\Implementation
  7-4    Variant number                            (0Bh=MPCore); defined
  3-0    Revision number of the part               (04h=Fourth);/
```

New3DS: 410120b4h = VFPv2 D variant (with single AND double precision).



## FPSCR Register (Floating Point Status/Control Register for user-level) (R/W)


```
  31     N Flag (1=Comparision result is Less Than)
  30     Z Flag (1=Comparision result is Equal)
  29     C Flag (1=Comparision result is Equal, Greater Than, or Unordered)
  28     V Flag (1=Comparision result is Unordered)
         Note: Use FMSTAT opcode to transfer above flags to ARM CPSR flags
  27-26  Unused (0)
  25     Default Nan mode   (XXX see page C2-16) (0=Disable, 1=Enable)
  24     Flush-to-zero mode (XXX see page C2-14) (0=Disable, 1=Enable)
  23-22  Rounding mode (0=To Nearest, 1=Up, 2=Down, 3=Towards Zero)
  21-20  Vector Stride (0/3 = 1/2 Singles; or 0/3 = 1/2 Doubles) (1/2=Reserved)
  19     Unused (0)
  18-16  Vector Len    (0..7 = 1..8 Singles; or 0..3 = 1..4 Doubles)
  15     Trap Enable Input Denormal (aka Subnormal)     ;\
  14-13  Unused (0)                                     ;
  12     Trap Enable Inexact                            ; Trap Enable aka
  11     Trap Enable Underflow                          ; Exception Enable
  10     Trap Enable Overflow                           ;
  9      Trap Enable Division by Zero                   ;
  8      Trap Enable Invalid Operation                  ;/
  7      Cumulative Exception Input Denormal            ;\
  6-5    RES                                            ;
  4      Cumulative Exception Inexact                   ; Cumulative what...?
  3      Cumulative Exception Underflow                 ;
  2      Cumulative Exception Overflow                  ;
  1      Cumulative Exception Division by Zero          ;
  0      Cumulative Exception Invalid Operation         ;/
```



## FPEXC Register (Floating Point Exception Register for system-level) (R/W)


```
  31     Exception Flag ... long blurb replated to process swap code
  30     Enable Floating Point Instructions (0=Disable, 1=Enable)
  29-0   Sub-architecture defined (see below for mpcore)
 Extra mpcore bits:
  29     Unused (0)
  28     FPINST2 instruction valid flag
  27-11  Unused (0)
  10-8   VECITR Number of remaining iterations after exception (0..6=1..7, 7=0)
  7      INV Input exception flag
  6-4    Unused (0)
  3      UFC Potential Underflow Flag
  2      OFC Potential Overflow Flag
  1      Unused (0)
  0      IOC Potential invalid operation flag
```

The exception handler must clear bit31 and bit28.



## FPINST - Floating-Point Instruction Register, Privileged 0xEE000A00 (R/W)


Contains the opcode that has triggered the exception. The Cond field in
bit28-31 is changed to 0Eh (Always), and the Fd:D, Fn:N, Fm:M are changed to
indicated the fault-location within a vector (with FPEXC.bit8-10 indicating the
remaining unprocessed elements of the vector).



## FPINST2 - Floating-Point Instruction Register 2, Privileged UNP (R/W)


If FPEXC.bit28=1, then this register contains another float opcode (that was
prefetched, but not yet executed). The Cond field in bit28-31 is changed to 0Eh
(Always). The exception handler should handle the failed FPINST opcode, then
try to execute prefetched FPINST2 opcode, and then return from exception.



## MVFR0, Media and VFP Feature Register 0, Any 0x11111111 (R)


```
  31-28  VFP hardware support level when user traps are disabled
         (01h=In MPCore processors when Flush-to-Zero and Default_NaN and
         Round-to-Nearest are all selected in FPSCR, the coprocessor does not
         require support code. Otherwise floating-point support code is
         required)
  27-24  Support for short vectors           (01h=Yes)
  23-20  Support for hardware square root    (01h=Yes)
  19-16  Support for hardware divide         (01h=Yes)
  15-12  Support for software/user traps     (01h=Yes/support code is required)
  11-8   Support for double precision VFP    (01h=Yes, v2)
  7-4    Support for single precision VFP    (01h=Yes, v2)
  3-0    Support for the media register bank (01h=Yes/support 16, 64bit regs)
```



## MVFR1 - Media and VFP Feature Register 1, Any 0x00000000 (R)


```
  31-28  Reserved
  11-8   Support for media extension, single precision floating-point (00h=No)
  7-4    Support for media extension, integer instructions            (00h=No)
  3-0    Support for media extension, load/store instructions         (00h=No)
```




# <a name="armvfpfloatingpointopcodeencoding"></a>ARM VFP Floating Point Opcode Encoding




## Comparision of normal ARM copro opcodes and VFP opcodes


```
  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0|
  |_Cond__|1_1_0_0_0_1_0|L|__Rn___|__Rd___|__CP#__|_CPopc_|__CRm__| 2reg normal
  |_Cond__|1_1_0_0_0_1_0|L|__Rn___|__Rd___|__CP#__|0|0|M|1|__Fm___| 2reg on VFP
  |_Cond__|1_1_0|P|U|N|W|L|__Rn___|__CRd__|__CP#__|____Offset_____| Mem normal
  |_Cond__|1_1_0|P|U|D|W|L|__Rn___|__Fd___|__CP#__|____Offset_____| Mem on VFP
  |_Cond__|1_1_1_0|_CPopc_|__CRn__|__CRd__|__CP#__|_CP__|0|__CRm__| CDP normal
  |_Cond__|1_1_1_0|p|D|q|r|__Fn___|__Fd___|__CP#__|N|s|M|0|__Fm___| CDP on VFP
  |_Cond__|1_1_1_0|CPopc|L|__CRn__|__Rd___|__CP#__|_CP__|1|__CRm__| 1reg normal
  |_Cond__|1_1_1_0|CPopc|L|__Fn___|__Rd___|__CP#__|N|0_0|1|0_0_0_0| 1reg on VFP
```


```
  Cond             = Condition
  L                = Load/Store direction for memory/register transfers
  Fm:M, Fn:N, Fd:D = Float Registers S0..S31 (or D0..D15, with LSB=0)
  Rd, Rn           = ARM Registers
  PUW, pqrs, CPopc = Opcode bits
  CP#              = Coprocessor number (0Ah=Single-, 0Bh=Double-Precision)
  Offset           = Address step, implies number of registers for FLDM/FSTM
```




# <a name="armvfpfloatingpointmathsopcodes"></a>ARM VFP Floating Point Maths Opcodes




## VFP data-processing primary opcodes


```
  pqrs cp10/cp11                  Instruction functionality
  0000 FMAC{S|D}{cond} Fd,Fn,Fm   Fd = +(Fn*Fm)+Fd   ;Multiply, Add
  0001 FNMAC{S|D}{cond} Fd,Fn,Fm  Fd = -(Fn*Fm)+Fd   ;Multiply, Negate, Add
  0010 FMSC{S|D}{cond} Fd,Fn,Fm   Fd = +(Fn*Fm)-Fd   ;Multiply, Subtract
  0011 FNMSC{S|D}{cond} Fd,Fn,Fm  Fd = -(Fn*Fm)-Fd   ;Multiply, Negate, Sub
  0100 FMUL{S|D}{cond} Fd,Fn,Fm   Fd = +(Fn*Fm)      ;Multiply
  0101 FNMUL{S|D}{cond} Fd,Fn,Fm  Fd = -(Fn*Fm)      ;Multiply, Negate
  0110 FADD{S|D}{cond} Fd,Fn,Fm   Fd = Fn+Fm         ;Add
  0111 FSUB{S|D}{cond} Fd,Fn,Fm   Fd = Fn-Fm         ;Sub
  1000 FDIV{S|D}{cond} Fd,Fn,Fm   Fd = Fn/Fm         ;Divide
  1001 -Undefined-
  1010 -Undefined-
  1011 -Undefined-
  1100 -Undefined-
  1101 -Undefined-
  1110 -Undefined-
  1111 -Extension instructions-
```



## VFP data-processing extension opcodes


```
  Fn   N cp10/cp11                  Instruction functionality
  0000 0 FCPY{S|D}{cond} Fd,Fm      Fd = Fm        ;Copy
  0000 1 FABS{S|D}{cond} Fd,Fm      Fd = abs(Fm)   ;Absolute
  0001 0 FNEG{S|D}{cond} Fd,Fm      Fd = -Fm       ;Negate
  0001 1 FSQRT{S|D}{cond} Fd,Fm     Fd = sqrt(Fm)  ;Square root
  001x x -Undefined-
  0100 0 FCMP{S|D}{cond} Fd,Fm      Fd-Fm     ;Compare
  0100 1 FCMPE{S|D}{cond} Fd,Fm     Fd-Fm     ;Compare, exception on quiet NaNs
  0101 0 FCMPZ{S|D}{cond} Fd        Fd-0      ;Compare
  0101 1 FCMPEZ{S|D}{cond} Fd       Fd-0      ;Compare, exception on quiet NaNs
  0110 x -Undefined-
  0111 0 -Undefined-
  0111 1 FCVT{DS|SD}{cond} Fd,Fm    Single <--> Double-precision conversion
  1000 0 FUITO{S|D}{cond} Fd,Im     Unsigned integer --> float
  1000 1 FSITO{S|D}{cond} Fd,Im     Signed integer --> float
  1001 x -Undefined-
  101x x -Undefined-
  1100 0 FTOUI{S|D}{cond} Id,Fm     Float --> unsigned integer
  1100 1 FTOUIZ{S|D}{cond} Id,Fm    Float --> unsigned integer, round to zero
  1101 0 FTOSI{S|D}{cond} Id,Fm     Float --> signed integer
  1101 1 FTOSIZ{S|D}{cond} Id,Fm    Float --> signed integer, round to zero
  111x x -Undefined-
```

cp10: FCVTDS Dd,Sm  ;Double \<-- Single

cp11: FCVTSD Sd,Dm  ;Single \<-- Double



## Nocash syntax


The useless {S|D} and {DS|SD} suffixes are ommitted. FCVT is renamed to FMOV.
F{UI|SI}TO{UI|SI}{Z} is renamed to FMOV{UI|SI}{Z}, with operand I0..I31 for the
integer register.




# <a name="armvfpfloatingpointloadstoreopcodes"></a>ARM VFP Floating Point Load/Store Opcodes




## VFP single register transfer instructions


```
  cp   opcode L Instruction name   Instruction functionality
  cp10 000    0 FMSR{cond} Sn,Rd   Sn = Rd        ;\Single-Precision or Integer
  cp10 000    1 FMRS{cond} Rd,Sn   Rd = Sn        ;/
  cp10 111    0 FMXR{cond} sys,Rd  Reg(Fn,N) = Rd ;\SystemReg (FPSID, etc.)
  cp10 111    1 FMRX{cond} Rd,sys  Rd = Reg(Fn,N) ;/  ;<-- or FMSTAT{cond}
  cp11 000    0 FMDLR{cond} Dn,Rd  Dn.31-0 = Rd   ;\LSW of Double-Precision
  cp11 000    1 FMRDL{cond} Rd,Dn  Rd = Dn.31-0   ;/
  cp11 001    0 FMDHR{cond} Dn,Rd  Dn.63-32 = Rd  ;\MSW of Double-Precision
  cp11 001    1 FMRDH{cond} Rd,Dn  Rd = Dn.63-32  ;/
  other's       -Undefined-
```

System Register encodings:

```
  Fn   N  System register
  0000 0  FPSID (New3DS: 410120b4h = VFPv2 with single AND double precision)
  0001 0  FPSCR      ;(FMSTAT opcode encodes as FMRX R15,FPSCR)
  0110 0? MVFR1                       ;\mpcore only
  0111 0? MVFR0                       ;/
  1000 0  FPEXC
  1001 0? FPINST                      ;\mpcore only
  1010 0? FPINST2                     ;/
```



## VFP two register transfer instructions (VFPv2 and above)


```
  cp   L Instruction name               Instruction functionality
  cp10 0 FMSRR{cond} {Sm,Sm+1},Rd,Rn    Fm = Rn, (Fm+1) = Rd    ;XXX swapped?
  cp10 1 FMRRS{cond} Rd,Rn,{Sm,Sm+1}    Rn = Fm, Rd = (Fm+1)    ;XXX swapped?
  cp11 0 FMDRR{cond} Dm,Rd,Rn           Fm[31:0] = Rd, Fm[63:32] = Rn
  cp11 1 FMRRD{cond} Rd,Rn,Dm           Rd = Fm[31:0], Rn = Fm[63:32]
```



## VFP load and store instructions


```
  PUW  L=0/1,cp10/cp11                             Registers transferred
  000  -Two-register transfer instructions-        -
  001  -Undefined-                                 -
  010  FSTM|FLDMIA{S|D|X}{<cond>} Rn,{Fd,Fd+1,..}  Multiple Registers
  011  FSTM|FLDMIA{S|D|X}{<cond>} Rn!,{Fd,Fd+1,..} Multiple Registers Increment
  100  FST|FLD{S|D}{<cond>} Fd, [Rn{,-offs*4}]     One register, -offs
  101  FSTM|FLDMDB{S|D|X}{<cond>} Rn!,{Fd,Fd+1,..} Multiple Registers Decrement
  110  FST|FLD{S|D}{<cond>} Fd, [Rn{,+offs*4}]     One register, +offs
  111  -Undefined-                                 -
```

FSTM/FLDM do transfer multiple words (with offs containing the number of words
to be transferred, 1..32 for {S}, or an even number 2..32 for {D}.

VFP load/store multiple addressing modes

```
  Non-stacking mnemonic   Stacking mnemonic
  FLDMIA{S|D|X}           FLDMFD{S|D|X}     FPOP{S|D|X}
  FLDMDB{S|D|X}           FLDMEA{S|D|X}
  FSTMIA{S|D|X}           FSTMEA{S|D|X}
  FSTMDB{S|D|X}           FSTMFD{S|D|X}     FPUSH{S|D|X}
```



## Nocash syntax


The useless {S|D} suffixes are ommitted, the weird {X} suffix is kept used to
preserve weirdness.

Fancy {} brackets are omitted, LDM/STM must use square [Rn] brackets, the
register list in LDM/STM is specified as Fx-Fz (rather than Fx,Fy,Fz).

All FMxxxx opcodes are renamed to FMOV{LSW|MSW}.



## Weird STM/LDM{X} - for registers with unknown precision


The weird {X} mode is same as {D}, but with offset.bit0=1 (ie. with offs=3..33
instead of 2..32; and thereby actually transferring an unused dummy word).

The weird {X} mode is/was intended for registers with unknown content (eg. when
pushing/popping registers without knowing if they contain integer/single/double
precision values; which might be a problem with internal accumulators in the
VFP unit).

The weird {X} mode was declared as "deprecated in ARMv6" in DDI 0100I, but
later re-declared as required for "compatibility with future VFP
implementations" in DDI 360F. However, unknown if there are/were/will be any
such implementations that do require it.

For now, it should be best to use {D} mode instead of weird {X}. Probably even
{S} should also work the same (if the endianess-based word-order doesn't
matter).




# <a name="3dsfilesemmcpartitions"></a>3DS Files - eMMC Partitions



The 3DS can have up to eight primary NCSD partitions, some of these partitions
point to secondary MBR partition tables, each of those MBRs could have up to
four child partitions (with FAT filesystems).



## NAND structure


```
  Offset    Size      Name  _NCSD_partition_  AES Description
                            FS   crypt index  key
                            type type
  00000000h 200h                                  NCSD header
  00000000h 0B100000h       0x01 0x01  0x00   03h DSi MBR
  00004000h 200h?             -    -     -    -   Some Consoles: Dummy FAT16
  00012C00h 200h              -    -     -    11h New3DS FIRM keys
  00012E00h 08FB5200h twln                    03h DSi FAT16 File System, main
  09011A00h 020B6600h twlp                    03h DSi FAT12 File System, photo
  0B100000h 00030000h       0x04 0x02  0x01   07h AGB_FIRM GBA savegame
  0B130000h 00400000h firm0 0x03 0x02  0x02   06h Firmware partition
  0B530000h 00400000h firm1 0x03 0x02  0x03   06h Firmware partition (backup)
  0B930000h 2F5D0000h       0x01 0x02  0x04   04h Old3DS: MBR
  0B95CA00h 2F3E3600h nand                    04h Old3DS: FAT16 File System
  0B930000h 41ED0000h       0x01 0x03  0x04   05h New3DS: MBR
  0B95AE00h 41D2D200h nand                    05h New3DS: FAT16 File System
```



## Physical Size


```
  Device  eMMC Chip                Size
  2DS     Toshiba ?                3AF00000h ;\943MB   ;uh, all unknown
  Old3DS  Toshiba ?                3AF00000h ;/        ;CID and chip names?
  2DS     ?                        3B000000h ;<-- 3AF00000h and up E3h-filled?
  2DS     Samsung ?                3BA00000h ;\954MB
  Old3DS  Samsung ?                3BA00000h ;/
  2DS     Samsung ?                4D800000h ;\1240MB
  New3DS  Samsung KLM4G1YE0C-B301  4D800000h ;/
  New3DS  Samsung ?                74800000h ;-1864MB
  2DS     Toshiba ?                76000000h ;\1888MB
  New3DS  Toshiba ?                76000000h ;/
```



## Encryption


The NAND file system is encrypted using AES-CTR. The keyslot used for each
partition is determined by the NCSD partition FS type and encryption type.


NAND sectors which were never written to contain plaintext 00h or FFh bytes.


None of the NAND partitions are normally accessible from the ARM11, except for
twlp. CTR/TWL NAND FS can only be accessed when the exheader access control
descriptor for those are enabled. Normally the CTR/TWL NAND descriptors are
never enabled for retail ARM11 CXI processes. The ARM11 can only access
"nand:/rw/" mounted as the nandrw archive, and "nand:/ro/" mounted as the
nandro archive below.



## eMMC 4000h (on some consoles) (empty 00h-filled on others)


On some 3DS systems (such as 3DS XL), there's a plaintext FAT16 boot record
located at NAND offset 0x4000. This block does not exist for launch-day 3DS
systems. This is the only plaintext block for this "partition".

That is, a 200h-byte VBR sector with string FAT16 (the actual FAT, Root, and
Data sectors don't exist... and the Data clusters would probably overlap other
partitions).



## eMMC 12C00h (aka Sector 96h) (New3DS only) (empty FFh-filled on Old3DS)


```
  000h 10h   Used for generating Key X values for keyslot 15h and 18h
  010h 10h   Used for generating Key X values for keyslot 16h and 19h-1Fh ;v9.6
  020h 1E0h  Further constants (unused)
```

This 200h-byte sector contains New3DS keys, this entire sector is encrypted via
AES-ECB with a console-unique keyX+keyY. The keyX+keyY for this is generated by
the New3DS arm9bin-loader. Once the arm9bin-loader finishes decrypting this
data, the keyX+keyY in the keyslot are then cleared, then the memory used for
generating the keydata is disabled (after it finishes using it for TWL key
init).

The decrypted sector is same on all New3DS consoles (except, retail-vs-debug
are different):

```
  Decrypted 200h-bytes on Retail: 07h,29h,44h,38h, ..., 13h,63h,CFh,8Fh
  Decrypted 200h-bytes on Dev:    Unknown...
```



## 3DS CTR partition


The structure of nand/title appears to be exactly the same as SD, except
savegames are stored under the nand/data/\<ID0>/sysdata directory instead.
The sub-directory name under nand/data is the SHA256 hash over the movable.sed
keyY. This nand/data/\<ID0> directory is the NAND equivalent of the
"sdmc/Nintendo 3DS/\<ID0>/\<ID1>" directory, however the data
contained here is stored in cleartext. The movable.sed keyY is only used for
AES MACs for nand/data/\<ID0>. The nand/data/\<ID0>/extdata directory
contains the shared extdata, and is structured exactly the same way as SD
extdata.



## DSi TWL partition


The structure of these TWL partitions is mostly the same as DSi, except tickets
are stored in the CTR FAT FS. The twlp partition is exactly the same as DSi.
The structure of twln/title is exactly the same as CTR NAND/SD, except the .cmd
file is a cleartext file (this is likely a dummy file). The data directory
under system titles' /title directory does not exist, this likely only exists
for DSiWare. The directory names titleID-High used under twln/title is from
DSi.



## 3ds:\\_\_journal.nn\_ (with system attribute)


```
  00000h 12    ID "LIAFEFAS1",0,0,0  (aka 1SAFEFAIL backwards)
  0000Ch 4     Total Filesize/200h (can be C0h=18000h or E0h=1C000h)
  00010h 4     Bytes 83h,3Eh,5Ch,89h or 86h,03h,0Fh,D7h (timestamp or so?)
  00014h 4     Value 01h (whatever)
  00018h ..    Zero
  001DCh 4     Value 03h (whatever)
  001E0h 20h   Whatever (maybe SHA256 on something) (3Fh,5Ch,AEh,20h,..)
  00200h 4     Value 06h (whatever)
  00204h 1F4h  Zero
  00400h 200h  Some FAT Directory sector with short filenames
  00600h 200h  Some FAT Allocation sector with FAT16 entries
  00800h 7C00h Zero
 Below can be at 08400h..17FFFh, or alternately at 04400h..1BFFFh:
  08400h 200h  Some FAT Directory sector with short filenames
  08600h 200h  Some FAT Allocation sector with FAT16 entries
  08800h F800h Random garbage, or encrypted sectors, or whatever
```

Unknown purpose, might be some debug log, or undo-info for handling incomplete
FAT writes to the 3DS partition? If so, unknown if it's important to
update/delete the journal file after manually changing FAT contents (to prevent
the OS from corrupting/undoing the manual changes).

Unknown if there is a list of sector numbers for the 200h-byte sectors (maybe
that list exists, but gets zerofilled after completion?), unknown why there are
only short filenames (normally there should be also long/lowercase names).




# <a name="3dsfilesncsdformat"></a>3DS Files - NCSD Format



NCSD format is used for internal eMMC storage & for 3DS ROM cartridges. The
NCSD can contain up to 8 partitions.

- For eMMC, the partitions are:
  - Part Type     Content
  - 0    MBR      DSi MBR (with two FAT filesystems, FAT16+FAT12)
  - 1    GBA-SAVE GBA savegame (temporary storage, used on power-off in GBA mode)
  - 2    FIRM     Firmware partition (firm0)
  - 3    FIRM     Firmware partition (firm1) (backup copy, same as above)
  - 4    MBR      3DS MBR (with one FAT filesystem, FAT16)
  - 5-7  -        Unused
- For 3DS ROM Cartridges (aka CCI images), the partitions are:
  - Part Type     Content
  - 0    NCCH     Executable Content (CXI)
  - 1    NCCH     E-Manual (CFA)
  - 2    NCCH     Download Play Child container (CFA) (if any)
  - 3-5  -        Unused
  - 6    NCCH     New3DS System Update Data (CFA) (if any) ;\aka firmware updates
  - 7    NCCH     Old3DS System Update Data (CFA)          ;/



## Blurb


There are two known specialisations of the NCSD container format:

```
  - The CTR Cart Image (CCI) format (CCI is the format of game ROM images)
  - The 3DS' raw NAND format
```

CTR System Update (CSU) is a variant of CCI, where the only difference is in
the file extension (uh, that is the file extension of a ROM-image that needs to
be copied to a dev flashcard or so?). This is used with developer System
Updates and associated Tools.

The format of partitions can be determined from the partition FS flags
(normally these are zero for CCI/CSU NCSD Images) (uh, what/where is "FS
flags"?).



## NCSD header


```
  000h 100h    RSA-2048 SHA-256 signature of the NCSD header (including MBR!)
  100h 4       ID "NCSD"
  104h 4       Size of the NCSD image (in media units)
  108h 8  ?    Media ID
  110h 8*1     Partitions Type  (0=NCCH or Unused, 1=MBR, 3=FIRM, 4=GBA-SAVE)
  118h 8*1     Partitions Crypt (0=NCCH or Unused, 1=DSi, 2=3DS, 3=New3DS)
  120h 8*(4+4) Partitions Offset & Size (in media units)
 For eMMC:
  160h 25h Zerofilled
  185h 1   Unknown (04h)
  186h 6   Zerofilled
  18Ch 1   Unknown (01h)
  18Dh 1   Zero
  18Eh 1   Media Unit Size (200h SHL N) (usually 00h, aka 200h-bytes)
  18Fh 2Fh Zerofilled (unencrypted, despite of below)
  1BEh 42h Encrypted MBR partition-table, for the two DSi partitions
             (key-data used for this keyslot is console-unique).
 For ROM carts:
  160h 20h Exheader SHA-256 hash (uh, really?)                     (usually 0)
  180h 4   Additional header size (uh, does that mean "Exheader"?) (usually 0)
  184h 4   Sector zero offset (whatever, in whatever units, usually 0)
  188h ..  Partition Flags (uh, why called "flags" and why "partition"?)
  188h 1   Backup Write Wait Time (The time to wait to write save to backup
             after the card is recognized (0-255 seconds)). NATIVE_FIRM loads
             this flag from the gamecard NCSD header starting with 6.0.0-11.
  189h 1   unknown, maybe related to below "Save Crypto"?
  18Ah 1   unknown, ?
  18Bh 1   Media Card Device (1=NOR Flash, 2=None, 3=BT) (SDK 3.X+)
  18Ch 1   Media Platform Index (1=CTR)
  18Dh 1   Media Type Index (0=InnerDevice, 1=Card1, 2=Card2, 3=ExtendedDevice)
  18Eh 1   Media Unit Size (200h SHL N)
  18Fh 1   Media Card Device (1=NOR Flash, 2=None, 3=BT) (Only SDK 2.X)
  190h 40h Partition ID table (8x8 bytes)
  1D0h 20h Reserved
  1F0h 0Eh Reserved?
  1FEh 1   Support for this was implemented with 9.6.0-X FIRM.
             Bit0=1 enables using bits 1-2, it's unknown what these two
             bits are actually used for (the value of these two bits get
             compared with some other value during NCSD
             verification/loading).
             This appears to enable a new, likely hardware-based,
             antipiracy check on cartridges.
  1FFh 1   Support for this was implemented with 9.6.0-X FIRM, see below
             regarding save crypto.
```



## NCSD Signature


The RSA pubk used for gamecard NCSD is stored in ITCM (what/wherefrom?).

The RSA pubk used for NAND NCSD is stored in "Process9 .(ro)data instead of
ITCM". Uh, shouldn't that key (also?) be in bootrom?



## Partition Flags (In Terms of Save Crypto Determination) (uh, Save what?)


Note: Byte 01h,03h,07h do probably refer to NCSD[189h,18Bh,18Fh].

Note: flag[1,3,7] do probably ALSO refer to NCSD[189h,18Bh,18Fh].

Note: partitionflag[1,3,7] do MAYBE ALSO refer to NCSD[189h,18Bh,18Fh]?

```
  Byte   Description
  01h    Starting with 6.0.0-11 NATIVE_FIRM will use this flag to determine
           the gamecard savegame keyY method, when flag[3] is set.
           00h = 2.0.0-2 hashed keyY,
           01h = new keyY method implemented with 6.0.0-11.
           0Ah = implemented with 9.3.0-X. On Old3DS this is identical to
             the 2.2.0-4 crypto. On New3DS this is identical to the 2.2.0-4
             crypto, except with New3DS-only gamecard savedata keyslots.
```

Starting with 9.6.0-X FIRM, Process9 now sets \<savecrypto\_stateval> to
partitionflag[1] + \<the u8 value from NCSD+0x1FF>, instead of just
setting it to partitionflag[1].

```
  03h    Support for this flag was implemented in NATIVE_FIRM with 2.0.0-2.
           When this flag is set the hashed gamecard savegame keyY method is
           used, this likely still uses the repeating-CTR however.
           With 6.0.0-11 the system will determine the gamecard savegame keyY
           method via flag[1], instead of just using the hashed keyY via this
           flag.
  07h    This flag enables using the hashed gamecard savegame keyY method,
           support for this flag was implemented in NATIVE_FIRM with 2.2.0-4.
           All games with the NCSD image finalized since 2.2.0-4 (and contains
           2.2.0-4+ in the system update partition) have this flag set, this
           flag also enables using new CTR method as well.
```

Starting with 9.6.0-X FIRM, Process9 will just write val0 to a state field then
return 0, instead of returning an error when the save crypto type isn't
recognized. This was the \*only\* actual functionality change in the Old3DS
Process9 function for gamecard savedata crypto init.



## Card Info Header - uh, maybe this is the "Exheader" aka "Additional header"?


```
  Offset Size  Description
  200h   4     CARD2: Writable Address In Media Units (For 'On-Chip' Savedata)
               CARD1: Always FFFFFFFFh.
  204h   4     Card Info Bitmask
  208h   108h? Reserved1
  300h   4     Unknown (1DD7AA00h)
  ...    ..
  310h   2     Title version
  312h   2     Card revision
  ...    ..
  320h   8     Title ID for CVer USA (000400db00017202h) (even so in JPN cart)
  328h   ?     Unknown (1022h)
  208h?? CEEh? Reserved2
  1000h  10h   Card seed AES-KeyY (first u64 is Media ID (same as first NCCH
                 partitionId))
  1010h  10h   Encrypted card seed (AES-CCM, keyslot 3Bh for retail cards,
                 see CTRCARD_SECSEED)
  1020h  10h   Card seed AES-MAC
  1030h  0Ch   Card seed AES-IV
  103Ch  C4h   Reserved3
  1100h  100h  Copy of first NCCH header (excluding RSA signature)
 Development Card Info Header Extension:
 Unknown how to read from 1200h..3FFFh. When trying to do so on retail card:
 Encrypted read (cmd BFh) does merely return random garbage at 1200h..3FFFh.
 Unencrypted read (cmd 82h) can read from 1000h only (though MAYBE it can
 read MULTIPLE blocks from 1000h upwards?)
 Below says something about NTR cmd 90h or CTR cmd 90h or A2h, but that
 refers to getting the 32bit Chip ID, not to header data at 1200h and up.
  1200h  200h  CardDeviceReserved1
  1400h  10h   TitleKey (whever that is... something alike as in tickets?)
  1410h  F0h   CardDeviceReserved2
```

Note that a particular(=which?) flashcard vendor puts what many(=who?) refer to
as "private headers"(=what?) here in place of actual development card
information. This(=which?) header is constituted(=whut?) by a cartridge-unique
Id obtained from pxi:ps9::GetRomId(=what?) and the title-unique cart ID
(identical for all carts of the same title; can be retrieved using the NTR
gamecard protocol command 90h or through the CTR protocol commands 90h or A2h)
(uh, actually, that is the Chip ID, not a "title-unique cart ID" thing).



## Tools


ctrtool - (CMD) (Windows/Linux) Parsing NCSD files

3DSExplorer - (GUI) (Windows Only) Parsing NCSD files




# <a name="3dsfilesfirmformat"></a>3DS Files - FIRM Format



File format for the 3DS' Firmware, it contains up to four 'sections' of data
comprising the ARM9 and ARM11 kernels, and some fundamental processes.

The firmware sections are not encrypted.


The ARM9 section contains the ARM9 kernel (and loader) and the Process9 NCCH
(which is the only process run in user mode on the ARM9). The ARM11 sections
contain the ARM11 kernel (and loader), and various ARM11 process NCCHs. For
NATIVE\_FIRM/SAFE\_MODE\_FIRM these ARM11 processes are sm, fs, pm, loader, and
pxi. Normally the 4th section is not used. The code loaded from FIRM is
constantly running on the system until another FIRM is launched. The ARM11
kernel is hard-coded to always decompress the ExeFS .code of embedded ARM11
NCCHs without checking the exheader compression bit.


FIRM Format can exist in two locations:

```
  As raw eMMC sectors (defined in the NCSD Header of the eMMC storage)
  As .firm files (in NCCH .app files, in the "\title\00040138" firmware folder)
```

And, in Wifi-Flash and NTRCARDs (that's both only for repair/unbricking).



## FIRM Header


```
  000h  4       ID "FIRM"
  004h  4       Boot priority (0=Normal/Lowest)
  008h  4       ARM11 Entrypoint (usually 1FFxxxxxh, aka AXI WRAM.. or DSP?)
  00Ch  4       ARM9 Entrypoint  (usually 080xxxxxh, aka ARM9-only RAM)
  010h  30h     Reserved (0)
  040h  30h     Firmware Section Header 1 (usually several NCCH's with ExeFS)
  070h  30h     Firmware Section Header 2 (usually ARM11 code)
  0A0h  30h     Firmware Section Header 3 (usually ARM9 code & Process9 NCCH)
  0D0h  30h     Firmware Section Header 4 (often unused, zerofilled)
  100h  100h    RSA-2048 SHA-256 signature of the FIRM header
```

The RSA signature is checked when bootrom/Process9 are doing FIRM-launch (with
the public key being hardcoded in each). The signature is not checked when
installing FIRM to the NAND firm0/firm1 partitions.



## Firmware Section Headers


```
  000h  4       Byte offset      (relative to begin of FIRM header)
  004h  4       Physical address where the section is loaded to
  008h  4       Byte-size    (or 0=None)
  00Ch  4       Copy-method (0=NDMA, 1=XDMA, 2=CPU mem-copy)
                            (0=ARM9/WRAM, 1=ARM11/AXI/VRAM, 2=?)
  010h  20h     SHA-256 Hash of Firmware Section
```

Note on Copy-method: Process9 ignores this field. Boot9 doesn't immediately
throw an error when this isn't 0..2. In that case it will jump over
section-data-loading which then results in the hash verification with the below
hash being done with the hash already stored in the SHA hardware.



## FIRM Load Areas


Common Load areas are:

```
  08006000h 0.9M  ARM9-WRAM  (common for ARM9 code) (not first/last some bytes)
  18000000h 6.0M  VRAM       (eg. used by GBA/DSi firmwares)
  1FF00000h 0.5M  DSP Memory (eg. used by FIRM0)
  1FF80000h 0.5M  AXI RAM    (common for ARM11 code)
```

With that areas, a FIRM file can be max 7.9Mbyte (if it is loaded as file, the
default size of the firm0/firm1 partitions is only 4Mbyte each).

There is a blacklist in bootrom preventing some memory regions:

```
  07FFB800h..07FFFBFFh  ARM9 ITCM part (otp, mbr, keys...)
  FFF00000h..FFF02FFFh  ARM9 DTCM (first 3000h) (arm9 data)
  FFF03000h..FFF03FFFh  ARM9 DTCM (last 1000h) (arm9 stack)
  080F8000h..080FFFFFh  ARM9 WRAM (last 8000h) (rom card related?)
  08000000h..0800003Fh  ARM9 WRAM (first 40h) (exception vectors, etc)
  20000000h..27FFFFFFh  FCRAM (whole 128MB)
  FFF00000h..1FFFFFFFh  Bugged (size of that area is negative/nonsense)
```

Moreover, the bootrom doesn't have Main RAM and New3DS memory enabled. And, the
bootrom PU has also disabled some memory areas (though those might pass when
using DMA for loading?).




# <a name="3dsfilesfirmencryption"></a>3DS Files - FIRM Encryption



FIRMs are more or less unencrypted, except that they are stored in encrypted
memory:

- - FIRM bootcode is stored in an encrypted partition (with the usual eMMC
    - encryption; using a different keyslot than FAT partitions though)
- - FIRMs for GBA/DSi/SafeMode are stored in NCCHs files (with the eMMC
    - filesystem encryption; and usually with NCCH[18Fh].bit2=1, ie. no further
    - encryption in NCCH ExeFS)

Apart from that, FIRMs are having a RSA signature (which can be broken via
sighax).



## Self-decrypting New3DS FIRMs


New3DS FIRMs are containing self-decrypting ARM9 code (there is no requirement
to do that in homebrew FIRMs, it's basically a nag feature, making it slightly
more difficult to disassemble or patch the official FIRMs).

The ARM9 block (the FIRM section with the ARM9 entrypoint) looks as so:

```
  000h 10h  Encrypted Key_15h_x (same for all FIRM's)
  010h 10h  AES-CTR Key Y   ;\for decrypting the code at 800h and up
  020h 10h  AES-CTR IV      ;/(these are different in each FIRM version)
  030h 8    Size of encrypted binary as decimal ASCII string (eg. "546048",0,0)
  038h 8    Padding (FFh-filled)
  040h 10h  Encrypted zeroes (won't boot if decrypted data is nonzero)
  050h 7B0h Padding (FFh-filled)                        ;-before version 9.5.0
  050h 10h  Some kind of unused debug info              ;\
  060h 10h  Encrypted Key_16h_x                         ; version 9.5.0 and up
  070h 790h Padding (00h-filled)                        ;/
  800h ..   Encrypted ARM9-binary (size as from [030h], eg. 546048 bytes)
  ...  ..   Code: Unencrypted ARM9 bootstub
  ...  10h  Data: Seed value for key 18h..1Fh       (eg. A4h,8Dh,E4h,F1h,..)
  ...  10h  Data: Key_15h_y (for encrypted zeroes)  (eg. 25h,91h,2Ah,C1h,..)
  ...  4    Data: Entrypoint to decrypted ARM9 code (eg. 08xxxxxxh)
  ...  1+3  Data: Some flag byte (initially zero, and FFh-filled padding)
  ...  ..   Padding to 200h-byte boundary (zerofilled)
  NOTE: Later FIRMs do reportedly have another Seed value for key 19h-1Fh,
  which is probably inserted somewhere(?) in the above data area.
```

Alongsides with the keys stored at begin & end of the above ARM9 block, the
decryption code use two more sources:

```
  SHA256 computed across first 90h bytes of encrypted OTP memory
  Data read from eMMC address 12C00h (aka eMMC sector number 96h)
```

Aside from doing the self-decryption, the bootstub does additionally initialize
keyslots 15h, 16h, and 18h..1Fh (some of those are being used elsewhere).



## New3DS FIRM Self-decryption and Key Init


```
  sha256(dst=sha_otp, src=10012000h, srclen=90h)             ;\load key
  key_11h_x = sha_otp[00h..0Fh]                              ; sector and
  key_11h_y = sha_otp[10h..1Fh]                              ; decrypt it
  Read_eMMC(dst=mmc_buf, src=12C00h, len=200h)               ; via OTP
  Decrypt_AES_ECB(key=11h, srcdst=mmc_buf, len=200h)         ;/
  key_11h_normal = mmc_buf[000h..00Fh]
  seed = const(A4h,8Dh,E4h,F1h,..)  ;from firm9+xxx          ;\
  AES_ECB_Decrypt(key=11h, dst=temp, src=seed, len=10h)      ; key 18h
  key_18h_x = temp[00h..0Fh]                                 ;/
  Decrypt_AES_ECB(key=11h, dst=temp, src=firm9+00h, len=10h) ;\
  key_15h_x = temp[00h..0Fh]                                 ;
  key_16h_x = temp[00h..0Fh]                                 ; key 15h/16h
  if ver>=v9.6 then key_11h_normal = mmc_buf[010h..01Fh]     ;
  Decrypt_AES_ECB(key=11h, dst=temp, src=firm9+60h, len=10h) ;
  if ver>=v9.5 then key_16h_x = temp[00h..0Fh]               ;/
  BigEndianIncrement(seed)                                   ;\
  if ver>=v9.6 then seed=OtherConst(??)  ;XXX unknown        ;
  for i=19h to 1Fh                                           ; key 19h-1Fh
    AES_ECB_Decrypt(key=11h, dst=temp, src=seed, len=10h)    ;
    key_(i)_x = temp[00h..0Fh]                               ;
    BigEndianIncrement(seed)                                 ;/
  key_16h_y = firm9+10h                                      ;\
  aes_iv = firm9+20h                                         ; decrypt
  size=asc2bin(firm9+30h)                                    ; firm code
  Decrypt_AES_CTR(key=16h, src=dst=firm9+800h, len=size)     ;/
  key_15h_y = const(25h,91h,2Ah,C1h,..)  ;from firm9+xxx     ;\verify
  Decrypt_AES_ECB(key=15h, dst=temp, src=firm9+40h, len=10h) ; zeroes
  if temp[00h..0Fh]<>0 then error                            ;/
```

As shown above, there are three revisions (v8.1 being the original New3DS
firmware, and small changes made in v9.5 and v9.6). The versions before v9.5
didn't actually touch keyslot 16h (the key\_16h\_x/y values shown above were
written to keyslot 15h). The versions before v9.6 did produce other keys for
keyslot 19h-1Fh (but they were never used, so one will only need the newer v9.6
values; which require finding a yet unknown seed value though).



## Terror


Caution: The FIRM key init description on 3dbrew FIRM page is incomplete,
confusing, irrelevant, and simply mind blowing (the description won't make any
sense at all without simultaneously looking at the disassembled firmware code;
or perhaps looking at above pseudo code).




# <a name="3dsfilesfirmversions"></a>3DS Files - FIRM Versions




## New3DS ARM9 kernel - weird blurb


The only actual code-difference for the Old3DS/New3DS ARM9-kernels' crt0,
besides TWL AES / 10012000h (=OTP?) related code, is that the New3DS
ARM9-kernel writes 1 to REG\_EXTMEMCNT9 (=CFG9\_EXTMEMCNT9?) in the crt0 (unknown
what crt0 means, elsewhere it's said that "0xffff8000 is crt0", although that
does actually more look like a ROM address).



## New3DS Process9


The following is all of the differences for Old3DS/New3DS Process9 with
9.3.0-X:

The FIRM-launch code called at the end of the New3DS proc9 main() has different
mem-range checks.

In the New3DS proc9, the v6.0/v7.0 keyinit function at the very beginning
(before the original code) had additional code added for setting CTRNAND
keyslot 0x5, with keydata from .data. After setting the keyY, the keyY in .data
is cleared.

In New3DS proc9, the functions for getting the gamecard crypto keyslots / NCCH
keyslot can return New3DS keyslots when New3DS flags (NCSD/NCCH) are set.

The code/data for the binary near the end of arm9mem is slightly different,
because of memory-region sizes.

The only difference in .data (besides the above code binary) is that the New3DS
proc9 has an additional 0x10-byte block for the keyslot 0x5 keyY, see above.



## Variations


There exists different official firmwares for the 3DS: The default one
(NATIVE\_FIRM) is used to run all 3DS content and boots by default, while
backwards compatibility is handled by TWL\_FIRM and AGB\_FIRM. There furthermore
is a rescue mode provided by SAFE\_MODE\_FIRM.



## NATIVE\_FIRM


NATIVE\_FIRM is the FIRM which is installed to the NAND firm partitions, which
is loaded by bootrom.

Version history:

```
  System
  version           old 3DS
                    title version   old 3DS
                   /                hex title
                  /                 contentID     Kernel/FIRM
                 /        ________/               version (old
                /        /         ______________ 3DS/new 3DS)  FIRM
               /        /         /    ________________________ ARM11-sysmodule
              /        /         /    /                         Product Code
  Factory    v0      00      2.3-0   - ;Factory FIRM, titleID 00040001-00000002
  Pre-1.0    -       -       2.23-X  - ;Referenced in v1.0 Home Menu NCCH hdr
  1.0.0-0    v432    00      2.27-0  -               ?  ?   2011?
  1.1.0-     v1472   02      2.28-0  -               -  -   2011?
  2.0.0-     v2516   09      2.29-7  -               -  -   2011?
  2.1.0-3    v3553   0B      2.30-18 0608builder     ?  ?   2011?
  2.2.0-X ?  v4595   0F      2.31-40 0909builder     ?  ?   2011?
  3.0.0-     v5647   18      2.32-15 1128builder     -  -   2011?
  4.0.0-7    v6677   1D      2.33-4  0406builder     ?  ?   2012
  4.1.0-     v7712   1F      2.34-0  0508builder     -  -   2012?
  5.0.0-11   v8758   25      2.35-6  0228builder     ?  ?   2013
  5.1.0-11   v9792   26      2.36-0  0401builder     ?  ?   2013
  6.0.0-11   v10833  29      2.37-0  0520builder     17 Jun 2013 ;Non-US: -12
  6.1.0-11   v11872  2A      2.38-0  0625builder     27 Jun 2013 ;Non-US: -12
  7.0.0-13   v12916  2E      2.39-4  1125builder     09 Dec 2013
  7.2.0-17   v13956  30      2.40-0  0404builder     12 May 2014
  8.0.0-18   v15047  37      2.44-6  0701builder     07 Jul 2014
  8.1.0-0 ?  -       -       2.45-5  -               26 Sep 2014 ;New3DS Launch
  9.0.0-20   v17120  38      2.46-0  0828builder     06 Oct 2014
  9.3.0-21   v18182  3F      2.48-3  1125builder     08 Dec 2014
  9.5.0-22   v19216  40      2.49-0  0126builder     02 Feb 2015
  9.6.0-24   v20262  49      2.50-1  0311builder     23 Mar 2015
  10.0.0-27  v21288  4B      2.50-7  0812builder     08 Sep 2015
  10.2.0-28  v22313  4C      2.50-9  1009builder     19 Oct 2015
  10.4.0-29  v23341  50      2.50-11 1224builder     18 Jan 2016
  11.0.0-33  v24368  52      2.51-0  0406builder     09 May 2016
  11.1.0-34  v25396  56      2.51-2  0805builder     13 Sep 2016
  11.2.0-35  v26432  58      2.52-0  1015builder     24 Oct 2016
  11.3.0-36  v27476  5C      2.53-0  0126builder     06 Feb 2017
  11.4.0-37  v28512  5E      2.54-0  0314builder     10 Apr 2017
  11.8.0-41  v29557  64      2.55-0  0710pseg-ciuser 30 Jul 2018
  11.12.0-44 v30593  66      2.56-0  1021pseg-ciuser 04 Nov 2019
  11.13.0-45 ?       ?       ?       ?               02 Dec 2019
```

Note: The above "builder" strings seem to be the actual Month/Day built-date.



## SAFE\_MODE\_FIRM


SAFE\_MODE is used for running the System Updater. SAFE\_MODE\_FIRM and
NATIVE\_FIRM for the initial versions are exactly the same, except for the
system core version fields.



## TWL\_FIRM


TWL\_FIRM handles DS(i) backwards compatibility.

The 3DS-mode ARM9 core seems to switch into DSi-mode (for running DSi-mode ARM9
code) by writing to a PDN register (this changes the memory layout to DSi-mode
/ etc, therefore this register poke \*must\* be executed from ITCM). This is the
final 3DS-mode register poke before the ARM9 switches into DSi-mode. DS(i)-mode
ARM7 code is run on the internal ARM7 core, which is started up during TWL\_FIRM
boot. Trying to read from the exception-vector region (address 0x0) under this
DSi-mode ARM7 seems to only return 0x00/0xFF data. Also note that this DSi-mode
ARM7 runs code (stored in TWL\_FIRM) which pokes some DSi-mode registers that on
the DSi were used for disabling access to the DSi bootROMs, however these
registers do not affect the 3DS DSi-mode ARM9/ARM7 "bootrom" region
(exceptionvector region + 0x8000) at all.


For shutting down the system, TWL\_FIRM writes MCU[20h]=08h. For returning to
3DS-mode, TWL\_FIRM writes to MCU[20h]=04h to trigger a hardware system reboot.


The TWL\_FIRM ARM11-process includes a TWL bootloader, see here(?) and here(?)
for details.


TWL\_FIRM verifies all TWL RSA padding with the following. This is different
from the DSi "BIOS" code.

The first byte must be 0x0.

The second byte must be 0x1 or 0x2.

Executes a while(\<value of byte at current pos in RSA message>). When the
second\_byte in the message is 0x1, the byte at curpos must be 0xFF (otherwise
the non-zero value of the byte at curpos doesn't matter). This loop must find a
zero byte before offset 0x7F in the message otherwise an error is returned.

Returns an address for msg\_curpos+1.


totalhashdatasize = rsasig\_bytesize - above position in the message for the
hashdata. The actual "totalhashdatasize" in the RSA message must be \<=
\<expected hashdata\_size>(0x74 for bootloader). Uh, \<=\<>()??? The
TWL\_FIRM code copies the RSA "hashdata" to the output buffer, using the actual
size of the RSA "hashdata".



## AGB\_FIRM


AGB\_FIRM handles running GBA VC titles. The ARM9 FIRM section for TWL\_FIRM and
AGB\_FIRM are exactly the same (for TWL\_FIRM and AGB\_FIRM versions which were
updated with the same system-update).




# <a name="3dsfilesfirmlaunchparameters"></a>3DS Files - FIRM Launch Parameters




## FIRM Launch Parameters


The FIRM-launch parameters structure is located at FCRAM+0, size 0x1000-bytes.
The ARM11-kernel copies this structure elsewhere, then clears the 0x1000-bytes
at FCRAM+0. It will not handle an existing structure at FCRAM+0 if CFG\_BOOTENV
is zero. The ARM9 kernel writes some values about the boot environment to AXI
WRAM during init to enable this.

Note: it seems NATIVE\_FIRM ARM11-kernel didn't parse this during boot until
3.0.0-X?

```
  000h 300h unknown/unspecified (probably as on DSi?)
  300h 100h 'TLNC' block created by TWL applications, handled by NS for
              backwards-compatibility purposes. See here for more info
  400h 4    Flags
  404h 0Ch  unknown/unspecified
  410h 0Ch  This is used for overriding the FIRM_* fields in
              Configuration_Memory, when the flag listed below is set,
              in the following order (basically just data-copy from here
              to 0x1FF80060): "FIRM_?", FIRM_VERSIONREVISION,
              FIRM_VERSIONMINOR, FIRM_VERSIONMAJOR, FIRM_SYSCOREVER,
              and FIRM_CTRSDKVERSION
  41Ch ..   unknown/unspecified
  438h 4    The kernel checks this field for value 0xFFFF, if it matches
              the kernel uses the rest of these parameter fields,
              otherwise FIRM-launch parameters fields are ignored by
              the kernel
  43Ch 4    CRC32 across [400h..53Fh] with [43Ch]=zero
              When invalid the kernel clears the entire buffer used for
              storing the FIRM-params, therefore no actual FIRM-params are
              handled after that
  440h 10h  Titleinfo Program Info, used by NS during NS startup, to
              launch the specified title when the below flag is set
  450h 10h  Titleinfo Program Info. This might be used for returning
              to the specified title, once the above launched title
              terminates?
  460h 4    Bit0: 0 = titleinfo structure isn't set,
                  1 = titleinfo structure is set
  464h ..   unknown/unspecified
  480h 20h  Can be set via buf1 for APT:SendDeliverArg/APT:StartApplication
  4A0h 10h  Can be set by NSS:SetWirelessRebootInfo
  4B0h 14h  SHA1-HMAC of the banner for TWL/NTR titles. This can be set
              by NSS:SetTWLBannerHMAC
  4C4h ..   unknown/unspecified
  500h 40h  This is used by APT:LoadSysMenuArg and APT:StoreSysMenuArg
  540h ..   unknown/unspecified
  D70h 290h Config data struct for LGY FIRM
```


Flags from offset 0x400:

```
  +00h    1       This can be used for overriding the default FCRAM
                    memory-regions allocation sizes (APPLICATION, SYSTEM, and
                    BASE). The values for this is the same as
                    Configmem-APPMEMTYPE. Values 0-1 are handled the same way
                    by the kernel. However for NS, 0=titleinfo structure for
                    launching a title isn't set, while non-zero=titleinfo
                    structure is set.
  +01h    3       Setting bit0 here enables overriding the FIRM_* fields in
                    Configuration_Memory.
```


Config struct for booting LGY FIRMs from offset 0xD70:

```
  000h 1    Config block 0x30000
  001h 1    Config block 0x70001
  002h 1    System language (Config block 0xA0002)
  003h 1    Region from SecureInfo ("pseudo-block" 0x140000 in LGY FIRM)
  004h 0Fh  Serial number from SecureInfo ("pseudo-block" 140001h in LGY FIRM)
  013h 1    Config block 0x100002
  014h 10h  Config block 0x100003
  024h 2    Config block 0x100000
  026h 1    Cleared to zero
  027h 1    Cleared to zero
  028h 94h  Config block 0x100001
  0BCh 2    Config block 0x50000
  0BEh 2    Config block 0x50001
  0C0h 38h  Config block 0x50002
  0F8h 20h  Config block 0x50004
  118h 134h Config block 0x20000
  24Ch 10h  Config block 0x40000
  25Ch 1Ch  Config block 0x40001
  278h 4    Cleared to zero
  27Ch 4    Cleared to zero
  280h 8    Config block 0x30001
  288h 2    CRC16 over the above fields from offset 0x0, size 0x288,
              if not valid, LGY FIRM uses dummy data from .(ro)data
  28Ah 2    If non-zero, the size (below) is hardcoded (currently) to
              value 0x288, otherwise the size field below is used
  28Ch 4    Value 0x288 (size used for verifying the CRC16)
```

"Cleared to zero" fields above are not read at all by LGY FIRM.




# <a name="3dsfilesncchformat"></a>3DS Files - NCCH Format




## NCCH (Nintendo Content Container Header) (in .app files)


This format is used to store the content of any installed title. There are two
NCCH variants:

```
  CXI aka CTR Executable Image, with ARM11 code
  CFA aka CTR File Archive, with data only
```

The CXI/CFA format is structured in the following order:

```
  NCCH header                                                  (unencrypted)
  Exheader (CXI only)                                          (encrypted)
  Logo (5.0.0-11 and up)                                       (unencrypted)
  SDK Strings (aka plain binary region) (optional, CXI only)   (unencrypted)
  ExeFS filesystem (optional) - ARM11 code (CXI), icon/banner  (encrypted)
  RomFS filesystem (optional) - Used for external file storage (encrypted)
```

User-executable Tools (eg. System Settings) do have two NCCH .app files: One
with the program .code, and one with the data manual. Internal System Modules
(eg. MCU driver) have only one .app file (with program .code, without manual).



## NCCH Header


```
  000h 100h RSA-2048 SHA-256 signature of the NCCH header
  100h 4    ID "NCCH"
  104h 4    Content size, in media units (1 media unit = 200h bytes)
  108h 8    Partition ID (usually same as Program ID, or weird stuff...?)
  110h 2    Maker code (3030h)
  112h 2    Version (0000h=Normal/Data?, 0001h=Weird?, 0002h=Normal/Code?)
  114h 4    SEEDDB Checksum (see NCCH Encryption chapter) (firmware 9.6.0)
  118h 8    Program ID (aka Title ID)
  120h 10h  Reserved
  130h 20h  Logo Region SHA-256 hash (5.0.0-11 and up)
  150h 10h  Product code ("CTR-x-xxxx") (for CFA: always "CTR-P-CTAP"?)
  160h 20h  Extended header SHA-256 hash (SHA256 of 2x Alignment Size... uh?)
  180h 4    Extended header size minus 400h, in bytes (usually 400h) (0=None)
  184h 4    Reserved
  188h ..   "Flags" (see below) (aka "ncchflag[0..7]")
  188h 3    Unknown (zero)
  18Bh 1    Crypto 2nd Keyslot (00h=None, 01h=Key25h, 0Ah=Key18h, 0Bh=Key1Bh)
  18Ch 1    Content Platform   (01h=CTR=3DS, 02h=Snake=New3DS)
  18Dh 1    Content Type Bit-masks: Data=0x1, Executable=0x2, SystemUpdate=0x4,
              Manual=0x8, Child=(0x4|0x8), Trial=0x10.
              When 'Data' is set, but not 'Executable', NCCH is a CFA.
              Otherwise when 'Executable' is set, NCCH is a CXI.
  18Eh 1    Content Unit Size (200h SHL N)   ;uh, NOT? same as "media units"?
  18Fh 1    Flags Bit0=FixedKey, Bit1=NoMountRomFs, Bit2=NoCrypto, Bit5=NewKeyY
  190h 4    Plain region offset, in media units
  194h 4    Plain region size, in media units
  198h 4    Logo Region offset, in media units ;\For applications built with
  19Ch 4    Logo Region size, in media units   ;/SDK 5+ (5.0.0-11 and up)
  1A0h 4    ExeFS offset, in media units
  1A4h 4    ExeFS total size, in media units
  1A8h 4    ExeFS header size, in media units (for SHA256 at [1C0h])
  1ACh 4    Reserved
  1B0h 4    RomFS offset, in media units
  1B4h 4    RomFS total size, in media units
  1B8h 4    RomFS header size, in media units (for SHA256 at [1E0h])
  1BCh 4    Reserved
  1C0h 20h  ExeFS superblock SHA-256 hash
  1E0h 20h  RomFS superblock SHA-256 hash
```

All of the hashes stored in this NCCH header are over the cleartext data.

Given offsets are based on the start of the file.



## Extended header


The extended header contains additional information regarding/restricting
access control.

- [3DS Files - NCCH Extended Header](#3dsfilesncchextendedheader)


## Logo


- [3DS Files - NCCH Logo](#3dsfilesncchlogo)


## Plain binary region (SDK strings) (CXI only)


This region contains several zero-terminated ASCII strings (usually in form
"[SDK+Blah:Blahblah]",00h).

```
  "The version used for the "FIRMWARE" tag (what?) is the kernel/FIRM
  version, this version can also be stored in the exheader "kernel release
  version" ARM11 kernel descriptor field. As of 2.2.0-X the NATIVE_FIRM
  kernels check the CXI exheader "kernel release version" field, if it is
  stored in the CXI exheader. If the kernel/FIRM version specified by this
  field is higher than the version of the running NATIVE_FIRM, the kernel
  will return error-code D9001413h."
```

Uh, all that blurb seems to say that... the SDK string is irrelevant - and if
there's anything relevant, then it's the descriptor, but not/never the SDK
string?



## ExeFS and RomFS (Filesystems)


- [3DS Files - NCCH ExeFS](#3dsfilesncchexefs)
- [3DS Files - NCCH RomFS](#3dsfilesncchromfs)
Both ExeFS and RomFS are designed as read-only filesystems (in lack of a FAT,
changing filesizes would require to relocate all following files).



## Encryption (for Exheader, ExeFS, and RomFS)


- [3DS Files - NCCH Encryption](#3dsfilesncchencryption)


## Region Locking


The region-locking info checked by home menu is stored in the "icon" file in
ExeFS.



## RSA


CFAs NCCH header signature uses a fixed RSA public key.

CXIs NCCH header signature uses the RSA public key stored in the Exheader
(whereof, that part of the Exheader is signed via another RSA key).



## Tools


ctrtool - (CMD) (Windows/Linux) Parsing and decrypting (debug only) NCCH files




# <a name="3dsfilesncchextendedheader"></a>3DS Files - NCCH Extended Header



The NCCH Exheader contains information for the .code file in the ExeFS (the
.code file itself has no file header, and contains only raw code/data).


The Exheader exists only if NCCH[180h]>0. That is, it does exist for NCCH's
with ExeFS .code file. For some reason ExeFS .firm does also have Exheader (but
unknown if it's used for anything). Whilst E-Manuals have only RomFS, without
ExeFS, and without Exheader.



## NCCH Extended Header (Exheader, at offset 200h and up)


```
  200h 200h  SCI, System Control Info
  400h 200h  ACI, Access Control Info 1
  600h 100h  RSA-SHA256 Signature across [900h..BFFh] (using key from bootrom)
  700h 100h  RSA Public Key for NCCH Header at [000h..1FFh]
  800h 200h  ACI, Access Control Info 2 (for limitation of first ACI)
```


When loading the exheader, Process9 compares the exheader data with the data in
the AccessDesc (note that not everything is compared here). When these don't
match, an error is returned. The Process9 code handling this validation was
updated with v6.0; the only change in this function seems to be the check for
the "Ideal processor" field.



## System Control Info (SCI)


```
  200h 8     Application title (default is "CtrApp") or module name (eg. "mcu")
  208h 5     Reserved
  20Dh 1     Flags (bit0=Compressed .code file, bit1=SD Application)
  20Eh 2     Remaster version
  210h 4     Text code set info Address (usually 00100000h)             ;\
  214h 4     Text code set info Size in 1000h-byte page units           ; Code
  218h 4     Text code set info Size in bytes (excluding padding)       ;/
  21Ch 4     Stack size (in bytes?) (usually 1000h)                     ;-Stack
  220h 4     Read-only code set Address (should be 1000h-page aligned)  ;\
  224h 4     Read-only code set Size in 1000h-byte page units           ; Const
  228h 4     Read-only code set Size in bytes (excluding padding)       ;/
  22Ch 4     Reserved
  230h 4     Data code set info Address (should be 1000h-page aligned)  ;\
  234h 4     Data code set info Size in 1000h-byte page units           ; Data
  238h 4     Data code set info Size in bytes (excluding padding)       ;/
  23Ch 4     BSS size (in bytes?) (usually XXXXh)                       ;-BSS
  240h 30h*8 Dependency module list (several 8-byte Title IDs)
  3C0h 8     SystemInfo SaveData Size
  3C8h 8     SystemInfo Jump ID
  3D0h 30h   SystemInfo Reserved
```

Most of these fields are used in LOADER:LoadProcess.


"On retail for SD applications, exheader\_systeminfoflags.flag bit1 must be
set."



## Access Control Info (ACI)


- ARM11 Local System Capabilities:
  - 400h 8     Program ID (same as in NCCH Header)
  - 408h 4     Core version (Title ID low of required FIRM)
  - 40Ch 2     Flag1 and Flag2 (both implemented starting from 8.0.0-18).
  - 40Eh 1     Flag0
  - 40Fh 1     Priority
  - 410h 16\*2  Resource limit descriptors ;1st byte controls max allowed CpuTime
  - 430h  8    Storage Info Extdata ID
  - 438h  8    Storage Info System savedata IDs
  - 440h  8    Storage Info Storage accessible unique IDs
  - 448h  8    Storage Info Filesystem Access Info (flags, see below)
  - 450h 32\*8  Service Access Control
  - 550h 2\*8   Extended service access control ;implemented with 9.3.0-X
  - 560h 15    Reserved
  - 56Fh 1     Resource limit category (0=APPLICATION, 1=SYS\_APPLET,
                                  - 2=LIB\_APPLET,
                                  - 3=OTHER (sysmodules running under the BASE memregion))
- ARM11 Kernel Capabilities:
  - 570h 70h   ARM11 Kernel Capability Descriptors (28x32bit)
  - 5E0h 10h   Reserved
- ARM9 Access Control:
  - 5F0h 15    ARM9 Access Control Descriptors
  - 5FFh 1     ARM9 Descriptor Version (must be 02h for original firmware,
                            - must be 02h or 03h for 9.3.0-X and up)



## Flag0


```
  Bits  Description
  0-1   Ideal processor
  2-3   Affinity mask
  4-7   Old3DS system mode:
          0    =  Prod (64MB of usable application memory)
          1    =  Undefined (unusable)
          2    =  Dev1 (96MB of usable application memory)
          3    =  Dev2 (80MB of usable application memory)
          4    =  Dev3 (72MB of usable application memory)
          5    =  Dev4 (32MB of usable application memory)
          6-7  =  Undefined Same as Prod?
          8-15 =  unknown/unspecified
```

In the exheader data, the ideal processor field is a bit-index, while in the
AccessDesc (the 2nd ACI at A00h and up) the ideal processor field is a bitmask.
When the bit specified by the exheader field is not set in the AccessDesc
field, an error is returned.

if((1 \<\< exheaderval) & accessdescval == 0) return error


During a FIRM-launch when a TitleInfo structure was specified, the field at
offset 400h in the FIRM-launch parameters is set to the SystemMode of the
specified title, however in some cases other values are written there. With
8.0.0-18 NS will now check the output of PTMSYSM command 040A0000h, when the
output is non-zero and a certain NS state field is value-zero, the following is
executed otherwise this is skipped. With that check passed on 8.0.0-18, NS will
then check (Flag2 & 0Fh). When that is value2, the output value (used for
the FIRM-launcher parameter field mentioned above) is set to value7. Otherwise,
when that value is non-zero, the output value is set to 6.



## Flag1


```
  Bits  Description
  0     EnableL2Cache (Unknown what this actually does, New3DS-only presumably)
  1     cpuspeed_804MHz (Default "cpuspeed" when not set)
  2-7   Unused
```


In order for the exheader to have any of the above new bits set, the AccessDesc
must have the corresponding bit set, otherwise the invalid-exheader error is
returned.


Homebrew which runs under a title which has the above cpuspeed flag set, runs
much faster on New3DS. It's unknown how exactly the system handles these flags.


When launching titles / perhaps other things with APT, NS uses
PTMSYSM:ConfigureNew3DSCPU with data which originally came from these flags; NS
does this regardless of what the running 3DS system is. However, due to a
bug(?) in NS the value sent to that command is always either 00h or 03h. When
calculating that value, the code only ever uses the cpuspeed field, not the
cache field: code to actually load and check the value of the cache field
appears to be missing.



## Flag2


```
  Bit     Description
  0-3     New3DS system mode:
            0    = Legacy (use Old3DS system mode)
            1    = Prod (124MB of usable application memory)
            2    = Dev1 (178MB of usable application memory)
            3    = Dev2 (124MB of usable application memory)
            4-7  = Undefined Same as Prod?
            8-15 = unknown/unspecified
  4-7     Unused
```

When in Legacy mode, the actual memory layout is the same as in New3DS Prod,
except the available application memory as reported to the application is
reduced to the Old3DS size.


The exheader value for the New3DS system mode value must be equal to the
AccessDesc value, otherwise the invalid-exheader error is returned.



## Storage Info Filesystem Access Info


```
  Bit    Description
  0      Category system application
  1      Category hardware check
  2      Category filesystem tool
  3      Debug
  4      TWL card backup
  5      TWL NAND data
  6      BOSS
  7      sdmc:/
  8      Core
  9      nand:/ro/ (Read Only)
  10     nand:/rw/
  11     nand:/ro/ (Write Access)
  12     Category system settings
  13     Cardboard
  14     Export/Import IVS
  15     sdmc:/ (Write-only)
  16     Switch cleanup (Introduced in 3.0.0?)
  17     Savedata move (Introduced in 5.0.0)
  18     Shop (Introduced in 5.0.0)
  19     Shell (Introduced in 5.0.0)
  20     Category home menu (Introduced in 6.0.0)
  21     Seed DB (Introduced in 9.6.0-X FIRM, Home Menu
                  has this bit set starting with 9.6.0-X)
  22-55  Reserved
  56     Not use RomFS
  57     Use Extended Savedata Access
  58-63  Reserved
```

When bit57 is set, the "Extdata ID" and "Storage Accessable Unique IDs" regions
are used to store a total of 6 "Accessible Save IDs". Introduced in 6.0.0.



## Service Access Control


This is the list of services which the process is allowed to access, this is
registered with the services manager. Each service listed in the exheader must
be listed in the AccessDesc, otherwise the invalid exheader error is returned.
The order of the services for exheader/AccessDesc doesn't matter. The
AccessDesc can list services which are not in the exheader, but normally the
service-access-control data for exheader/AccessDesc are exactly the same.

This list is submitted to SRVPM:RegisterProcess.



## ARM11 Kernel Capability Descriptors


The kernel capability descriptors are passed to svcCreateProcess.

There are different descriptor types, determined by the number of leading ones
in the binary value representation of bits 20-31. The different types are laid
out as follows:

```
  Bit31-20      Expl.
  1110xxxxxxxx  Interrupt info
  11110xxxxxxx  System call mask
                  Bits 24-26: System call mask table index
                  Bits 0-23: mask
  1111110xxxxx  Kernel release version
                  Bits 8-15: Major version
                  Bits 0-7: Minor version
  11111110xxxx  Handle table size
                  Bits 0-18: size
  111111110xxx  Kernel flags
                  Bit  Description
                  0    Allow debug
                  1    Force debug
                  2    Allow non-alphanum
                  3    Shared page writing
                  4    Privilege priority
                  5    Allow main() args
                  6    Shared device memory
                  7    Runnable on sleep
                  8-11 Memory type (1: application, 2: system, 3: base)
                  12   Special memory
                  13   Process has access to CPU core 2 (New3DS only)
  11111111100x  Map address range
                  Describes a memory mapping like the 111111111110
                  descriptor, but an entire range rather than a single
                  page is mapped. Another 11111111100x descriptor
                  must follow this one to denote the (exclusive) end
                  of the address range to map
  111111111110  Map memory page
                  Bits 0-19: page index to map (virtual address >> 12;
                  the physical address is determined per-page according
                  to Memory layout); Bit 20: Map read-only (otherwise
                  read-write)
```



## ARM9 Access Control Descriptors


```
  Bit     Description
  0       Mount nand:/
  1       Mount nand:/ro/ (Write Access)
  2       Mount twln:/
  3       Mount wnand:/
  4       Mount card SPI
  5       Use SDIF3
  6       Create seed
  7       Use card SPI
  8       SD application (Not checked)
  9       Mount sdmc:/ (Write Access)
```




# <a name="3dsfilesncchexefs"></a>3DS Files - NCCH ExeFS




## ExeFS Header (max 10 files)


```
  000h 10h*10  File headers for File 1..10        ;First at 000h
  0A0h 20h     Reserved
  0C0h 20h*10  SHA256 Hash for File 10..1         ;First at 1E0h
```

File hashes are stored in reverse order, i.e. the hash at offset 1E0h
corresponds to the first ExeFS section.

Each file header has a corresponding file hash, which is the SHA256 hash
calculated over the entire file contents.



## File headers


There are a maximum of 10 file headers in the ExeFS format (the maximum number
of file headers is disputable, with makerom indicating a maximum of 8 sections
and makecia indicating a maximum of 10 (uh, are homebrew tools?). From a
non-SDK point of view, the ExeFS header format can hold no more than 10 file
headers within the currently define size of 200h bytes). The file headers have
the following structure:

```
  00h 8     File name (ASCII, zeropadded) (all 00h for unused entries)
  08h 4     File offset in bytes (0=Right after the 200h-byte ExeFS Header)
  0Ch 4     File size in bytes
```

File offsets are non-inclusive of the header's size (200h bytes). Also, file
headers which are not used are filled with all zeros.

The file offsets should be 200h-byte aligned. The file size is usually 4-byte
aligned (unknown if that is actually required).



## ExeFS Files


ExeFS or Executable Filesystem contains information related to the executable
program, and is the part of the CXI format.

The ExeFS usually contains one or more of the following files:

```
  .code   Contains ARM11 code, which can be optionally
            reverse-LZSS compressed via an exheader flag.
  .firm   Contains FIRM with ARM9/ARM11 code (usually plus some NCCH's)
  logo    Contains distribution licensing Binary data
  banner  Contains the banner which homemenu uses for this CXI
  icon    Contains the icon which homemenu displays for this CXI
```

- [3DS Files - NCCH Logo](#3dsfilesncchlogo)


## .code (ARM11)


The .code file does simply contain plain code/data without any file header
(instead, the .code file's load addresses and compression flag are located in
the NCCH Exheader).

For the LZrev decompression function, see:

- [LZ Decompression Functions](#lzdecompressionfunctions)
The (decompressed) filesize should be a multiple of 1000h bytes (and the
code/const/data sections should be on 1000h-byte page boundaries, as specified
in the NCCH Exheader).



## .code (GBA)


The .code files for GBA games do reportedly contain the GBA ROM-image, with an
extra GBA Footer (with info on cartridge type and preferred LCD color scheme).
For details:

- [3DS Config - ARM7 Registers (GBA/NDS/DSi Mode)](#3dsconfigarm7registersgbandsdsimode)
Unknown if GBA games have specific entries in NCCH header/exheader.




# <a name="3dsfilesncchromfs"></a>3DS Files - NCCH RomFS




## Overall RomFS file structure


```
  00000h 5Ch     RomFS Header (see below)                          ;Header
  0005Ch 4       Padding to 20h-byte boundary (0)
  00060h 20h*N   SHA256's on the 1000h-byte block(s) at xx000h     ;Master Hash
  ...    ..      Padding to block-byte boundary (0)
  01000h ....    RomFS Directory/Files (see below)                 ;Level 3
  ...    ..      Padding to block-byte boundary (0)
  xx000h 20h*NN  SHA256's on each 1000h-byte block at yy000h and up;Level 1
  ...    ..      Padding to block-byte boundary (0)
  yy000h 20h*NNN SHA256's on each 1000h-byte block at 1000h and up ;Level 2
```



## RomFS Header (5Ch bytes)


```
  000h 8   ID "IVFC",00h,00h,01h,00h
  008h 4   Master Hash Size (eg. 20h) (aka Size of SHA256's at 00060h)
  00Ch 8   Level 1 Logical Offset             (usually 0)                    ;\
  014h 8   Level 1 Size of SHA256's at xx000h (eg. 60h aka 24A0h/1000h*20h)  ;
  01Ch 4   Level 1 Block size (1 SHL N)       (usually 0Ch=1000h)            ;/
  020h 4   Reserved (0)
  024h 8   Level 2 Logical Offset             (eg. 1000h) (Level 1 size)     ;\
  02Ch 8   Level 2 Size of SHA256's at yy000h (eg. 24A0h aka 124A20h/1000h*20h)
  034h 4   Level 2 Block size (1 SHL N)       (usually 0Ch=1000h)            ;/
  038h 4   Reserved (0)
  03Ch 8   Level 3 Logical Offset             (eg. 4000h) (Level 1+2 size)   ;\
  044h 8   Level 3 Size of Directory/File area at 001000h  (eg. 124A20h)     ;
  04Ch 4   Level 3 Block size (1 SHL N)       (usually 0Ch=1000h)            ;/
  050h 4   Reserved (0)
  054h 4   Header Size or so?                 (usually 5Ch)
  058h 4   Optional info size (uh?)           (usually 0)
  05Ch 4   unknown/padding                    (usually 0)
```

The "Logical Offsets" are completely unrelated to the physical offsets in the
RomFS partition. Instead, the "Logical Offsets" might be something about where
to map the Level 1-3 sections in virtual memory (with the physical Level 3,1,2
ordering being re-ordered to Level 1,2,3)?

The various SHA256's are similar to the "Digest" tables in DSi cart header.



## RomFS Directory/File area (aka Level 3) (usually/always? starting at 1000h)


```
  000h 4    Header Length (usually 28h)
  004h 4    Directory Hash Table Offset (usually 28h)
  008h 4    Directory Hash Table Length
  00Ch 4    Directory Table Offset (eg. 44h) (first=Root)
  010h 4    Directory Table Length
  014h 4    File Hash Table Offset
  018h 4    File Hash Table Length
  01Ch 4    File Table Offset (eg. 170h) (starting with Root)
  020h 4    File Table Length (eg. 52Ch)
  024h 4    File Data Offset (eg. 6A0h)
  028h ..   Directory Hash Table
  ..   ..   Directory Table
  ..   ..   File Hash Table
  ..   ..   File Table
  ..   ..   File Data (each file aligned to 10h-byte boundary)
```

Note: The first Directory Table entry is the Root directory. Apart from that,
there is no real requirement for the location of the other directory (and file)
table entries. However, Table entries are commonly held to be sorted
alphabetically. And, Siblings should be stored at continous table offsets (so
all entries for one directory are grouped together; that can speed up sector
loading).



## Directory Table Entries


```
  00h   4   Directory Table Offset of Parent Directory       (Self for Root)
  04h   4   Directory Table Offset of next Sibling Directory (FFFFFFFFh=None)
  08h   4   Directory Table Offset of first Child Directory  (FFFFFFFFh=None)
  0Ch   4   File Table Offset of first File                  (FFFFFFFFh=None)
  10h   4   Directory Table Offset of next Directory with same Hash
  14h   4   Name Length in bytes (ie. L=NumChars*2) (0 for Root)
  18h   L   Directory Name (16bit Unicode)
  18h+L 0/2 Alignment padding
```



## File Table Entries


```
  00h   4   Directory Table Offset of Parent Directory
  04h   4   File Table Offset of next Sibling File           (FFFFFFFFh=None)
  08h   8   File Data Offset (64bit)
  10h   8   File Data Size   (64bit)
  18h   4   File Table Offset of next File with same Hash    (FFFFFFFFh=None)
  1Ch   4   Name Length in bytes (ie. L=NumChars*2)
  20h   L   File Name (16bit Unicode)
  20h+L 0/2 Alignment padding
```



## File/Directory Hash Tables (for quick lookup)


```
  00h   N*4 Offset to File/Directory with matching Chksum (FFFFFFFFh=None)
```

These tables can be used for fast lookup (faster than doing char-by-char string
compares for all names in directory). For searching a specific name in a
specific directory, compute a checksum on the Directory Offset and Name:

```
  chksum = ParentDirectoryOffset XOR 123456789
  for i=0 to NameLength/2-1
    chksum = (chksum ROR 5) XOR Name[i*2]  ;32bit rotate, then XOR lower 16bit
  offset = hashtable [(chksum MOD (hashtablesize/4))*4]
```

Then verify if Name(offset) and ParentDirectory entry(offset) do actually
match, and else retry with offset=NextHashOffset(offset).

Note: The hashtablesize's should be roughly same or bigger than the total
number of files/directories in the RomFS (multiplied by 4, as each entry is
32bit wide). Even then, there can be false matches, including matches in
different directories (which can slowdown things when needing additional sector
reads for obtaining the table entries for such directories).



## RomFS can be used for...


```
  in conjunction with the ExeFS of a NCCH
  to contain the game manual accessible from the Home Menu
  to contain the DLP Child CIA   ;uh, is that "CIA" a homebrew fileformat?
  to contain game cartridge update data
```




# <a name="3dsfilesncchencryption"></a>3DS Files - NCCH Encryption



The extended header, the ExeFS, and the RomFS are encrypted using AES-CTR.



## AES-CTR Encryption FirstKeyX and FirstKeyY:


The FirstKey is used for NCCH Exheader, and ExeFS Header, and for two ExeFS
files ("icon" and "banner").

```
  FirstKeyX = KeyX from keyslot 2Ch (as set by bootrom)
  FirstKeyY = NCCH[000h..00Fh]  ;first 10h bytes of RSA signature
```



## AES-CTR Encryption SecondKeyX and SecondKeyY:


The SecondKey is also used for the whole RomFS (header, all files, and
SHA256's). And, for all ExeFS files (EXCEPT "icon" and "banner"), ie. it's used
for ".code", ".firm", "logo", and any further ExeFS files.

```
  if NCCH[18Bh]=00h then SecondKeyX = KeyX from keyslot 2Ch (original firmware)
  if NCCH[18Bh]=01h then SecondKeyX = KeyX from keyslot 25h (firm7.0.0)
  if NCCH[18Bh]=0Ah then SecondKeyX = KeyX from keyslot 18h (firm9.3.0) ;\New
  if NCCH[18Bh]=0Bh then SecondKeyX = KeyX from keyslot 1Bh (firm9.6.0) ;/3DS
  if NCCH[18Fh].bit5=0 then SecondKeyY = NCCH[000h..00Fh]   (original firmware)
  if NCCH[18Fh].bit5=0 then SecondKeyY = see SEEDDB below   (firm9.6.0)
```

With the original firmware, the SecondKey is just same as FirstKey (ie. there's
only one key in that case). Newer firmwares have added the extra keys shown
above, but they aren't used for ALL titles (eg. a new 3DS may use keyslot 25h
for eShop, and keyslot 2Ch for System Settings).



## SecondKeyY from SEEDDB (firm9.6.0) (New3DS)


```
  ;load SEEDDB (nand:/data/<ID0>/sysdata/0001000f/00000000),
  ;that file contains 32byte entries (with 8-byte Title ID, 16-byte seed,
  ;plus 8-byte reserved; whereof titleid might refer to ProgramID or so?),
  ;find the matching entry for current "titleid", then do:
  temp[00h..0Fh] = seed for current title (from SEEDDB file)           ;\
  temp[10h..17h] = NCCH[118h..11Fh]  ;Program ID                       ; test
  sha256(dst=temp, src=temp, srclen=18h)                               ;
  if temp[00h..03h] <> NCCH[114h..117h] then error                     ;/
  temp[00h..0Fh] = NCCH[000h..00Fh]  ;first 10h bytes of RSA signature ;\
  temp[10h..1Fh] = seed for current title (from SEEDDB file)           ; key
  sha256(dst=temp, src=temp, srclen=20h)                               ;
  SecondKeyY=temp[00h..0Fh]  ;use first 10h bytes of SHA256 as KeyY    ;/
```



## Special Cases


```
  if NCCH[18Fh].bit2=1                     ;\NoCrypto flag (eg. in NCCH's
    Exit  ;not encrypted                   ;/located inside of FIRM files)
  if NCCH[118h..11Fh]=NCCH[400h..407h]     ;\
    SkipDecrypt (or NeedEncrypt)           ; Program ID in Header vs Exheader
    ;above can be checked only if Exheader ; currently/already decrypted
    ;does exist, ie. if NCCH[180h]<>0      ;/
  if NCCH[18Fh].bit0=1  ;FixedCryptoKey flag         ;\
    if (ProgramID.MSW AND FFFFC010h)=00040010h       ; debug only, not retail:
      NormalKey=FixedSystemKey (52h,7Ch,E6h,30h,..)  ; instead of First/Second
    else                                             ; KeyX+KeyY
      NormalKey=Zerofilled (00h's)                   ;/
```



## Encryption IV


```
  if NCCH[112h]=01h  ;NCCH version (weird, is/was that version really used?)
    Force MediaUnitSize=1 (or 200h?) ;fixed? (instead of 200h SHL N bytes?)
    IV[00h..07h] = NCCH[108h..10Fh]    ;NCCH Partition ID (forwards!)
    IV[08h..0Bh] = Zero
    IV[0Ch..0Fh] = BigEndianAddr (200h=Exheader, [1A0h]=ExeFS, [1B0h]=RomFS)
  if NCCH[112h]=02h  (or =00h, too?)   ;NCCH version
    IV[00h..07h] = NCCH[10Fh..108h]    ;NCCH Partition ID (backwards!)
    IV[08h]      = Type (01h=Exheader, 2=ExeFS, 3=RomFS)
    IV[09h..0Fh] = Zero (plus offset/10h within Exheader/ExeFS/RomFS area)
```

When starting elsewhere than BEGIN of Exheader/ExeFS/RomFS, add offset/10h to
the IV value (whereas, mind that IV is big-endian in the above description; it
may be easier to set the IV in little-endian mode though).




# <a name="3dsfilesncchlogo"></a>3DS Files - NCCH Logo



The logo was originally stored as file "logo" (in the encrypted ExeFS). Newer
files have the logo stored in separate unencrypted data block (see NCCH header
entries [130h,198h,19Ch]). Even in newer firmwares, the old location in "logo"
file is still used by Safe Mode files (at least so on Old3DS). Unknown if the
new logo block can also exist in absence of ExeFS.


"The Logo contains distribution licensing Binary data (types: Nintendo,
Licensed, Published, or Distributed). Additionally it could have no license
(type None). System applications and applets that interact with the Home Menu
are typically set to type 'none' as they don't display that information."



## Logo Compression


Reportedly "contains distribution licensing Binary data".

"The size of this logo is always 2000h-bytes."

The logo seems to be LZ11 compressed, see:

- [LZ Decompression Functions](#lzdecompressionfunctions)
This file is a LZ11 compressed DARC. The last 20h bytes of the decompressed
data is a HMAC SHA256 hash over the actual DARC.

The HMAC key(s) used for the SHA256-HMAC is unknown.



## Logo DARC Archive


- [3DS Files - Archive DARC](#3dsfilesarchivedarc)
The DARC contains three folders and several files (below is from Safe Mode
System Updater):

```
  anim
    NintendoLogo_D_00_SceneOutA.bclan  ;\
    NintendoLogo_D_00_SceneOutB.bclan  ; D
    NintendoLogo_D_00_SceneOutC.bclan  ;/
    NintendoLogo_U_00_SceneOutA.bclan  ;\
    NintendoLogo_U_00_SceneOutB.bclan  ; U
    NintendoLogo_U_00_SceneOutC.bclan  ;/
  blyt
    NintendoLogo_D_00.bclyt            ;-D
    NintendoLogo_U_00.bclyt            ;-U
  timg
    3dsLogo_00.bclim
    3dsLogo_01.bclim
    3dsLogo_02.bclim
    3dsLogo_03.bclim
    LT_00.bclim
    LT_01.bclim
    LTMask_00.bclim
    Nintendo_128x64.bclim
```

Unknown if other logo/darc packages contain other file/folder names.



## Logo DARC Files


- [3DS Files - Video Layout (CLYT/FLYT)](#3dsfilesvideolayoutclytflyt)
- [3DS Files - Video Layout Animation (CLAN/FLAN)](#3dsfilesvideolayoutanimationclanflan)
- [3DS Files - Video Layout Images (CLIM/FLIM)](#3dsfilesvideolayoutimagesclimflim)



# <a name="3dsfilestitlecontentmetadatacmd"></a>3DS Files - Title Content Metadata (CMD)




## Content Metadata (.cmd) file format


```
  00h     4    File number for 000000nn.cmd file (eg. 3=00000003.cmd)
  04h     4    Number of Contents (N)
  08h     4    Number of Contents (N) (same as above)
  0Ch     4h   Zerofilled  ;reportedly always 1  ;\maybe shop titles??
  10h     10h  Zerofilled  ;reportedly AES-MAC   ;/or SD card exports???
  20h     N*4  List of file numbers for 000000nn.app files
  20h+N*4 N*4  List of file numbers for 000000nn.app files (same as above)
  20h+N*8 -    Nothing     ;reportedly more AES-MAC's ???
```

The .cmd file is reportedly "encrypted with a console unique keyslot"???
(actually, it isn't encrypted at all, at least not on eMMC).


"\<ContentID>.cmd" - (The Content ID is a u32, initially: 00000001 when
the title is first installed. Changing by an increment of +0x1 for each time
the 3DS adds/removes '.app' files) This file contains data taken from the
title's TMD. See the below table for the format of the cleartext .cmd file. The
Title.db contains the Content ID for the '.cmd' file, but does not contain a
hash of the '.cmd' file. This acts as part of the DRM for installed titles,
along with the title.db.


The below AES-CMACs (including the last 0x10-bytes of the header) are only used
for SD titles, for NAND download-play titles, and non-system DSiWare titles.
For other titles, these MACs are set to all-zero.

```
  000h 4      .cmd ContentID, for the .cmd filename. This is the beginning
                of the header   ;uh, which header? what for?
  004h 4      Number of AES-CMACs and Content IDs in the first list (X).
                The method to determine this is explained below.
  008h 4      Number of Content IDs in the second list (Y)
  00Ch 4      Unknown, usually (always?) 1.
  010h 10h    AES-CMAC over first 0x10
  020h 4*X    List of installed Content IDs in order of Content Index, with
                missing contents replaced with 0xFFFFFFFF
  020h+4*X     4*Y     List of installed Content IDs in order of ID name
  020h+4*(X+Y) 10h*X   AES-CMACs for each content in the first list, generated
                         using the process below
```

The number of AES-CMACs depends on the highest Content Index installed. For
example, a title with 5 contents, but only 1 and 3 are installed, will still
result in 3 AES-CMACs, with the 2nd one being unused.


For SD contents, each AES-CMAC is generated by combining the NCCH header
without the signature (0x100-0x1FF), the Content Index and Content ID at the
end, both as u32. Then calculate the SHA256 of the data and generate the
AES-CMAC using the SD/NAND AES-CMAC key.


For TWLNAND contents, the same process is used (even for SRL contents) with the
keyslot for NAND dbs.





# <a name="3dsfilestitlemetadatatmd"></a>3DS Files - Title Metadata (TMD)



Title metadata is a format used to store information about a title (installed
title, DLC, etc.) and all its installed contents, including which contents they
consist of and their SHA256 hashes.



## Signature Type


```
  Value           Signature Method        Signature Size  Padding Size
  0x010000        RSA_4096 SHA1 (Unused for 3DS)            0x200   0x3C
  0x010001        RSA_2048 SHA1 (Unused for 3DS)            0x100   0x3C
  0x010002        Elliptic Curve with SHA1 (Unused for 3DS) 0x3C    0x40
  0x010003        RSA_4096 SHA256                           0x200   0x3C
  0x010004        RSA_2048 SHA256                           0x100   0x3C
  0x010005        ECDSA with SHA256                         0x3C    0x40
```

The hash for the signature, is calculated over the header of the TMD.



## TMD Format


```
  000h 4      Signature Type (00h,01h,00h,04h) (100h-byte RSA-SHA256)
  004h 100h   Signature RSA-SHA256 across 140h..203h
  104h 3Ch    Signature padding/alignment (zerofilled)
  140h 40h    Signature Name "Root-CA00000003-CP0000000b", 00h-padded
  180h 1      TMD Version (always 1 on 3DS, unlike DSi)
  181h 1      ca_crl_version (0)
  182h 1      signer_crl_version (0)
  183h 1      Zero       (padding/align 4h)
  184h 8      System Version (0)
  18Ch 8      Title ID
  194h 4      Title Type     (40h, big-endian)
  198h 2      Group ID       (0)
  19Ah 4      SD/MMC "public.sav" filesize in bytes  (3DS: savedata size)
  19Eh 4      SD/MMC "private.sav" filesize in bytes (3DS: 0=none)
  1A2h 4      Zero
  1A6h 1      SRL Flag (00h=3DS, but also 0=DSiware, uh?)
  1A7h 3      Zero
  1AAh 10h    Zerofilled (DSi: Parental Control Age Ratings)
  1BAh 1Eh    Zerofilled
  1D8h 4      Access Rights (0)
  1DCh 2      Title Version
  1DEh 2      Content Count (number of entries at B04h)
  1E0h 2      Boot Content
  1E2h 2      Padding
  1E4h 20h    SHA256 across Content Info Records at [204h..B03h]
  204h 900h   Content Info Records (40h entries, with 24h-bytes each)
  B04h 30h*N  Content Chunk Records (N entries, with 30h-bytes each)
```



## Content Info Records (useless, can be ignored, except for error checking)


There are 64 of these records, usually only the first is used.

```
  000h 2    Content index offset  (I)
  002h 2    Content command count (N)
  004h 20h  SHA256 across TMD[B04h+I*30h+(0..N*30h-1)    ;(?)
```



## Content chunk records


There is one of these for each content contained in this title (determined by
"Content Count" in the TMD Header).

```
  000h 4    Content id    (aka name of .app file maybe?) (homebrew/dev=random?)
  004h 2    Content index (see below)
  006h 2    Content type  (see below)
  008h 8    Content size  (of app file)
  010h 20h  SHA-256 hash  (on what? the app file?) (before/after decrypt?)
```

Content Index:

```
  0000h = Main Content (3DS NCCH.exec, or 3DS NCCH.data, or DSiware/DSidata)
  0001h = Home Menu Manual (.CFA)
  0002h = DLP Child Container (.CFA)
  This does not apply to DLC.
```

Content Type flags:

```
  0     Encrypted (CIA blocks)  (0=Unencrypted/homebrew, 1=Encrypted)
  1     Disc (uh?)              (0=Normal, 1=whut?)
  2     CFM (abbreviation for?) (0=Normal, 1=whut?)
  3-13  Zero                    (0=Normal)
  14    Optional (uh?)          (0=Normal, 1=whut?)
  15    Shared (uh?)            (0=Normal, 1=whut?)
```



## Certificate Chain


If the TMD file is obtained from Nintendo's CDN, then it will have two
certificates appended at the end of the file:

```
  CERTIFICATE  SIG.TYPE  RETAIL CERT  DEBUG CERT  DESCRIPTION
  TMD          RSA-2048  CP0000000b   CP0000000a  to verify the TMD signature
  CA           RSA-4096  CA00000003   CA00000004  to verify the TMD Certificate
```

The CA certificate is issued by 'Root', the public key for which is stored in
NATIVE\_FIRM.




# <a name="3dsfilestitleticketticketdb"></a>3DS Files - Title Ticket (ticket.db)




## 3ds:\dbs\ticket.db (about 35.5Mbytes) (237F600h bytes)


ticket.db is a DIFF container containing a short 10h-byte header followed by a
BDRI filesystem.

- [3DS Files - Savedata DISA and DIFF](#3dsfilessavedatadisaanddiff)
- [3DS Files - Savedata SAVE/BDRI/VSXE Formats](#3dsfilessavedatasavebdrivsxeformats)
The 10h-byte header (between DIFF and BDRI layer) looks as so:

```
  000h 8    ID "TICK",01h,00h,00h,00h
  008h 4    Garbage (eg. random, or 0)
  00Ch 4    Garbage (eg. random-30h, or 1)
  010h ...  BDRI filesystem (about 17Mbytes) (10A2000h) (with ticket files)
```

The BDRI can contain up to 8192 files, usually it does contain about 200
tickets for the system titles, including the DSiware titles, plus any further
tickets for titles purchased from e-Shop (no matter if the titles are stored on
eMCC or on SD Cards).


Tickets are a format used to store an encrypted titlekey (using AES-CBC). With
3DS, the Ticket format was updated (now v1) from Wii/DSi format (v0).

- [DSi SD/MMC DSiware Tickets and Title metadata](ds.html#dsisdmmcdsiwareticketsandtitlemetadata)


## Ticket format


```
  Pre   4    One (1) (unknown purpose)   ;\little endian  ;\in ticket.db
  Pre   4    Size of below ticket (350h) ;/               ;/(not in .cia's)
  000h  4    Signature Type (00h,01h,00h,04h) (100h-byte RSA-SHA256)
  004h  100h Signature RSA-SHA256 across 140h..34Fh ?
  104h  3Ch  Signature padding/alignment (zerofilled)
  140h  40h  Signature Name "Root-CA00000003-XS0000000c", 00h-padded
  180h  3Ch  ECC Public Key (uh, what for?) (can be zero/none)
  1BCh  1    Ticket Version (always 1 on 3DS) (unlike DSi/Wii)
  1BDh  1    CaCrl Version
  1BEh  1    SignerCrl Version
  1BFh  10h  TitleKey (normal-key encrypted using one of the common keyYs)
  1CFh  1    Zero
  1D0h  8    Ticket ID  (00,04,xx,xx,xx,xx,xx,xx) ?   (...or random 64bit)
  1D8h  4    Console ID (Decrypted OTP[04h..07h], in reverse byte-order)
  1DCh  8    Title ID   (00,04,xx,xx,xx,xx,xx,xx) (same as ticket filename)
  1E4h  2    Zero
  1E6h  2    Title Version
  1E8h  4    Zero
  1ECh  4    Zero
  1F0h  1    License Type
  1F1h  1    Common keyY number for [1BFh] (0..5) (1 for retail system titles)
  1F2h  2Ah  Zero
  21Ch  4    eShop Account ID? (zero in many system files)
  220h  1    Zero
  221h  1    Audit (whatever, usually 01h)   (can be 00h, for debug/whatever?)
  222h  20h  00h-filled (Wii: Content access permissions, 1 bit per content)
  242h  20h  00h-filled (Wii: Content access permissions, 1 bit per content)
  262h  2    Zero
  264h  40h  Limits
  2A4h  ACh  Content Index (*)  (uh, but WHAT is a Content Index ??)
  350h  ..   Certificates (included in e-Shop downloads, not stored in files)
```

\* The Content Index of a ticket has its own size defined within itself (usually
ACh), with seemingly a minimal of 20 bytes.


The "Content Index" (whatever that is) at 2A4h looks as so:

```
  2A4h  4    Unknown (00h,01h,00h,14h)
  2A8h  4    Unknown (00h,00h,00h,ACh) Size of stuff at 2A4h..34Fh ?
  2ACh  4    Unknown (00h,00h,00h,14h)
  2B0h  4    Unknown (00h,01h,00h,14h)
  2B4h  4    Unknown (00h,00h,00h,00h)
  2B8h  4    Unknown (00h,00h,00h,28h)
  2BCh  4    Unknown (00h,00h,00h,01h)
  2C0h  4    Unknown (00h,00h,00h,84h)
  2C4h  4    Unknown (00h,00h,00h,84h)
  2C8h  4    Unknown (00h,03h,00h,00h)
  2CCh  4    Unknown (00h,00h,00h,00h)
  2D0h  20h  Unknown (FFh-filled) (or 00h-filled in some tickets)
  2F0h  60h  Unknown (00h-filled)
```



## Signature Type


```
  Value       Signature Method                  Signature Size  Padding Size
  0x010000    RSA_4096 SHA1 (Unused for 3DS)            0x200   0x3C
  0x010001    RSA_2048 SHA1 (Unused for 3DS)            0x100   0x3C
  0x010002    Elliptic Curve with SHA1 (Unused for 3DS) 0x3C    0x40
  0x010003    RSA_4096 SHA256                           0x200   0x3C
  0x010004    RSA_2048 SHA256                           0x100   0x3C
  0x010005    ECDSA with SHA256                         0x3C    0x40
```

The hash for the signature is calculated over the Ticket Data.


The Ticket Title Version is generally the same as the title version stored in
the Title Metadata. Although it doesn't have to match the TMD version to be
valid.



## TitleKey (for decrypting .app's in CIA's or Shop downloads)


First of, decrypt the ticket's Title Key via AES-CBC:

```
  dev/retail      = can be detected from RSA Signature Name at TIK[140h]
  KEY_X[00h..0Fh] = Keyslot 3Dh, as set by bootrom (differs for retail/dev)
  KEY_Y[00h..0Fh] = common key(0..5) from FIRM, index 0..5 from TIK[1F1h]
  KEY[00h..0Fh]   = derived from above KeyX/Y (retail key0..5 and dev key1..5)
  KEY[00h..0Fh]   = fixed normal key from FIRM (special, for dev key0 only)
  IV[00h..07h]    = Title ID (big-endian), from TIK[1DCh]
  IV[08h..0Fh]    = Zero
  SRC[00h..0Fh]   = Encrypted Title Key, from TIK[1BFh]
  aes-cbc decrypt
```

Then use the decrypted key to decrypt the .app via AES-CBC:

```
  KEY[00h..0Fh]   = Decrypted title key (decrypted from ticket)
  IV[00h..01h]    = Content Index (big endian, from TMD[B04h+N*30h+4])
  IV[02h..0Fh]    = Zero
  SIZE            = Content Size (from TMD[B04h+N*30h+8])
  aes-cbc decrypt (unless TMD[B04h+N*30h+6] has flagged encryption=0)
```

Note: For AES-CBC random access, one can use the preceeding "encrypted 10h-byte
block" as IV value (except, use the above IV for first block).

Unknown if there is a dev/retail flag in the ticket (if not, then one could

instead check the RSA Signature Name; retail="Root-CA00000003-XS0000000c")



## Limits


In demos, the first u32 in the "Limits" section is 0x4, then the second u32 is
the max-playcount.



## Certificate Chain


Tickets retrieved from CDN/SOAP have a certificate chain appended at the end of
the file. There are two certificates in this chain:

```
  CERTIFICATE SIG.TYPE  RETAIL CERT  DEBUG CERT  DESCRIPTION
  Ticket      RSA-2048  XS0000000c   XS00000009  to verify Ticket signature
  CA          RSA-4096  CA00000003   CA00000004  to verify Ticket Certificate
```

The CA certificate is issued by 'Root', the public key for which is stored in
NATIVE\_FIRM.



## Notes


CommonETicket (for short, cetk) is the name given to tickets for titles which
are not available on the eShop, like system titles. As the name suggests, they
are not unique tickets, the same ticket is common to each 3ds which has
installed that title. This is in contrast to tickets for eShop content, which
are generated prior to initial download, and are unique to 3ds it was generated
for.

CETK can be fetched through HTTP using the link to default update server, using
the title's TMD URL where "cetk" is used instead of "tmd" for the URL. The 3DS
NIM module retrieves system tickets via SOAP request GetSystemCommonETicket
instead of directly downloading the cetks with HTTPS. The cetks are also
accessible via HTTP (even though the 3DS never accesses them like that).



## Other Ticket files/folders


Apart from ticket.db, there is a 4B000h-byte file called 3ds:\tmp\title.tik
containing the following stuff:

```
  0000h 350h    Ticket (without 8-byte header)    ;-350h-byte ticket
  0350h 9Ch     Unknown (00h-filled)              ;\                    ;\
  03ECh 4       Unknown (FFh,FFh,E3h,E7h)         ; 128h-byte whatever  ; fifty
  03F0h 88h     Unknown (00h-filled)              ;/                    ; 128h
  0478h 9Ch     Unknown (00h-filled)              ;\                    ; byte
  0514h 4       Unknown (FFh,FFh,E3h,E7h)         ; 128h-byte as above  ; blks
  0518h 88h     Unknown (00h-filled)              ;/                    ;
  ...   48*128h ...                               ;-128h-byte's as above;/
  3D20h 0B8h    Unknown (00h-filled)              ;\
  3DD8h 4       Unknown (52h,46h,00h,00h)         ; whatever
  3DDCh 4       Unknown (58h,A8h,07h,00h)         ;
  3DE0h 4       Unknown (B4h,32h,15h,00h)         ;/
  3DE4h 4721Ch  Unknown (00h-filled)              ;-lots of zeroes
```

Additionally, there are two empty ticket folders:

```
  3ds:\ticket\     ;on 3DS partition
  dsi:\ticket\     ;on DSi partition
```

The latter would have been used on DSi to store .tik files (but the 3DS does
instead store all tickets in ticket.db, including DSiware tickets).




# <a name="3dsfilestitlecertificatescertsdb"></a>3DS Files - Title Certificates (certs.db)




## 3ds:\dbs\certs.db (6000h-byte DIFF container with 2800h bytes of raw data)


```
  000h 4     ID "CERT"                                           ;\
  004h 4     Zero                                                ; header
  008h 4     Size of used area at 010h..A0Fh ? (A00h)            ;
  00Ch 4     Random garbage? (eg. 080FFFE0h or 080496E1h)        ;/
  010h 4     Signature Type (00,01,00,03) (200h-byte RSA-SHA256) ;\
  014h 200h  Signature RSA across 250h..40Fh ?                   ;
  214h 3Ch   Signature padding/alignment (zerofilled)            ;
  250h ..    Signature Name ("Root", zeropadded)                 ;
  290h ..    Key Type (00,00,00,01) (100h-byte RSA)              ; CA00000003
  294h ..    Key Name ("CA00000003", zeropadded)                 ; (for below)
  2D4h 4     Key Random/time/type/flags/chksum?    7BE8EF6Ch     ;
  2D8h 100h  Key Public RSA Key (B2,79,C9,E2,...)                ;
  3D8h 4     Key Public RSA Exponent? (00,01,00,01)              ;
  3DCh 34h   Key padding/alignment (zerofilled)                  ;/
  410h 4     Signature Type (00,01,00,04) (100h-byte RSA-SHA256) ;\
  414h 100h  Signature RSA across 550h..70Fh ?                   ;
  514h 3Ch   Signature padding/alignment (zerofilled)            ;
  550h ..    Signature Name ("Root-CA00000003", zeropadded)      ;
  590h ..    Key Type (00,00,00,01) (100h-byte RSA)              ; CP0000000b
  594h ..    Key Name ("CP0000000b", zeropadded)                 ; (for TMDs)
  5D4h 4     Key Random/time/type/flags/chksum?    137A080Bh     ;
  5D8h 100h  Key Public RSA Key (A6,89,C5,90,...)                ;
  6D8h 4     Key Public RSA Exponent? (00,01,00,01)              ;
  6DCh 34h   Key padding/alignment (zerofilled)                  ;/
  710h 4     Signature Type (00,01,00,04) (100h-byte RSA-SHA256) ;\
  714h 100h  Signature RSA across 850h..A0Fh ?                   ;
  814h 3Ch   Signature padding/alignment (zerofilled)            ;
  850h ..    Signature Name ("Root-CA00000003", zeropadded)      ;
  890h ..    Key Type (00,00,00,01) (100h-byte RSA)              ; XS0000000c
  894h ..    Key Name ("XS0000000c", zeropadded)                 ; (for
  8D4h 4     Key Random/time/type/flags/chksum?    137A0894h     ; Tickets)
  8D8h 100h  Key Public RSA Key (AD,50,5B,B6,...)                ;
  9D8h 4     Key Public RSA Exponent? (00,01,00,01)              ;
  9DCh 34h   Key padding/alignment (zerofilled)                  ;/
  A10h 1F0h  Padding (0)                                         ;\unused
  C00h 1C00h Random garbage?                                     ;/
```

The 200h-byte Public Key for the 'Root' signature is reportedly somewhere in
NATIVE\_FIRM (unknown where though, knowing the first some bytes would help)
(also unknown if it is the same 'Root' key as on DSi).

The DSi has a similar file called cert.sys:

- [DSi SD/MMC Firmware dev.kp and cert.sys Certificate Files](ds.html#dsisdmmcfirmwaredevkpandcertsyscertificatefiles)
The DIFF container uses the standard DISA/DIFF format

- [3DS Files - Savedata DISA and DIFF](#3dsfilessavedatadisaanddiff)
However, the DIFF in certs.db does contain raw data (instead of the
SAVE/BDRI/VSXE filesystems that are usually found in DISA/DIFF containers).




# <a name="3dsfilestitledatabasefilestitledbimportdbetc"></a>3DS Files - Title Database Files (title.db, import.db, etc.)



These files contain data relating to install/usage/management of installed 3DS
titles. The database files are located at:

```
  3ds:\dbs\*.db
  sd:\Nintendo 3DS\<ID0>\<ID1>\dbs\*.db
```

ID0 is the first 0x10-bytes from a SHA256 hash. The installation of SD Card
titles was introduced in the 2.0.0-2 update and the SD dbs files are encrypted
by the general SD filesystem encryption rule. These files are DIFF containers.
These DIFF files do not use external IVFC level 4, so all database data is
duplicated in the container. In this page only the inner content of the
container is described.

These files are only created on SD (via AM) if they don't exist when the eShop
application is starting up, during network init etc (prior to showing the
"system update required" dialog).



## 3ds:\dbs\title.db (can contain max 1379 files)



## sd:\Nintendo 3DS\\<ID0>\\<ID1>\dbs\title.db


Title database, contains entries for all installed titles (TWL & CTR) on
the 3DS (each database is responsible for titles installed on its medium).



## 3ds:\dbs\import.db



## sd:\Nintendo 3DS\\<ID0>\\<ID1>\dbs\import.db


Import Databases, containing entries for titles (or versions of titles) not yet
installed, ready for transferring to the title.db. ("Automatic Update uses
this, so completing the update takes seconds." uh, why does that take so much
time?)



## 3ds:\dbs\tmp\_t.db


Temporary Title database containing one entry for the currently installed
Download Play Child.



## 3ds:\dbs\tmp\_i.db


Similar to import.db, except it's used in conjunction with tmp\_t.db, for
installing Download Play Children.


The inner content of the container consists of a pre-header with size of 0x80
identifying the Database Type, followed by a BDRI container. The offsets in the
BDRI header are usually relative to the offset to the start of the BDRI header
(0x80 in the file)


Pre Header

```
  000h 8    ID (eg. "NANDTDB",00h) (see below)
  008h 78h  Reserved
  080h ...  BDRI filesystem (with 80h-byte files containing Title Info)
```

The 8-byte ID can be:

```
  ID="NANDIDB",00h --> 3ds:\dbs\import.db
  ID="NANDTDB",00h --> 3ds:\dbs\title.db
  ID="TEMPIDB",00h --> 3ds:\dbs\tmp_i.db, tmp_t.db
  ID="TEMPTDB",00h --> sd:\Nintendo 3DS\<ID0>\<ID1>\dbs\import.db, title.db
```



## Title Info Entry -- is that... maybe "title.db" files...?


An entry contains information taken from both the application NCCH file(s) and
TMD.

```
  000h 8    Title Size
  008h 4    Title Type (usually 40h)
  00Ch 4    Title Version
  010h 1    Flags_0.0 (Electronic Manual: 0=None?, 1=Yes?)
  011h 1    Flags_0.1 (0)
  012h 1    Flags_0.2 (0)
  013h 1    Flags_0.3 (0)
  014h 4    TMD Content ID (aka filenumber for "000000xx.tmd" ?)
  018h 4    CMD Content ID (aka filenumber for "cmd\000000xx.cmd" ?)
  01Ch 1    Flags_1.0 (SD Save Data: 0=None?, 1=Yes?)
  01Dh 1    Flags_1.1
  01Eh 1    Flags_1.2
  01Fh 1    Flags_1.3
  020h 4    Extdata ID low (zero if title doesn't use Extdata)
  024h 4    Reserved (0)
  028h 1    Flags_2.0 DSiWare Related (Visibility on Home Menu/Export Flag?)
  029h 1    Flags_2.1 ?
  02Ah 1    Flags_2.2 ?
  02Bh 1    Flags_2.3 ?
  02Ch 1    Flags_2.4 in DSiWare and in titles with an 'Application' Title ID
  02Dh 1    Flags_2.5 DSiWare Related (Visibility on Home Menu/Export Flag?)
  02Eh 1    Flags_2.6 ?
  02Fh 1    Flags_2.7 ?
  030h 10h  Product Code (eg. "CTR-N-HASJ", "", or "DS INTERNET", zeropadded)
  040h 10h  Reserved (0)
  050h 4    Unknown (32bit random/checksum/id/whatever)
  054h 2Ch  Reserved (0)
```



## Notes


"It is important to note the database doesn't contain a hash of the .cmd. So if
a user has more than one valid set of application data for a given .cmd Content
ID they can be manually interchanged without issue. Though renaming a .cmd file
to match the Content ID which the title.db is expecting will result in an
error, as the CTR for the per-console encryption layer changes depending on the
file path, and the MAC of the .cmd is probably generated with the .cmd Content
ID in mind."


"These NAND/SD /dbs images seem to be loaded by the ARM9 while NATIVE\_FIRM is
booting."


"Removing ticket.db from a New3DS with signature checks disabled will not
result in an unbootable system, however all icons except Slot-1 will disappear
from Home. Applets can however still be used. Recovery can be accomplished via
hardmod or arm9loaderhax plus a known good backup of the file (or the whole
partition or disk); Gamecard exploits were not tested, and Browserhax did not
work."




# <a name="3dsfilestitleinstallationarchivecia"></a>3DS Files - Title Installation Archive (CIA)




## CIA Format (CTR Importable Archive)


```
  0000h 4      Header Size (usually 2020h bytes)
  0004h 2      Type        (seems to be always 0)
  0006h 2      Version     (seems to be always 0)
  0008h 4      Cert size   (0A00h, or 0=None)
  000Ch 4      Ticket Size (0350h, or 0=None)
  0010h 4      TMD Size    (0B34h+N*30h, or 200h=Dummy)
  0014h 4      Meta Size   (3AC0h, or 200h=Dummy, 8=CVer USA, or 0=None)
  0018h 8      APP Size    (can contain multiple contents, see TMD)
  0020h 2000h  APP Flags   (64Kbit/flags, usually 80h or C0h plus zeropadding)
  2020h 20h    Zerofilled  (padding to 40h-byte boundary)
  2040h [08h]  Certificate chain
  ...   ..     Zerofilled  (padding to 40h-byte boundary)
  ...   [0Ch]  Ticket file
  ...   ..     Zerofilled  (padding to 40h-byte boundary)
  ...   [10h]  TMD file
  ...   ..     Zerofilled  (padding to 40h-byte boundary)
  ...   [18h]  APP file(s) (usually encrypted via ticket)
  ...   ..     Zerofilled  (padding to 40h-byte boundary)
  ...   [14h]  Meta file   (3AC0h, or 08h, or 0=None) (if any)
  ...   ..     Zerofilled  (padding to 40h-byte boundary)
```



## Certificate Chain (A00h bytes, with three certificates)


```
  RSA-4096 for below certificates (Retail=CA00000003, or Dev=CA00000004)
  RSA-2048 for Ticket signature   (Retail=XS0000000c, or Dev=XS00000009)
  RSA-2048 for TMD signature      (Retail=CP0000000b, or Dev=CP0000000a)
```

The same three certificates are also stored in certs.db,

- [3DS Files - Title Certificates (certs.db)](#3dsfilestitlecertificatescertsdb)


## Ticket (350h bytes), with decrypt key for APP file(s)


- [3DS Files - Title Ticket (ticket.db)](#3dsfilestitleticketticketdb)


## TMD (B34h+N\*30h bytes), contains info about the separate APP file(s)


- [3DS Files - Title Metadata (TMD)](#3dsfilestitlemetadatatmd)


## APP file(s)


This region can contain one or more contents (eg. separate .app files for
executable and manual, with .app sizes as listed in the TMD file; the .app
files can be 3DS NCCH images, or DSiware images, or DSi datafiles like DS Cart
Whitelist).

The .app contents are usually encrypted using the ticket's titlekey (see the
Ticket chapter for details).

```
  There are two unencrypted variants:
  1) Encryption can be disabled in Content Type flags in the TMD file (that's
     done in most or all homebrew CIA's like ctrQuake.cia)
  2) Pre-retail prototype CIA's from mid 2010 didn't include tickets, and are
     thus unencrypted (the Ticket Size entry in CIA header is probably zero?)
```



## Meta (3AC0h bytes) (if any)


```
  0000h 30h*8 Dependency module list    ;from NCCH Exheader ;NCCH[240h]
  0180h 180h  Reserved (0)
  0300h 4     Core version              ;from NCCH Exheader ;NCCH[408h?]
  0304h FCh   Reserved (0)
  0400h 36C0h SMDH Icon/Title           ;from NCCH ExeFS    ;ExeFS:\icon
```

The above data block is only present for NCCH executables (DSiware files and
NCCH data files don't have the Exheader and ExeFS).

- [3DS Files - NCCH Extended Header](#3dsfilesncchextendedheader)
- [3DS Files - Video Icons (SMDH)](#3dsfilesvideoiconssmdh)


## Meta (8 bytes) (CVer USA)


Seems to contain a copy of the "CVer - RomFS:\version.bin" file.

- [3DS Files - Version (CVer and NVer)](#3dsfilesversioncverandnver)
Confusingly, the japanese system update contains 000400db00017202.cia (that
name would be CVer USA, but the file contains CVer JPN). And confusingly, the
system update doesn't contain any NVer file (unknown if/how it is updating
NVer).



## APP Flags


This appears to be a 64Kbit array with flags for Content Index 0000h..FFFFh
(the first flag for index 0000h being located in bit7 of first byte).

The number of contents and content indices are found in the TMD file (most
titles have only 1 or 2 contents, so the first flag byte is usually 80h or C0h,
followed by 1FFFh zero bytes).

Unknown if these flags are used for anything... maybe there are cases where the
TMD lists multiple APPs, but only one of them being updated in the CIA?


```
 ___________________________________ Blurp ____________________________________
```



## Overview


CIA format allows the installation of titles to the 3DS. CIA files and titles
on Nintendo's CDN contain identical data. As a consequence, valid CIA files can
be generated from CDN content. This also means CIA files can contain anything
that titles on Nintendo's CDN can contain. Uh, what is a CDN?


Under normal circumstances CIA files are used where downloading a title is
impractical or not possible. Such as distributing a Download Play child, or
installing forced Gamecard updates. Those CIA(s) are stored by the titles in
question, in an auxiliary CFA file.


Development Units, are capable of manually installing CIA files via the Dev
Menu.



## Format


The CIA format has a similar structure to the Wii's WAD format (aka DSi Tad?).

The file is represented in little-endian.

The data is aligned in 40h-byte blocks (if a content ends at the middle of the
block, the next content will begin from a new block).


```
 _____________________________ System Update CFA ______________________________
```


This system update CFA contains the below files in the RomFS. This CFA is
stored in the NCSD system-update partition (partition 7), the data from this
CFA RomFS can also be transferred for Download Play when the client needs
updated.

```
  ROM Cart NCSD Partition 6, NCCH RomFS:\SNAKE\cup_list  ;\New3DS System Update
  ROM Cart NCSD Partition 6, NCCH RomFS:\SNAKE\*.cia     ;/
  ROM Cart NCSD Partition 7, NCCH RomFS:\cup_list        ;\Old3DS System Update
  ROM Cart NCSD Partition 7, NCCH RomFS:\*.cia           ;/
```



## cup\_list


This uses the same format as the CVer cup\_list, this system-update CFA cup\_list
contains the titleIDs for all of the titles stored in this RomFS.

- [3DS Files - Version (CVer and NVer)](#3dsfilesversioncverandnver)


## \<titleID>.cia


This is the CIA for each system-update title, for retail gamecards these CIAs
are generated from the titles available on CDN at the time the NCSD image was
finalized. The latest version(at the time of CFA generation) of every system
title from CDN is stored here, excluding titles with the title-versions for
1.0.0-0.



## New3DS


New3DS system-update partitions are located at partition6 in gamecards. The
RomFS contains a "SNAKE" directory, the contents of that directory have the
same structure as the Old3DS sysupdate CFA RomFS.


```
 _____________ Old CIA Formats (some pre-retail prototype stuff) ______________
```



## 24/06/2010 - CTR\_SDK: 0\_10


```
  000h 4     Archive Header Size (Usually = 0x2020 bytes)
  004h 2     Type
  006h 2     Version
  008h 4     Unused (aka size=0, or what?)                    (no Cert)
  00Ch 4     Unused (aka size=0, or what?)                    (no Tick)
  010h 4     Zero Filled Data (usually 0x200 bytes in length) (no TMD)
  014h 4     Zero Filled Data (usually 0x200 bytes in length) (no Meta)
  018h 8     APP file size
  020h 2000h Content Index
```

The order of the sections in the CIA file:

```
  * Header
  * Zero Data (aka dummy TMD?)
  * Zero Data (aka dummy Meta?) (but here with Meta in front of APP area!?)
  * APP file data (unencrypted, as there's no ticket with titlekey)
```

Only one executable supported. Uh, are there MORE than one "executable"
supported in later versions??? With different title IDs??? But that would
somewhat require multiple TMD's and Ticket's?



## 06/07/2010 - CTR\_SDK: 0\_10\_2


```
  000h 4     Archive Header Size (Usually = 0x2020 bytes)
  004h 2     Type
  006h 2     Version
  008h 4     Unused (aka size=0, or what?)           (no Cert)
  00Ch 4     Ticket size
  010h 4     TMD file size
  014h 4     Unused (aka size=0, or what?)           (no Meta)
  018h 8     APP file size
  020h 2000h Content Index
```

The order of the sections in the CIA file:

```
  * Header
  * Ticket
  * TMD
  * APP file data
```

Very similar to the final CIA version (encryption, TMD, etc), except there is
no embedded Certificate Chain.



## Late 2010


The final version was invented in late 2010 (and, with the 3DS being released
in 2011, retail CIA's are probably always using the final version).




# <a name="3dsfilestitlehomebrewexecutables3dsx"></a>3DS Files - Title Homebrew Executables (3DSX)



The 3DSX format is a homebrew executable file format. The main feature is
having relocateable code, which may have been required for some older exploits
that didn't provide full control of the virtual memory mapping.

As such, the .3dsx format is no longer useful (at least not once when having
installed a bootloader), and one could instead use regular .code, .firm, .ncch,
or .cia files for homebrew.



## 3DSX File Format


Header:

```
  00h  4   ID "3DSX"
  04h  2   Header size (20h or 2Ch)
  06h  2   Relocation Header size (unspecified purpose) (always 8)
  08h  4   Format version         (unspecified purpose) (always 0)
  0Ch  4   Flags                  (unspecified purpose) (always 0)
  10h  4   Code Segment Size
  14h  4   Rodata Segment Size
  18h  4   Data Segment Size (including bss)
  1Ch  4   Bss Segment Size
```

Extended Header (when [04h]>20h):

```
 (20h) 4   Icon/Title Offset       (or ?=None)
 (24h) 4   Icon/Title Size (36C0h) (or ?=None)
 (28h) 4   RomFS Offset            (or 0=None)
```

Relocation Header(s)

```
  ..   4   Number of absolute Code relocations   (=maybe num skip/patch pairs?)
  ..   4   Number of relative Code relocations   (unknown purpose, always 0)
  ..   4   Number of absolute Rodata relocations (=maybe num skip/patch pairs?)
  ..   4   Number of relative Rodata relocations (unknown purpose, always 0)
  ..   4   Number of absolute Data relocations   (=maybe num skip/patch pairs?)
  ..   4   Number of relative Data relocations   (unknown purpose, always 0)
```

Segments

```
  ..   ..  Code Segment
  ..   ..  Rodata Segment
  ..   ..  Data Segment (whatever... maybe excluding bss?)
```

Relocation Tables

```
  ..   ..  Code Relocation Table
  ..   ..  Rodata Relocation Table
  ..   ..  Data Relocation Table
```

Optional (when [04h]>20h):

```
  ..   ..  Icon/Title (SMDH Format)
  ..   ..  RomFS      (RomFS Directory/File area, without IVFC header+SHA's)
```

Unknown how the executable could access the RomFS (it might be loaded to some
RAM address, which would be a waste of memory) (or otherwise the executable
would need to know the path\filename of the 3dsx file).



## Relocation Table (entries?):


```
  00h  2   Number of words to skip
  02h  2   Number of words to patch
```

Unknown what this does. The file is probably meant to be originated at a fixed
base address (maybe zero?), and one would add the actual load address to any
such "absolute" addresses? And do whatever on "relative" addresses?



## Note


Some 3DSX files can be found at:

- [http://www.3dbrew.org/wiki/Homebrew\_Applications](http://www.3dbrew.org/wiki/Homebrew_Applications)



# <a name="3dsfilesclientcertkeyclcerta"></a>3DS Files - Client Cert/Key (ClCertA)



ClCertA (title id: 0004001b00010002) contains the following encrypted files:

```
  RomFS:ctr-common-1-cert.bin   ;default SSL client cert
  RomFS:ctr-common-1-key.bin    ;default SSL client private key
```

The .bin files are AES-CBC encrypted using keyslot 0Dh (as set by bootrom):
000h 10h  IV value for AES-CBC                        ;-IV value for decrypt

```
  010h LEN  DER file (LEN=filesize-20h-PAD)             ;\
  xxxh PAD  Padding to 10h-byte boundary (zerofilled)   ; AES-CBC encrypted
  xx0h 1    Size of above padding (PAD)                 ; (keyslot 0Dh)
  xx1h 0Fh  Padding to 10h-byte boundary (zerofilled)   ;/
```

The decrypted files are in .der format:

- [DSi SD/MMC Firmware Certificate/Keys (DER)](ds.html#dsisdmmcfirmwarecertificatekeysder)
The files are used by SSL module, the retail cert name is "CTR Common Prod 1".


The following servers require usage of ClCertA to connect:

- [https://account.nintendo.net/](https://account.nintendo.net/)
                  - ;Account/OAuth2 related
- [https://ccif.ctr.shop.nintendo.net/](https://ccif.ctr.shop.nintendo.net/)
      - ;CreditCardInfo/transaction? related
- [https://ecs.c.shop.nintendowifi.net/](https://ecs.c.shop.nintendowifi.net/)
    - ;ECommerce SOAP, ticket-related
- [https://cas.c.shop.nintendowifi.net/](https://cas.c.shop.nintendowifi.net/)
    - ;Cataloging SOAP
- [https://ninja.ctr.shop.nintendo.net/](https://ninja.ctr.shop.nintendo.net/)
    - ;eShop-related
- [https://nus.c.shop.nintendowifi.net/](https://nus.c.shop.nintendowifi.net/)
    - ;NetUpdate SOAP, used by NIM module




# <a name="3dsfilesctcert"></a>3DS Files - CTCert



Below seems to describe "CTCert".

Uh, unknown if/where this "CTCert" is stored?

Maybe it exists only after having connected to the shop at least once (similar
to DSi's dev.kp)?

Or maybe it's a slightly reformatted copy of the Decrypted OTP, maybe only
temporarily stored in RAM?

Or maybe below does describe .ctx file format rather than CTCert format?


The console-unique CTCert is used for signing CTX files (uh, really signing
them? with a public key??), the DeviceCert used by eShop, and for DSiWare
exports. This ECDSA signature, the ECDSA private key for this cert, and the
IssuerID is loaded from memory initialized by bootrom instead of NAND. This is
the 3DS equivalent of the DSi TWCert (aka the "TW cert" in DSi "Tad" files?).


The CTCert is signed with ECDSA by Nintendo. CTCerts can be verified via a DER
stored in NATIVE\_FIRM, separate DERs are used for retail and dev/debug.



## Structure


```
  000h 4     Signature Type (00010005h)
  004h 3Ch   Signature ECDSA
  040h 40h   Signature padding/alignment (zerofilled)
  080h 40h   Signature Name (retail="Nintendo CA - G3_NintendoCTR2prod")
                            (dev="Nintendo CA - G3_NintendoCTR2dev")
  0C0h 4     Key Type
  0C4h 40h   Key Name "CT<DeviceId>-<ConsoleType>"  aka "CTxxxxxxxx-xx"?
               DeviceId is the hex DeviceId (aka Decrypted OTP[04h..07h]?)
               ConsoleType is "00"=retail, "01"=dev
  104h 04    Key Expiration UNIX Time, big endian (seconds since 1 Jan 1970 ?)
  108h 3Ch   Key Public ECDSA Key (point X,Y)
               "This is two consecutive u8 arrays (each one of length 1Eh),
               where the first one corresponds to the ECDSA R coordinate,
               and the second to ECDSA S coordinate. These are in big endian."
  144h 3Ch   Key padding/alignment (zerofilled)
```


The ECDSA public key for this cert is converted from the ECDSA private key
initialized by bootrom (uh, that's probably meant to be from Decrypted OTP).
The curve used for ECDSA is sect233r1.




# <a name="3dsfilesdictionarynjdc"></a>3DS Files - Dictionary (NJDC)



NJDC files contain dictionaries (maybe for spellchecking?), NJDC files are
found in:

- Shared Data Archives: Dictionary (RomFS:\..\\*.a) ;for console/region languages
- System Applets: 3DS Browser applet (RomFS:\iwnn\..\\*.a) ;for all languages



## Dictionary Format


The files contain a header and several large tables. The header size (and the
location/presence of the header entries) varies from file to file; possibly
depending on some header flags?

All values, offsets and UTF-16 chars are BIG-ENDIAN.

```
  000h 4    Header ID ("NJDC")
  004h 2    Unknown (1 or 2)
  006h 2    Unknown (0 or 1)
  008h 2    Unknown (4 or 5 or 0Fh)
  00Ah 2    Unknown (0)
  00Ch 4    Total Filesize minus a few bytes?
  010h 4    Unknown (00xxh)
  014h 4+4  Unknown (00xxh,00xxh) (usually both the same value)
  01Ch 4    Unknown (00xxh)
  ...  ..   ???
  ...  4    Offset to 10-byte Table
  ...  4    Offset to UTF-16 Strings
  ...  4    Offset to 2-byte Table
  ..   ..   Some zeroes and offsets?
  ...  4    Offset to 2 bytes? (08h,06h)
  ...  4    Values 00h,01h,01h,01h
  ...  4    Values 00h,01h,01h,01h
  ...  ..   ???
  ...  4    Number of words (N) ?
  ...  ..   ???
  ...  ..   4-byte Table (maybe some lookup table?)
  ...  2    2 bytes? (08h,06h)
  ...  N*10 10-byte Table (see below)
  ...  ..   UTF-16 Strings (raw strings, without trailing zeroes)
  ...  N*2  2-byte Table (values 0101h*(40h..7Dh)?) (flags/lookup?) (if any)
  ...  4    Footer ID ("NJDC") (can be unaligned)
```

10-byte Table:

```
  000h 1    String Length in bytes (always even, since chars are UTF-16)
  001h 3    String Offset (relative to String Table base)
  004h 6    Zerofilled
```



## Bad Word List


Roughly related, there is Bad Word list in

```
  System Data Archives 2, NGWord (RomFS:*.txt)
```

The .txt files are UTF-16 (starting with FFh,FEh byte-order-marker).




# <a name="3dsfilesguidegbin"></a>3DS Files - Guide (GBIN)



GBIN Files are found in 3DS Camera & 3DS Sound (RomFS:\res\Guide\*.gbin).

The files contain several "T\_xxx" and "D\_xxx\_y" strings, bundled with unknown
small numbers.

Purpose is unknown, maybe some Tree structure, or a list of Chapters (T) and
Pages (D).

The files contain no real data, so they do probably refer to whatever other
files, ie. translating names to file indices and/or assigning attributes.



## GBIN Format


```
  000h 4     ID "GBIN"
  004h 4     Number of GUID entries
  008h ..    GUID entries
```

GUID entry format:

```
  000h 4     ID "GUID"
  004h 4     Number of D-entries
  008h 4     Unknown (0 or 1 or 2)
  00Ch 4     Unknown (0 or 1 or 2)
  010h 4     Unknown (0..0Fh?)
  014h 0Ch   Unknown (0)
  020h 10h   T-Name ("T_001" and up, zeropadded)
  030h N*14h D-Entries
```

D-Entry Format:

```
  000h 10h   D-NAME ("D_001_0" and up, zeropadded)
  010h 4     Unknown (0..04h?)
```




# <a name="3dsfilesversioncverandnver"></a>3DS Files - Version (CVer and NVer)




## 3ds:\title\000400db System Data Archives 2 - NVer and CVer


```
  NVer - RomFS:\version.bin        ;exists always (revision number)      ;-NVer
  CVer - RomFS:\version.bin        ;exists always (major.minor version)  ;\
  CVer - RomFS:\cup_list           ;exists only before 8.0.0-18          ; CVer
  CVer - RomFS:\masterkey.bin      ;exists in 7.2.0-17 and up            ;
  CVer - RomFS:\titleversion.txt   ;exists in 9.6.0-X and up             ;/
```

See also:

- [3DS Files - FIRM Versions](#3dsfilesfirmversions)
- [http://www.3dbrew.org/wiki/Home\_Menu](http://www.3dbrew.org/wiki/Home_Menu) \<-- more versions!



## NVer - RomFS:\version.bin (8 bytes)


This 8-byte file mainly contains the system revision number, for the version
number displayed by System Settings. The rest of the data used for the system
version is contained in CVer.

```
  000h 2     Reserved (0)
  002h 1     Revision version number (0..45) (the version's -N suffix)
  003h 1     Reserved (0)
  004h 1     ASCII character for the system version region (eg. "J"=Japan)
  005h 3     Reserved (0)
```

Note: The NVer "revision" number does usually increase alongsides with the
"major.minor" number in CVer (but some updates have only either one of those
increased) (unknown why, maybe one file refers to FIRM version, and the other
to Kernel version or whatever).



## CVer - RomFS:\version.bin (8 bytes)


This 8-byte file contains most of the data used for displaying the system
version in System Settings. Format of the system version:
"major.minor.build-revision region".

```
  000h 1     Build version number (0)
  001h 1     Minor version number (0..13)
  002h 1     Major version number (1..11)
  003h 1     Reserved (0)
  004h 1     ASCII character for the system version region (eg. "J"=Japan)
  005h 3     Reserved (zeroes, or same as [000h..002h])
```



## CVer - RomFS:\cup\_list (800h bytes) (exists only before 8.0.0-18)


```
  000h N*8   TitleID list of system titles (8 bytes each)   ;eg. 127 titles
  ...  ..    Zerofilled (padding to 800h-byte filesize)
```

This list doesn't contain all system titles, though most are contained in this
list.

This file was removed from the CDN CVer RomFS, starting with 8.0.0-18.

A similar "cup\_list" file is bundled with System Update CIA's:

- [3DS Files - Title Installation Archive (CIA)](#3dsfilestitleinstallationarchivecia)


## CVer - RomFS:\masterkey.bin (40h bytes, exists in 7.2.0-17 and up)


```
  000h 1     Region (00h=Japan, 01h=USA, 02h=EUR, etc.)
  001h 1     Version (0Ah=v7.2, 0Bh=v8.0, etc.)
  002h 0Eh   Zerofilled
  010h 10h   AES IV value for decrypting below key
  020h 20h   Encrypted HMAC key
```

This file is used by System Settings. The HMAC key is decrypted using AES-CTR
using a key from "mset .rodata" and the above IV value.



## CVer - RomFS:\titleversion.txt (ASCII 5-7 bytes) (exists in 9.6.0-X and up)


With 9.6.0-X, this is a 5-byte file containing the following: "9.6.7". This is
the parsed version of the CVer TMD title-version.

After USA 9.6.0-X for \<=v11.0, this matches the version from CVer
version.bin.




# <a name="3dsfilescrr0andcro0files"></a>3DS Files - CRR0 and CRO0 Files



CRO0 and CRR0 files are reportedly somehow related, but unknown how exactly.

```
  System Tools: Nintendo Network ID Settings and System Applets: Miiverse have
    "RomFS:\.crr\static.crr" ;-CRR0 (whatever)
    "RomFS:\cro\static.crs"  ;-CRO0 (without actual code/data in there)
  System Data Arvives 1: web-lot/OSS CROs has
    "RomFS:\cro2\oss.cro"    ;\both are CRO0's (with code/data each)
    "RomFS:\cro2\webkit.cro" ;/(but without any CRR0 file)
  System Applets 3DS Browser has
    "RomFS:\.crr\static.crr" ;-CRR0 (whatever)
    "RomFS:\*.cro.lex"       ;-several LZ11 compressed .cro's
    "RomFS:\static.crs"      ;-CRO0 (without actual code/data in there)
```

Unknown if/where any more such files exist.


```
 _________________________________ CRR0 Files _________________________________
```



## CRR0 Files (must be stored under "RomFS:\.crr\")


```
  000h 4     ID "CRR0"
  004h 4     Reserved (0)
  008h 4     Next loaded CRR       ;\must be zero in file,
  00Ch 4     Previous loaded CRR   ;/set by RO during loading
  010h 4     Debug Info Offset (usually 0=None)
  014h 4     Debug Info Size   (usually 0=None)
  018h 8     Reserved (0)
  020h 4     UniqueID Mask    (eg. F00000FFh)
  024h 4     UniqueID Pattern (eg. zero)
  028h 18h   Reserved (0)
  040h 100h  RSA-2048 modulo (for signature at 240h..33Fh)
  140h 100h  RSA-2048 signature over [020h+(0..11Fh)] signed by Nintendo
  240h 100h  RSA-2048 signature over [340h+(0..357h?)]   (uh, why that size?)
  340h 4     Process UniqueID<<8, from the ProgramID
  344h 4     Total Filesize
  348h 8     Reserved (0)
  350h 4     Hash-table Offset (usually 360h)
  354h 4     Hash-table Number of Entries (uh, 2 when having only 1 .crs file?)
  358h 4     Plain region Offset containing text tags, from process NCCH
  35Ch 4     Plain region Size
  360h 20h*N Hash-table (SHA256's on first 80h-bytes of CRO0's) (or not so??)
  ...  ..    Plain region (some SDK strings) (does that have any purpose?)
  ...  ..    Padding to 1000h-byte boundary (CCh-filled)
```

Each hash stored in the hash-table is over the (which?) corresponding
executable CRO0 hash-table.


```
 _________________________________ CRO0 Files _________________________________
```


CRO with extension .cro is used for "DLLs". CRS with extension .crs is in the
same format of CRO but storing the symbol information of the static module (the
main application) (uh, aka the "ExeFS:\.code" file?) (uh, and, importantly,
.crs files seem to contain only symbols and stuff (and empty code/data
sections)).



## CRO0 Files (.cro and .crs)


```
  000h 20h  SHA256 on CRO0 header bytes 080h..17Fh         ;\
  020h 20h  SHA256 on code area (offset/size at [0B0h])    ; hash-table,
  040h 20h  SHA256 on ?                                    ; verified by CRR
  060h 20h  SHA256 on .data area (offset/size at [0B8h])   ;/
  080h 4    ID "CRO0"
  084h 4    Name offset (same as [0C0h])
  088h 4    Zero (changed to Next loaded CRO pointer by RO during loading)
  08Ch 4    Zero (changed to Prev loaded CRO pointer by RO during loading)
  08Ch 4    Previous loaded CRO pointer, set by RO during loading
  090h 4    Total Filesize
  094h 4    .bss size
  098h 4    Unknown
  09Ch 4    Unknown
           Below four words are "Segment offset" (FFFFFFFFh if not exists)
  0A0h 4    Export symbol "nnroControlObject_" offset (FFFFFFFFh in .crs)
  0A4h 4    Function "OnLoad" (called on init)
  0A8h 4    Function "OnExit" (called on exit)
  0ACh 4    Function "OnUnresolved" (called on unresolved function calls)
  0B0h 4+4  Code Section                offset, size
  0B8h 4+4  .data Section               offset, size
  0C0h 4+4  Module Name                 offset, size
  0C8h 4+4  Segment Table               offset, num (size=num*12)
  0D0h 4+4  Named Export Table          offset, num (size=num*8)
  0D8h 4+4  Indexed Export Table        offset, num (size=num*4)
  0E0h 4+4  Export Strings              offset, size
  0E8h 4+4  Export Tree (fast lookup)   offset, num (size=num*8) (trie-like)
  0F0h 4+4  Import Module Table         offset, num (size=num*20)
  0F8h 4+4  Import Patches              offset, num (size=num*12)
  100h 4+4  Named Import Table          offset, num (size=num*8)
  108h 4+4  Indexed Import Table        offset, num (size=num*8)
  110h 4+4  Anonymous Import Table      offset, num (size=num*8)
  118h 4+4  Import Strings              offset, size
  120h 4+4  unk8                        offset, num
  128h 4+4  Relocation Patches          offset, num (size=num*12)
  130h 4+4  unk9                        offset, num
  138h 48h  Zerofilled
  ...  ..   Code Section, etc. (in whatever order)
  ...  ..   Padding to 1000h-byte boundary (CCh-filled)
```


Segment offset (4 bytes) (used at [0A0h..0AFh], and also in many Table's)

```
  Bit0-3     Segment index for table
  Bit4-31    Offset into segment
```


Segment Table entry (12 bytes)

```
  000h 4     Segment offset
  004h 4     Segment size
  008h 4     Segment id (0=.text, 1=.rodata, 2=.data, 3=.bss)
```


Named Export Table entry (8 bytes)

```
  000h 4     Name offset
  004h 4     "Segment offset" for export
```


Indexed Export Table entry (4 bytes)

```
  000h 4     "Segment offset" for export
```


Named Import Table entry (8 bytes)

```
  000h 4     Name offset
  004h 4     Offset of the head of a linear list that contains the
                  patches for this import
```


Indexed Import Table entry (8 bytes)

```
  000h 4     Index of the export symbol
  004h 4     Offset of the head of a linear list that contains the
                  patches for this import
```


Anonymous Import Table entry (8 bytes)

```
  000h 4     "Segment offset" of the export symbol
  004h 4     Offset of the head of a linear list that contains the
                  patches for this import
```


Import Module Table entry (20 bytes)

```
  000h 4     Module name offset
  004h 4     Indexed import num
  008h 4     Offset of the head of a sub list in Indexed Import Table
  00Ch 4     Anonymous import num
  010h 4     Offset of the head of a sub list in Anonymous Import Table
```


Patch entry (12 bytes)

```
  000h 4     "Segment offset" for output.
  004h 1     Patch type (apparently a subset of relocation type for ARM ELF):
               0=nothing/ignore
               2=38=write u32 absolute (base+addend)
               3=write u32 relative (base+addend-in_ptr)
               10=THUMB branch
               28=ARM32 branch
               29=modify ARM32 branch offset
               42=write u32 relative (((signed int)base*2)/2+addend-in_ptr)
               other=err
  005h 1     For import patches, non-zero if last entry; for relocation
             patches, this is the referred segment index
  006h 1     For import patches, 1 is written to first entry if all symbols
             loaded successfully; unknown (padding?) for relocation patches
  007h 1     Unknown (padding?)
  008h 4     addend
```

ARM32 branch instruction is constructed as follows:

```
  If addend > 02000000h or addend < FE000000h, then skip.
  If (addend&1) == 1 then write "b +4" (nop).
  Else write as normal.
```

Unknown what "addend" means... addition offset? end of addition?


When the RO module loads the entire CRO into process memory (mapped in the
00100000h-04000000h region), it modifies the mapped CRO data. The magic field
is also changed to "FIXD" if fix level is not 0.


Upon loading, the RO module will look for export symbol "nnroAeabiAtexit\_" to
patch it to its import symbol "\_\_aeabi\_atexit".




# <a name="3dsfilesarchivedarc"></a>3DS Files - Archive DARC



DARC archives are used in various places, sometimes uncompressed, or often with
LZSS or LZ11 compression. For example,

```
  Uncompressed DARC     Manual.bcma file (e-manual)
  LZSS compressed DARC  .arc files (nested within above .bcma file)
  LZ11 compressed DARC  NCCH Logo (in NCCH Header, or NCCH ExeFS:\logo)
  LZ11 compressed DARC  .arc.LZ files (eg. in 3DS Camera RomFS "lyt" folder)
```

The DARC format is about same as the Wii's U8 format (with different header,
different byte-order, and UTF-16 instead of ASCII names).



## DARC header


```
  000h 4    ID "darc"
  004h 2    Byte Order (FEFFh)
  006h 2    Header Size (001Ch)
  008h 4    Version (01000000h)
  00Ch 4    Total Filesize (excluding trailing 20h-byte SHA256-HMAC, if any)
  010h 4    Offset of File/Folder List (usually 1Ch)
  014h 4    Size of File/Folder List, PLUS File/Folder Name Area
  018h 4    Offset of File Data Area
  ..   ..   File/Folder List (0Ch bytes per file/folder)
  ..   ..   File/Folder Name Area (UTF-16)
  ..   ..   File Data Area (usually each file is 20h-byte aligned)
 (..) (20h) Trailing SHA256-HMAC, if any (this is NOT 20h-byte aligned)
```



## Root/Dot Entries (first 1-2 entries in File/Folder List)


```
  Entry0: Type=Folder, Name="", Offset=0, End=TotalNumDirEntries  ;Root
  Entry1: Type=Folder, Name=".", Offset=0, End=TotalNumDirEntries ;Dot (if any)
```

Entry0/Root is important to know the total directory size, and to compute the
begin of the Name Area:

```
  NameArea = FileFolderList + TotalNumDirEntries*0Ch
```

Entry1/Dot is somewhat useless, but it does exist in most (not all) darc files,
ie. the path strings can appear as so:

```
  darc:\.\dir\subdir\file       ;<-- ugly, but used in most darc files
  darc:\dir\subdir\file         ;<-- nicer, used in a few darc files
```

It's best to hide the "." in path strings (ie. detect if Entry1 is a Folder,
with name "." and same Offset/End as Entry0, and if so, skip/ignore it).



## File/Folder List Entries (0Ch bytes per entry)


```
  000h 3    Name offset (24bit, relative to begin of Name Area)
  003h 1    Type        (00h=File, 01h=Folder)
 When Type=00h=File:
  004h 4    File offset (relative to begin if darc; NOT to begin of Data Area)
  008h 4    File size
 When Type=01h=Folder:
  004h 4    Folder Parent Index (0=Root, 1=Dot, Other=NestedSubdir's)
  008h 4    Folder End Index (entries up to excluding End Index are childs)
```



## Special Cases


3DS Face Raiders RomFS:\hal\effect\kbb\kbb.dat doesn't have a "." dot folder.

3DS Mii Maker RomFS:\shaders\shader.arc has nested folders & empty folders.

3DS Activity Log RomFS:\P\_UlcdTest\_LZ.bin contains an empty darc.



## Example


```
  64 61 72 63                            ;id "darc"
  FF FE 1C 00
  00 00 00 01
  28 65 00 00
  1C 00 00 00
  1C 04 00 00
  40 04 00 00
  00 00 00 01  00 00 00 00  15 00 00 00  ;00h folder ""
  02 00 00 01  00 00 00 00  15 00 00 00  ;01h folder "."
  06 00 00 01  01 00 00 00  09 00 00 00  ;02h folder "anim";\
  10 00 00 00  40 04 00 00  F8 00 00 00  ;03h              ;
  54 00 00 00  40 05 00 00  EC 00 00 00  ;04h              ;
  98 00 00 00  40 06 00 00  F8 00 00 00  ;05h              ;
  DC 00 00 00  40 07 00 00  CC 0C 00 00  ;06h              ;
  20 01 00 00  20 14 00 00  54 0C 00 00  ;07h              ;
  64 01 00 00  80 20 00 00  4C 02 00 00  ;08h              ;/
  A8 01 00 01  01 00 00 00  0C 00 00 00  ;09h folder "..." ;\
  B2 01 00 00  E0 22 00 00  A8 02 00 00  ;0Ah              ;
  E2 01 00 00  A0 25 00 00  3C 10 00 00  ;0Bh              ;/
  12 02 00 01  01 00 00 00  15 00 00 00  ;0Ch folder "..." ;\
  1C 02 00 00  00 36 00 00  28 04 00 00  ;0Dh              ;
  3E 02 00 00  80 3A 00 00  28 01 00 00  ;0Eh              ;
  60 02 00 00  00 3C 00 00  28 04 00 00  ;0Fh              ;
  82 02 00 00  80 40 00 00  28 08 00 00  ;10h              ;
  A4 02 00 00  00 49 00 00  A8 00 00 00  ;11h              ;
  C4 02 00 00  00 4A 00 00  28 08 00 00  ;12h              ;
  DC 02 00 00  80 52 00 00  28 02 00 00  ;13h              ;
  F4 02 00 00  00 55 00 00  28 10 00 00  ;14h              ;/
  00 00                                  ;name "",0000h
  2E 00 00 00                            ;name ".",0000h
  61 00 6E 00 69 00 6D 00 00 00          ;name "anim",0000h
  ...
```




# <a name="3dsfilesarchivesarc"></a>3DS Files - Archive SARC



SARC archives contain only files, not folders. However, the filenames do
usually contain slashes (eg. "bsnd/cursor.bcwav"), so software could split
those names into folder+filename, if desired.

SARC is used by 3DS eShop Applet, RomFS:\layout\ and RomFS:\sound\.



## SARC Header


```
  000h 4     ID "SARC"
  004h 2     Header Size (14h)
  006h 2     Byte Order (FEFFh)
  008h 4     Total Filesize
  00Ch 4     Data Offset (aka Size of SARC+SFAT+SFNT)
  010h 2     Unknown/version? (always 0100h)
  012h 2     Unknown/reserved? (0)
  ..   ..    SFAT Chunk (see below) (Directory)
  ..   ..    SFNT Chunk (see below) (Filename strings)
  ..   ..    Data
```



## SFAT Chunk (File Allocation Table)


```
  000h 4     ID "SFAT"
  004h 2     Header Size (0Ch)
  006h 2     Number of FAT Entries
  008h 4     Filename Hash Multiplier (usually 65h)
  00Ch N*10h FAT Entries (10h bytes each)
```

FAT Entry Format:

```
  000h 4    Filename Checksum (sorted, with smallest checksum in 1st FAT entry)
  004h 2    Filename Offset (at SFNT+8+Offset*4)
  006h 2    File Attribute? (always 0100h)
  008h 4    File Data Start (at Data+Start)
  00Ch 4    File Data End   (at Data+End, aka Data+Start+Size)
```

The filename checksums are calculated as follows:

```
  sum=0, for i=0 to namelen-1, sum=(sum*hash_multiplier)+name[i], next i
```



## SFNT Chunk (Filename Table)


```
  00h 4    ID "SFNT"
  04h 2    Header Length (08h)
  06h 2    Unknown (padding?)
  08h ..   Filenames (ASCII, terminated by zero, on 4-byte boundaries)
```



## File Data (at Offset specified in SARC[0Ch])


Files are at least 4-byte aligned (some SARCs do reportedly use 80h-byte
alignment).



## Tools


SARC Extractor/Creator with TAR-like command line flags. Can decompress a .zlib
SARC file (4-byte size header + ZLIB data).




# <a name="3dsfilesarchivearcless"></a>3DS Files - Archive arcless




## arcless Format


This is a very simple archive format, found in some LZ-compressed files, eg. in
3DS Sound and 3DS Camera (RomFS:\lyt\C.LZ and RomFS:\shaders\shaders.LZ), 3DS
Picture Picker (RomFS:\sound\csnd.LZ), and also in uncompressed form, eg. 3DS
Sound (RomFS:\res\S.pack).

```
  000h+N*40h 38h     Filename (ASCII, zeropadded)                      ;\
  038h*N*40h 4       File Offset (always 80h-aligned)                  ;
  03Ch*N*40h 4       File Size                                         ; header
  ..         1       Zero (indicates end of directory)                 ;
  ..         ..      Zeropadding to 80h-byte boundary                  ;/
  xxx*80h    ..      File data (at above offsets)                      ;\data
  ..         ..      Zeropadding to 80h-byte boundary, after each file ;/
```

The header doesn't contain any ID (like "NARC", "SARC", or "darc" or so).
However, one can more or less reliably detect it by checking for valid ASCII
characters, zeropaddings, 1st Offset being located after the directory, further
Offsets being located at Offset+Size+Alignment from previous entry, and with
Offset+Size not exceeding the archive size.




# <a name="3dsfilesarchivezar"></a>3DS Files - Archive ZAR




## ZAR Format (Zelda Archive, used in 3DS Zelda Ocarina of Time)


```
  000h 4      ID "ZAR",01h                                   ;\
  004h 4      Total Filesize                                 ;
  008h 2      Number of Filetype Entries    (T)              ;
  00Ah 2      Number of Files (of any type) (F)              ; header
  00Ch 4      Offset to Filetypes section (20h)              ;
  010h 4      Offset to Filesize/name section                ;
  014h 4      Offset to Fileoffset section                   ;
  018h 8      ID "queen",0,0,0                               ;/
  020h T*10h  Filetype Entries                               ;\type list
  ...  ..     Filetype Names and File List for each Filetype ;/
  ...  F*8    Filesize/Filename Entries                      ;\
  ...  ..     Filenames (ASCII, terminated by zero)          ; file list
  ...  F*4    Fileoffset Entries                             ;/
  ...  ..     File data...                                   ;-file data
```



## Filetypes Entries


```
  000h 4    Number of Files for the Filetype (0=None)
  004h 4    Offset to File List for the Filetype (FFFFFFFFh=None)
  008h 4    Offset to Filetype name (eg. "unknown",0 or "zsi",0 etc.)
  00Ch 4    Unknown (always FFFFFFFFh)
```

The File List contains a list of 32bit File indices for the Filetype (0=1st
file, 1=2nd file, etc).

The number of filetypes varies between 2 and 8 in known files. Known filetype
names are:

```
  "anb",00h       boy/.../*.anb    ;eg. in actor\zelda_link_child_ultra.zar
  "ccb",00h       ?
  "cmab",00h      misc/.../*.cmab
  "cmb",00h       Model/.../*.cmb  (or lowercase, model/.../*.cmb)
  "csab",00h      Anim/.../*.csab
  "ctxb",00h      tex/.../*.ctxb
  "faceb",00h     boy/.../*.faceb  ;eg. in actor\zelda_link_opening.zar
  "qdb",00h       demo/.../*.qdb   ;eg. in actor\zelda_horse.zar, scene\*.zar
  "tbd",00h       txt/.../*.tbd    ;eg. in kankyo\kankyo_common.zar
  "unknown",00h   Anim/.../*.cskla ;eg. in actor/zelda_magic_wind.zar
  "zsi",00h       collision/.../*.zsi
```

Type "unknown" does always exist as first type entry (even if it contains no
files; the only archive containing an "unknown" file is
actor/zelda\_magic\_wind.zar, which contains Anim/new\_magic\_wind.cskla).



## Filesize/Filename Entries


```
  000h 4    File size
  004h 4    Offset to filename (ASCII, terminated by zero)
```



## Fileoffset Entries


```
  000h 4    Offset to File data
```



## Directories


The ZAR format doesn't directly support directories. However, most filenames
contain slashes so one could split those into folder/filename.

Note: RomFS:\scene\\*.zar does use "\" backslashes instead of "/" slashes, that,
with some names starting with dot or dotdot (".\" or  "..\..\").

If desired, one could also treat the ZAR's Filetypes section as top-level
directories, or as filetype suffix (although "Model" and ".cmb" in filenames
like "Model\filename.cmb" do already imply the type anyways).



## Note


See 
- [https://wiki.cloudmodding.com/oot/Category:File\_Formats](https://wiki.cloudmodding.com/oot/Category:File_Formats) for more Zelda fileformats (QBF, QCL, QM, etc).




# <a name="3dsfilesccalformathardwarecalibrationhwcal"></a>3DS Files - CCAL Format (Hardware calibration, HWCAL)



The two HWCAL files contain (initial?) calibration values, the data is also
stored in the system settings config file, unknown which of those three files
contains the most up to date values for daily use.

- [3DS Files - Config Savegame](#3dsfilesconfigsavegame)


## Reading


"If 0x1FF81006 (uh, what, where from?) is 3 or 4 or 7 or 8 or 9 then the
calibration data is read from the EEPROM using the i2c:EEP service command
0x001000C0, using offset 0x000 for HWCAL0, and offset 0x800 for HWCAL1.
Otherwise attempt is made to read CTRNAND:/ro/sys/HWCAL(0|1).dat instead."



## Summary


```
  File Data  Size  ConfigInfoBlk Bit  Description
  000h -     200h  -             -    Header
  200h 000h  10h   00040000h     3    Touchscreen
  214h 014h  08h?  ???                Circle Pad (part 1)
  220h 020h  2     00050000h     1    Screen flicker
  224h 024h  1     00010000h     7    RTC Compensation Value
  228h 028h  1     ???                DSPRAM related
  230h 030h  8Ah   ???           2?   Camera position
  2BCh 0BCh  12h   00040002h     6    Gyroscope
  2D0h 0D0h  0Ch   00040003h     8    Accelerometer
  2E0h 0E0h  134h  00020000h     5    Codec (CDC)
  418h 218h  04h?  ???         null?  Programmable Infrared Transmitter (PIT)
  420h 220h  214h  00070000h     9?   3D filters ... maybe this is "Surround"?
  640h 440h  20h   ???           10   Power saving mode (ABL)
  670h 470h  20h   00050005h     11?  Stereo Display Settings
  6A0h 4A0h  38h   00050002h     12   Backlight PWM (BLPWM)
  6E0h 4E0h  18h   ???                Circle Pad extra (part 2)
  700h 500h  0Ch   ???                ???
  710h 510h  20h   ???                ???
  740h 540h  08h   ???         not?   MCU
  750h 550h  02h   00050006h   not11? 3D screen (ULCD) delay
  760h 560h  08h   00070002h   not?   Microphone echo cancellation
  770h 570h  10Ch  00050008h   not?   Power saving mode (ABL) extra
  880h 680h  08h   ???         not?   CStick (Right stick)
  890h 690h  18h   00180001h   null?  Quad Tracking Module (QTM)
```



## Aging flags (for Header entry [00Eh])


```
  Bit     Description
  0       FCRAM (unknown, bit0 is usually zero)
  1       Screen flicker (always successful)
  2       Camera
  3       Touchscreen panel (always successful)
  4       Circle Pad (analog stick)
  5       Codec
  6       Gyroscope
  7       RTC Compensation Value
  8       Accelerometer
  9       Surround
  10      Power saving mode (ABL)
  11      3D screen (ULCD)
  12      Backlight PWM (BLPWM)
  13      Analog stick A (???)
  14      Camera extensions (?)
  15      Power saving mode (ABL) in legacy (DSi/GBA) mode
```

Unknown if these are actually test results, maybe they are just entry-present
flags? With later entries instead indicated by "Value 0001h" in the newly added
fields?



## Header


```
  000h 4    File ID "CCAL"
  004h 4    Version (eg. Old3DS:0000000Dh, New3DS:00000012h)
  008h 4    Data size (always 07D0h, for entry 200h..9CFh)
  00Ch 1    Model version (?) (usually 00h)
  00Dh 1    CAL revision (incremented each time the CAL file is updated)
  00Eh 2    Bitmask of successful Aging tests (Old3DS:73FEh, New3DS:77FEh)
  010h 20h  SHA256HMAC (retail) or SHA256 (dev) of the data section
  030h 1D0h Zero
```



## Touchscreen


```
  200h 2    s16 RawX0
  202h 2    s16 RawY0
  204h 2    s16 PointX0
  206h 2    s16 PointY0
  208h 2    s16 RawX1
  20Ah 2    s16 RawY1
  20Ch 2    s16 PointX1
  20Eh 2    s16 PointY1
  210h 2    Checksum?
  212h 2    Zero
```



## Circle Pad (part 1)


```
  214h 2    s16 CenterX (usually 08xxh)
  216h 2    s16 CenterY (usually 08xxh)
  218h 4    Zero (hmmm, uncommonly... not set to Value 0001h ?)
  21Ch 2    Checksum?
  21Eh 2    Zero
```



## Screen flicker


```
  220h 1    u8 FlickerTop                             (maybe for MCU[03h] ?)
  221h 1    u8 FlickerBottom                          (maybe for MCU[04h] ?)
  222h 1    Checksum ([220h] XOR FFh)
  223h 1    Checksum ([221h] XOR FFh)    ;uh, reportedly without XOR FFh ???
```



## RTC Compensation Value


```
  224h 1    u8 Compensation Value (???) (usually 80h) (maybe for MCU[37h] ?)
  225h 1    Checksum ([224h] XOR FFh)
  226h 2    Zero
```



## DSP-RAM related?


```
  228h 1    DSPRAM related (spotted FEh on Old3DS, 86h on New3DS)
  229h 1    Checksum ([228h] XOR FFh)
  22Ah 6    Zero
```



## Camera position ;uh, for which of the three camera(s)?


```
  230h 4    u32 flags
  234h 4    float scale
  238h 4    float RotationZ
  23Ch 4    float TranslationX
  240h 4    float TranslationY
  244h 4    float RotationX
  248h 4    float RotationY
  24Ch 4    float ViewAngleRight
  250h 4    float ViewAngleLeft
  254h 4    float ChartDistance(???)
  258h 4    float CameraDistance
  25Ch 2    s16 ImageWidth
  25Eh 2    s16 ImageHeight
  260h 10h  u8 reserved[0x10]
  270h 40h  u8 ???[0x40]
  2B0h 2    s16 aeBaseTarget(???)
  2B2h 2    s16 kRL
  2B4h 2    s16 kGL
  2B6h 2    s16 kBL
  2B8h 2    s16 ccmPosition
  2BAh 2    Checksum?
```



## Gyroscope


```
  2BCh 2    s16 ZeroX
  2BEh 2    s16 PlusX
  2C0h 2    s16 MinusX
  2C2h 2    s16 ZeroY
  2C4h 2    s16 PlusY
  2C6h 2    s16 MinusY
  2C8h 2    s16 ZeroZ
  2CAh 2    s16 PlusZ
  2CCh 2    s16 MinusZ
  2CEh 2    Checksum?
```



## Accelerometer


```
  2D0h 2    s16 OffsetX
  2D2h 2    s16 ScaleX
  2D4h 2    s16 OffsetY
  2D6h 2    s16 ScaleY
  2D8h 2    s16 OffsetZ
  2DAh 2    s16 ScaleZ
  2DCh 2    Checksum?
  2DEh 2    Zero
```



## Codec (CDC) (aka TSC)


```
  2E0h 1    u8 DriverGainHP       ;TSC[65h:0Ch].bit3-7
  2E1h 1    u8 DriverGainSP       ;TSC[65h:12h].bit2-7 and TSC[65h:13h].bit2-7
  2E2h 1    u8 AnalogVolumeHP     ;TSC[65h:16h] and TSC[65h:17h]
  2E3h 1    u8 AnalogVolumeSP     ;TSC[65h:1Bh] and TSC[65h:1Ch]
  2E4h 1    s8 ShutterVolume0     ;TSC[00h:41h] and TSC[00h:42h] ;\maybe camera
  2E5h 1    s8 ShutterVolume1     ;TSC[64h:7Bh]                  ;/sound fx?
  2E6h 1    u8 MicrophoneBias     ;TSC[65h:33h]
  2E7h 1    u8 QuickCharge (???)  ;TSC[65h:42h].bit0-1
  2E8h 1    u8 PGA_GAIN (mic)     ;TSC[65h:41h].bit0-5
  2E9h 3    u8 reserved[3]
  2ECh 1Eh  s16 FilterHP32[3*5]   ;TSC[0Bh:02h..1Fh] and TSC[0Bh:42h..5Fh]
  30Ah 1Eh  s16 FilterHP47[3*5]   ;TSC[0Bh:20h..3Dh] and TSC[0Bh:60h..7Dh]
  328h 1Eh  s16 FilterSP32[3*5]   ;TSC[0Ch:02h..1Fh] and TSC[0Ch:42h..5Fh]
  346h 1Eh  s16 FilterSP47[3*5]   ;TSC[0Ch:20h..3Dh] and TSC[0Ch:60h..7Dh]
  364h 38h  s16 FilterMic32[3+5*5];TSC[05h:08h..3Fh]
  39Ch 38h  s16 FilterMic47[3+5*5];TSC[05h:48h..7Fh]
  3D4h 38h  s16 FilterFree [3+5*5];TSC[08h:xxh, 09h;xxh, 0Ah:xxh]
  40Ch 1    u8 AnalogInterval     ;TSC[67h:27h].lsbs ;\
  40Dh 1    u8 AnalogStabilize    ;TSC[67h:19h].lsbs ;
  40Eh 1    u8 AnalogPrecharge    ;TSC[67h:17h].msbs ; Touchscreen/CirclePad
  40Fh 1    u8 AnalogSense        ;TSC[67h:17h].lsbs ;
  410h 1    u8 AnalogDebounce     ;TSC[67h:1Bh].lsbs ;
  411h 1    u8 Analog_XP_Pullup   ;TSC[67h:19h].msbs ;
  412h 1    u8 YM_Driver          ;TSC[67h:1Bh].msb  ;/
  413h 1    u8 reserved
  414h 2    Checksum?
  416h 2    Zero
```



## Programmable Infrared Transmitter (PIT) -- New3DS only (zerofilled on Old3DS)


```
  418h 2    u16 VisibleFactor
  41Ah 2    u16 IRFactor
  41Ch 2    Value Zero (hmmm, uncommonly... not set to Value 0001h ?)
  41Eh 2    Checksum?
```



## 3D filters ;uh, is that 3d video? and/or 3d surround audio?


```
  420h 200h u16 SpecialFilter[0x100] <-- Old3DS: mostly zero, unlike New3DS
  620h 14h  u32 IIRSurroundFilter[5] <-- both Old3DS and New3DS
  634h 2    Checksum?
  636h 0Ah  Zero
```



## Power saving mode (ABL)


```
  640h 4    u32 DitherPattern
  644h 2    s16 StartX
  646h 2    s16 StartY
  648h 2    u16 SizeX
  64Ah 2    u16 SizeY
  64Ch 2    s16 GTH_Ratio
  64Eh 1    u8 DitherMode
  64Fh 1    u8 MinRS
  650h 1    u8 MaxRS
  651h 1    u8 MinGTH
  652h 1    u8 MinMax (???)
  653h 1    u8 ExMax (???)
  654h 1    u8 inertia
  655h 9    u8 LutListRS[9]
  65Eh 2    u8 reserved[2]
  660h 2    Checksum?
  662h 0Eh  Zero
```



## Stereo Display Settings


```
  670h 20h  Float values? (see config file)
  690h 2    Checksum?
  692h 0Eh  Zero
```



## Backlight PWM (BLPWM) ;uh, which backlight/mode(s)? Upper2D, Upper3D, Lower?


```
  6A0h 24h  float coefficient[3][3]
  6C4h 1    u8 NumLevels
  6C5h 1    u8 padding
  6C6h 0Eh  u16 brightnesses[7]
  6D4h 2    u16 BaseDivisor
  6D6h 2    u16 MinimumBrightnessHw
  6D8h 2    Checksum?
  6DAh 06h  Zero
```



## Circle Pad (part 2)


```
  6E0h 4    float ScaleX
  6E4h 4    float ScaleY
  6E8h 2    s16 MaxX
  6EAh 2    s16 MinX
  6ECh 2    s16 MaxY
  6EEh 2    s16 MinY
  6F0h 2    s16 type
  6F2h 6    u8 unknown_padding[6]
  6F8h 2    Checksum?
  6FAh 06h  Zero
```



## Unknown ???


```
  700h 0Ch  ???
  70Ch 2    Checksum?
  70Eh 2    Zero
```



## Unknown ???


```
  710h 20h  ???
  730h 2    Checksum?
  732h 0Eh  Zero
```



## MCU


```
  740h 2    s16 SVR2_Min (???)
  742h 2    s16 SVR2_Max (???)
  744h 2    s16 VolumeSliderMin      (maybe for MCU[58h] ?)
  746h 2    s16 VolumeSliderMax      (maybe for MCU[59h] ?)
  748h 2    Value 0001h (?)
  74Ah 2    Checksum?
  74Ch 4    Zero
```



## 3D screen (ULCD) delay


```
  750h 1    u8 To2D
  751h 1    u8 To3D
  752h 2    Value 0001h (?)
  754h 2    Checksum?
  756h 0Ah  Zero
```



## Microphone echo cancel


```
  760h 8    s8 params[8]
  768h 2    Value 0001h (?)
  76Ah 2    Checksum?
  76Ch 4    Zero
```



## Power saving mode (ABL) extra -- New3DS only (zerofilled on Old3DS)


```
  770h 1    u8 MaxInertia
  771h 1    u8 pad
  772h 2    u16 PWM_CNT_EX
  774h 4    u32 Histogram1
  778h 4    u32 Histogram2
  77Ch 100h u32 adjust[0x40]
  87Ch 2    Value 0001h (?)
  87Eh 2    Checksum?
```



## CStick (Right stick) -- New3DS only (zerofilled on Old3DS)


```
  880h 1    u8 ThinningCountX(???)
  881h 1    u8 ThinningCountY(???)
  882h 6    u16 reserved[3]
  888h 2    Value 0001h (?)
  88Ah 2    Checksum?
  88Ch 4    Zero
```



## Quad Tracking Module (QTM) -- New3DS only (zerofilled on Old3DS)


```
  890h 4    float DivisorAtZero (???)
  894h 4    float TranslationX
  898h 4    float TranslationY
  89Ch 4    float RotationZ
  8A0h 4    float HorizontalAngle
  8A4h 4    float OptimalDistance
  8A8h 2    Value Zero (hmmm, uncommonly... not set to Value 0001h ?)
  8AAh 2    Checksum?
  8ACh 124h Zero
```



## Unknown things


The HMAC key for header signature is unknown.

The Checksum function is unknown (for 1-2 byte sections it's just the 1-2
byte(s) XORed FFh).

The purpose of most entries is unknown.

Unknown how to read the EEPROM data (maybe similar as for Wifi EEPROM?).

Unknown what size EEPRM has (apparently at least 1000h bytes).

Unknown if EEPROM has any header (maybe only 30h bytes instead 200h bytes?).




# <a name="3dsfilesconfigsavegame"></a>3DS Files - Config Savegame



This page describes the format of the Cfg NAND savegame. These blocks can be
accessed with the Cfg service commands.


The data is stored in "3ds:\data\\<ID0>\sysdata\00010017\00000000" (which
is a DISA file with SAVE filesystem, containing only one file, ie. the "config"
file described below).



## Structure of save-file "/config"


```
  Offset Size   Description
  0000h  2      Total entries (N) (usually 32h..41h)
  0002h  2      End of unused space, begin of Data (455Ch..41E4h)
  0004h  N*0Ch  Block entries
  ...    ...    Unused space
  455Ch         Data for the entries (used from top, starting at 7FFFh)
```

The filesize for this /config file is 0x8000-bytes.



## Configuration block entry


```
  00h 4  BlkID (00xx000xh)
  04h 4  Offset to the data for this block when size is >4, otherwise
           this word is the data for this block
  08h 2  Size
  0Ah 2  Flags (usually 000Ch or 000Eh, unknown meaning)
```



## Configuration blocks


```
  BlkID   Flags Size Description
  00000000h 0Ch 2    Config savegame version? (0015h or 0039h)
  00010000h 0Ch 1    RTC Compensation Value (usually 80h)
  00020000h 0Ch 134h Codec
  00030000h 0Ch 1    Leap Year Counter (read By PTM)
  00030001h 0Eh 08h  User time offset (read by CECD): displayed_time-rtc_time
  00030002h 0Ch 08h  Settings time offset: newly_set_time-rtc_time
  00040000h 0Ch 10h  Touch calibration (read by HID)
  00040001h 0Ch 1Ch  Analog Stick Calibration Param? (read by HID)
  00040002h 0Ch 12h  Gyroscope (read by HID)
  00040003h 0Ch 0Ch  Accelerometer (read by HID)
  00040004h 0Ch 1Ch  CStick calibration data
  00050000h 0Ch 2    Screen flicker
  00050001h 0Ch 2    Backlight controls (read by GSP)
                       (u8 ABL_powersave_enable, u8 brightness_level)
  00050002h 0Ch 38h  Backlight PWM (read by GSP)
  00050003h 0Ch 20h  Power saving mode (ABL) calibration (read by GSP)
  00050004h 0Ch 20h  Power saving mode (ABL) calibration
  00050005h 0Eh 20h  Stereo Display Settings (HWCAL block 0x470)
  00050006h 0Ch 2    3D switching delay (two bytes: To2D, To3D)
  00050007h 0Ch 4    ?
  00050008h 0Ch 10Ch Power saving mode (ABL) extra config
  00050009h 0Ch 08h  new3DS only(?) backlight control
                       (5th byte: auto-brightness enable)
  00060000h 0Ch 96h  ??? (HWCAL block 0x500) (but, that HWCAL is smaller?)
  00070000h 0Eh 214h 3D filters ... maybe this is "Surround"?
  00070001h 0Eh 1    Sound output mode (mono=0, stereo=1, surround=2)
  00070002h 0Eh 08h  Microphone echo cancellation params
  00080000h 0Ch C00h WiFi configuration slot 0
  00080001h 0Ch C00h WiFi configuration slot 1
  00080002h 0Ch C00h WiFi configuration slot 2
  00090000h 0Eh 08h  This contains a u64 ID, used by processes using
                       NWMUDS:InitializeWithVersion. The first word is the
                       same as LocalFriendCodeSeed, while the latter is a
                       separate word.
  00090001h 0Eh 08h  Same content as 0x0009000? This console-unique u64 is
                       used by GenHashConsoleUnique. It is generated by
                       ((3FFFFFFFFh) & LocalFriendCodeSeed) | (random16 << 48))
                       where random16 is generated by GenerateRandomBytes
  00090002h 0Eh 4    The first two bytes are the same random16 used in
                       0x00090001. The second two bytes are zeros.
  000A0000h 0Eh 1Ch  Username in UTF16
  000A0001h 0Eh 2    Birthday (u8 month, u8 day)
  000A0002h 0Eh 1    Language
  000B0000h 0Eh 4    CountryInfo
  000B0001h 0Eh 800h Country name in UTF-16, every 0x80-bytes is an entry for
                       each language, in the order of the Language table below
                       (not all entries are set)
  000B0002h 0Eh 800h State name in UTF-16, every 0x80-bytes is an entry for
                       each language
  000B0003h 0Eh 4    Coordinates. A pair of s16 represents latitude and
                       longitude, respectively. One need to multiply both
                       value by 180/32768 to get coordinates in degrees
  000C0000h 0Eh C0h  Restricted photo exchange data, and other info (includes
                       a mirror of Parental Restrictions PIN/Secret Answer)
  000C0001h 0Eh 14h  COPPACS restriction data
  000C0002h 0Eh 200h ? Contains the email address set during Parental
                        Restriction setup.
  000D0000h 0Eh 4    u16 at offset 0x0: EULA Version which was agreed to.
  000E0000h 0Eh 1    ?
  000F0000h 0Ch 10h  Debug configuration, read by NS on dev-units: on startup,
                       NS does svcKernelSetState(6, 1, (u64)debug_flags & 1);
                       svcKernelSetState(6, 2, (u64)debug_flags & 2); (see
                       here) where debug_flags is the u32 located at offset
                       0xC in this struct. Then it compares the u32 from +8 in
                       this config-block with the APPMEMTYPE. When those don't
                       match NS starts a FIRM-launch (with the same FIRM
                       titleID as the currently running one) to boot into a
                       FIRM with the APPMEMTYPE value from this config-block.
                       The byte at offset 0 is related to the memtype as well.
  000F0001h 0Ch 8    ?
  000F0003h 0Ch 1    ?
  000F0004h 0Ch 4    System-Model value byte, followed by 3 unknown bytes
  000F0005h 0Ch 4    The first u8 indicates whether network updates are
                       enabled (however, NIM only checks this flag with
                       developer ENVINFO).
  000F0006h 0Ch 28h  In NIM, taken as a (hopefully null terminated) string
                       used for the "X-Device-Token" http header field for
                       NPNS url.
  00100000h 0Ch 2    ?
  00100001h 0Ch 94h  Parental Restrictions PIN/Secret Answer and other info
  00100002h 0Ch 1    ?
  00100003h 0Ch 10h  ?
  00110000h 0Ch 4    The low u16 indicates whether the system setup is
                       required, such as when the system is booted for the
                       first time or after doing a System Format
                       (0=Setup required, non-zero=No setup required)
  00110001h 0Ch 8    TitleID of the menu to launch, used by NS on dev units
                       (this block can be edited on dev units with Config)
  00120000h 0Ch 8    Volume Slider Bounds (Read by HID and PTM)
  00130000h 0Eh 4    If response is 0x100 then debug mode is enabled.
  00150000h 0Ch 4    ?
  00150001h 0Ch 8    ?
  00150002h 0Eh 4    In NIM, taken as an u32, using the low u16, casted to a
                       char, and turned lower case for the making of the url
                       for NPNS.
  00160000h 0Eh 4    Unknown, first byte is used by config service-cmd
                       0x00070040. (Unknown whether the last 3-bytes are used)
  00170000h 0Eh 4    Miiverse (OLV) access key
  00180000h 0Ch 4    QTM Infrared LED related, can be 0 or 1 ... maybe "PIT"?
  00180001h 0Ch 18h  QTM calibration data
  00190000h 0Ch 1    Unknown. NFC-module checks for value1/non-value1.
```

The developer unit TID block (uh, what?) only exists on developer units.



## Stereo Display Settings


All values are hard-coded in cfg module.

```
  00h    4    62.0f   assumed pupillary distance in mm?
  04h    4    289.0f  assumed distance in mm between player's eyes and
                        upper screen?
  08h    4    76.80f  width in mm    ;\size of Old3DS upper screen
  0Ch    4    46.08f  height in mm   ;/(doesn't vary for different models?)
  10h    4    10.0f
  14h    4    5.0f
  18h    4    55.58f
  1Ch    4    21.57f
```



## Languages


```
  ID      Description (two letter code... and guessed meaning)
  0  =    JP Japanese
  1  =    EN English
  2  =    FR French
  3  =    DE German
  4  =    IT Italian
  5  =    ES Spanish
  6  =    ZH ...maybe a widespread chinese dialect...?
  7  =    KO Korean
  8  =    NL Dutch
  9  =    PT Portugese
  10 =    RU Russian
  11 =    TW ...maybe a taiwanese chinese dialect...?
```



## CountryInfo


```
  00h 1   ?
  01h 1   ?
  02h 1   State/Province code
  03h 1   Country code, same as DSi/Wii country codes. Value 0xFF is invalid.
```



## 0x000A0000 Block


```
  00h 14h  UTF-16 username, with no NULL-terminator (uh, what if shorter?)
  14h 4    Usually zero?
  18h 4    u32 NGWord version the username was last checked with. If this
             value is less than the u32 stored in the NGWord CFA
             "romfs:/version.dat", the system then checks the username
             string with the bad-word list CFA again, then updates this field
             with the value from the CFA
```



## WiFi Slot Structure


```
  000h   2     Unknown? (can be 0001h)
  002h   2     CRC-16 checksum of the next 410h bytes (unknown initial value)
  004h   88h   First network structure. Only set if the network was set
                 "normally", or was the last to be set using WPS during the
                 session
  08Ch   20h   Padding
  0ACh   88h   Second network structure. Only set if the network was set
                 using WPS, otherwise 0-filled
  134h   20Ch  Padding
  340h   1     Obtain IP, Gateway, Subnet (0=Manual, 1=Auto/DHCP)
  341h   1     Obtain DNS Server address  (0=Manual, 1=Auto/DHCP)
  342h   2     Padding ?
  344h   4     IP address               ;\
  348h   4     Gateway                  ; used only if [340h]=00h
  34Ch   4     Subnet Mask              ;/
  350h   4     Primary DNS Server       ;\used only if [341h]=00h
  354h   4     Secondary DNS Server     ;/
  358h   4     Always 0x01050000 ?      ;\     <-- rather 00000001h (!) or 501h
  35Ch   4     IP address to use        ; Only set if the network was the
  360h   6     MAC address of the AP    ; last to be set during the session.
  366h   1     Channel (range ?..?)     ;      <-- can be 06h,0Bh
  367h   1     Padding ?                ;/
  368h   1     Proxy Enable         (00h=None, 01h=Yes)
  369h   1     Proxy Authentication (00h=None, 01h=Yes)
  36Ah   2     Proxy Port (16bit)
  36Ch   30h   Proxy Name (ASCII string, max 47 chars, padded with 00's)
  39Ch   34h   Padding
  3D0h   20h   Proxy Authentication Username (ASCII string, padded with 00's)
  3F0h   20h   Proxy Authentication Password (ASCII string, padded with 00's)
  410h   2     Padding ?
  412h   2     MTU Value (Max transmission unit) (576..1500, usually 1400)
  414h   7ECh  Padding
```

Network structure (used twice in the above WiFi slot structure):

```
  00h   1     Whether the network was set or not?
  01h   1     Whether to use this network structure to connect?
  02h   1     Whether this structure is the first (0) or the second (1) in the
                larger WiFi slot structure?
  03h   1     Padding ?
  04h   20h   SSID (ASCII string, padded with 00's) (see below for length)
  24h   1     SSID Length in characters (01h..20h, or 00h=unused)
  25h   1     AP crypto key type (maybe related to WEP/WPA bytes on NDS?)
  26h   2     Padding ?
  28h   40h   WPA/WPA2 password (ASCII string, padded with 00's)
  68h   20h   Precomputed PSK (based on WPA/WPA2 password and SSID)
```

The above data is (slightly reordered) also stored in Wifi FLASH:

- [DS Firmware Wifi Internet Access Points](ds.html#dsfirmwarewifiinternetaccesspoints)
The DSi did have support for six access points (3xWEP and 3xWEP/WPA), unknown
if the old 3xWEP ones are still supported on 3DS, and if so, if they are also
stored in the Config Samegame file.



## LCD display config


There seems to be some sort of LCD display configuration stored in this cfg.
When using the cfg-save from an Old3DS on a New3DS without formatting the cfg
first, the bottom-screen display is somewhat off (which is fixed by formatting
the cfg-save).



## Parental control Block 0x00100001


```
  00h   0Dh  Unknown
  0Dh   4    PIN
  11h   20h  Secret answer in UTF-16
```



## Parental Control setting block 0xC0000


```
  00h   4    Parental Control restriction bitmask
  04h   ...     ?
  0Ch   4    Parental Controls PIN code
```



## Parental Control restriction bitmask (?=Allow, ?=Disallow)


```
  Bit     Restriction name
  0       Global Parental Controls enable
  3       Sharing Images/Audio/Video/Long Text Data
  4       Internet Browser
  5       StreetPass
  6       Friend Registration
  8       eShop
  10      Miiverse (view)
  11      Miiverse (post)
  31      "Child Online Privacy Protection" (see CFG:IsCoppacsSupported)
```




# <a name="3dsfilestitleids"></a>3DS Files - Title IDs




## 3DS Partition Files/Folders


```
  3ds:\__journal.nn_                       file?
  3ds:\data\<ID0>\extdata\00048000\..      savedata files  ;\note: <ID0> comes
  3ds:\data\<ID0>\sysdata\..               savedata files  ;/from movable.sed
  3ds:\dbs\certs.db                        database?
  3ds:\dbs\import.db                       database?
  3ds:\dbs\ticket.db                       database? (insane 37Mbyte file???)
  3ds:\dbs\title.db                        database?
  3ds:\dbs\tmp_i.db                        database?
  3ds:\dbs\tmp_t.db                        database?
  3ds:\fixdata\sysdata\                    empty folder
  3ds:\private\movable.sed                 file?
  3ds:\ro\private\                         empty folder
  3ds:\ro\shared\                          empty folder
  3ds:\ro\sys\HWCAL0.dat                   hardware calibration data
  3ds:\ro\sys\HWCAL1.dat                   hardware calibration data copy
  3ds:\rw\shared\                          empty folder
  3ds:\rw\sys\lgy.log                      log file for DSi ErrDisp?
  3ds:\rw\sys\LocalFriendCodeSeed_B        seed file?
  3ds:\rw\sys\native.log (if any)          log file for 3DS ErrDisp?
  3ds:\rw\sys\rand_seed                    seed file?
  3ds:\rw\sys\SecureInfo_A                 Region and Serial/Barcode
  3ds:\rw\sys\updater.log                  log file?
  3ds:\ticket\                             empty folder
  3ds:\title\00040010\..                   System Applications
  3ds:\title\0004001b\..                   System Data Archives 1
  3ds:\title\00040030\..                   System Applets
  3ds:\title\0004009b\..                   Shared Data Archives
  3ds:\title\000400db\..                   System Data Archives 2
  3ds:\title\00040130\..                   System Modules
  3ds:\title\00040138\..                   System Firmware
  3ds:\tmp\title.tik                       temporary file?
```



## DSi 1st Partition Files/Folders on 3DS


```
  dsi:\import\                             empty folder
  dsi:\shared1\                            empty folder
  dsi:\shared2\0000                        sound recorder data
  dsi:\sys\log\inspect.log                 log file
  dsi:\sys\log\inspect.log~                log file
  dsi:\sys\log\product.log                 log file
  dsi:\sys\log\product.log~                log file
  dsi:\sys\TWLFontTable.dat                font file
  dsi:\ticket\                             empty folder
  dsi:\title\00030005\42383841\..          DS Internet settings for 3DS
  dsi:\title\00030005\484e4441\..          DS Download Play
  dsi:\title\0003000f\484e4841\..          DS Cart Whitelist
  dsi:\title\0003000f\484e4c41\..          DSi Version Data
  dsi:\tmp\                                empty folder
```



## DSi 2nd Partition Files/Folders on 3DS


```
  photo:\photo\private\ds\app\484E494A\pit.bin   camera info
```



## 3ds:\title\00040010\.. System Applications


```
  00020000 System Settings, mset JPN       ;\
  00021000 System Settings, mset USA       ;
  00022000 System Settings, mset EUR       ; System Settings (mset)
  00026000 System Settings, mset CHN       ; CTR-N-HASx
  00027000 System Settings, mset KOR       ;
  00028000 System Settings, mset TWN       ;/
  00020100 Download Play, dlplay JPN       ;\
  00021100 Download Play, dlplay USA       ;
  00022100 Download Play, dlplay EUR       ; Download Play (dlplay)
  00026100 Download Play, dlplay CHN       ; CTR-N-HDLx
  00027100 Download Play, dlplay KOR       ;
  00028100 Download Play, dlplay TWN       ;/
  00020200 Activity Log JPN                ;\
  00021200 Activity Log USA                ;
  00022200 Activity Log EUR                ; Activity Log
  00026200 Activity Log CHN                ; CTR-N-HMKx
  00027200 Activity Log KOR                ;
  00028200 Activity Log TWN                ;/
  00020300 Health Safety, safe JPN         ;\
  00021300 Health Safety, safe USA         ;
  00022300 Health Safety, safe EUR         ; Health and Safety Info (safe)
  00026300 Health Safety, safe CHN         ; CTR-N-HACx
  00027300 Health Safety, safe KOR         ;
  00028300 Health Safety, safe TWN         ;
  20020300 Health Safety, safe JPN New3DS  ;
  20021300 Health Safety, safe USA New3DS  ;
  20022300 Health Safety, safe EUR New3DS  ;
  N/A      Health Safety, safe CHN New3DS  ;
  20027300 Health Safety, safe KOR New3DS  ;
  N/A      Health Safety, safe TWN New3DS  ;/
  00020400 Nintendo 3DS Camera, CtrApp JPN ;\
  00021400 Nintendo 3DS Camera, CtrApp USA ;
  00022400 Nintendo 3DS Camera, CtrApp EUR ; Nintendo 3DS Camera (CtrApp)
  00026400 Nintendo 3DS Camera, CtrApp CHN ; CTR-N-HEPx
  00027400 Nintendo 3DS Camera, CtrApp KOR ;
  00028400 Nintendo 3DS Camera, CtrApp TWN ;/
  00020500 Nintendo 3DS Sound, CtrApp JPN  ;\
  00021500 Nintendo 3DS Sound, CtrApp USA  ;
  00022500 Nintendo 3DS Sound, CtrApp EUR  ; Nintendo 3DS Sound (CtrApp)
  00026500 Nintendo 3DS Sound, CtrApp CHN  ; CTR-N-HESx
  00027500 Nintendo 3DS Sound, CtrApp KOR  ;
  00028500 Nintendo 3DS Sound, CtrApp TWN  ;/
  00020700 Mii Maker, EDIT JPN             ;\
  00021700 Mii Maker, EDIT USA             ;
  00022700 Mii Maker, EDIT EUR             ; Mii Maker (EDIT)
  00026700 Mii Maker, EDIT CHN             ; CTR-N-HEDx
  00027700 Mii Maker, EDIT KOR             ;
  00028700 Mii Maker, EDIT TWN             ;/
  00020800 StreetPass Mii Plaza, MEET JPN  ;\
  00021800 StreetPass Mii Plaza, MEET USA  ;
  00022800 StreetPass Mii Plaza, MEET EUR  ; StreetPass Mii Plaza (MEET)
  00026800 StreetPass Mii Plaza, MEET CHN  ; CTR-N-HMEx
  00027800 StreetPass Mii Plaza, MEET KOR  ;
  00028800 StreetPass Mii Plaza, MEET TWN  ;/
  00020900 eShop, tiger JPN                ;\
  00021900 eShop, tiger USA                ;
  00022900 eShop, tiger EUR                ; eShop (tiger)
  N/A      eShop, tiger CHN                ; CTR-N-HGRx
  00027900 eShop, tiger KOR                ;
  00028900 eShop, tiger TWN                ;/
  00020a00 System Transfer, CARDBOARD JPN  ;\
  00021a00 System Transfer, CARDBOARD USA  ;
  00022a00 System Transfer, CARDBOARD EUR  ; System Transfer (CARDBOARD)
  N/A      System Transfer, CARDBOARD CHN  ; CTR-N-HCBx
  00027a00 System Transfer, CARDBOARD KOR  ;
  00028a00 System Transfer, CARDBOARD TWN  ;/
  00020b00 Nintendo Zone, Nintendo JPN     ;\
  00021b00 Nintendo Zone, Nintendo USA     ;
  00022b00 Nintendo Zone, Nintendo EUR     ; Nintendo Zone ("Nintendo")
  N/A      Nintendo Zone, Nintendo CHN     ; CTR-N-HMAx
  N/A      Nintendo Zone, Nintendo KOR     ;
  N/A      Nintendo Zone, Nintendo TWN     ;/
  00020d00 Face Raiders JPN                ;\
  00021d00 Face Raiders USA                ;
  00022d00 Face Raiders EUR                ; Face Raiders
  00026d00 Face Raiders CHN                ; CTR-N-HCHx
  00027d00 Face Raiders KOR                ;
  00028d00 Face Raiders TWN                ;
  20020d00 Face Raiders JPN New3DS         ;
  20021d00 Face Raiders USA New3DS         ;
  20022d00 Face Raiders EUR New3DS         ;
  N/A      Face Raiders CHN New3DS         ;
  20027d00 Face Raiders KOR New3DS         ;
  N/A      Face Raiders TWN New3DS         ;/
  00020e00 AR Games, AR_ACT JPN            ;\
  00021e00 AR Games, AR_ACT USA            ;
  00022e00 AR Games, AR_ACT EUR            ; AR Games (AR_ACT)
  00026e00 AR Games, AR_ACT CHN            ; CTR-N-HARx
  00027e00 AR Games, AR_ACT KOR            ;
  00028e00 AR Games, AR_ACT TWN            ;/
  00020f00 Safe mode SysUpdater, mset JPN  ;\
  00021f00 Safe mode SysUpdater, mset USA  ;
  00022f00 Safe mode SysUpdater, mset EUR  ; Safe mode System Updater (mset)
  00026f00 Safe mode SysUpdater, mset CHN  ; CTR-N-HSHx
  00027f00 Safe mode SysUpdater, mset KOR  ;
  00028f00 Safe mode SysUpdater, mset TWN  ;/
  00023000 Promotional video JPN           ;\
  00024000 Promotional video USA           ;
  00025000 Promotional video EUR           ; Promotional video
  N/A      Promotional video CHN           ; (Variable?)
  N/A      Promotional video KOR           ;
  N/A      Promotional video TWN           ;/
  0002bf00 Network ID Settings, act JPN    ;\
  0002c000 Network ID Settings, act USA    ;
  0002c100 Network ID Settings, act EUR    ; Nintendo Network ID Settings (act)
  N/A      Network ID Settings, act CHN    ; CTR-N-HAFx
  N/A      Network ID Settings, act KOR    ;
  N/A      Network ID Settings, act TWN    ;/
  20023100 New3DS microSD Management, mcopy JPN  ;\
  20024100 New3DS microSD Management, mcopy USA  ; New_3DS-only
  20025100 New3DS microSD Management, mcopy EUR  ; microSD Management ('mcopy')
  N/A      New3DS microSD Management, mcopy CHN  ; CTR-N-HAJx
  N/A      New3DS microSD Management, mcopy KOR  ;
  N/A      New3DS microSD Management, mcopy TWN  ;/
  2002c800 New3DS HOME menu/menu JPN       ;\
  2002cf00 New3DS HOME menu/menu USA       ; New_3DS-only, currently stubbed
  2002d000 New3DS HOME menu/menu EUR       ; "HOME menu/menu"
  N/A      New3DS HOME menu/menu CHN       ; Contains information manual data
  2002d700 New3DS HOME menu/menu KOR       ;
  N/A      New3DS HOME menu/menu TWN       ;/ CTR-P-CTAP
  2002c900 New3DS Friends list/friend JPN  ;\
  2002d100 New3DS Friends list/friend USA  ; New_3DS-only, currently stubbed
  2002d200 New3DS Friends list/friend EUR  ; "Friends list/friend"
  N/A      New3DS Friends list/friend CHN  ; Contains information manual data
  2002d800 New3DS Friends list/friend KOR  ;
  N/A      New3DS Friends list/friend TWN  ;/ CTR-P-CTAP
  2002ca00 New3DS Notifications/newslist JPN ;\
  2002d300 New3DS Notifications/newslist USA ; New_3DS-only, currently stubbed
  2002d400 New3DS Notifications/newslist EUR ; "Notifications/newslist"
  N/A      New3DS Notifications/newslist CHN ; Contains information manual data
  2002d900 New3DS Notifications/newslist KOR ;
  N/A      New3DS Notifications/newslist TWN ;/ CTR-P-CTAP
  2002cb00 New3DS Game notes/cherry JPN    ;\
  2002d500 New3DS Game notes/cherry USA    ; New_3DS-only, currently stubbed
  2002d600 New3DS Game notes/cherry EUR    ; "Game notes/cherry"
  N/A      New3DS Game notes/cherry CHN    ; Contains information manual data
  2002da00 New3DS Game notes/cherry KOR    ;
  N/A      New3DS Game notes/cherry TWN    ;/ CTR-P-CTAP
```



## 3ds:\title\0004001b System Data Archives 1


```
  00010002 ClCertA, Client Cert/Keys       ;-contains ".der" files
  00010702 NS CFA
  00010802 Dummy (dummy.txt)
  00018002 web-browser data for NNID / networking, etc.
  00018102 web-browser data for Miiverse offline mode, local web
  00018202 web-kit/OSS CROs for Miiverse applet and "act"
  00019002 Fangate_updater
```



## 3ds:\title\00040030 System Applets


```
  00008102 Test Menu, Demo1 ALL                 ;-CTR-P-CTAP
  00008202 Home Menu, menu JPN                  ;\
  00008f02 Home Menu, menu USA                  ;
  00009802 Home Menu, menu EUR                  ; Home Menu (menu)
  0000a102 Home Menu, menu CHN                  ; CTR-P-HMMx
  0000a902 Home Menu, menu KOR                  ;
  0000b102 Home Menu, menu TWN                  ;/
  00008402 Camera applet JPN                    ;\
  00009002 Camera applet USA                    ; Camera applet (CtrApp)
  00009902 Camera applet EUR                    ; used by Home-menu
  0000a202 Camera applet CHN                    ; CTR-N-HCSx
  0000aa02 Camera applet KOR                    ;
  0000b202 Camera applet TWN                    ;/
  00008502  JPN                                 ;\
  00009102  USA                                 ;
  00009a02  EUR                                 ; whatever
  ?         CHN                                 ; not available on CDN
  ?         KOR                                 ;
  ?         TWN                                 ;/
  00008602 Instruction Manual JPN               ;\
  00009202 Instruction Manual USA               ;
  00009b02 Instruction Manual EUR               ; Instruction Manual viewer
  0000a402 Instruction Manual CHN               ; CTR-N-HMVx
  0000ac02 Instruction Manual KOR               ;
  0000b402 Instruction Manual TWN               ;/
  00008702 Game Notes, Cherry JPN               ;\
  00009302 Game Notes, Cherry USA               ;
  00009c02 Game Notes, Cherry EUR               ; Game Notes (Cherry)
  0000a502 Game Notes, Cherry CHN               ; CTR-N-HGMx
  0000ad02 Game Notes, Cherry KOR               ;
  0000b502 Game Notes, Cherry TWN               ;/
  00008802 Internet Browser, spider JPN         ;\
  00009402 Internet Browser, spider USA         ;
  00009d02 Internet Browser, spider EUR         ; Internet Browser (spider)
  0000a602 Internet Browser, spider CHN         ;
  0000ae02 Internet Browser, spider KOR         ;
  0000b602 Internet Browser, spider TWN         ;/
  20008802 Internet Browser, SKATER JPN New3DS  ;\
  20009402 Internet Browser, SKATER USA New3DS  ; New 3DS
  20009d02 Internet Browser, SKATER EUR New3DS  ; Internet Browser (SKATER)
  ?        Internet Browser, SKATER CHN New3DS  ; CTR-N-HBRx
  2000ae02 Internet Browser, SKATER KOR New3DS  ;
  N/A      Internet Browser, SKATER TWN New3DS  ;/
  00008a02 ErrDisp ALL                          ;\Fatal error viewer, ErrDisp
  00008a03 ErrDisp ALL Safe mode                ;/
  20008a03 ErrDisp JPN Safe mode New3DS         ;\
  20008a03 ErrDisp USA Safe mode New3DS         ;
  20008a03 ErrDisp EUR Safe mode New3DS         ; ErrDisp Safe mode New3DS
  ?        ErrDisp CHN Safe mode New3DS         ;
  20008a03 ErrDisp KOR Safe mode New3DS         ;
  N/A      ErrDisp TWN Safe mode New3DS         ;/
  00008d02 Friend List, friend JPN              ;\
  00009602 Friend List, friend USA              ;
  00009f02 Friend List, friend EUR              ; Friend List (friend)
  0000a702 Friend List, friend CHN              ; CTR-N-HFRx
  0000af02 Friend List, friend KOR              ;
  0000b702 Friend List, friend TWN              ;/
  00008e02 Notifications, newslist JPN          ;\
  00009702 Notifications, newslist USA          ;
  0000a002 Notifications, newslist EUR          ; Notifications (newslist)
  0000a802 Notifications, newslist CHN          ; CTR-N-HCRx
  0000b002 Notifications, newslist KOR          ;
  0000b802 Notifications, newslist TWN          ;/
  0000c002 Keyboard, swkbd JPN                  ;\
  0000c802 Keyboard, swkbd USA                  ;
  0000d002 Keyboard, swkbd EUR                  ; Software Keyboard (swkbd)
  0000d802 Keyboard, swkbd CHN                  ; CTR-N-HKYx
  0000de02 Keyboard, swkbd KOR                  ;
  0000e402 Keyboard, swkbd TWN                  ;
  0000c003 Keyboard, swkbd JPN Safe mode        ;
  0000c803 Keyboard, swkbd USA Safe mode        ;
  0000d003 Keyboard, swkbd EUR Safe mode        ;
  0000d803 Keyboard, swkbd CHN Safe mode        ;
  0000de03 Keyboard, swkbd KOR Safe mode        ;
  0000e403 Keyboard, swkbd TWN Safe mode        ;
  2000c003 Keyboard, swkbd JPN Safe mode New3DS ;
  2000c803 Keyboard, swkbd USA Safe mode New3DS ;
  2000d003 Keyboard, swkbd EUR Safe mode New3DS ;
  ?        Keyboard, swkbd CHN Safe mode New3DS ;
  2000de03 Keyboard, swkbd KOR Safe mode New3DS ;
  N/A      Keyboard, swkbd TWN Safe mode New3DS ;/
  0000c102 Mii picker, appletEd JPN             ;\
  0000c902 Mii picker, appletEd USA             ;
  0000d102 Mii picker, appletEd EUR             ; Mii picker (appletEd)
  0000d902 Mii picker, appletEd CHN             ; CTR-N-HMSx
  0000df02 Mii picker, appletEd KOR             ;
  0000e502 Mii picker, appletEd TWN             ;/
  0000c302 Picture picker, PNOTE_AP JPN         ;\
  0000cb02 Picture picker, PNOTE_AP USA         ;
  0000d302 Picture picker, PNOTE_AP EUR         ; Picture picker (PNOTE_AP)
  0000db02 Picture picker, PNOTE_AP CHN         ; CTR-N-HCCx
  0000e102 Picture picker, PNOTE_AP KOR         ;
  0000e702 Picture picker, PNOTE_AP TWN         ;/
  0000c402 Voice memo picker, SNOTE_AP JPN      ;\
  0000cc02 Voice memo picker, SNOTE_AP USA      ;
  0000d402 Voice memo picker, SNOTE_AP EUR      ; Voice memo picker (SNOTE_AP)
  0000dc02 Voice memo picker, SNOTE_AP CHN      ; CTR-N-HMCx
  0000e202 Voice memo picker, SNOTE_AP KOR      ;
  0000e802 Voice memo picker, SNOTE_AP TWN      ;/
  0000c502 error display JPN-USA-EUR            ;\
  0000cf02 error display CHN-KOR-TWN            ;
  0000c503 error display JPN-USA-EUR Safe mode  ; Non-critical error display
  0000cf03 error display CHN-KOR-TWN Safe mode  ; (error) (online, etc)
  2000c503 error display JPN New3DS Safe mode   ; CTR-N-HEEx
  2000c503 error display USA New3DS Safe mode   ;
  2000c503 error display EUR New3DS Safe mode   ;
  ?        error display CHN New3DS Safe mode   ;
  2000cf03 error display KOR New3DS Safe mode   ;
  N/A      error display TWN New3DS Safe mode   ;/
  0000cd02 extrapad JPN-USA-EUR                 ;\Circle Pad Pro (extrapad)
  0000d502 extrapad CHN-KOR-TWN                 ;/CTR-N-HADx test/calibration
  0000c602 eShop applet JPN                     ;\eShop applet (mint), used by
  0000ce02 eShop applet USA                     ; applications for accessing
  0000d602 eShop applet EUR                     ; the eShop, for DLC/etc.
  N/A      eShop applet CHN                     ; Also used by the eShop
  0000e302 eShop applet KOR                     ; application itself
  0000e902 eShop applet TWN                     ;/CTR-N-HAAx
  0000bc02 Miiverse, olv JPN                    ;\
  0000bd02 Miiverse, olv USA                    ;
  0000be02 Miiverse, olv EUR                    ; Miiverse (olv)
  ?        Miiverse, olv CHN                    ; CTR-N-HAEx
  N/A      Miiverse, olv KOR                    ;
  ?        Miiverse, olv TWN                    ;/
  0000f602 Miiverse, memolib or so JPN-USA-EUR  ;\Likely the "system library"
  ?        Miiverse, memolib or so  CHN         ; for Miiverse (memolib)
  N/A      Miiverse, memolib or so  KOR         ; CTR-N-HAGA
  ?        Miiverse, memolib or so  TWN         ;/
  00008302 Miiverse-posting applet, solv3 JPN   ;\
  00008b02 Miiverse-posting applet, solv3 USA   ; In-app Miiverse-posting
  0000ba02 Miiverse-posting applet, solv3 EUR   ; applet (solv3)
  ?        Miiverse-posting applet, solv3 CHN   ; CTR-N-HAHx
  N/A      Miiverse-posting applet, solv3 KOR   ;
  ?        Miiverse-posting applet, solv3 TWN   ;/
  00009502 Cabinet, amiibo Settings JPN         ;\
  00009e02 Cabinet, amiibo Settings USA         ;
  0000b902 Cabinet, amiibo Settings EUR         ; Cabinet (amiibo Settings)
  ?        Cabinet, amiibo Settings CHN         ; CTR-N-HA3x
  00008c02 Cabinet, amiibo Settings KOR         ;
  0000bf02 Cabinet, amiibo Settings TWN         ;/
```



## 3ds:\title\0004009b Shared Data Archives


```
  00010202 Probably Mii-related                 ;-RomFS contains "CFL_Res.dat"
  00010402 Region Manifest aka area             ;-Mounted as "area:"
  00010602 Non-Nintendo TLS Root-CA Certificates;-RomFS contains ".der" files
  00011002 Dictionary CHN-CH      CHN           ;\
  00011102 Dictionary TWN-TW      TWN           ;
  00011202 Dictionary NL-NL       EUR           ;
  00011302 Dictionary EN-GB       EUR           ;
  00011402 Dictionary EN-US       USA           ;
  00011502 Dictionary FR-FR       EUR           ; Dictionary
  00011602 Dictionary FR-CA       USA           ;
  00011702 Dictionary DE-regular  EUR           ;
  00011802 Dictionary IT-IT       EUR           ;
  00011902 Dictionary JA-small-32 JPN           ;
  00011a02 Dictionary KO-KO       KOR           ;
  00011b02 Dictionary PT-PT       EUR           ;
  00011c02 Dictionary RU-regular  EUR           ;
  00011d02 Dictionary ES-ES       EUR+USA       ;
  00011e02 Dictionary PT-BR       USA           ;/
  00012202 Error Strings JPN                    ;\
  00012302 Error Strings USA                    ;
  00012102 Error Strings EUR                    ; Error Strings
  00012402 Error Strings CHN                    ;
  00012502 Error Strings KOR                    ;
  00012602 Error Strings TWN                    ;/
  00013202 Eula JPN                             ;\
  00013302 Eula USA                             ; End User blurp
  00013102 Eula EUR                             ;
  00013502 Eula CHN                             ;/
  00014002 System Font JPN-EUR-USA              ;\
  00014102 System Font CHN                      ; System Font
  00014202 System Font KOR                      ;
  00014302 System Font TWN                      ;/
  00015202 Rate or so JPN                       ;\
  00015302 Rate or so USA                       ; whatever rate
  00015102 Rate or so EUR                       ; (several CLIM files, probably
  N/A      Rate or so CHN                       ; age rating logos per country)
  00015502 Rate or so KOR                       ;
  0015602  Rate or so TWN                       ;/   ;<-- only 7 letter???
```



## 3ds:\title\000400db System Data Archives 2


```
  00010302 NGWord bad word list                 ;-
  00010502 Nintendo Zone hotspot list           ;-hotspot.conf
  00016102 NVer JPN                             ;\
  00016202 NVer USA                             ;
  00016302 NVer EUR                             ; NVer ?
  00016402 NVer CHN                             ;
  00016502 NVer KOR                             ;
  00016602 NVer TWN                             ;
  20016102 NVer JPN New3DS                      ;
  20016202 NVer USA New3DS                      ;
  20016302 NVer EUR New3DS                      ;
  N/A      NVer CHN New3DS                      ;
  20016502 NVer KOR New3DS                      ;
  N/A      NVer TWN New3DS                      ;/
  00017102 CVer JPN                             ;\
  00017202 CVer USA  ;<-- also in JPN carts?    ;
  00017302 CVer EUR                             ; CVer ?
  00017402 CVer CHN                             ;
  00017502 CVer KOR                             ;
  00017602 CVer TWN                             ;/
```



## 3ds:\title\00040130 System Modules


```
  00001002 sm               ;(Stored in NATIVE_FIRM)
  00001003 sm Safe mode     ;(Stored in NATIVE_FIRM Safe mode)
  00001102 fs               ;(Stored in NATIVE_FIRM)
  00001103 fs Safe mode     ;(Stored in NATIVE_FIRM Safe mode)
  00001202 pm               ;(Stored in NATIVE_FIRM)
  00001203 pm Safe mode     ;(Stored in NATIVE_FIRM Safe mode)
  00001302 loader           ;(Stored in NATIVE_FIRM)
  00001303 loader Safe mode ;(Stored in NATIVE_FIRM Safe mode)
  00001402 pxi              ;(Stored in NATIVE_FIRM)
  00001403 pxi Safe mode    ;(Stored in NATIVE_FIRM Safe mode)
  00001502 Application Manager, AM
  00001503 Application Manager, AM Safe mode
  20001503 Application Manager, AM Safe mode New3DS
  00001602 Camera
  20001602 Camera New3DS
  00001702 Config, cfg
  00001703 Config, cfg Safe mode
  20001703 Config, cfg Safe mode New3DS
  00001802 Codec
  00001803 Codec Safe mode
  20001803 Codec Safe mode New3DS
  00001a02 DSP
  00001a03 DSP Safe mode
  20001a03 DSP Safe mode New3DS
  00001b02 GPIO
  00001b03 GPIO Safe mode
  20001b03 GPIO Safe mode New3DS
  00001c02 GSP          ;something GPU related?
  20001c02 GSP New3DS
  00001c03 GSP Safe mode
  20001c03 GSP Safe mode New3DS
  00001d02 Human Interface Devices HID
  00001d03 Human Interface Devices HID Safe mode
  20001d03 Human Interface Devices HID Safe mode New3DS
  00001e02 i2c
  20001e02 i2c New3DS
  00001e03 i2c Safe mode
  20001e03 i2c Safe mode New3DS
  00001f02 MCU
  20001f02 MCU New3DS
  00001f03 MCU Safe mode
  20001f03 MCU Safe mode New3DS
  00002002 Microphone MIC
  00002102 PDN
  00002103 PDN Safe mode
  20002103 PDN Safe mode New3DS
  00002202 Play time PTM (pedometer, battery manager)
  20002202 Play time PTM New3DS (pedometer, battery manager)
  00002203 Play time PTM Safe mode
  20002203 Play time PTM Safe mode New3DS
  00002302 spi
  20002302 spi New3DS
  00002303 spi Safe mode
  20002303 spi Safe mode New3DS
  00002402 Network manager, AC
  00002403 Network manager, AC Safe mode
  20002403 Network manager, AC Safe mode New3DS
  00002602 Cecd (StreetPass)
  00002702 CSND
  00002703 CSND Safe mode
  20002703 CSND Safe mode New3DS
  00002802 Download Play, DLP
  00002902 HTTP
  00002903 HTTP Safe mode
  20002903 HTTP Safe mode New3DS
  00002a02 MP
  00002a03 MP Safe mode
  00002b02 NDM
  00002c02 NIM
  00002c03 NIM Safe mode
  20002c03 NIM Safe mode New3DS
  00002d02 Low-level wifi manager, NWM
  00002d03 Low-level wifi manager, NWM Safe mode
  20002d03 Low-level wifi manager, NWM Safe mode New3DS
  00002e02 Sockets
  00002e03 Sockets Safe mode
  20002e03 Sockets Safe mode New3DS
  00002f02 SSL
  00002f03 SSL Safe mode
  20002f03 SSL Safe mode New3DS
  00003000 Process9  ;Stored in ARM9 section of NATIVE_FIRM and Safe Mode FIRM
  00003102 Process Manager, PS
  00003103 Process Manager, PS Safe mode
  20003103 Process Manager, PS Safe mode New3DS
  00003202 friends (Friends list)
  00003203 friends (Friends list) Safe mode
  20003203 friends (Friends list) Safe mode New3DS
  00003302 Infrared, IR
  00003303 Infrared, IR Safe mode
  20003303 Infrared, IR Safe mode New3DS
  00003402 BOSS (SpotPass)
  00003502 News (Notifications)
  00003702 RO
  00003802 act (handles Nintendo Network accounts)
  00004002 nfc Old3DS
  20004002 nfc New3DS
  20004102 mvd New3DS
  20004202 qtm New3DS
  00008002 NS (Memory-region: "SYSTEM")
  00008003 NS (Memory-region: "SYSTEM") Safe mode
  20008003 NS (Memory-region: "SYSTEM") Safe mode New3DS
```



## 3ds:\title\00040138 System Firmware


```
  00000001 DevUnit SafeUpdater or so    ;DevUnit, similar to Safe mode_FIRM
  00000002 Native Firmware Old3DS       ;NATIVE_FIRM         (Native Firmware)
  20000002 Native Firmware New3DS       ;NATIVE_FIRM New_3DS (Native Firmware)
  00000003 Safe Mode Old3DS             ;Safe mode_FIRM
  20000003 Safe Mode New3DS             ;Safe mode_FIRM New_3DS
  00000102 TWL DSi Firmware Old3DS      ;TWL_FIRM         (DSi Firmware)
  20000102 TWL DSi Firmware New3DS      ;TWL_FIRM New_3DS (DSi Firmware)
  00000202 AGB GBA Firmware Old3DS      ;AGB_FIRM         (GBA Firmware)
  20000202 AGB GBA Firmware New3DS      ;AGB_FIRM New_3DS (GBA Firmware)
```



## 3ds:\title\00040000 Factory Test


```
  00056c00 Flipnote Studio 3D JPN                   ;\tickets exist on New3DS
  000eca00 3D demo video (paperplanes/butterflies)  ;/
  0f980000 CTRAging ("Test Program") (uh, or reportedly uppercase 0F980000 ?)
```



## 3ds:\title\00040001 Download Play Titles and Old3DS Factory OS


Normally, 00040001 is for Download Play Titles. Additionally, Old3DS has
Factory stuff in 00040001 (New3DS has the Factory OS in the "normal" locations,
ie. FIRM in 00040138, Applets in 00040030, and Modules in 00040130).



## 3ds:\title\0004000e Patches/Updates?


Whatever, patches/updates for titles in 3ds:\title\00040000 or so?



## 3ds:\data\\<ID0>\extdata\00048000:


```
  e0000000 System transfer (request transfer if file is present)
  f0000001 Camera application NAND JPEG/MPO files, phtcache.bin, UploadData.dat
  f0000002 Sound application NAND M4A files
  f0000009 SpotPass content storage for notifications
  f000000b Miis and Play/Usage Records
  f000000c Contains bashotorya.dat and bashotorya2.dat
  f000000d Home Menu SpotPass content data storage
  f000000e Update notification versionlist.dat (added in 7.0.0-13)
```



## 3ds:\data\\<ID0>\sysdata:


- System Module Savegames (0001xxxx)...
  - 0001000f reportedly SEEDDB or so
  - 00010011 FS module savedata  ;used for Anti Savegame Restore
  - 00010015 AM module savedata
  - 00010017 Config savegame      ;aka System Settings (user name, etc.)
  - 00010022 PTM savegame
  - 00010026 CECD savegame
  - 0001002c NIM savegame
  - 00010032 Friends module savegame
  - 00010034 BOSS module savegame
  - 00010035 News module savegame
  - 00010038 Act module savegame
  - 00010040 NFC module savegame
- System application and applet savegames (0002xxxx)...
  - 00020082 Home Menu savegame JPN
  - 0002008f Home Menu savegame USA
  - 00020098 Home Menu savegame EUR
  - 00020086 Instruction Manual applet savegame JPN
  - 00020092 Instruction Manual applet savegame USA
  - 0002009b Instruction Manual applet savegame EUR
  - 00020087 Game Notes applet savegame JPN
  - 00020093 Game Notes applet savegame USA
  - 0002009c Game Notes applet savegame EUR
  - 00020088 Old3DS/New3DS Internet Browser savegame JPN
  - 00020094 Old3DS/New3DS Internet Browser savegame USA
  - 0002009d Old3DS/New3DS Internet Browser savegame EUR
  - 0002008d Friend List applet savegame JPN
  - 00020096 Friend List applet savegame USA
  - 0002009f Friend List applet savegame EUR
  - 000200bb Additional savedata t.bin history for the New3DS Browser (ALL)
  - 000200bc olv applet savegame, Miiverse JPN
  - 000200bd olv applet savegame, Miiverse USA
  - 000200be olv applet savegame, Miiverse EUR
  - 000200c5 error applet savegame (ALL)
  - 000200c6 mint applet savegame (ALL)
  - 00020200 System Settings savegame JPN  ;\whatever, contains Mset.data
  - 00020210 System Settings savegame USA  ; and MsetForBoss.dat
  - 00020220 System Settings savegame EUR  ;/
  - 00020202 Activity Log application savegame JPN
  - 00020212 Activity Log application savegame USA
  - 00020222 Activity Log application savegame EUR
  - 00020204 Nintendo 3DS Camera application savegame JPN
  - 00020214 Nintendo 3DS Camera application savegame USA
  - 00020224 Nintendo 3DS Camera application savegame EUR
  - 00020205 Nintendo 3DS Sound application savegame JPN
  - 00020215 Nintendo 3DS Sound application savegame USA
  - 00020225 Nintendo 3DS Sound application savegame EUR
  - 00020207 Mii Maker application savegame JPN
  - 00020217 Mii Maker application savegame USA
  - 00020227 Mii Maker application savegame EUR
  - 00020208 StreetPass Mii Plaza application savegame JPN
  - 00020218 StreetPass Mii Plaza application savegame USA
  - 00020228 StreetPass Mii Plaza application savegame EUR
  - 00020209 eShop application savegame JPN
  - 00020219 eShop application savegame USA
  - 00020229 eShop application savegame EUR
  - 0002020a System Transfer savegame JPN
  - 0002021a System Transfer savegame USA
  - 0002022a System Transfer savegame EUR
  - 0002020b Nintendo Zone savegame JPN
  - 0002021b Nintendo Zone savegame USA
  - 0002022b Nintendo Zone savegame EUR
  - 0002020d Face Raiders savegame JPN
  - 0002021d Face Raiders savegame USA
  - 0002022d Face Raiders savegame EUR
  - 0002020e AR Games savegame JPN
  - 0002021e AR Games savegame USA
  - 0002022e AR Games savegame EUR
  - 000202bf act (NNID settings) application savegame JPN
  - 000202c0 act (NNID settings) application savegame USA
  - 000202c1 act (NNID settings) application savegame EUR
  - 00020231 microSD Management application savegame JPN
  - 00020241 microSD Management application savegame USA
  - 00020251 microSD Management application savegame EUR




# <a name="3dsfilestitlens"></a>3DS Files - Title NS



System Data Archives NS (titleID=0004001B00010702) contains 2-4 files:

```
  RomFS:\key.bin
  RomFS:\value.bin
  RomFS:\ctr_backup_black_list  ;v6.0.0 and up
  RomFS:\qtm_black_list         ;v8.1.0 and up, New3DS only
```

Most of these files seem to contain 20bit Title IDs, merged with flags in upper
bits. The 20bit IDs are taken from bit8-27 of the full 64bit Title ID:

```
  64bit: "0004xxxxxtttttxx"  -->  20bit: "ttttt"
```

A list with 64bit 3DS Title IDs can be found at 
- [http://www.3dsdb.com/](http://www.3dsdb.com/)


## key.bin


Unknown purpose, used when launching applications, contains several entries
with flags and 20bit title IDs for Ridge Racer and Zelda Ocarina of Time (for
several regions each).

```
  000h N*4  Entries (00Xttttth)
```

Original filesize was 12 bytes, changed to 48 bytes in v6.0.0, and changed to
32 bytes in later New3DS versions (and also changed the flag bits in bit20-23).
The separate entries are:

```
  12-byte    48-byte    32-byte    ;Title
  -          00000000h  -          ;Garbage?
  -          00400000h  -          ;Garbage?
  -          00800000h  -          ;Garbage?
  -          00800000h  -          ;Garbage?
  00200328h  00E00328h  00200328h  ;Ridge Racer 3D (JPN)
  -          00000334h  00400334h  ;Zelda Ocarina of Time 3D (JPN)
  -          00000335h  00400335h  ;Zelda Ocarina of Time 3D (USA)
  -          00000336h  00400336h  ;Zelda Ocarina of Time 3D (EUR)
  0020033Bh  00E0033Bh  0020033Bh  ;Ridge Racer 3D (EUR)
  00200358h  00E00358h  00200358h  ;Ridge Racer 3D (USA)
  -          000008F8h  004008F8h  ;Zelda Ocarina of Time 3D (KOR)
  -          000008F9h  004008F9h  ;Zelda Ocarina of Time 3D (CHN)
```



## value.bin


```
  000h N*8  Entries (00000000xxxxxxxxh)
```

Original filesize was 8 bytes, changed to 32 bytes in v6.0.0, and changed to 16
bytes in later New3DS versions.

- 8-bytes on Old3DS:
  - 000h 8    Unknown, 0000000047E00001h
- 32-bytes on Old3DS:
  - 000h 8    Unknown, 0000000000000002h
  - 008h 8    Unknown, 00000000002001CAh
  - 010h 8    Unknown, 0000000000000000h
  - 018h 8    Unknown, 0000000047E00001h
- 16-bytes on New3DS:
  - 000h 8    Unknown, 0000000047E00001h
  - 008h 8    Unknown, 0000000000000002h

This is used when launching applications.



## ctr\_backup\_black\_list (v6.0.0 and up)


Blacklist with 20bit Title IDs for SD Savedata Backups.

```
  000h 4    Number of entries (5Dh in v6.0.0, or 61h in later versions)
  004h 0Ch  Zero
  010h N*4  Entries (001ttttth, with ttttt=00321h..0107Ch)
```



## qtm\_black\_list (v8.1.0 and up, New3DS only)


Might be a list of 20bit Title IDs for disabling QTM (New3DS head-tracking)?

```
  000h 4    Number of entries? (04h)
  004h 0Ch  Zero
  010h N*4  Entries (001F8087h, 004F8088h, 006F8089h, 010F8090h)
```

The 20bit values in range F8000h-FEFFFh are reportedly used for "Evaluation" or
"Factory" titles, rather than retail titles?




# <a name="3dsfilessavedataextdata"></a>3DS Files - Savedata Extdata



Extdata files in FAT filesystem:

```
  ..\00000000\00000001    ;-DIFF:VSXE directory
  ..\00000000\00000002    ;-DIFF:raw_data (usually 1-byte icon?)
  ..\00000000\00000003    ;\
  ..\00000000\00000004    ; DIFF:raw_data (usually user/boss files, if any)
  ..\00000000\ (etc.)     ;/
  ..\Quota.dat            ;-DIFF:raw_data (QUOT, whatever)
```

Example content of the above DIFF:VSXE filesystem:

```
  icon                ;with 64bit VSXE.ID same as DIFI.ID of 00000000\00000002
  boss\               ;usually empty folder (used in SpotPass data)
  user\somefile.dat   ;with 64bit VSXE.ID same as DIFI.ID of 00000000\000000xx
  user\otherfile.bin  ;with 64bit VSXE.ID same as DIFI.ID of 00000000\000000xx
```



"This page describes the format and encryption of extdata, "extra data" stored
on SD card and NAND, at":

```
  3ds:\data\<ID0>\extdata\00048000\
  sd:\Nintendo 3DS\<ID0>\<ID1>\extdata\00000000\
```

"Extdata ID High is always 00000000 for SD, and always 00048000 for eMMC.
Regular apps can only mount SD extdata using the same Extdata ID which is
stored in the CXI exheader. Therefore, regular apps which have the exheader
Extdata ID set to zero can't use extdata. This restriction doesn't apply for
shared extdata with Extdata ID high "bitmask"(=?) 48000h stored on NAND. System
apps with a certain(=?) access right can mount arbitrary extdata. All NAND
extdata is shared extdata, while all SD extdata is normal extdata."



## Quota.dat File (DIFF container with 48h-byte raw data)


```
  000h 4       ID "QUOT"
  004h 4       Version (00030000h)
  008h 4       Always 1000h, maybe DIFF/VSXE cluster/block size?
  00Ch 4       Always 7Eh, maybe \00000000\ directory capacity?
  010h 4       Zero
  014h 4       Unknown (eg. 4000h, 134h, 8D9h, or 2A8h, or C8h) ;maybe max size
  018h 4       Zero
  01Ch 4       Unknown (eg. 3FC0h, 123h, 121h, or 0EEh, or B0h) ;maybe max-xx
  020h 4       Zero
  024h 4       Zero
  028h 4       Unknown (eg. 3FD7h, 128h, 128h, or 17Dh, or B0h) ;maybe max-x
  02Ch 4       Zero
  030h 4       Most recent "00000000\000000xx" file number? (2 and up)
  034h 4       Zero
  038h 4       Zero
  03Ch 4       Zero
  040h 4       Most recent "00000000\000000xx" file size? (or 0=deleted?)
  044h 4       Zero
```

Quota.dat exists for eMMC shared extdata only (not for SD extdata). The purpose
of the Quota.dat file is unknown (it might be some kind of log file, and/or
containing some settings/limits or so).



## VSXE File System


The extdata\00048000\f00000xx\00000000/00000001 files contain a VSXE filesystem
(inside of the DIFF container).

- [3DS Files - Savedata SAVE/BDRI/VSXE Formats](#3dsfilessavedatasavebdrivsxeformats)
The VSXE format does have file & directory names, but without actually
assigning data clusters to files (instead, VSXE does merely assign ID values to
each "file" - and that ID refers to the DIFF[154h] ID in one of the
extdata\00048000\f00000xx\00000000/000000xx files).



## Virtual File System Structure


When extdata is created, these are always created regardless of whether the
title actually uses them.

```
  /icon  This virtual file contains the extdata icon displayed in data
           management. This icon can only be written to by titles when
           creating extdata, titles would have to recreate extdata to
           change the icon. This file can't be read directly, instead it
           is read via FS:ReadExtSaveDataIcon.
  /user/ This virtual directory contains the title's actual extdata files.
  /boss/ This virtual directory can contain SpotPass content. SpotPass
           content can only be downloaded to this /boss virtual directory.
```


User extdata and SpotPass extdata use separate mount points at /user and /boss.
Therefore one mount can't access the other virtual directory, and also can't
access /icon (the title's SpotPass extdata can be mounted by the title itself,
if it uses SpotPass).



## Extended Banner (optional)


Folder "\user\ExBanner\" can contain optional extended banner files:

```
  \user\ExBanner\COMMON.bin     ;-common data for all regions
  \user\ExBanner\JPN_JP.bin     ;\
  \user\ExBanner\USA_EN.bin     ; per region/language
  etc.                          ;/
```

If present, this banner is displayed instead of the CXI ExeFS banner.

Uh, displayed instead of? Or does it merely replace textures?

- [3DS Files - Video Banner (Extended Banner)](#3dsfilesvideobannerextendedbanner)


## SD Extdata ID's


```
  JPN      USA      EUR       Description     Extdata images
  00000082 0000008f 00000098  Home Menu extdata, this contains home-menu
                                savedata and cached icons for applications.
  00000200 00000210 00000220  System Settings extdata added with 2.0.0-2.
  00000207 00000217 00000227  Mii Maker, contains an ExBanner      cleartext
  00000208 00000218 00000228  Streetpass Mii Plaza                 11 mb big!
  00000209 00000219 00000229  eShop, contains store music in AAC format.
  0000020b 0000021b 0000022b  Nintendo Zone
  0000020d 0000021d 0000022d  Face Raiders, likely contains an ExBanner
  000002cc 000002cd 000002ce  Home Menu theme
  ?        000004aa 000004ab  Nintendo Video Extra Data
```

This is where the video files are stored, and includes the thumbnail, the
description, and possibly some checksum info in each video file stored in the
extdata images. There are always 9 files within the subdirectory "00000000" of
this folder, even without any videos downloaded. The files are "00000001" -
"00000009", and "00000003" - "00000008" have the same filesize of 50.7 MB. It
is possible to restore the older videos by overwriting all the files within
this directory. Provided of course you have made a backup of the files before
hand, by copying all the files within this directory to your computer. As far
I'm aware its not possible to mix and match the files in order to get certain
videos in one grouping, ie. having all 3 Zelda orchestral recordings in one
group of 4 Nintendo videos.

```
  00000306 00000308 00000307  Mario Kart 7
  0000030b 0000030d 0000030c  Nintendogs + Cats
  00000326 00000326 00000326  Pokdex 3D
  00000305 0000032d 0000033c  Super Street Fighter IV 3D
  00000328 00000358 0000033b  Ridge Racer 3D
  ?        0000034d 00000402  Samurai Warriors Chronicles
  ?        0000034f 0000038a  Dead or Alive Dimensions
  00000481 N/A      N/A       Monster Hunter Tri G (Download-Quests)
  ?        00000517 00000518  Swapnote
  0000055d 0000055d 0000055d  P-Letter X, P-Letter Y
  ?        00000725 00000724  Ambassador Certificate
  ?        ?        000007af  New Super Mario Bros. 2
  ?        00000863 00000864  Animal Crossing: New Leaf
  ?        00000a85 00000a86  Professor Layton and the Miracle Mask
  ?        ?        00000a87  Professor Layton and the Azran Legacy (German)
  ?        ?        00000b4f  Fullblox / Crashmo
  ?        ?        00000ba9  Pokmon Mystery Dungeon: Gates to Infinity
  ?        ?        00000c24  Denpa men
  00000c73 00000c73 00000c73  Save Data Transfer Tool
  ?        ?        00000d9a  Donkey Kong Country Returns 3D: Trailer
  ?        ?        00000ea6  Etrian Odyssey IV
  ?        00000edf 00000ee0  Super Smash Bros. for Nintendo 3DS
  ?        00000f14 00000f1e  Phoenix Wright: Ace Attorney - Dual Destinies
  ?        00001007 00001005  Professor Layton vs Phoenix Wright: Ace Attorney
  ?        ?        00001062  Nintendo Pocket Football Club
  ?        ?        0000111c  Yoshi's New Island
  ?        ?        00001131  Fantasy Life
  000011c5 000011c5 000011c5  Pokmon Omega Ruby, Pokmon Alpha Sapphire
  ?        ?        000012ca  Mario vs. Donkey Kong: Tipping Stars
  ?        ?        00001499  Korg DSN-12
  ?        ?        000014f2  Animal Crossing: Happy Home Designer
  000014d1 000014d1 000014d1  Home Menu badge
  ?        ?        00001632  Fullblox / Stretchmo
  ?        ?        00001646  Pokmon Rumble World
  00001648 00001648 00001648  Pokmon Sun, Pokmon Moon
  0000165c 0000165c 0000165c  Home Menu saved theme layouts
  ?        ?        00001678  Yo-kai Watch
  ?        ?        000018fa  Phoenix Wright: Ace Attorney - Spirit of Justice
  ?        ?        0000198f  Animal Crossing: New Leaf - Welcome amiibo
  ?        ?        00001a05  Super Mario Maker
  ?        ?        00001a2e  Swapdoodle
```



## eMMC Shared Extdata ID's


```
  e0000000 Request system transfer (if present)
  f0000001 Camera application NAND JPEG/MPO files, phtcache.bin, UploadData.dat
  f0000002 Sound application NAND M4A files
  f0000009 SpotPass content storage for notifications
  f000000b Miis and Play/Usage Records
             Contains idb.dat, idbt.dat, gamecoin.dat, ubll.lst, CFL_DB.dat,
             and CFL_OldDB.dat. These files contain cleartext Miis and some
             data relating (including cached ICN data) to Play/Usage Records
  f000000c Contains bashotorya.dat and bashotorya2.dat
  f000000d Home Menu SpotPass content data storage
  f000000e Update notification versionlist.dat (added in 7.0.0-13)
```



## Shared Extdata "f000000b" gamecoin.dat


```
  000h 4  Fixed ID or so (4F00h)
  004h 2  Total Play Coins
  006h 2  Total Play Coins obtained on the date stored below. When the below
            date does not match the current date, this field is reset to zero,
            then the date (and other fields) are updated. Once this value
            is >=10, no more Play Coins can be obtained until the current date
            changes.
  008h 4  Total step count at the time a new Play Coin was obtained.
  00Ch 4  Step count for the day the last Play Coin was obtained, for that
            day's step count (same as the step count displayed by home-menu
            when this file was updated).
  010h 2  Year
  012h 1  Month
  013h 1  Day
```

The above date stores the last time new Play Coin(s) were obtained. The
contents of this file is updated by home-menu. PTM:GetTotalStepCount is not
checked constantly, after home-menu boot this is only checked when waking from
sleep-mode. Each time home-menu updates the contents of this file, home-menu
will set the Play Coin total to 300 if it's higher than the 300 Play Coin
limit.



## Shared Extdata "f000000b" ubll.lst


List of blocked users.

Empty space is filled with 0Ch-long sequences of 00 00 ... 07



## Tools


3ds-save-tool - Extract/verifies extdata




# <a name="3dsfilessavedatasavebdrivsxeformats"></a>3DS Files - Savedata SAVE/BDRI/VSXE Formats




## SAVE/BDRI/VSXE Header


```
  000h 4   ID "SAVE",00h,00h,04h,00h ;for savegame (file names + data clusters)
           ID "BDRI",00h,00h,03h,00h ;for database (file IDs   + data clusters)
           ID "VSXE",00h,00h,03h,00h ;for extdata  (file names + data IDs)
  008h 8   File System Information offset (SAVE/BDRI=20h or VSXE=138h)
  010h 8   Image size in blocks (eg. 1Eh)
  018h 4   Image block size (usually 1000h) (or 80h or 200h, in databases)
  01Ch 4   Padding
 Extra entries, for VSXE (extdata) only:
  020h 8    Unknown (can be 1)                                            (1)
  028h 4    Most recently mounted Extdata image 'Action'   ;whut?         (0)
  02Ch 4    Unknown                                                       (0)
  030h 4    Most recently mounted Extdata image FAT file  (eg. 3="00000003")
  034h 4    Unknown                                                       (0)
  038h 100h Most recently mounted Extdata image VSXE name (eg. "/user/file",0)
  Note: The Quota.dat file does also seem to log some "most recent" stuff.
```



## File System Information (usually at offset 20h or 138h)


```
  000h 4   Unknown (0)
  004h 4   Cluster size (usually 1000h) (or 80h or 200h, in databases)
  008h 8   Directory hash table offset (eg. 88h, ie. after SAVE header)
  010h 4   Directory hash table bucket count (eg. 0Bh)
  014h 4   Padding (0) (or 04h in BDRI?)
  018h 8   File hash table offset      (eg. B4h, ie. after above table)
  020h 4   File hash table bucket count (eg. 0Bh)
  024h 4   Padding (0) (or 04h in BDRI?)
  028h 8   File allocation table offset (eg. E0h)
  030h 4   File allocation table entry count (eg. 1Dh = Cluster 0..1Dh)
  034h 4   Padding (0) (or 04h in BDRI?)
 Single Partition (normal case):
  038h 8   Cluster 1 offset                    (usually 1000h)             ;<--
  040h 4   Num clusters                        (eg. 1Dh = Cluster 1..1Dh)
  044h 4   Padding (0)
  048h 4   Directory table first cluster-1     (usually 0, ie. Cluster 1)  ;<--
  04Ch 4   Directory table num clusters        (usually 1)                 ;<--
  050h 4   Max number of subdirectories (0..N) (eg. 0Ah=Dummy+Root+10 Sub's)
  054h 4   Padding (0)
  058h 4   File table first cluster-1          (usually 1, ie. Cluster 2)  ;<--
  05Ch 4   File table num clusters             (usually 01h)               ;<--
  060h 4   Max number of files                 (eg. 0Ah=Dummy+10 Files?)
  064h 4   Padding (0)
 Dual Partition (more tightly packed):
  038h 8   Cluster 1 start               (always 0, start in partition B)  ;<--
  040h 4   Num clusters                        (eg. 1Dh = Cluster 1..1Dh)
  044h 4   Padding (0)
  048h 8   Directory table offset                                          ;<--
  050h 4   Max number of subdirectories (0..N) (eg. 0Ah=Dummy+Root+10 Sub's)
  054h 4   Padding (0)
  058h 8   File table offset                                               ;<--
  060h 4   Max number of files                 (eg. 0Ah=Dummy+10 Files?)
  064h 4   Padding (0)
```

When partition B doesn't exist, directory & file entry tables are allocated
in the data region, and while (uh?) be marked allocated in file allocation
table as if they are two normal files.

However, only continuous allocation has been observed, so directly reading
block\_count \* block\_size bytes from data\_region + starting\_block\_index \*
block\_size should be safe.



## Directory Table


```
  Entry #0     Dummy Entry    (aka entrypoint for unused (deleted?) entries)
  Entry #1     Root Directory (aka entrypoint for used entries)
  Entry #2..X  Sub-directories (used and deleted entries?)
  Entry #Y..Z  Sub-directories (still unused entries?) (zerofilled)
```

Directory Entries:

```
  SAVE VSXE BDRI Siz Content
  000h 000h 000h 4   Directory Index of Parent directory (0=none; in root)
  004h 004h -    16  Directory Name in ASCII, zeropadded (all zero for root)
  014h 014h 004h 4   Directory Index of next sibling directory   (0=none)
  018h 018h 008h 4   Directory Index of first subdirectory       (0=none)
  01Ch 01Ch 00Ch 4   File index of first file in this directory  (0=none)
  020h 020h 010h ..  Padding (0) / zero?
  024h 024h 01Ch 4   Directory Index of next same hash table bucket (0=none)
```

Dummy Directory entries:

```
  SAVE VSXE BDRI Siz Content
  000h 000h 000h 4   Current Total entry count (eg. 2 = Dummy+Root)
  004h 004h 004h 4   Maximum entry count = maximum directory count + 2
  008h 008h 008h ..  Padding / All zero
  024h 024h 01Ch 4   Directory Index of next dummy (=deleted?) entry (0=none)
```

Dummy entries are left there when deleting directories, and reserved for future
use.



## File Table


```
  Entry #0     Dummy Entry
  Entry #1..X  File Entries (used and deleted entries?)
  Entry #Y..Z  File Entries (still unused entries?) (zerofilled)
```

The file entry table is an array of the entry type shown below. It contains
information for each file.

```
  SAVE VSXE BDRI Siz Content
  000h 000h 000h 4   Directory index of Parent Directory
  004h 004h -    16  File Name in ASCII, zeropadded
  -    -    004h 8   Title ID
  014h 014h 00Ch 4   File index of next sibling file (0=none)
  018h 018h 010h 4   Padding
  01Ch -    014h 4   First cluster-1 (0..N-1 = Cluster 1..N, or 80000000h=None)
  020h -    018h 8   File Size
  -    -    020h 4   Padding?
  -    01Ch -    4   Always 80000000h (extdata has no clusters)
  -    020h -    8   Unique identifier. See Extdata
  028h 028h 024h 4   Padding?
  02Ch 02Ch 028h 4   File Index of next file in same hash table bucket (0=none)
```

Dummy File entries:

```
  SAVE VSXE BDRI Siz Content
  000h 000h 000h 4   Current total entry count (eg. 2=Dummy+OneFile)
  004h 004h 004h 4   Maximum File entry count = maximum file count + 1
  008h 008h 008h ..  Padding (0)
  02Ch 02Ch 028h 4   File Index of the next dummy (=deleted?) entry (0=last)
```

Dummy entries are left there when deleting files, and reserved for future use.



## File Allocation Table (FAT)


The FAT uses 64bit entries, containing the next & previous cluster number
(unlike microsoft FATs, which contain next cluster only).

```
  0-30  Previous Cluster (1..max, or 0=None)
  31    Blah flag (0=No, 1=First cluster, or Second/Last entry of large block)
  32-62 Next Cluster     (1..max, or 0=None)
  63    Multiple flag    (0=No, 1=First entry of Large block)
```

The Multiple flag indicates a large block that consists of more than one
cluster. The first entry in the large block has Multiple=1, the second and last
entry of the large block contain the first/last cluster numbers of the large
block.

- For example, a file using cluster 20, 100-120, 50 (in that order):
  - File List:     Cluster=19 (aka 20-1)           ;-first cluster of file
  - FAT[20]:       Prev=0,   Next=100, Blah=1      ;-cluster 20
  - FAT[100]:      Prev=20,  Next=50,  Multiple=1  ;\
  - FAT[101]:      Prev=100, Next=120, Blah=1      ; cluster 100..120
  - FAT[102..119]: Zero (or garbage?)              ;
  - FAT[120]:      Prev=100, Next=120, Blah=1      ;/
  - FAT[50]:       Prev=100, Next=0                ;-cluster 50

All free blocks that are not allocated to any files also form a node chain in
the allocation table, with starting in FAT[0]:

```
  FAT[0]:        Prev=0, Next=FirstFree    ;-points to begin of free chain
```



## Directory Hash Table & File Hash Table


```
  000h 4   File/Directory Index of 1st name with hash=0
  004h 4   File/Directory Index of 1st name with hash=1
  008h 4   File/Directory Index of 1st name with hash=2
  etc.
```

The hash depends on parent\_directory\_index and file/directory name as key:

```
  hash = parent_dir_index XOR 091A2B3Ch ;-parent mangled with digits 0123+9ABC
  hash = (hash ROR 1) XOR name[00h]     ;\
  hash = (hash ROR 1) XOR name[04h]     ; 16-byte file/directory name
  hash = (hash ROR 1) XOR name[08h]     ; (including trailing 00h's)
  hash = (hash ROR 1) XOR name[0Ch]     ;/
  hash = (hash MOD bucket_count)        ;-final value
```

Uh, but, that cannot be true for BDRI...

```
  BDRI doesn't have any file names (instead has 8-byte Title IDs)
  BDRI doesn't have any directory names
```



## Layout for duplicate data = true


The DISA container only has one partition which is always configured as
external IVFC level 7 disabled (see DISA format for details). All components
are stored in this partition as

- Partition A
  - SAVE/BDRI/VSXE header
  - Directory hash table
  - File hash table
  - File allocation table (FAT)
  - data region
  - directory entry table is allocated inside data region  ;Cluster 1
  - file entry table as well                               ;Cluster 1+x
  - all file data is also allocated here                   ;Cluster 1+x+y
- Partition B
  - none such

In this layout, all data is duplicated by DISA's DPFS tree, which is what the
parameter duplicate data implies.



## Layout for duplicate data = false


The DISA container has two partitions. Partition A is always configured as
external IVFC level 7 disabled, and partition B is configured as it enabled.
Components are stored among the two partitions as

- Partition A
  - SAVE header at the beginning
  - Directory hash table
  - File hash table
  - File allocation table (FAT)
  - directory entry table
  - file entry table
- Partition B
  - used as data region entirely, and only has file data allocated.  ;Cluster 1

In this layout, all file system metadata is duplicated by partition A DPFS
tree, but file data is not as partition B has external IVFC level 7.



## Initialization


When a save FLASH contains all xFFFF blocks it's assumed uninitialized by the
game cartridges and it initializes default data in place, without prompting the
user. The FFFFFFFFh blocks are uninitialized data. When creating a non-gamecard
savegame and other images/files, it's initially all FFFFFFFFh until it's
formatted where some of the blocks are overwritten with encrypted data.



## Tools


3dsfuse supports reading and modifying savegames. In the mounted FUSE
filesystem, the /output.sav is the raw FLASH save-image. When the save was
modified, a separate tool to update the CMAC must be used with /clean.sav,
prior to writing output.sav to a gamecard.

3DSExplorer supports reading of savegames, it doesn't support reading the new
encrypted savegames and maybe in the future it will support modifying (some of
the modyfing code is already implemented).

wwylele's 3ds-save-tool supports extracting files from savegames and extdata.
It properly reconstructs data from the DPFS tree and extracts files in
directories hierarchy.

3dsfuse-ex similar to 3dsfuse, but supports savegame inner FS, proper DPFS
handling, and automatic CMAC update. Still WIP.




# <a name="3dsfilessavedatadisaanddiff"></a>3DS Files - Savedata DISA and DIFF



DISA and DIFF are two container formats (usually containing SAVE/BDRI/VSXE
filesystems, or raw data in some cases).

The DISA/DIFF containers are storing everything in data pairs that consist of
active/inactive halves (somewhat maintaining a backup copy in the active half,
whilst allowing to write new data to the inactive half). Additionally, there
are SHA256's for all data blocks (for error checking, and for preventing
hacks/patches when not having the AES-CMAC key for the master checksum).



## Duplicated Data Pairs


One can safely overwrite the inactive halves (whilst other tasks could still
read the old intact data, and without risking to destroy the active data if the
console crashes during writing), and finally apply the changes by toggling the
active half flags.

The disadvantages are that the duplicated data requires twice as much memory,
crawling through the 7 levels does hurt read/write access time, writing the 7
levels does reduce the chip lifetime, the DIFI's and DPFS level 1-2 are using
the same 200h-byte sector for active/inactive halves (so write errors on that
sectors would also destroy the old active data).

The whole concept is either blatant nonsense, or incredibly clever (in case
Nintendo should have somehow estimated that the few benefits are outweighting
the many disadvanges).



## Variants with Duplicated or Non-duplicated Data


1) Single Partition with Internal Level 7 (duplicated data)

2) Single Partition with External Level 7 (non-duplicated data)

3) Dual Partition (one Internal and one External for partially-duplicated data)

4) DIFF:VSXE directory file, with data stored in separate DIFF:data files


```
        XXX extdata\..\Quota.dat         has external IVFC
        XXX extdata\..\00000000\00000002 has external IVFC
```



## Format


A DISA / DIFF file consists of the following components:

```
  0000h 200h  Header (DISA or DIFF)
  0200h 130h  1st DIFI+IVFC+DPFS+SHA256 for Partition A
                (and somewhere DIFI+IVFC+DPFS+SHA256 for Partition B, if any?)
  0330h 130h  2nd DIFI+IVFC+DPFS+SHA256 for Partition A (as above)
  1000h ...   Partition A
  xxxxh ...   Partition B (optional, can only exist for DISA, not for DIFF).
```



## Encryption


DISA and DIFF formats don't have their own encryption specification. They
follow the encryption method defined by their media:

```
  - Gamecard savegames have special wear leveling + encryption layers.
  - Files on SD follow the general SD filesystem encryption rule.
  - Files on NAND are in cleartext, after decrypting the NAND partition.
```



## DISA header (used for Savegame and System savedata)



## DIFF header (for Extdata and Title Database)


All offsets in the header are relative to the beginning of the DISA/DIFF file,
except for partition descriptor offsets, which are relative to the beginning of
the (active) partition table.

```
  DISA DIFF Siz Content
  000h 000h 10h AES-CMAC on SHA256 on special ID-strings-and-Header[100h..1FFh]
  010h 010h F0h Padding (0)
  100h 100h 8   ID ("DISA",00h,00h,04h,00h or "DIFF",00h,00h,03h,00h)
  108h -    4   Partition count, 1 or 2     (aka "1=A" or "2=A+B")          (1)
  10Ch -    4   Padding
  110h 108h 8   1st DIFI offset  ;\the active one is selected            (200h)
  118h 110h 8   2nd DIFI offset  ;/via below Active flag)                (330h)
  120h 118h 8   DIFI+IVFC+DPFS+SHA256 table size (12Ch) (or 12Ch*2 when two?)
  128h -    8   Partition A DIFI+IVFC+DPFS+SHA256 offset in active DIFI     (0)
  130h -    8   Partition A DIFI+IVFC+DPFS+SHA256 size                   (12Ch)
  138h -    8   Partition B DIFI+IVFC+DPFS+SHA256 offset in active DIFI  (0) ;?
  140h -    8   Partition B DIFI+IVFC+DPFS+SHA256 size               (0) ;12Ch?
  148h 120h 8   Partition A offset (DPFS flags, IVFC SHA's, ...      (1000h)
  150h 128h 8   Partition A size                                     (3F000h)
  158h -    8   Partition B offset                                   (0)
  160h -    8   Partition B size                                     (0)
  168h 130h 4   Active DIFI+IVFC+DPFS+SHA256 flag (0=2nd DIFI, 1=First DIFI)
  16Ch 134h 20h Active DIFI+IVFC+DPFS+SHA256 table SHA256
  -    154h 8   Unique identifier for Extdata (zero for title database)
  18Ch 15Ch ..  Unused (up to 1FFh), might contain leftover data
```

When the partition count is 1, there is no partition B and all of its related
fields are zero.



## DIFI table


All offsets are relative to the beginning of the DIFI partition descriptor,
except for External IVFC level 7 offset, which is relative to the beginning of
the partition.

```
  000h 8     ID "DIFI",00h,00h,01h,00h
  008h 8     IVFC descriptor offset (44h) ;\checksum tree SHA256's   ;"IVFC"
  010h 8     IVFC descriptor size   (78h) ;/
  018h 8     DPFS descriptor offset (BCh) ;\active/inactive data pair flags
  020h 8     DPFS descriptor size   (50h) ;/
  028h 8     SHA256 Partition hash offset (10Ch) ;\aka "Partition master hash"?
  030h 8     SHA256 Partition hash size  (20h*N) ;/
  038h 1     IVFC level 7 location (0=Internal, Nonzero=External) (usually 0)
  039h 1     Active flag for DPFS Level 1 (0=1st half, 1=2nd half)
  03Ah 2     Padding (0)
  03Ch 8     External IVFC level 7 offset (zero if Internal IVFC level 7)
  044h 78h   IVFC descriptor (see below)
  0BCh 50h   DPFS descriptor (see below)
  10Ch 20h*N SHA256 Partition master hash list (SHA's for Level 4)
  (then followed by another DIFI+IVFC+DPFS+SHA256 for partition B, if any?)
```

Note: There are two DIFI tables (the active one being selected in
DISA[168h]/DIFF[130h]). Both DIFI's are usually containing the exact same
offsets and sizes (and do differ only by Flag in DIFI[039h] and the SHA's at
DIFI[10Ch]) (however, the inactive DIFI may initially contain unformatted
garbage).



## DPFS descriptor


This header defines each level of DPFS tree. All offsets are relative to the
beginning of the partition.

```
  000h 8   ID "DPFS",00h,00h,01h,00h
  008h 8   Level 1 offset        (usually 0)                     ;\Flags for
  010h 8   Level 1 size per half (usually 4, or N*4 if bigger)   ; Level 2
  018h 8   Level 1 block size    (unused, usually 0)             ;/
  020h 8   Level 2 offset        (usually N*4*2, at level 1 end) ;\Flags for
  028h 8   Level 2 size per half (usually 80h*N)                 ; Level 3
  030h 8   Level 2 block size    (1 SHL N, usually 7=80h bytes)  ;/
  038h 8   Level 3 offset        (usually 1000h-aligned)         ;\IVFC's
  040h 8   Level 3 size per half (usually 1000h*N)               ; (SHA's+Data)
  048h 8   Level 3 block size  (1 SHL N, usually 12=1000h bytes) ;/
```

The flags are stored in 32bit snippets, weirdly with bit31 being the 1st block
(that can be resolved as "BitNumber=BlockNumber XOR 1Fh"). The flags are
selecting the active half of the next level (0=1st Half, or 1=2nd Half).

The above DPFS "size" values refer to "one half" (the 1st half is at "offset",
the 2nd half is at "offset+size").

- [3DS Files - Savedata DISA and DIFF - Data Pairs](#3dsfilessavedatadisaanddiffdatapairs)


## IVFC descriptor


This header defines each level of IVFC tree. All offsets are relative to

the beginning of the active half of DPFS level 3.

```
  000h 8   ID "IVFC",00h,00h,02h,00h
  008h 8   Master hash size = partition master hash size in DIFI header (N*20h)
  010h 8   Level 4 offset (usually 0)                           ;\SHA's for
  018h 8   Level 4 size   (usually 20h, or N*20h if bigger)     ; Level 5
  020h 8   Level 4 block size (1 SHL N, usually 9=200h bytes)   ;/
  028h 8   Level 5 offset (usually 20h, aka level 1 end)        ;\SHA's for
  030h 8   Level 5 size   (usually 20h, or N*20h if bigger)     ; Level 6
  038h 8   Level 5 block size (1 SHL N, usually 9=200h bytes)   ;/
  040h 8   Level 6 offset (usually 40h, aka level 2 end)        ;\SHA's for
  048h 8   Level 6 size   (usually 20h*N)                       ; Data
  050h 8   Level 6 block size (1 SHL N, usually 12=1000h bytes) ;/
  058h 8   Level 7 offset (unused for External IVFC Level 7)    ;\Data (eg.
  060h 8   Level 7 size   (usually 1000h*N)                     ; SAVE filesys)
  068h 8   Level 7 block size (1 SHL N, usually 12=1000h bytes) ;/
  070h 8   IVFC descriptor size? (usually 78h)
```

The above IVFC "size" values refer to "one half" (the 1st half is at "offset",
the 2nd half is at "offset+level3size").

- [3DS Files - Savedata DISA and DIFF - Checksums](#3dsfilessavedatadisaanddiffchecksums)



# <a name="3dsfilessavedatadisaanddiffdatapairs"></a>3DS Files - Savedata DISA and DIFF - Data Pairs



```
  DPFS might be short for
    DataPair...
    DuPlicates
    PersistentData structure (DP backwards)
```



## Loading active blocks


To read data from src\_offset (eg. begin of SAVE filesystem at src\_offset=0):

```
  load the active difi/ivfc/dpfs block
  if external_flag_from_DIFI[38h] then
    readbytes(partition_base+external_level7_base+src_offset, len)
  else
    level3_byte_addr = level7_base+src_offset
   snippet_loop:
    snippet_len = min(len, distance to level3_blocksize boundary)
    level2_bit_index = (level3_byte_addr/level3_blocksize) xor 1Fh    ;\
    level2_byte_addr = (level2_bit_index/8)                           ;
    level1_bit_index = (level2_byte_addr/level2_blocksize) xor 1Fh    ;
    level1_byte_addr = (level1_bit_index/8)                           ;/
    base1 = level1_base+level1_size*(active_flag_from_DIFI[039h])
    flag1 = readbyte(level1_byte_addr+base1, size=1)
    base2 = level2_base+level2_size*((flag1 shr (level1_bit_index AND 7) AND 1)
    flag2 = readbyte(level2_byte_addr+base2, size=1)
    base3 = level3_base+level3_size*((flag2 shr (level2_bit_index AND 7) AND 1)
    data  = readbytes(level3_byte_addr+base3, snippet_len)
    raise src/dst, decrease len by snippet_len, if len>0 then goto snippet_loop
```



## Partition


A partition can have two types of layout. This is determined by the field
DIFI+38h (Enable external IVFC level 7).

The layout type 0 (external IVFC level 7 disabled) contains

```
  DPFS Level 1         (contains active flags for DPFS level 2)
  DPFS Level 2         (contains active flags for DPFS level 3)
  DPFS Level 3         (contains IVFC levels and Data?)
    IVFC Level 4         (contains SHA256's for IVFC level 5)
    IVFC Level 5         (contains SHA256's for IVFC level 6)
    IVFC Level 6         (contains SHA256's for IVFC level 7)
    IVFC Level 7         (contains the actual content data)
```

The layout type 1 (external IVFC level 4 enabled) contains

```
  DPFS Level 1     ;Flags for DPFS Level 2
  DPFS Level 2     ;Flags for DPFS Level 3
  DPFS Level 3, and inside
    IVFC Level 4     ;SHA256's on IVFC Level 5
    IVFC Level 5     ;SHA256's on IVFC Level 6
    IVFC Level 6     ;SHA256's on IVFC Level 7
  IVFC Level 7 ;the actual content data, note that this is outside DPFS level 3
```



## Summary diagram


external link: 
- [https://i.imgur.com/BjwShJZ.png](https://i.imgur.com/BjwShJZ.png)
Please move this into 3dbrew when file uploading is fixed.




# <a name="3dsfilessavedatadisaanddiffchecksums"></a>3DS Files - Savedata DISA and DIFF - Checksums




## AES CMAC


The AES CMAC is located at the beginning of the DISA / DIFF image, and it is
10h long. The rest F0h bytes before the header are unused.

The key used for the AES CMAC is generated by the hardware key engine.

The data being authenticated by the AES CMAC is a 20h-byte SHA-256 hash of a
data block.


## CTR-NOR0 This CMAC type is used for gamecard savegames, 28h-bytes

      - 000h 8    ID "CTR-NOR0"                             ;\CMAC area
      - 008h 20h  SHA-256 of the following 108h-byte block  ;/
      - 028h 8    ID "CTR-SAV0"
      - 030h 100h Copy of the DISA header

## CTR-SIGN This CMAC type is used for SD savegames, 30h-bytes

      - 000h 8    ID "CTR-SIGN"                             ;\
      - 008h 8    Title ID                                  ; CMAC area
      - 010h 20h  SHA-256 of the following 108h-byte block  ;/
      - 030h 8    ID "CTR-SAV0"
      - 038h 100h Copy of the DISA header

## CTR-SYS0 This CMAC type is used for NAND system save, 110h-bytes

      - 000h 8    ID "CTR-SYS0"
      - 008h 8    Save ID. The higher word is always zero
      - 010h 100h Copy of the DISA header

## CTR-EXT0 This CMAC type is used for extdata, 11Ch-bytes

      - 000h 8    ID "CTR-EXT0"
      - 008h 8    Extdata ID                eg. "00048000\x00000xx\" ?
      - 010h 4    0 for Quota.dat, 1 otherwise
      - 014h 4    ID in the "device" file name  "\00000000\nnnnnnnn" ?  ;\zero for
      - 018h 4    ID in the "device" directory name that the file is in ;/Quota.dat
      - 01Ch 100h Copy of the DIFF header

## CTR-9DB0 This CMAC type is used for title database, 10Ch-bytes

      - 000h 8    ID "CTR-9DB0"
      - 008h 4    Database .db file ID (0..5, see below)
      - 00Ch 100h Copy of the DIFF header
      - The Database .db file IDs are:
      - 0=ticket.db, 1=certs.db, 2=title.db, 3=import.db, 4=tmp\_t.db, 5=tmp\_i.db

Here is a summary table of the CMAC type and the AES key slot used:

```
  Usage           Media    Format  CMAC type       CMAC Keyslot
  Savegames       Gamecard DISA    CTR-NOR0        19h/33h
  Savegames       SD       DISA    CTR-SIGN        30h
  System SaveData NAND     DISA    CTR-SYS0        30h
  Private Extdata SD       DIFF    CTR-EXT0        30h
  Shared Extdata  NAND     DIFF    CTR-EXT0        30h
  Title Database  SD       DIFF    CTR-9DB0        30h
  Title Database  NAND     DIFF    CTR-9DB0        0Bh
```

Note: The AES keyslots are known (shown above), but the AES IV appears to be
unknown?



## IVFC tree


The IVFC tree is used for data verification. It is very similar to the IVFC
tree in RomFS, except that it has an additional level here. For level 4, 5 and
6, each level is a list of SHA-256 hash, of which each corresponds to a block
of the next level which is zero-padded to align the block size (the block size
of the next level is defined in the IVFC descriptor).


The partition master hash in the partition descriptor can be seen as IVFC level
0, which hashes level 4 following the same rule. The master hash is usually 20h
long, consisting only one hash. This is because most DISA / DIFF files are not
large enough to have multiple hashes on the top level, which isn't the case for
some title database files.


However, not all data is hashed - only ranges that have been written with valid
data are properly hashed.


Level 7 is the actual content of the partition, which is what the container
format essentially contains.



## IVFC Chain of trust


AES CMAC verifies the header.

The header verifies the active partition table via the table hash.

In the partition table, each descriptor verifies level 4 of its IVFC tree via
the master hash.

Each IVFC level verifies the next level, until the level 7, which is the inner
content (eg. the SAVE file system).




# <a name="3dsfilessavedatagamecardflashencryptionandwearleveling"></a>3DS Files - Savedata Gamecard FLASH Encryption and Wear Leveling



Unlike SD and NAND savegames, Gamecard savegames have and additional Encryption
and Wear Leveling layer.


```
 ________________________ Gamecard savegame Encryption ________________________
```



## Repeating CTR Fail (newbie guide on what is a repeating 512-byte keystream)


On the 3DS savegames are stored much like on the DS, that is on a FLASH chip in
the gamecart. On the DS these savegames were stored in plain-text but on the
3DS a layer of encryption was added. This is AES-CTR, as the contents of
several savegames exhibit the odd behavior that xor-ing certain parts of the
savegame together will result in the plain-text appearing.


The reason this works is because the stream cipher used has a period of 512
bytes. That is to say, it will repeat the same keystream after 512 bytes. The
way you encrypt with a stream cipher is you XOR your data with the keystream as
it is produced. Unfortunately, if your streamcipher repeats and you are
encrypting a known plain-text (in our case, zeros) you are basically giving
away your valuable keystream.



## Savegame keyY


All gamecard and (!!?!!) SD savegames are encrypted with AES-CTR. The base CTR
for gamecard savegames is all-zero. The gamecard savegame keyslots' keyY (these
savegame keyslots use the hardware key-generator) is unique for each region and
for each game. The NCSD partition flags determine the method used to generate
this keyY. When the save NCSD flags checked by the running NATIVE\_FIRM are
all-zero, the system will use the repeating CTR, otherwise a proper CTR which
never repeats within the image is used.


The AES-CMAC (which uses a hardware key-generator keyslot, as mentioned above)
at the beginning of the savegame must match the calculated CMAC using the
DISA/DIFF data, otherwise the savegame is considered corrupted (see below).


When all of the flags checked by the running NATIVE\_FIRM are clear, the keyY
(original keyY method used with saves where the CTR repeats within the image)
is the following:

```
  00h 8     First 8-bytes from the plaintext CXI accessdesc signature.
  08h 4     u32 CardID0 from gamecard plaintext-mode command 0x90,
              Process9 reads this with the NTRCARD hw. The actual cmdID used
              by Process9 is different since Process9 reads it with the
              gamecard in encrypted-mode.
  0Ch 4     u32 CardID1 from gamecard plaintext-mode command 0xA0,
              Process9 reads this with the NTRCARD hw. The actual cmdID used
              by Process9 is different since Process9 reads it with the
              gamecard in encrypted-mode.
```



## 2.0.0-2 Hashed keyY and 2.2.0-4 Savegame Encryption


When certain NCSD partition flags are set, a SHA-256 hash is calculated over
the data from the CXI (same data used with the original plain keyY), and the
0x40-bytes read from a gamecard command (this 0x40-byte data is also read by
GetRomId, which is the gamecard-uniqueID). The first 0x10-bytes from this hash
is used for the keyY. When flag[7] is set, the CTR will never repeat within the
save image, unlike the original CTR-method. All games which had the retail NCSD
image finalized after the 2.2.0-4 update (and contain 2.2.0-4+ in the System
update partition), use this encryption method.


This keyY generation method was implemented with 2.0.0-2 via NCSD partition
flag[3], however the proper CTR wasn't implemented for flag[7] until 2.2.0-4.
The hashed keyY flag[3] implemented with 2.0.0-2 was likely never used with
retail gamecards.



## 6.0.0-11 Savegame keyY


```
  XXX also used/similar for NCCH "Keyslot25h" ???
```

6.0.0-11 implemented support for generating the savegame keyY with a new
method, this method is much more complex than previous keyY methods. This is
enabled via new NCSD partition flags, all retail games which have the NCSD
image finalized after the 6.0.0-11 release (and 6.0.0-11+ in the system update
partition) will have these flags set for using this new method.


A SHA-256 hash is calculated over the same data used with the above hashed keyY
method, after hashing the above data the following data is hashed: the CXI
programID, and the ExeFS:/.code hash from the decrypted ExeFS header. An
AES-CMAC (the keyslot used for this uses the hardware key-scrambler) is then
calculated over this hash, the output CMAC is used for the savegame keyY.


The keyY used for calculating this AES-CMAC is initialized while NATIVE\_FIRM is
loading, this keyY is generated via the RSA engine. The RSA slot used here is
slot0 (key-data for slot0 is initialized by bootrom), this RSA slot0 key-data
is overwritten during system boot. This RSA slot0 key-data gets overwritten
with the RSA key-data used for verifying RSA signatures, every time Process9
verifies any RSA signatures except for NCCH accessdesc signatures. Starting
with 7.0.0-13 this key-init function used at boot is also used to initialize a
separate keyslot used for the new NCCH encryption method.


This Process9 key-init function first checks if a certain 0x10-byte block in
the 0x01FF8000 region is all-zero. When all-zero it immediately returns,
otherwise it clears that block then continues to do the key generation. This is
likely for supporting launching a v6.0+ NATIVE\_FIRM under this FIRM.


```
 ___________________________ Gamecard wear leveling ___________________________
```


The 3DS employs a wear leveling scheme on the savegame FLASH chips (only used
for CARD1 gamecards). This is done through the usage of blockmaps and a
journal. The blockmap is located at offset 0 of the flash chip, and is
immediately followed by the journal. The initial state is dictated by the
blockmap, and the journal is then applied to that.


First, there are 8 bytes whose purposes are currently unknown. Then comes the
actual blockmap. The blockmap structure is simple:

```
  struct header_entry {
    uint8_t phys_sec  ;when bit7=1: block has chksums (else chksums are all 0)
    uint8_t alloc_cnt
    uint8_t chksums[8]
  } __attribute__((__packed__));
```

There's one entry per sector, counting from physical sector 1 (sector 0
contains the blockmap/journal).

The 2 bytes that follow the blockmap are the CRC16 (with initial value FFFFh)
of the first 8 bytes and the blockmap.


Then comes the journal. The journal structure is as follows:

```
  struct sector_entry {
    uint8_t virt_sec         ;Mapped to sector
    uint8_t prev_virt_sec    ;Physical sector previously mapped to
    uint8_t phys_sec         ;Mapped from sector
    uint8_t prev_phys_sec    ;Virtual sector previously mapped to
    uint8_t phys_realloc_cnt ;Amount of times physical sector has been remapped
    uint8_t virt_realloc_cnt ;Amount of times virtual sector has been remapped
    uint8_t chksums[8]
  } __attribute__((__packed__));
```


```
  struct long_sector_entry{
    struct sector_entry sector
    struct sector_entry dupe
    uint32_t magic           ;With magic being a constant 080D6CE0h.
  }__attribute__((__packed__));
```


The checksums in the blockmap/journal entries work as follows:

each byte is the checksum of an encrypted 200h bytes large block,

to calculate the checksum, a CRC16 of the block (with initial value FFFFh) is
calculated, and the two bytes of the CRC16 are XORed together to produce the
8bit checksum




# <a name="3dsfilesmessagesmsgstdbn"></a>3DS Files - Messages (MsgStdBn)



Message files contain text messages, usually there are separate message files
for different languages (in separate folders).

```
  <name>.msbt (MsgStdBn format) - Message Text
  <name>.msbp (MsgPrnBn format) - Message Project/styles (if present)
  RI.mstl     (raw binary)      - Unknown purpose
```



## MsgStdBn Header  (\<file>.msbt)


```
  000h 8     ID "MsgStdBn"
  008h 2     Byte Order (FEFFh)
  00Ah 2     Zero (0)
  00Ch 1     Message encoding (0=UTF-8, 1=UTF-16, 2=UTF-32)
  00Dh 1     Version number (always 3)
  00Eh 2     Number of following Chunks (4=LBL1+ATR1+TXT2+TSY1 or 2=NLI1+TXT2)
  010h 2     Zero (0)
  012h 4     Total Filesize (unaligned 32bit)
  016h 0Ah   Zero (0)
```



## LBL1 Chunk (Labels)


```
  000h 4       Chunk ID "LBL1"
  004h 4       Chunk Size (minus 10h, and excluding 16-byte padding)
  008h 8       Padding (0)
  010h 4       Number of Hash Table Entries (always 65h in MsgStdBn files)
  014h N*(4+4) Number of Matches + Offset to 1st match (from LBL1+10h)
  ...  ..      Label strings (8bitLen+Chars+32bitIndexIntoTXT2)
  ..   ..      Padding to 16-byte boundary (ABh-filled)
```

Hash Table Entries

```
  000h 4       Number of matching labels (0=None)
  004h 4       Offset to 1st matching label (from LBL1+10h) (garbage if None)
```

Label Strings

```
  000h  1      Label String length (LEN)
  001h  LEN    Label String (ASCII) (without any ending 00h byte)
  1+LEN 4      Message Index in TXT2 Chunk (unaligned 32bit)
```



## ATR1 Chunk (Attributes)


```
  000h 4      Chunk ID "ATR1"
  004h 4      Chunk Size (minus 10h, and excluding 16-byte padding)
  008h 8      Zero (0)
  010h 4      Number of Messages (N) (same as in TXT2 chunk)
  014h 4      Bytes per Attribute (siz) (0=None)
  ...  N*4    offsets to attributes from ATR1+10h  ;\only present if siz<>0
  ...  N*siz  attributes? (voice/window style?)    ;/
  ..   ..     Padding to 16-byte boundary (ABh-filled)
```



## TXT2 Chunk (Text Strings)


```
  000h 4     Chunk ID "TXT2"
  004h 4     Chunk Size (minus 10h, and excluding 16-byte padding)
  008h 8     Zero (0)
  010h 4     Number of Messages (N)
  014h N*4   Offsets to Strings (from TXT2+10h)
  ...  ..    Strings (usually in UTF-16, terminated by 0000h)
  ..   ..    Padding to 16-byte boundary (ABh-filled)
```

UTF-16 Characters:

```
  0000h=End of String (except inside Escape sequences)
  000Ah=Linebreak
  000Eh=Escape Code (change text color, etc.)
  00xxh=ASCII Characters 20h..7Eh
```

Escape Sequences:

```
  000h 2     Escape Code (000Eh)
  002h 2     Command Type
  004h 2     Command SubType
  006h 2     Number of following parameter bytes (0=None) (usually even)
  008h N     Parameters
```

Command Type.SubType are maybe somewhat like so:

```
  0000h.0003h Change Color maybe (param16bit) ?
  0000h.000xh Change other stuff maybe, like font size?
```

There is probably also something for inserting User Name or other strings and
numeric variables, sound effects, and perhaps something for prompting user
input?



## TSY1 Chunk (Style Info)


```
  000h 4     Chunk ID "TSY1"
  004h 4     Chunk Size (minus 10h, and excluding 16-byte padding) (NumMsg*4)
  008h 8     Zero (0)
  010h N*4   Style index in MSBP file (aka MsgPrjBn) (FFFFFFFFh=None?)
  ..   ..    Padding to 16-byte boundary (ABh-filled)
```

Uh, 3DS System Settings has Style Index values 0, 1, 2, and FFFFFFFFh (but
doesn't has a .msbt file at all).



## NLI1 Chunk (reportedly used in some files, instead of LBL1/ATR1/TSY1?)


```
  0x00h 4        Chunk ID "NLI1"
  0x04h 4        Chunk Size (minus 10h, and excluding 16-byte padding)
  0x08h 8        Zero
  0x10h 4        Number of entries
  0x14h N*(4+4)  Whatever List (Message ID? and Offset in TXT2)
```


Hash Tables

Many items (such as messages in msbt files or colors in msbp files) are looked
up by label. The labels are looked up with a hash table and are stored in a
different block than the items themselves. In official files the hash table
always has a fixed number of slots (101 in msbt files, 29 in msbp files), even
if it contains only a few labels.

```
  The following hash algorithm is used:
  def calc_hash(label, num_slots):
    hash = 0
    for char in label:
        hash = hash * 492h + ord(char)
    return (hash AND 0FFFFFFFFh) MOD num_slots
```

The block with the labels contains the following data:

```
  000h 4       Number of slots
  004h 8*N     Hash table slots
  ...  ..      Labels
```

Hash Table Slot

```
  000h 4       Number of labels
  004h 4       Offset to labels
```

Label

```
  000h 1       Length of label string
  001h ..      Label string (without null terminator)
  ...  4       Item index
```


```
 __________________________ MsgPrjBn (aka .msbp file)__________________________
```



## MsgPrjBn Header (\<file>.msbp) (if any)


```
  000h 8     ID "MsgPrjBn"
  008h 2     Byte Order (FEFFh)
  00Ah 2     Zero (0)
  00Ch 1     Message encoding (0=UTF-8, 1=UTF-16, 2=UTF-32) (usually 0 ??)
  00Dh 1     Version number (always 3)
  00Eh 2     Number of following Chunks (12=CLR1+CLB1+ATI2+ALB1+etc.)
  010h 2     Zero (0)
  012h 4     Total Filesize (unaligned 32bit)
  016h 0Ah   Zero (0)
```

This file contains style information for text messages.

```
  CLR1    Color RGBA Values     ;\Colors
  CLB1    Color Labels          ;/
  ATI2    Attribute Information ;\
  ALB1    Attribute Labels      ; Attributes
  ALI2    Attribute Lists       ;/
  TGG2    Tag Groups            ;\
  TAG2    Tags                  ; Tags
  TGP2    Tag Parameters        ;
  TGL2    Tag Lists             ;/
  SYL3    Styles                ;\Styles
  SLB1    Style Labels          ;/
  CTI1    Project Content Info  ;-Contents
```

The overall chunk format is:

```
  000h 4       Chunk ID   (eg. "CLR1")
  004h 4       Chunk Size (minus 10h, and excluding 16-byte padding)
  008h 8       Padding (0)
  010h ..      Data (depending on chunk)
  ..   ..      Padding to 16-byte boundary (ABh-filled)
```


```
 ______________________________ MsgPrjBn Colors _______________________________
```



## CLR1 Chunk (Color RGBA Values)


```
  000h 4+4+8   Chunk ID "CLR1", Chunk Size, Zeroes
  010h 4       Number of Colors
  014h N*4     Colors (RGBA)
  ..   ..      Padding to 16-byte boundary (ABh-filled)
```



## CLB1 Chunk (Color Labels)


```
  000h 4+4+8   Chunk ID "CLB1", Chunk Size, Zeroes
  010h 4       Number of Hash Table Entries (always 1Dh in MsgPrjBn files)
  014h N*(4+4) Number of Matches + Offset to 1st match (from CLB1+10h)
  ...  ..      Label strings (8bitLen+Chars+32bitIndexIntoCLR1)
  ..   ..      Padding to 16-byte boundary (ABh-filled)
```

Color Labels can be "Red", "Write, "Blue", for example.


```
 ____________________________ MsgPrjBn Attributes _____________________________
```



## ATI2 Chunk (Attribute Information)


```
  000h 4+4+8   Chunk ID "ATI1", Chunk Size, Zeroes
  010h 4       Number of attributes (0=None)
  014h 8*N     Attributes
```

Attribute Format:

```
  000h 1       Type
  001h 1       Padding
  002h 2       List index (in ALI2 block, only valid if the type=9)
  004h 4       Offset
```



## ALB1 Chunk (Attribute Labels)


```
  000h 4+4+8   Chunk ID "ALB1", Chunk Size, Zeroes
  This block contains labels for the ATI2 block.
```

The Hash slots can be all empty without any strings (eg. as so in DSi-to-3DS
Transfer Tool).



## ALI2 Chunk (Attribute Lists)


```
  000h 4+4+8   Chunk ID "ALI2", Chunk Size, Zeroes
  010h 4       Number of lists
  014h 4*N     Offsets to attribute lists
  ...     ..   Attribute lists
```

Attribute List

```
  000h 4       Number of list items
  004h 4*N     Offsets to list item names
  ...  ..      Null-terminated list item names
```


```
 _______________________________ MsgPrjBn Tags ________________________________
```



## TGG2 Chunk (Tag Groups)


```
  000h 4+4+8   Chunk ID "TGG2", Chunk Size, Zeroes
  010h 2       Number of tag groups
  012h 2       Padding
  014h 4*N     Offsets to tag groups
  ...  ..      Tag groups
```

Tag Group

```
  000h 2       Number of tags
  002h 2*N     Tag indexes (in TAG2 block)
  ...  ..      Null-terminated tag group name
```

Tag Groups can be "UserName", "DayTime", "ErrorInfo", for example.



## TAG2 Chunk (Tags)


```
  000h 4+4+8   Chunk ID "TAG2", Chunk Size, Zeroes
  010h 2       Number of tags
  012h 2       Padding
  014h 4*N     Offsets to tags
```

Tag

```
  000h 2       Number of tag parameters
  002h 2*N     Tag parameter indexes (in TGP2 block)
  ...  ..      Null-terminated tag name
```

Tags can be "MyName", "SenderName" "Hour", "Minute", "ErrorCode", for example.



## TGP2 Chunk (Tag Parameters)


```
  000h 4+4+8   Chunk ID "TGP2", Chunk Size, Zeroes
  010h 2       Number of parameters
  012h 2       Padding
  014h 4*N     Offsets to parameters
```

Tag Parameter

```
  000h 1       Parameter type
 If type is not 9:
  001h ..      Null terminated parameter name
 If type is 9:
  001h 1       Padding
  002h 2       Number of tag list items
  004h 2*N     List item indexes (in TGL2 block)
  ...  ..      Null terminated parameter name
```

Parameter names can be "face", "percent", "r", "g", "b", "a", "name", for
example.



## TGL2 Chunk (Tag Lists)


```
  000h 4+4+8   Chunk ID "TGL2", Chunk Size, Zeroes
  010h 2       Number of list items (0=None)
  012h 2       Padding
  014h 4*N     Offsets to list item names
  ...  ..      Null-terminated list item names
```


```
 ______________________________ MsgPrjBn Styles _______________________________
```



## SYL3 Chunk (Styles)


```
  000h 4+4+8   Chunk ID "SYL3", Chunk Size, Zeroes
  010h 4       Number of styles
  014h 16*N    Styles
```

Style

```
  000h 4       Region width (in pixels? max FFh on DSi)
  004h 4       Line num (position? or Height?) (usually 1 or more)
  008h 4       Font index (eg. 0,1,2 for type, or small/med/large maybe?)
  00Ch 4       Base color index (uh, what?) (usually FFFFFFFFh) (or 0)
```



## SLB1 Chunk (Style Labels)


```
  000h 4+4+8   Chunk ID "SLB1", Chunk Size, Zeroes
  This block contains labels for the SYL3 block.
```

Style names can be "commonBtn\_D\_1\_T\_sysBtnL\_00" or the like.


```
 ______________________________ MsgPrjBn Content ______________________________
```



## CTI1 Chunk (Project Content Info)


This block contains the names of the source files that the MSBT files were
generated from. The source files have the .mstxt extension.

```
  000h 4+4+8   Chunk ID "CTI1", Chunk Size, Zeroes
  010h 4       Number of filenames
  014h 4*N     Offsets to filename strings (from CTI1+10h)
  ...  ..      Null-terminated source filename strings (eg. "cardboard.mstxt")
```


```
 ________________________________ RI.mstl file ________________________________
```



## RI.mstl file (unknown purpose)


```
  000h 4      Number of whatevers
  004h N*2Ch  Whatevers
```




# <a name="3dsfilesvideoiconssmdh"></a>3DS Files - Video Icons (SMDH)



This page describes the format of the icon stored at CXI ExeFS:/icon and CIA
icons. The CXI icon is displayed by Home Menu and System Settings (3DS Software
Management), while CIA icons are dummies and not yet utilised by Dev 3DS' (as
of rev 47586).



## Icon File Format (36C0h bytes)


```
  0000h 4     ID "SMDH"
  0004h 2     Version (unknown/unspecified) (value 0000h exists)
  0006h 2     Reserved (0)
  0008h 200h  Title Japanese             ;\
  0208h 200h  Title English              ;
  0408h 200h  Title French               ; Each 200h-byte entry consists of:
  0608h 200h  Title German               ;   80h-byte   Short Description
  0808h 200h  Title Italian              ;   100h-byte  Long Description
  0A08h 200h  Title Spanish              ;   80h-byte   Publisher
  0C08h 200h  Title Simplified Chinese   ; All encoded in UTF-16
  0E08h 200h  Title Korean               ;
  1008h 200h  Title Dutch                ;
  1208h 200h  Title Portuguese           ;
  1408h 200h  Title Russian              ;
  1608h 200h  Title Traditional Chinese  ;
  1808h 200h  Title Reserved             ;
  1A08h 200h  Title Reserved             ;
  1C08h 200h  Title Reserved             ;
  1E08h 200h  Title Reserved             ;/
  2008h 1     Age Rating CERO (Japan)
  2009h 1     Age Rating ESRB (USA)
  200Ah 1     Age Rating Reserved
  200Bh 1     Age Rating USK (German)
  200Ch 1     Age Rating PEGI GEN (Europe)
  200Dh 1     Age Rating Reserved
  200Eh 1     Age Rating PEGI PRT (Portugal)
  200Fh 1     Age Rating PEGI BBFC (England)
  2010h 1     Age Rating COB (Australia)
  2011h 1     Age Rating GRB (South Korea)
  2012h 1     Age Rating CGSRR (Taiwan)
  2013h 1     Age Rating Reserved
  2014h 1     Age Rating Reserved
  2015h 1     Age Rating Reserved
  2016h 1     Age Rating Reserved
  2017h 1     Age Rating Reserved
  2018h 4     Region Lockout (bit0=JPN, bit1=USA, bit2=EUR, bit3=AUS, bit4=CHN,
                bit5=KOR, bit6=TWN, bit7-31=Reserved) (7FFFFFFFh=Region Free)
  201Ch 4     Match Maker ID      ;\Match Maker IDs (Online Play)
  2020h 8     Match Maker BIT ID  ;/
  2028h 4     Flags
  202Ch 1     EULA Version Minor  ;\
  202Dh 1     EULA Version Major  ;/
  202Eh 2     Reserved
  2030h 4     'Optimal Animation Default Frame' (for BNR) (uh, maybe preview?)
  2034h 4     CEC (StreetPass) ID (So the Home Menu knows which application
                icon to show the 'Green' CEC notification for)
  2038h 8     Reserved
  2040h 480h  Small Icon (24x24pix, shown on top screen when pausing the app)
  24C0h 1200h Large Icon (48x48pix, the general icon)
```



## Flags [2028h]


```
  0     Visibility Flag (Required for visibility on the Home Menu) (1=show?)
  1     Auto-boot this gamecard title
  2     Allow use of 3D? (For use with parental Controls. An application
          can use the 3D affect, even when this flag isn't set)
  3     Require accepting CTR EULA before being launched by Home
  4     Autosave on exit? (see below)
  5     Uses an Extended Banner?
  6     Region game rating required
  7     Uses save data? (see below)
  8     Application usage is to be recorded. If this is zero, it causes
          the application's usage to be omitted from the Home Menu's icon
          cache, as well as in other places.
  9     unknown/unspecified
  10    Disables SD Savedata Backups for this title. This is in addition to
         the blacklist.
  11    unknown/unspecified
  12    New 3DS exclusive title. Shows an error if used on Old 3DS.
  13-31 unknown/unspecified
```


Age Rating: Active ratings have a bitmask of 80h, and inactive ratings have no
bitmask at all. Ratings without the 80h bitmask are ignored. 40h bitmask
indicates Rating Pending. 20h bitmask indicates No Age Restriction. Age limits
are set by adding the minimal age to 80h (for example, limiting to 12 years and
up would give a bitmask of 8Ch)


Region Lockout: Regions are 'included' in region lock by setting their bitmask
value. Nintendo defines region free as 7FFFFFFFh. Early in the 3DS'
development, Nintendo grouped the Australian and Europe markets together.
Nintendo defines market Europe as having the combined bitmasks of Europe and
Australia. No 3DS' which check the Australia bitmask have been seen (Australia
uses the European 3DS model).


The EULA version is checked when the Accept EULA flag is set, the version is
compared to one stored in the 3DS. If the SMDH version is greater, then the
user will be prompted to accept the EULA.



## Effect of SaveData and AutoSave


These options have no effect on the performance of the application itself:
they're used to select an appropriate warning when closing an application from
Home.

Both off: "Closing software" (no warning if quitting directly with X)

SaveData: "Do you want to close [...]? (Unsaved data will be lost.)"

AutoSave: ?

Both on: "Saving data and closing software..." (no warning if quitting directly
with X)



## 'Optimal Animation Default Frame' (for BNR)


This is a float, indicating the preferred (or 'most representative') frame for
the banner animation.



## CEC (StreetPass) ID


This u32 represents the application CEC ID. This is likely loaded by
applications for use with the CEC services as well.



## Icon graphics


Both of the icons are encoded in RGB565 meaning 16bpp.

The data is encoded in tiles (starting from size 8x8, continuing recursively).

- If the buffer is like this:
  - 0       1       2       3       4       5       6       7       8       9
  - 10      11      12      13      14      15      16
- Then the image would look like this:
  - x=0     x=1     x=2     x=3     x=4
  - 0       1       4       5       16
  - 2       3       6       7       ...
  - 8       9       12      13
  - 10      11      14      15
- Uh, are that pixels or 8x8pix tiles?
- Either way, how would that translate to actual 24x24pix or 48x48pix icons??

Although both icons are known to be RGB565, developers have the option of
encoding icons (and banners) with the following encodings:

```
  RGBA8
  RGB8
  RGBA5551
  RGB565     (used)
  RGBA4
  LA8
  HILO8
  L8
  A8
  LA4
  L4
  ETC1
  ETC1A4
```

This does not necessarily mean the other encodings will be used, it is just
that those are the options when compiling. Like we've seen with Super Mario 3D
Land Nintendo has changed save file encryption, and "likewise" they can encode
icons and banners differently should they choose to. Currently we've seen just
RGB565 so don't be fooled if an icon doesn't show up right! It is probably one
of these formats above. Although we will probably not see other formats used
for a while it's nice to know they have an opportunity to change.

Also note that it seems Nintendo stores "each pixel in word-order", so the
actual "order of order" of "each color channel" in memory will depend on the
endianness. uh, what?



## Tools


```
  CiTRUS - (GUI)(Windows Only) Generating ICN files (aka icon files)
  3DSExplorer - (GUI)(Windows Only) Parsing ICN files (aka icon files)
```




# <a name="3dsfilesvideobannercbmd"></a>3DS Files - Video Banner (CBMD)



CBMD - CTR Banner Model Data (archive for CGFX/CWAV files)

These are stored in CXI ExeFS:/banner and optionally in extdata exbanner.

This is used for banners of titles you see in the home menu.

BNR used for the app banners in the CXI/exbanner is the same as CBMD with CWAV
at the end (uh, who is "BNR", and is that CWAV always supported in all cases,
or only for that "BNR" thing?).



## CBMD Header


```
  000h 4     ID "CBMD"
  004h 4     Zero
  008h 4     CGFX Offset for Default (88h)  ;-main CGFX file (for all regions)
  00Ch 4     CGFX Offset for EUR-English    ;\
  010h 4     CGFX Offset for EUR-French     ; region-specific CGFX files
  014h 4     CGFX Offset for EUR-German     ; (or 0=None)
  018h 4     CGFX Offset for EUR-Italian    ; (these are smaller CGFX files,
  01Ch 4     CGFX Offset for EUR-Spanish    ; usually with one or two custom
  020h 4     CGFX Offset for EUR-Dutch      ; Textures) (3DS Activity Log has
  024h 4     CGFX Offset for EUR-Portuguese ; more custom entries though)
  028h 4     CGFX Offset for EUR-Russian    ; (Nintendo Network ID Settings
  02Ch 4     CGFX Offset for JPN-Japanese   ; doesn't have any custom CGFX's)
  030h 4     CGFX Offset for USA-English    ;
  034h 4     CGFX Offset for USA-French     ;    (unknown if CHN/KOR/TWN are
  038h 4     CGFX Offset for USA-Spanish    ;    also supported?)
  03Ch 4     CGFX Offset for USA-Portuguese ;/
  040h 44h   Padding (0)                    ;<-- XXX probably CHN/KOR/TWN here?
  084h 4     CWAV Offset for Sound wave data
  088h ..    CFGX/CWAV data area...
```


"The common CGFX is used if the CGFX offset for the system region/language is
zero. Those optional offsets can be used in extdata exbanner, but separate CBMD
banner files for each region/language can be used as well."



## Entry Size


The header contains only offsets. To compute the size, search the next bigger
offset (or use the filesize as max offset), and then subtract the current
offset from that value. Note: The list does usually contain increasing offsets
(but it may be a bad idea to rely on that, eg. EUR-Spanish and USA-Spanish
might use the same offsets).



## CGFX Graphics


- [3DS Files - Video Archive (CGFX)](#3dsfilesvideoarchivecgfx)
Banner CGFX files are LZ11-compressed, the decompressed CGFX size shouldn't
exceed 80000h bytes for banners.



## CWAV Sound


- [3DS Files - Sound Wave Data (CWAV Format)](#3dsfilessoundwavedatacwavformat)
Banner CWAV total channels must be 2, and the length of the audio must be 3
seconds or less (uh, is that regardless of sample rate/sample size?), otherwise
the sound will play incorrectly (beeping/clicking) or the model may fail to
load.




# <a name="3dsfilesvideobannerextendedbanner"></a>3DS Files - Video Banner (Extended Banner)




## Overview


The Extended Banner is used to add text (and optionally an extra texture) to a
given banner. It can also (optionally) be used to set an expiration date for a
banner.


See "\user\ExBanner\" for how the extended-banners are loaded from extdata. The
Home Menu extended-banner loading function will immediately return without
loading anything if the programID is for System Settings.



## System titles using extended banners


```
  Mii Maker
  Face Raiders
```



## Format - Extension: .BIN (...stored somewhere as extdata on SD card?)


```
  000h 2    Texture width (if texture is used)
  002h 2    Texture height (if texture is used)
  004h 2    Texture colour format (if texture is used)
  008h 4    Expire Date, Year    ;\
  00Ch 2    Expire Date, Month   ; what is that, ASCII? or 32bit year???
  010h 2    Expire Date, Day     ;/
  014h 15h  Name of texture (if texture is used) ;uh, 15h may mean 16 decimal?
  024h 200h Plain text comment (255 character max) to be displayed in the
              banner on the HOME Menu (UTF-16 or so?)
  224h 80h  unknown/unspecified
  2A4h ..   Texture data (if any)
```

The date used for never-expiring exbanners varies, on retail like with Mii
Maker this is 31 Dec 2099 (year=833h, month=0Ch, day=1Fh). The
expiration-timestamp is only used for SpotPass exbanners, not
extdata-exbanners.



## Texture Colour Formats


```
  00h = RGBA8
  01h = RGB8
  02h = RGBA5551
  03h = RGBA565
  04h = RGBA4
  05h = LA8
  06h = HILO8
  07h = L8
  08h = A8
  09h = LA4
  0Ah = L4
  0Bh = A4
  0Ch = ETC1
  0Dh = ETC1A4
```



## SpotPass


When Home Menu loads extended-banners, it also attempts to load a "CBMD" banner
via SpotPass service commands. Normally this CBMD banner doesn't exist in
extended-banner extdata. This is broken with New3DS titles since Home Menu uses
these BOSS commands with the New3DS bitmask in the programID set. The common
and language-specific (when offset is non-zero) "CGFX" specified by the CBMD
are decompressed and processed.


The "CGFX" sections in this CBMD are actually the exact same exbanners loaded
from normal extdata. The exbanner data from SpotPass is stored to the same
state as the extdata-exbanners. No CWAV is loaded from SpotPass data.


The exbanners from SpotPass must have a timestamp less than current\_datetime,
otherwise they won't be parsed. The timestamp for the banner is calculated
with: nintimestamp\_mktime(out, exbanner->year, exbanner->month,
exbanner->day, \<hour=23>, \<minute = 59>, \<second = 59>,
\<millisecond = 999>);




# <a name="3dsfilesvideolayoutclytflyt"></a>3DS Files - Video Layout (CLYT/FLYT)



CLYT (.bclyt) is the layout format used on the 3DS. It stands for (Binary) CTR
Layout, and is similar to the RLYT format used on the Wii.

FLYT is something similar (used in 3DS eShop applet RomFS:\layout\).



## CLYT Header


```
  000h 4     ID ("CLYT")         ;or "FLYT"
  004h 2     Byte Order  (FEFFh)
  006h 2     Header Size (0014h)
  008h 4     Version (02020000h)
  00Ch 4     Total Filesize
  010h 4     Number of following Chunks
```



## lyt1 (Layout)


```
  000h 4     Chunk ID "lyt1"
  004h 4     Chunk Size
  008h 4     Origin type (0=Classic, 1=Normal)
  00Ch 8     Vector2 Canvas Size
```



## txl1 (Texture List)


```
  000h 4     Chunk ID "txl1"
  004h 4     Chunk Size
  008h 4     Number of Textures (N)
  00Ch N*4   Texture Name Offsets (relative to the start of this "array")
  ..  ..     null terminated names
```



## fnl1 (Font List)


```
  000h 4     Chunk ID "fnl1"
  004h 4     Chunk Size
  008h 4     Number of Fonts (N)
  00Ch N*4   Font Name Offsets (relative to the start of this "array")
  ..  ..     null terminated names
```



## mat1 (Materials)


```
  000h 4     Chunk ID "mat1"
  004h 4     Chunk Size
  008h 4     Number of Materials (N)
  00Ch N*4   Material Entry Offsets (relative to the start of this "section")
```

After this, the material entries follow.

```
  00h 14h   String    Material Name
  14h 4     RGBA8     Tev Color (Buffer Color?)
  18h 18h   RGBA8[6]  Tev Constant Colors
  30h 4     UInt32    Flags / bitfield
    Bit     Flag / data
    0-1     Nr texMap
    2-3     Nr texMatrix
    4-5     Nr texCoordGen
    6-8     Nr tevStage
    9       Has alphaCompare
    10      Has blendMode
    11      Use Texture Only
    12      Separate Blend Mode
    14      Has Indirect Parameter
    15-16   Nr projectionTexGenParameter
    17      Has Font Shadow Parameter
```

Texture Map Entry:

```
  00h 2     UInt16  Texture Index
  02h 1     Byte    Bitfield
                Bit     Data
                0-1     Wrap S     (0=Clamp, 1=Repeat, 2=Mirror)
                2-3     Min Filter (0=Near, 1=Linear)
  02h 1     Byte    Bitfield        ;<-- uh, maybe at offset 03h?
                Bit     Data
                0-1     Wrap T     (0=Clamp, 1=Repeat, 2=Mirror)
                2-3     Mag Filter (0=Near, 1=Linear)
```

Texture Matrix Entry:

```
  00h 8     Vector2 Translation
  08h 4     Single  Rotation
  0Ch 8     Vector2 Scale
```

TODO: texCoordGen, tevStage, alphaCompare, blendMode, etc...



## pan1 (Pane)


```
  000h 4     Chunk ID "pan1"
  004h 4     Chunk Size
  008h 1     UInt8   Flags
                       Bit   Flag
                       0     Visible
                       1     InfluencedAlpha
                       2     LocationAdjust
  009h 1     UInt8   Origin
  00Ah 1     UInt8   Alpha
  00Bh 1     UInt8   Pane magnification flags
                       Bit   Flag
                       0     IgnorePartsMagnify
                       1     AdjustToPartsBounds
  00Ch 18h   String  Pane name
  024h 0Ch   Vector3 Translation
  030h 0Ch   Vector3 Rotation
  03Ch 8     Vector2 Scale
  048h 8     Vector2 Size
```



## pic1 (Picture)


```
  000h 4     Chunk ID "pic1"
  004h 4     Chunk Size
  008h 4     RGBA8   Top left vertex color
  00Ch 4     RGBA8   Top right vertex color
  010h 4     RGBA8   Bottom left vertex color
  014h 4     RGBA8   Bottom right vertex color
  018h 2     UInt16  Material ID
  01Ah 2     UInt16  Nr texture coordinates = N
 Texture coordinates entry
  01Ch+N*20h 8     Vector2 Top left vertex texture coordinate
  024h+N*20h 8     Vector2 Top right vertex texture coordinate
  02Ch+N*20h 8     Vector2 Bottom left vertex texture coordinate
  034h+N*20h 8     Vector2 Bottom right vertex texture coordinate
```



## txt1 (Text)



## wnd1 (Window)


...?



## bnd1 (Bounding)


```
  000h 4     Chunk ID "bnd1"
  004h 4     Chunk Size
  008h 2     UInt16? ?
  00Ah 2     UInt16? ?
  00Ch ? (0x10h up to 0x30h)     String  Bounding name
  03Ch 8     Vector2 ?
  044h 4     Vector2 ?
  ?    ?     ?       ?
```



## pts1 (Parts 1)


...?



## pas1 (Pane Start)


```
  000h 4     Chunk ID "pas1"
  004h 4     Chunk Size (08h)
```



## pae1 (Pane End)


```
  000h 4     Chunk ID "pae1"
  004h 4     Chunk Size (08h)
```



## grp1 (Group)


3  000h 4     Chunk ID "grp1"

```
  004h 4     Chunk Size (1Ch+(0..N)*10h)
  008h 10h   String  Group Name
  018h 4     UInt32  Nr Pane References (=N) (can be zero)
  01Ch 10h*N String[N]    Pane References
```



## grs1 (Group Start)


```
  000h 4     Chunk ID "grs1"
  004h 4     Chnunk Size (08h)
```



## gre1 (Group End)


```
  000h 4     Chunk ID "gre1"
  004h 4     Chunk Size (08h)
```



## Tools


```
  Every File Explorer has limited support for viewing these
```



## See also


- [http://florian.nouwt.com/wiki/index.php/CLYT\_%28File\_Format%29](http://florian.nouwt.com/wiki/index.php/CLYT_%28File_Format%29)
- [https://github.com/Gericom/EveryFileExplorer/tree/master/3DS/NintendoWare/LYT1](https://github.com/Gericom/EveryFileExplorer/tree/master/3DS/NintendoWare/LYT1)



# <a name="3dsfilesvideolayoutanimationclanflan"></a>3DS Files - Video Layout Animation (CLAN/FLAN)



- This article is a stub. You can help 3DBrew by expanding it.


CLAN (.bclan) is the layout animation format used on the 3DS. It stands for
(Binary) CTR Layout Animation, and is similar to the RLAN format used on the
Wii.

FLAN is something similar, used in 3DS eShop applet (RomFS:\layout\) and 3DS
Browser applet (RomFS:\lyt\).



## Header


```
  00h 4     String  ID ("CLAN")         ;or "FLAN"
  04h 2     UInt16  Byte Order (FEFFh)
  06h 2     UInt16  Header Size (14h)
  08h 4     UInt32  Revision
  0Ch 4     UInt32  File Size
  10h 4     UInt32  Nr Sections
```



## pat1 (Pattern 1)


```
  00h 4     String  Signature (pat1)
  04h 4     UInt32  Section Size
  08h 4     UInt32  Flags?
  0Ch 4     UInt32  ?
  10h 4     Int32   ?
  14h 4     UInt32  ?
  18h 10h   String  Pattern name
```



## pai1 (Pattern Instruction? 1)


```
  00h 4     String  Signature (pai1)
  04h 4     UInt32  Section Size
  08h 4     UInt32  ?
  0Ch 4     UInt32  Flags?
  10h 4     UInt32  Nr entries?
  14h 4     UInt32  Entries offset (relative to pai1)
```


## Instruction? entry(ies)?


```
  00h 14h   String  Target panel name
  14h 4     UInt32  Flags?
  18h 4     UInt32  Animation entry offset (relative to entry)
  1Ch 4     UInt32  ? (if flag bit 1 is set)
```


## Animation entry


```
  00h 4       String  Animation type
    Name    Description
    CLPA    CTR Layout Pane SRT (Scale/Rotate/Translate) animation.
    CLTS    CTR Layout Texture SRT animation.
    CLVI    CTR Layout Visibility animation.
    CLVC    CTR Layout Vertex Color animation.
    CLMC    CTR Layout Material Color animation.
    CLTP    CTR Layout Texture Pattern animation.
  04h 1       UInt8   Nr of animations
  05h 3       UInt8[3]        Padding
  ?   ?       ?       ?
```



## See also


- [http://wiki.tockdom.com/wiki/BRLAN](http://wiki.tockdom.com/wiki/BRLAN)
- [http://wiibrew.org/wiki/Wii\_Animations#Animations\_.28.2A.brlan.29](http://wiibrew.org/wiki/Wii_Animations#Animations_.28.2A.brlan.29)





# <a name="3dsfilesvideolayoutimagesclimflim"></a>3DS Files - Video Layout Images (CLIM/FLIM)



Unknown purpose, maybe some kind of images, ie. texture/bitmaps?

FLIM is something similar (used in 3DS eShop applet RomFS:\layout\).



## Footer


```
 00000000h  ..  Images...
 Footer+00h 4   ID "CLIM"               ;or "FLIM"
 Footer+04h 2   Byte Order (FEFFh)
 Footer+06h 2   Footer Size (14h)
 Footer+08h 4   Version? (02020000h)
 Footer+0Ch 4   Total Filesize
 Footer+10h 4?  Maybe number of images? (00000001h)
 Footer+14h 4   Chunk ID "imag"     ;\
 Footer+18h 4   Chunk Size (10h)    ; image data is at offset 0
 Footer+1Ch 2   Width?              ; (if multiple images should be allowed...
 Footer+1Eh 2   Height?             ; next image is at WHICH offset?)
 Footer+20h 4?  Type? (0Dh = 4bpp?) ;/   ;<-- ETC1A4 ?
 Footer+24h 4   Footer Offset (from begin of file to "CLIM") ;<--at end of file
```




# <a name="3dsfilesvideoarchivecgfx"></a>3DS Files - Video Archive (CGFX)



CGFX files exist as standalone files, and can be also found in CBMD banner
archives, usually with LZ11 compression.

CGFX is a container format used to store graphics resources.



## Overall CGFX Format


- [3DS Files - Video Archive (CGFX Header, Blocks, DICTs)](#3dsfilesvideoarchivecgfxheaderblocksdicts)


## CGFX Sections


- [3DS Files - Video Archive (CGFX\_00h - CMDL Models)](#3dsfilesvideoarchivecgfx00hcmdlmodels)
- [3DS Files - Video Archive (CGFX\_01h - TXOB Textures)](#3dsfilesvideoarchivecgfx01htxobtextures)
- [3DS Files - Video Archive (CGFX\_02h - LUTS Look-up Tables)](#3dsfilesvideoarchivecgfx02hlutslookuptables)
- [3DS Files - Video Archive (CGFX\_04h - SHDR Shaders)](#3dsfilesvideoarchivecgfx04hshdrshaders)
- [3DS Files - Video Archive (CGFX\_05h - CCAM Cameras)](#3dsfilesvideoarchivecgfx05hccamcameras)
- [3DS Files - Video Archive (CGFX\_06h - CFLT/CHLT/CALT Lights)](#3dsfilesvideoarchivecgfx06hcfltchltcaltlights)
- [3DS Files - Video Archive (CGFX\_08h - CENV Environments)](#3dsfilesvideoarchivecgfx08hcenvenvironments)
- [3DS Files - Video Archive (CGFX\_09h,0Ah,0Dh - CANM Animations)](#3dsfilesvideoarchivecgfx09h0ah0dhcanmanimations)
- [3DS Files - Video Archive (CGFX\_0Eh,0Fh - PEMT Emitters/Particles)](#3dsfilesvideoarchivecgfx0eh0fhpemtemittersparticles)


## Unknown CGFX Sections


These do reportedly exist... somewhere? Unknown which files do actually have
such sections.

- 3DS Files - Video Archive (CGFX\_03h - ???? Materials)

- 3DS Files - Video Archive (CGFX\_07h - CFOG? Fogs)

- 3DS Files - Video Archive (CGFX\_0Bh - ???? Visibility animations)

- 3DS Files - Video Archive (CGFX\_0Ch - ???? Camera animations)

The Materials are all-unknown. The Fogs are reportedly called CFOG, but
anything else is unknown. The two animation types might use CANM format like
the other three animation types, but that's just guessed.



## Skeleton data (uh, what? where?)


Each entry is E0h bytes in length and organized this way:

```
  00h 4     Offset (self relative) to name symbol
  04h 4     ?
  08h 4     Joint ID
  0Ch 4     Parent joint ID
  10h 4     Signed offset (self-relative) to parent joint
  14h 18h   unknown/unspecified
  2Ch 0Ch   Angle vector (floats, x, y, z)
  38h 0Ch   Position vector (floats, x, y, z)
  44h 30h   Transformation matrix (4x3)
  74h 30h   Identity matrix ? (4x3)
  A4h 1Ch   unknown/unspecified
```

Each entry stores the joint transformation data twice; once as angle/position
vectors and once as a transformation matrix. Each entry also stores a second
matrix which appears to always be identity(?)



## Tools


```
  Every File Explorer
  Ohana3DS and its forks
  SPICA
```



## Links


Another CGFX Format Description (Archived Page):

- [http://florian.nouwt.com/wiki/index.php/CGFX\_(File\_Format)](http://florian.nouwt.com/wiki/index.php/CGFX_(File_Format))
- [https://web.archive.org/web/20150511211029/http://florian.nouwt.com](https://web.archive.org/web/20150511211029/http://florian.nouwt.com)
  - /wiki/index.php/CGFX\_(File\_Format)




# <a name="3dsfilesvideoarchivecgfxheaderblocksdicts"></a>3DS Files - Video Archive (CGFX Header, Blocks, DICTs)




## CGFX Header


```
  000h 4     ID "CGFX"
  004h 2     Byte Order (FEFFh)
  006h 2     CGFX header size (14h)
  008h 4     Revision (can be 05000000h) (or 01000000h=Old, incompatible)
  00Ch 4     Total Filesize (bytes)
  010h 4     Number of blocks (usually 1=DATA, or 2=DATA+IMAG)
  ...  ..    DATA Block (DICT's, CMDL/TXOB/etc., and DICT Symbols)
  ...  ..    IMAG Block (optional, eg. for TXOB bitmaps)
```

The DATA block contains various small data structures. It's more or less
required to load the whole DATA block to memory when parsing those structs.

The IMAG block isn't required in memory (or, when needed, one may want to store
its content directly in VRAM).



## DATA Block (for CGFX Version 05000000h)


```
  000h      4     ID "DATA"
  004h      4     DATA Block Size (including DICT,CMDL,etc.)
  008h      4+4   DICT 00h for CMDL  Models                (NumEntries, Offset)
  010h      4+4   DICT 01h for TXOB  Textures              (NumEntries, Offset)
  018h      4+4   DICT 02h for LUTS  Look-up tables?       (NumEntries, Offset)
  020h      4+4   DICT 03h for ?     Materials             (NumEntries, Offset)
  028h      4+4   DICT 04h for SHDR  Shaders (+DVLB)       (NumEntries, Offset)
  030h      4+4   DICT 05h for CCAM  Cameras               (NumEntries, Offset)
  038h      4+4   DICT 06h for CFLT/CHLT/CALT Lights       (NumEntries, Offset)
  040h      4+4   DICT 07h for CFOG? Fogs                  (NumEntries, Offset)
  048h      4+4   DICT 08h for CENV  Environments          (NumEntries, Offset)
  050h      4+4   DICT 09h for CANM  Skeleton animations   (NumEntries, Offset)
  058h      4+4   DICT 0Ah for CANM  Texture animations    (NumEntries, Offset)
  060h      4+4   DICT 0Bh for ?     Visibility animations (NumEntries, Offset)
  068h      4+4   DICT 0Ch for ?     Camera animations     (NumEntries, Offset)
  070h      4+4   DICT 0Dh for CANM  Light animations      (NumEntries, Offset)
  078h      4+4   DICT 0Eh for PEMT  Emitters              (NumEntries, Offset)
 Below entry doesn't exist in all files (ie. abort here if [80h]="DICT").
 (080h)     4+4   DICT 0Fh for PEMT  Particles             (NumEntries, Offset)
  ...       ..    DICT's and CMDL/TXOB/etc. and Symbols...
```

The above Offsets are self-relative pointers to the corresponding DICT.

Unused DICTs have NumEntries=0 and Offset=0 (ie. the Offset doesn't point
anywhere in that case).



## IMAG Block (if present)


```
  000h       4     ID "IMAG"
  004h       4     IMAG Block Size
  008h       ...   Data (eg. texture bitmaps, referenced from TXOB's)
```



## DATA Block (for CGFX Version 01000000h)


3DS Activity Log does have some old CGFX file in RomFS:\simple.bcmdl, its the
data block lacks the "DATA" ID and Block Size, and the DICT's merely have
Offsets (without NumEntries).

```
  000h      4*9   DICT's (nine Offsets)
```

The CMDL/MTOB/etc. blocks in that file are probably also incompatible with
newer CGFX files?



## DICT - Directory with Symbol/Offset for each file


```
  000h 4     ID "DICT"
  004h 4     DICT size (1Ch+N*10h)
  008h 4     Number of entries (same as NumEntries in DATA's DICT list)
  00Ch 10h   DICT entry 0    (Patricia Tree Root entry)
  01Ch 10h*N DICT entry 1..N (Patricia Tree and actual Symbols/Offsets)
```

Patricia Tree Root entry:

```
  000h 4     Patricia Tree First Bit-number (always FFFFFFFFh=dummy/last)
  002h 2     Patricia Tree First entry (1..N) (usually points to rightmost bit)
  004h 0Ah   Patricia Tree Unused (zerofilled)
```

DICT entry 1..N format:

```
  000h 4     Patricia Tree Bit-number to be tested (0=Bit0 of 1st char) ?
  004h 2     Patricia Tree Next entry when test=0 ?
  006h 2     Patricia Tree Next entry when test=1 ?
  008h 4     Offset to symbol (self-relative) --> ASCII name
  00Ch 4     Offset to object (self-relative) --> flags followed by "CMDL" etc?
```

The Patricia Tree is intended for searching Symbols by testing a few bits
(without comparing all characters). The tree does somewhat unforunately start
with the highest bit in rightmost character (so the search string must be
assumed to be zeropadded). Unknown when the final entry is reached... when the
bit-test number is same/bigger than previous bit-test?


Note on DICT names: There can be several root entries with same name (eg. 3DS
Download Play ExeFS:\banner has name "COMMON" used for CFGX\_00h and CFGX\_09h
and CFGX\_0Ah root entries).




# <a name="3dsfilesvideoarchivecgfx00hcmdlmodels"></a>3DS Files - Video Archive (CGFX\_00h - CMDL Models)



CMDL is found in most CGFX files.



## CMDL - 3D Model


```
  000h 4     Flags (bit7: hasSkeletonSobj) (eg. 40000092h)
  004h 4     ID "CMDL"
  008h 4     Revision? (07000000h)
  00Ch 4     Name Offset (self-relative, same name as in parent DICT)
  010h 4     Unknown (0)
  014h 4     Unknown (0)
  018h 4     Unknown (1)
  01Ch 4     Unknown (1)
  020h 4     Unknown (0)
  024h 4     Unknown (0)
  028h 4+4   DICT for Animation Types                    (NumEntries, Offset)
  030h 0Ch   Scale        (3 float32: x, y, z) ;-usually (1,1,1)
  03Ch 0Ch   Rotation     (3 float32)          ;-usually (0,0,0)
  048h 0Ch   Translation  (3 float32)          ;-usually (0,0,0)
  054h 30h   Local Matrix (4x3 float32)        ;-usually unit matrix
  084h 30h   World Matrix (4x3 float32)        ;-usually unit matrix
  0B4h 4+4   Vertex Info SOBJ List (Meshes)              (NumEntries, Offset)
  0BCh 4+4   DICT for MTOB         (Materials)           (NumEntries, Offset)
  0C4h 4+4   Vertex Info SOBJ List (Shapes)              (NumEntries, Offset)
  0CCh 4+4   DICT for Unknown      (Mesh Nodes)          (NumEntries, Offset)
  0D4h 4     Unknown (1)
  0D8h 4     Unknown (0)
  0DCh 4     Unknown (0)
  0E0h 4     Skeleton Info SOBJ offset (self-relative) (present if flag bit7=1)
```

A CMDL section refers to outside data; it can not be considered separately from
the rest of the CGFX file. The second DICT in the CMDL section contains offsets
to MTOB objects.



## SOBJ List, at CMDL([B8h]+B8h)


```
  00h 4*N   Vertex Info SOBJ self-relative offset list
```



## MTOB - Materials - some kind of Texture Info, linked to TXOB


```
  000h 4     Flags (eg. 08000000h)
  004h 4     ID "MTOB"
  008h 4     Revision (06000000h)
  00Ch 4     Name Offset (self-relative, same name as in parent DICT)
  010h 4+4   Unknown (0,0)
  018h 4+4   Unknown (0,0)
  020h 4     Unknown (1)
  024h 4+4   Unknown (0,0)
  02Ch 4+4   Unknown (0,0)
  034h ...   Vectors/Matrices? (lots of float32's)
  0D8h ..    Unknown (00FFFFFFh, FFFFFFFFh, FFFFFFFFh, 00000000h)
  0E8h ..    Unknown (FFF2FFFFh, FF99CCCCh, FF000000h, FF000000h)
  0F8h ..    Unknown (FF000000h, FF000000h, 00000000h, 00000000h)
  108h 4     Unknown (3)
  ...  ...   ?
  ..   ..
```

Then somewhere inside/after MTOB comes something called TXOB with 40h-byte size
and SHDR (which are probably something else than the TXOB's and SHDR's in the
CGFX's "root directory") (though they might be meant to \<refer> to those
root entries).

```
  000h 4     Flags (eg. 20000004h)
  004h 4     ID "TXOB"
  008h 4     Revision (05000000h)
  00Ch 4     Name Offset (self-relative) (eg. points to empty string)
  010h 4+4   Unknown (0,0)
  018h 4     Name Offset (self-relative) (eg. points to "COMMON3",0)
  01Ch 4+4   Unknown (0,0)
  024h 4     Unknown (FFFFFF90h)
  028h 4     Unknown (1)
  02Ch 4+4+4 Unknown (0,0,0)
  038h 4     Unknown (3F800000h) (float32)
  03Ch 4     Unknown (0)
  -------------------------                                 ;\somehere is
  040h 4     Unknown (1)  or Flags for below shader stuff?  ; probably begin
  - - - - - - - -----------                                 ;/of shader struct?
  044h 4     ID "SHDR"
  048h 4     Revision (05000000h)
  04Ch 4     Name Offset (self-relative) (eg. points to ... what?)
  050h 4+4   Unknown (0,0)
  058h 4     Name Offset (self-relative) (eg. points to ... what?)
  05Ch 4     Unknown ?
  ...  ...   ?
  ..   ..
```



## SOBJ


SOBJ structures can be used to describe 3D objects that are part of the model.
If such is the case then they will follow this structure:

```
  000h 4     Flags (bit4: model, bit1: skeleton)
  004h 4     ID "SOBJ"
  008h 4     ?
  00Ch 4     Unknown symbol offset (self-relative)
  010h 0Ch   ?
  01Ch 4     Offset (self-relative) to Unknown1 (array of floats?)
  020h 0Ch   Mesh position vector (X/Y/Z floats)
  02Ch 4+4   Face Group List    (NumEntries, Offset) (list contains offsets)
  034h 4     ?
  038h 4+4   Vertex Group List  (NumEntries, Offset) (list contains offsets)
  040h 4     Unknown offset (self-relative) ?
```


Face groups:

```
  000h 4+4   Bone Group ID List (NumEntries, Offset) (list contains 32bit IDs)
  008h 4     ?
  00Ch 4+4   Unknown2 List      (NumEntries, Offset) (list contains offsets)
```


Unknown2:

```
  000h 4+4   Face Group Descriptor List (NumEntries, Offset) (contains offsets)
  008h 4+4   Unknown3 List              (NumEntries, Offset) (contains 32bit's)
  010h 8     ?
```


Face array descriptor:

```
  000h 4     Flags (bit 1: vertex index format: 0=byte, 1=short)
  004h 4     ?
  008h 4+4   Vertex Index Array (SizeInBytes, Offset)
```


Vertex groups come in a number of different formats. Typically the first vertex
group entry is of format 40000002h and contains the actual vertex array.


Vertex group format 40000002h:

```
  000h 4     Flags (40000002h)
  004h 4     ?
  008h 4     ?
  00Ch 4     ?
  010h 4     ?
  014h 4+4   Vertex Array       (SizeInBytes, Offset)
  01Ch 4     ?
  020h 4     ?
  024h 4     Vertex stride/size in bytes (see below)
  028h 4     Unknown3 count
  02Ch 4     Offset (self-relative) to component declaration offset array
```


Each mesh's primary vertex group contains an array of vertex component
declaration objects, defining the order and parameters for each of a vertex's
components.


Vertex component declaration:

```
  000h 4     Flags (40000001h)
  004h 4     Vertex component type (see below)
  008h 4     ?
  00Ch 4     ?
  010h 4     ?
  014h 4     ?
  018h 4     ?
  01Ch 4     ?
  020h 4     ?
  024h 1     Vertex component data type (see below)
  025h 1     ?
  026h 1     ?
  027h 1     ?
  028h 4     Number of values in this component (eg. XYZ=3, UV=2)
  02Ch 4     Multiplier for this component's values (float)
  030h 4     Position of this component within vertex stride
```

Vertex formats with bone data support multiple bone assignment. In this case,
the sum of all bone weights is 64h.

- Vertex component types:
  - 00h=Position
  - 01h=Normal
  - 02h=? (unobserved)
  - 03h=Color
  - 04h=UV0
  - 05h=UV1
  - 06h=? (unobserved, possibly UV2)
  - 07h=Weight
  - 08h=Index
- Vertex component data types:
  - 00h=sbyte
  - 01h=byte
  - 02h=short
  - 03h=? (unobserved, possibly ushort)
  - 04h=? (unobserved, possibly int)
  - 05h=? (unobserved, possibly uint)
  - 06h=float

Vertex components are stored as one of the above data types, and the vertex
component declaration contains a multiplier that adapts the values to the float
version which the game will use. For example, color RGBA values are stored as
bytes, and the multiplier converts them from 0-255 to 0-1.0, and position
components using short values are normalized via the multiplier to take
advantage of the entire short value range.




# <a name="3dsfilesvideoarchivecgfx01htxobtextures"></a>3DS Files - Video Archive (CGFX\_01h - TXOB Textures)



TXOB is found in most CGFX files.



## TXOB - Texture Objects?


TXOBs are contained within MTOBs. They can describe textures; if such is the
case, then their structure is as follows:

- Can be 40h-byte or 5Ch-byte size?
- 3dbrew messed blurb claims 4Ch-bytes (with overlapping entries)?
- Or are the 40h-byte ones sub-items in MTOB?
- And only the 5Ch-byte ones are actually DICT 01h entries?
  - 000h 4     Flags (eg. 20000004h=40h-byte, or 20000011h=5Ch-byte)
  - 004h 4     ID "TXOB"
  - 008h 4     Revision? (05000000h)
  - 00Ch 4     Offset (self-relative) to symbol
  - 010h 4     Unknown (0)
  - 014h 4     Unknown (0)
  - 018h 4     Texture height (eg. 40h)
  - 01Ch 4     Texture width  (eg. 10h)
  - 020h 4     Unknown (?)    (eg. 6758h, 6756h, 6758h)  ;\flags maybe?
  - 024h 4     Unknown (?)    (eg. 6760h, 6761h, 1401h)  ;/or handle/ID/index?
  - 028h 4     Mipmap levels  (eg. 1)
  - 02Ch 4     Unknown (0)
  - 030h 4     Unknown (0)
  - 034h 4     Texture format (eg. 5) (see below)
  - 038h 4     Unknown (?)    (eg. 4)
  - 03Ch 4     Texture height (eg. 40h)  ;\same as in [18h,1Ch] ?
  - 040h 4     Texture width  (eg. 10h)  ;/
  - 044h 4     Texture data size (eg. 800h) (width\*height\*bytes\_per\_pixel)
  - 048h 4     Texture data offset (self-relative) (eg. 1A070h) (that's in IMAG)
  - 04Ch 4     Unknown (0)
  - 050h 4     Unknown (?)       (eg. 10h)
  - 054h 4     Unknown (0)
  - 058h 4?    Unknown (0)

Texture format:

```
  00h=RGBA8
  01h=RGB8
  02h=RGBA5551
  03h=RGB565
  04h=RGBA4
  05h=LA8
  06h=HILO8
  07h=L8
  08h=A8
  09h=LA4
  0Ah=L4
  0Bh=A4 ?
  0Ch=ETC1 (see notes below)
  0Dh=ETC1A4 ?
```

Every texture format has its texture data divided into 8x8 tiles. See SMDH for
more information. ETC1 is a compressed texture format which compresses blocks
of 4x4 pixels into u64s. These u64 are traditionally stored in big endian;
however, nintendo's implementation stores them in little endian. ETC1 textures
are stored in 8x8 tiles; decompressed 4x4 therefore have to be organized
accordingly. See [1] for implementation example.




# <a name="3dsfilesvideoarchivecgfx02hlutslookuptables"></a>3DS Files - Video Archive (CGFX\_02h - LUTS Look-up Tables)



LUTS is found in some CGFX files (eg. 3DS System Settings ExeFS:\banner).



## LUTS - lookup table(s?) (possibly for use with shaders?)


```
  000h 4     Flags (eg. 04000000h)
  004h 4     ID "LUTS"
  008h 4     Revision (04000000h)
  00Ch 4     Name Offset
  010h 4+4   Unknown (0,0)
  018h 4+4   DICT for ... appears to describe material specularity? (Num,Offs)
```




# <a name="3dsfilesvideoarchivecgfx04hshdrshaders"></a>3DS Files - Video Archive (CGFX\_04h - SHDR Shaders)



SHDR is found some CGFX files, for example,

```
  3DS eShop RomFS:\shader contains one CGFX (and several raw DVLBs files)
  3DS Sound RomDS:\res\GfxShader.LZ contains two SHDR's in a single GGFX
```



## SHDR - Shader (contains a regular DVLB file, with some extra parameters)


```
  000h 4     Flags (eg. 80000002h)
  004h 4     ID "SHDR"
  008h 4     Revision (05000000h)
  00Ch 4     Name Offset (self-relative) (same as in parent DICT)
  010h 4+4   Unknown (0,0)
  018h 4     Shader Size (eg. 26A4h)              ;\Shader in DVLB file format
  01Ch 4     Shader Offset (self-relative) (28h)  ;/
  020h 4     Unknown (04h)       ;number of below words (eg. 4)              ;\
  024h 4     Unknown (eg. 26C4h) ;ptr to 4 words (8B31h,8B31h,8B31h,8B31h)   ;/
  028h 4     Unknown (04h)       ;number of below words (eg. 4)              ;\
  02Ch 4     Unknown (eg. 26CCh) ;ptr to 4 words (20h,A4h,128h,1ACh) ;Offsets;/
  030h 4     Unknown (04h)       ;number of below words (eg. 4)              ;\
  034h 4     Unknown (eg. 26D4h) ;ptr to 4 words (0,0,0,0)                   ;/
  038h 4     Unknown (0)
  03Ch 4     Unknown (0)
  040h 4     Unknown (0)
```

Unknown what the three lists at [20h..37h] are doing, and unknown what is at
the offset of the second list.


For the DVLB file format, see

- [3DS Files - Video Shaders (DVLB and DVOB Format)](#3dsfilesvideoshadersdvlbanddvobformat)



# <a name="3dsfilesvideoarchivecgfx05hccamcameras"></a>3DS Files - Video Archive (CGFX\_05h - CCAM Cameras)



CCAM is found in some CGFX files (eg. 3DS Sound RomFS:\res\S.pack).



## CCAM Format


```
  000h 4     Flags (eg. 4000000Ah)
  004h 4     ID "CCAM"
  008h 4     Revision (07000000h)
  00Ch 4     Name Offset (self-relative) (same as in parent DICT)
  010h 4+4   Unknown (0,0)
  018h 4+4   Unknown (1,1)
  020h 4+4   Unknown (0,0)
  028h 4+4   DICT for Camera Animation  (NumEntries,Offset)
  030h 0Ch   Vector? (3xFloat32) (1.0, 1.0, 1.0)
  ...  ..    More Vectors and/or Matrices ?
  0BCh 4     Unknown (1D4h)
  0C0h 4     Unknown (1E8h)
  0C4h 4     Unknown (0)
```



## Camera Animation (from DICT in CCAM) (eg. Name=CameraAnimation)


```
  000h 4     Unknown (80000000h)
  004h 4     Unknown (0)
  008h 4     Name Offset (self-relative) (same as in parent DICT)
  00Ch 4     Unknown (5)
  010h 4+4   DICT for whatever (NumEntries,Offset)
  018h 4     Unknown (3)
  01Ch 4     Unknown (8)
  020h 4     Unknown (0)
  024h 4     Unknown (8)
  028h 4     Unknown (6)
  02Ch 4     Unknown (2)
```

The DICT can have several entries (with names ProjectionUpdater.AspectRatio,
ProjectionUpdater.Far, ProjectionUpdater.Fovy, ProjectionUpdater.Near,
Transform, ViewUpdater.TargetPosition, ViewUpdater.Twist). The format(s) of
that entries are unknown.




# <a name="3dsfilesvideoarchivecgfx06hcfltchltcaltlights"></a>3DS Files - Video Archive (CGFX\_06h - CFLT/CHLT/CALT Lights)



CFLT (Directional/Fragment Lights) is found in some CGFX files, eg. 3DS System
Settings banner

CHLT (Hemisphere Lights) is less common, but found in StreetPass Mii Plaza
RomFS:\graphics\model\figure\_Galaxy2.lz77 and figure\_Link.lz77

CALT (Ambient? Lights) is even less common, found in StreetPass Mii Plaza
RomFS:\graphics\model\figure\_Pikmin.lz77 and figure\_Samus.lz77



## CFLT Format


```
  000h 4     Flags (eg. 400000A2h)
  004h 4     ID "CFLT"
  008h 4     Revision (06000000h)
  00Ch 4     Name Offset (self-relative) (same as in parent DICT)
  010h 4+4   Unknown (0,0)
  018h 4+4   Unknown (1,1)
  020h 4+4   Unknown (0,0)
  028h 4+4   DICT for Light Animation (NumEntries,Offset)
  030h 0Ch   Vector? (3xFloat32) (1.0, 1.0, 1.0)
  03Ch 0Ch   Vector? (3xFloat32) (0.0, 0.0, 0.0)
  048h 0Ch   Vector? (3xFloat32) (0.0, 0.0, 0.0)
  054h 30h   Matrix? (4x3xFloat32) (Identity)
  084h 30h   Matrix? (4x3xFloat32) (Identity)
  0B4h 4     Unknown (1)
  0B8h 10h   Unknown (zeroes)
  0BCh 40h   Float32's (all 1.0)
  0FCh 10h   Unknown (FF000000h, FFFFFFFFh, FFFFFFFFh, FFFFFFFFh)
  10Ch 0Ch   Vector? (3xFloat32?) (3F13CD3Ah, 3F13CD3Ah, BF13CD3Ah)
  118h 0Ch   Vector? (3xFloat32?) (00000000h, 00000000h, 00000000h)
  124h 0Ch   Vector? (3xFloat32?) (3F800000h, 0003F000h, 00080000h)
  130h 4     Unknown (1)
```

Some of the Vectors might be X,Y,Z vectors. Some might be R,G,B colors?



## Light Animation (from DICT in CFLT) (eg. Name=LightAnimation)


```
  000h 4     Unknown (80000000h)
  004h 4     Unknown (0)
  008h 4     Name Offset (self-relative) (same as in parent DICT)
  00Ch 4     Unknown (4)
  010h 4+4   DICT for whatever (NumEntries,Offset)
  018h 4     Unknown (5)
  01Ch 4     Unknown (8)
  020h 4     Unknown (0)
  024h 4     Unknown (0)
  028h 4     Unknown (3)
  02Ch 4     Unknown (6)
  030h 4     Unknown (2)
  034h 4     Unknown (0)
```

The DICT can have several entries (with names Ambient, Diffuse, Direction,
DistanceAttentuationEnd, DistanceAttentuationStart, IsLightEnabled, Specular0,
Specular1, Transform). The formats of those entries are unknown (the entries
seem to use different formats, eg. IsLightEnabled is 8 bytes).



## CHLT Format



## CALT Format


Unknown. Seems to be similar as CFLT (but, in case of CALT, with less Light
Animation DICT entries).




# <a name="3dsfilesvideoarchivecgfx08hcenvenvironments"></a>3DS Files - Video Archive (CGFX\_08h - CENV Environments)



CENV is found in some CGFX files, eg. 3DS System Settings ExeFS:\banner (with
Unknown2) or Mii Maker ExeFS:\banner (with Unknown1, Unknown2, Unknown3)



## CENV Format


```
  000h 4     Flags (eg. 00800000h)
  004h 4     ID "CENV"
  008h 4     Revision (01000000h)
  00Ch 4     Name Offset (self-relative) (same as in parent DICT)
  010h 4+4   Unknown0 (0,0)
  018h 4+4   Unknown1 (0,0)    (or 1,14h)     ;(Num,Offset ?)
  020h 4+4   Unknown2 (1,0Ch)  (or 2,10h)     ;(Num,Offset ?)
  028h 4+4   Unknown3 (0,0)    (or 1,10h)     ;(Num,Offset ?)
  ...  4*n1  Offset List for Unknown1 ?
  ...  4*n2  Offset List for Unknown2 ?
  ...  4*n3  Offset List for Unknown3 ?
```

Entries for Unknown1 (if any):

```
  000h 4     Unknown (0)
  004h 4     Corresponding name? (eg. Offset to "FragmentOperation")
  008h 4     Unknown (0)
  00Ch 4     Unknown (0)
```

Entries for Unknown2:

```
  000h 4     Unknown (1)
  004h 4     Unknown (4)
  008h 4     Unknown (4)
  00Ch 4     Unknown (0)
  010h 4     Corresponding Light name?  (eg. Offset to Name "Light1")
  014h 4     Unknown (0)
```

Entries for Unknown3 (if any):

```
  ...  ..    ?
```




# <a name="3dsfilesvideoarchivecgfx09h0ah0dhcanmanimations"></a>3DS Files - Video Archive (CGFX\_09h,0Ah,0Dh - CANM Animations)



- 3DS Files - Video Archive (CGFX\_09h - CANM Skeleton animations)

- 3DS Files - Video Archive (CGFX\_0Ah - CANM Texture animations)

- 3DS Files - Video Archive (CGFX\_0Dh - CANM Light animations)

CANM skeleton is found in some CGFX files, 3DS System Settings ExeFS:\banner

CANM texture is found in some CGFX files, eg. 3DS Download Play ExeFS:\banner

CANM light is found in some CGFX files, eg. 3DS Camera RomFS:\res\P\_Finder\_U


All of those types do begin with ID "CANM", but unknown if they are actually
using the same data structure(s).



## CANM (for Skeleton Animations, and Texture Animations)


```
  N/A  -     There is no leading Flags entry,
  000h 4     ID "CANM"
  004h 4     Revision (05000000h)
  008h 4     Name Offset (self-relative) eg. COMMON (same as in parent DICT)
  00Ch 4     Name Offset (self-relative) eg. SkeletalAnimation
  010h 4     Unknown (1)
  014h 4     Unknown (44160000h) (float32 maybe?)
  018h 4+4   DICT for ... whatever (NumEntries,Offset)  (Offset=0Ch)
  020h 4+4   Unknown (0,0)
```

Note: In the above example, the name "COMMON" is used for both CFGX\_00h and
CFGX\_09h and CFGX\_0Ah root entries.

The DICT in the CANM block(s) can contain items with various names, the
format(s) of that items are unknown.




# <a name="3dsfilesvideoarchivecgfx0eh0fhpemtemittersparticles"></a>3DS Files - Video Archive (CGFX\_0Eh,0Fh - PEMT Emitters/Particles)



- 3DS Files - Video Archive (CGFX\_0Eh - PEMT Emitters)

- 3DS Files - Video Archive (CGFX\_0Fh - PEMT Particles)

PEMT emitters is found in some CGFX files, eg. Mii Maker RomFS:\effects\..

PEMT particles is found in some CGFX files, eg. 3DS Camera RomFS:\effect\P.pack



## PEMT Format (as for CGFX\_0Fh Particles) (unknown if CGFX\_0Eh is same/similar)


```
  000h 4     Flags (eg. 40000006h)
  004h 4     ID "PEMT"
  008h 4     Revision (05000000h)
  00Ch 4     Name Offset (self-relative) (same as in parent DICT)
  010h 4+4   Unknown (0,0)
  018h 4+4   Unknown (1,1)
  020h ...   Several zeroes and float32's ...?
  0B8h 4     Name Offset (self-relative) (whatever name?)
  0BCh 4     Unknown (24h)                      (Offset?)
  0C0h 4     Unknown (0)
  0C4h 4     Unknown (3F800000h) (or 40000000h) (float32?)
  0C8h 4     Unknown (0)         (or 3DCCCCCDh)
  0CCh 4     Unknown (0Ah)       (or 13Dh)
  0D0h 4     Unknown (0)         (or 0)
  0D4h 4     Unknown (1)         (or 0)
  0D8h 4     Unknown (168h)      (or 3)
  0DCh 4     Unknown (0)         (or 4)
```

Then there comes some more stuff at offset 0E0h (which might be addressed via
Offset 24h stored at [0BCh] in above structure?). That extra data can somehow
vary randomly with/without DICT at different locations (it seems to be related
on "Flags" in first which can be 04000000h, 10000000h, 20000000h, 40000000h,
80000000h, although there are two variants for Flags=20000000h).

Unknown how that makes sense... maybe some of the below stuff is totally
unrelated to PEMT (ie. it might be referenced from somewhere else, and just
happens to be located after PEMT).


3DS Camera RomFS:\effect\P.pack\ScoreE.bcptlLZ has three variants with DICT
(all in one file).



## Variant with DICT and Flags=20000000h


```
  000h 4     Flags? (20000000h)
  004h 4     Unknown (0)
  008h 4     Unknown (3F000000h)
  ...  ..    Floats and/or whatever
  02Ch 4     Name Offset (self-relative) (whatever name?)
  030h 4     Unknown (3)         (or 2)
  034h 4+4   DICT for ... whatever (NumEntries,Offset)
  03Ch 4+4   Unknown (1,8)       (or 4,8)     (Num,Offset?)  ----.
  044h 4     Unknown (0)         (or 1)                          |
  048h ..    Unknown (0)         (or 3,7,5,2)              <-----'
```


## Variant with DICT and Flags=40000000h


```
  000h 4     Flags? (40000000h)
  004h 4     Unknown (0)
  008h 4     Unknown (3Fxxxxxxh)                        ;\one extra word here?
  ...  ..    Floats and/or whatever                     ;/
  030h 4     Name Offset (self-relative) (whatever name?)
  034h 4     Unknown (3)
  038h 4+4   DICT for ... whatever (NumEntries,Offset)
  040h 4+4   Unknown (1,8)                    (Num,Offset?)  ----.
  048h 4     Unknown (0)                                         |
  04Ch ..    Unknown (0)                                   <-----'
```


## Variant with DICT and Flags=10000000h


```
  000h 4     Flags? (10000000h)
  004h 4     Unknown (0)                                ;\no floats here
  008h 4     Unknown (80000000h)                        ; (or only a few)
  00Ch 4     Unknown (0)                                ;/
  010h 4     Name Offset (self-relative) (whatever name?)
  014h 4     Unknown (3)
  018h 4+4   DICT for ... whatever (NumEntries,Offset)
  020h 4+4   Unknown (1,8)                    (Num,Offset?)  ----.
  028h 4     Unknown (0)                                         |
  02Ch ..    Unknown (0)                                   <-----'
```

Then comes the DICT (unless type is 04000000h)... the DICT is containing
whatever... it can have MANY entries, in unknown format(s).



## Variant without DICT and Flags=04000000h


As found in Mii Maker RomFS:\effect\..\QR00.bcptl

```
  000h 4     Unknown (04000000h)
  004h 4     Unknown (0)             ;has only some floats, no DICT...
  008h 1Ch   Floats and/or whatever
  024h 2     Uhm, two zero bytes? (then followed by Symbol table)
```



## Variant without DICT and Flags=20000000h (despite same Flags can have DICT)


And Mii Maker also has some file with yet smaller DICT-less block, but with
20000000h (which usuallly DOES have DICT, but not in this case).

```
  000h 4     Unknown (20000000h)
  004h 4     Unknown (0)             ;has only some floats, no DICT...
  008h 18h   Floats and/or whatever
  020h 2     Uhm, bytes 00h, 01h? (then followed by Symbol table)
```



## Variant without DICT and Flags=80000000h


And, AR Games RomFS:\i\_ar\effect\Ef\_drawing.lz77

```
  000h 4     Unknown (80000000h)
  004h 4     Unknown (0)             ;has only some floats, no DICT...
  008h 10h   Floats and/or whatever
  018h 4     Unknown (0)
```


Some of the DICT-less variants seem to contain two bytes (rather than a whole
32bit word) in last entry? Usually that's padded to 32bit alignment, but not in
the last entry (which occurs right before the string table, which can start at
a non-aligned location).




# <a name="3dsfilesvideoshadersdvlbanddvobformat"></a>3DS Files - Video Shaders (DVLB and DVOB Format)



There are two shader file formats:

```
  DVLB - Vertex Shader Library (can contain one or more shaders) (common/used)
  DVOB - Vertex Shader Object  (single shader) (unknown if/where that's used?)
```

Shaders are usually stored in folder RomFS:\shaders, with extensions

```
  .shbin  Shader Binary in DVLB format (most common)
  .??     Shader Binary in DVOB format (unknown if/where that's used?)
  .bcsdr  Shader Binary in DVLB format stored inside of a CGFX container
  .csdr   ASCII, with shader binary(ies?) encoded in BASE64  (eg. in AR Games)
```



## DVLB Format (Vertex Shader Library) (can contain one or more shaders)


```
  000h 4    ID "DVLB" (Vertex Shader Library)
  004h 4    N = number of DVLEs in SHBIN
  008h 4*N  DVLE offset table (offsets to start of the DVLB(???) sections)
```

There is one DVLP block, containing the binary opcode/opdesc data for all
shaders (located right after the above header, ie. at offset 008h+4\*N).

```
  000h 4    ID "DVLP" (Vertex Shader Library Program Opcodes/Opdescs)
  004h 2    Type/Version?                (can be 0C02h)
  006h 2    Unknown                      (can be 0000h)
  008h 4    Opcode Table Offset          (from DVLP start) (28h)
  00Ch 4    Opcode Table Size            (in 4-byte units)
  010h 4    Opdesc Table Offset          (from DVLP start)
  014h 4    Opdesc Table Size            (in 8-byte units)
  018h 4    Line Number Table Offset ?   (from DVLP start)
  01Ch 4    Line Number Table Size   ?   (usually zero)
  020h 4    Filename Symbol Table Offset (from DVLP start)
  024h 4    Filename Symbol Table Size   (in 1-byte units)
  028h ..   Data for above Opcodes, Opdescs, etc.
```

There can be one or more DVLE blocks, with information about entrypoint and
parameters for each shader (located at Header[008h+index\*4]).

```
  000h 4    ID "DVLE" (Vertex Shader Library Function Entrypoints/Params)
  004h 2    Type/Version?                (can be 0C02h)
  006h 1    Shader type (0=Vertex shader, 1=Geometry shader, other=?)
  008h 4    Opcode Entrypoint Address    (in words, in memory) (main)
  00Ch 4    Opcode End Address           (in words, in memory) (endmain)
  010h 4    Unknown                      (can be 001F0001h)
  014h 4    Unknown                      (can be 00000000h)
  018h 4    Constant Table Offset        (relative to DVLE start) (eg. 40h)
  01Ch 4    Constant Table Size          (in 14h-byte units)
  020h 4    Label Table Offset           (relative to DVLE start)
  024h 4    Label Table Size             (in 10h-byte units)
  028h 4    Output Register Table Offset (relative to DVLE start)
  02Ch 4    Output Register Table Size   (in 8-byte units)
  030h 4    Input Register Table Offset  (relative to DVLE start)
  034h 4    Input Register Table Size    (in 8-byte units)
  038h 4    Symbol Table Offset          (relative to DVLE start)
  03Ch 4    Symbol Table Size            (in 1-byte units)
  040h ..   Data for above Constants, Labels, etc.
```



## DVOJ (Single Vertex Shader Function Object)


```
  000h 4    ID "DVOJ"
  004h 4    Unknown (seems to be related to the DVLE shader type) (uh?)
  008h 4    Unknown
  00Ch 4    Unknown                      (usually FFFFFFFFh)
  010h 4    Constant table Offset        (from DVOJ start)
  014h 4    Constant table Size          (in 14h-byte units)
  018h 4    Label table Offset           (from DVOJ start)
  01Ch 4    Label table Size             (in 10h-byte units)
  020h 4    Opcode Table Offset          (from DVOJ start)
  024h 4    Opcode Table Size            (in 4-byte units)
  028h 4    Opdesc Table Offset          (relative to DVLP??? start)
  02Ch 4    Opdesc Table Size            (in 8-byte units)
  030h 4    Line Number Table Offset ?   (from DVOJ start)
  034h 4    Line Number Table Size   ?   (in 8-byte units)
  038h 4    Relocation Table Offset      (from DVOJ start)
  03Ch 4    Relocation Table Size        (in 0Ch-byte units)
  040h 4    Output register table Offset (from DVOJ start)
  044h 4    Output register table Size   (in 8-byte units)
  048h 4    Input Register table Offset  (from DVOJ start)
  04Ch 4    Input Register table Size    (in 8-byte units)
  050h 4    Symbol table Offset          (from DVOJ start)
  054h 4    Symbol table Size            (in 1-byte units)
```

Entrypoint/End Address seem to be implied to be begin/end of the opcode area?


```
 _______________________________ Table Formats ________________________________
```



## Opcode Table (with 4-byte entries)


```
  000h 4    Shader Opcode
```



## Opdesc Table (with 8-byte entries)


```
  000h 4    Shader Opdesc (bit31: set to 1 in most (but not all) entries, why?)
  004h 4    Unknown, Flags? (usually 0Fh, 07h, or 03h)
```



## Constant Table (with 14h-byte entries)


- Bool Entries (with 00h in first byte):
  - 000h 1    Entry Type (Must be 00h for Bool Uniform)
  - 002h 1    Bool Uniform ID (whatever, maybe register number, 0..0Fh?)
  - 004h 1    Value (boolean, ie. 00h or 01h ?)
  - 005h 0Fh  Unused
- Integer Uniform Vector Entries (with 01h in first byte):
  - 000h 1    Entry Type (Must be 01h for Integer Uniform)
  - 002h 1    Integer Uniform vector ID (whatever, maybe register number, 0..3?)
  - 004h 1    x (u8)  ;Loop count-1
  - 005h 1    y (u8)  ;Loop starting index
  - 006h 1    z (u8)  ;Loop index step
  - 007h 1    w (u8)  ;uh, but integer uniforms have only 3 elements... x,y,z?
  - 008h 0Ch  Unused
- Float Uniform Vector Entries (with 02h in first byte):
  - 000h 1    Entry Type (Must be 02h for Float Uniform)
  - 002h 1    Float Uniform vector ID (00h..5Fh = c0..c95)
  - 004h 4    x (float24)   ;24bit float values (paddded with bit24-31=zero)
  - 008h 4    y (float24)   ;(weirdly, these 4x24bit must be manually merged
  - 00Ch 4    z (float24)   ;into 3x32bit before sending them to GPU)
  - 010h 4    w (float24)



## Output Register Table (with 8-byte entries)


```
  000h 2    Output Type (see below)                    (only lower 4bit used?)
  002h 2    Output Register ID                         (only lower 4bit used?)
  004h 2    Output Attribute Component Mask (eg. 5=xz) (only lower 4bit used?)
  006h 2    Unknown                                    (unknown?)
```

Output Types:

```
  00h = result.position
  01h = result.normalquat
  02h = result.color
  03h = result.texcoord0
  04h = result.texcoord0w
  05h = result.texcoord1
  06h = result.texcoord2
  07h = ?
  08h = result.view
```



## Input Register Table (with 8-byte entries)


```
  000h 4    Input Parameter Name Offset (in Symbol Table) (eg. "vVtxData")
  004h 2    Input Register Index Start (see below)
  006h 2    Input Register Index End   (end=start+num-1)
```

Input Register Indices:

```
  00h..0Fh = v0..v15  ;Vertex input registers    (per vertex)
  10h..6Fh = c0..c95  ;Float uniform registers   (per function)
  70h..73h = i0..i3   ;Integer uniform registers (per function)
  78h..87h = b0..b15  ;Bool uniform registers    (per function)
```



## Label Table (with 10h-byte entries)


```
  000h 1    Label ID (increasing IDs, starting at 00h) (unknown purpose)
  001h 3    Unknown (000100h)
  004h 4    Opcode Address (in words, in memory)
  008h 4    Unknown (FFFFFFFFh)
  00Ch 4    Label Name Offset (in Symbol Table) (eg. "main", and "endmain")
```



## Relocation Table (with 0Ch-byte entries) (exists in DVOB files only)


```
  000h 4    Opcode Address (in words, in memory) (excluding END, NOP, etc.)
  004h 4    Unknown  ;\probably some kind of opcode/opdesc relocation info?
  008h 4    Unknown  ;/(for merging several DVOB files in shader memory)
```



## Line Number Table (with 8-byte entries, one for each Opcode Table entry)


```
  000h 4    Source Filename Offset (in Symbol Table) (eg. "font_XxxShader.vsh")
  004h 4    Source Line number? (for the corresponding Opcode Table entry)
```



## Symbol Table (with ASCII strings, each terminated by 00h)


DVLB files have separate Symbol Tables in each DVLP/DVLE chunk:

```
  Symbols in DVLP chunk:    Source Filenames
  Symbols in DVLE chunk(s): Labels and Names for Input registers
```

DVOB files have all those symbols in a single Symbol Table.




# <a name="3dsfilesvideofontscfntandffntformat"></a>3DS Files - Video Fonts (CFNT and FFNT Format)




## CTR Font Format


.bcfnt files are bitmap fonts made for the 3ds. The system font uses this
format too except the header is changed from CFNT to CFNU and all file offsets
are changed to absolute in memory offsets.

```
  CFNT - 3DS Font version 3 file
  CFNU - 3DS Font version 3 stored in memory (System Font)
  FFNT - 3DS Font version 4 file
```

The format is based on the Nitro Font format for DS/DSi:

- [DS Cartridge Nitro Font Resource Format](ds.html#dscartridgenitrofontresourceformat)


## CFNT Header


```
  000h 4   ID ("CFNT" or "CFNU" or "FFNT")
  004h 2   Byte Order (FEFFh)
  006h 2   Header Size
  008h 4   Version (usually 03000000h) (also so for FFNT ?)
  00Ch 4   File size (the total)
  010h 4   Number of "blocks" to read
```



## Font Info Chunk


```
  CFNT FFNT Siz Content
  000h 000h 4   ID ("FINF")
  004h 004h 4   Section Size
  008h 008h 1   Font Type
  009h -    1   Line Feed (8bit)
  -    00Ch 2   Line Feed (16bit)
  00Ah 00Eh 2   Alter Char Index (maybe tileno for undefined chars?)
  00Ch 010h 3   Default Width's (3 bytes: Left, Glyph Width, Char Width)
  00Fh 013h 1   Encoding      (1=Unicode?)
  010h 014h 4   TGLP Offset
  014h 018h 4   CWDH Offset
  018h 01Ch 4   CMAP Offset
  01Ch 009h 1   Height
  01Dh 00Ah 1   Width
  01Eh 00Bh 1   Ascent
  01Fh -    1   Reserved
```



## Character Glyph Chunk (Tile Bitmaps)


```
  CFNT FFNT Siz Content
  000h 000h 4   ID ("TGLP")
  004h 004h 4   Section Size
  008h 008h 1   Cell Width
  009h 009h 1   Cell Height
  00Ah -    1   Baseline Position (8bit)
  -    010h 2   Baseline Position (16bit)
  00Bh 00Bh 1   Max Character Width
  00Ch 00Ch 4   Sheet Size
  010h -    2   Number of Sheets (16bit)
  -    00Ah 1   Number of Sheets (8bit)
  012h 012h 2   Sheet Image Format 0-13: (RGBA8, RGB8, RGBA5551, RGB565, RGBA4,
  014h 014h 2   Number of columns         LA8, HILO8, L8, A8, LA4, L4, A4,
  016h 016h 2   Number of rows            ETC1, ETC1A4)
  018h 018h 2   Sheet Width
  01Ah 01Ah 2   Sheet Height
  01Ch 01Ch 4   Sheet Data Offset
```



## Character Map(s) - Translation Tables for ASCII/JIS/etc to Tile Numbers?


```
  000h 4   ID ("CMAP")
  004h 4   Section Size
  008h 2   Code Begin
  00Ah 2   Code End
  00Ch 2   Mapping Method (0=Direct, 1=Table, 2=Scan)
  00Eh 2   Reserved?
  010h 4   Next CMAP Offset
```

Depending on the mapping method the next bytes are read like so:

```
  Direct: IndexOffset = read uint16
  Table:  IndexTable = read uint16 array (CodeEnd - CodeBegin + 1)
  Scan:   Number of Scan Entries = read uint16 for every scan
            entry: read uint16 & read uint16
```



## Character Width Chunk


```
  000h 4   ID ("CWDH")
  004h 4   Section Size
  008h 2   Start Index   ;\implies NumEntries = EndIndex-StartIndex+1
  00Ah 2   End Index     ;/
  00Ch 4   Next CWDH Offset
  010h 3*N Char Widths (3 bytes: Left, Glyph Width, Char Width)
```



## Tools


BFFNT Extractor/Creator. Creates PNG files from TGLP atlas data and a JSON
manifest.


See also: 
- [http://www.3dbrew.org/wiki/System\_Font](http://www.3dbrew.org/wiki/System_Font)


## Truetype Fonts (TTF)


Some 3DS titles are alsu using Truetype fonts:

```
  3DS System Data Archives 1, web-kit/OSS CROs (RomFS:\font\nintendo.ttf)
  3DS Browser applet (RomFS:\browser\font\nintendo_NTLG-DB_001.ttf)
```

That fileformat is also used in the Windows operating system:

```
  used in Windows 3.1 (Windows\System\*.ttf)
  used in Windows 95 (Windows\Fonts\*.ttf)
```

Fileformat specs can be found at:

- [https://docs.microsoft.com/en-us/typography/opentype/spec/](https://docs.microsoft.com/en-us/typography/opentype/spec/)




# <a name="3dsfilesvideotexturepackagectpk"></a>3DS Files - Video Texture Package (CTPK)



CTPK archives can contain one or more texture files. The archive does usually
contain filenames with .tga extension (although the bitmaps are raw data,
unrelated to the Targa .tga format).


CTPK is used in "3DS AR Games" (RomFS:\i\_ar\tex\Tx\_fishing.ctpk), and
reportedly in 3DS games "Persona Q" and "Persona Q2". Anyways, more common 3DS
texture formats seem to be CLIM files, and TXOB's inside of CFGX files.



## CTPK Header


```
  000h 4     ID "CTPK"                                              ;\
  004h 2     Version (0001h)                                        ;
  006h 2     Number of Texture Info Entries                         ;
  008h 4     Texture Data section offset (aka size of header+info)  ; Header
  00Ch 4     Texture Data section size                              ;
  010h 4     Texture Filename CRC32 Table                           ;
  014h 4     Conversion Info section offset                         ;
  018h 8     Padding (0)                                            ;/
  020h N*20h Texture Info Entries                                   ;\
  ...  N*4   Texture Bitmap Sizes (same as [004h] in Info Entries?) ;
  ...  N*var Texture Filename Strings (ASCII, terminated by 00h)    ;
  ...  ..    Padding (0) (to 8-byte boundary)                       ; Info
  ...  N*8   Texture Filename CRC32 Table                           ;
  ...  N*4   Conversion Info Block Entries                          ;
  ...  ...   Padding (0) (to 80h-byte boundary)                     ;/
  ...  N*var Texture Data section (raw bitmaps)                     ;-Data
```



## Texture Info Entries (starting at offset 020h)


Contains Filename, Size, Type, etc. (sorted aphabetically by filename).

```
  000h 4     Filename Offset
  004h 4     Texture Data Size (eg. 200h,800h,2000h,4000h,8000h?)
  008h 4     Texture Data Offset (relative to Texture Data section offset)
  00Ch 4     Texture Format (is that same/other as in "Conversion Info"?)
  010h 2     Width
  012h 2     Height
  014h 1     Mip Level
  015h 1     Type (0=Cube Map, 1=1D, 2=2D)
  016h 2     Cube Map Related
  018h 4     Bitmap Size Array Offset (relative to this block) (what for??)
  01Ch 4     Unix Timestamp
```



## Texture Filename CRC32 Table


CRC32s on the filenames (sorted by CRC32 values, starting with smallest value).

```
  000h 4     CRC32 of Filename (excluding trailing 00h)
  004h 4     File Number, index in Texture Info Entries (0..(N-1))
```



## Conversion Info Block Entries (unknown purpose, maybe info on source data?)


```
  000h 1     Texture Format           (usually 4,5,9,0Dh) (see below)
  001h 1     Unknown                  (usually 1=what?)
  002h 1     Compressed               (usually 1=what?)
  003h 1     ETC1 Related (Quality?)  (usually 3 or 6=what?)
```


Texture Formats:

```
  00h=RGBA8888
  01h=RGB888
  02h=RGBA5551
  03h=RGB565
  04h=RGBA4444
  09h=?
  0Ch=ETC1
  0Dh=ETC1 + Alpha
```




# <a name="3dsfilesvideobitmapbmp"></a>3DS Files - Video Bitmap (BMP)




## Windows Bitmap (.bmp)


Windows bitmap used in 3DS Browser applet (RomFS:\browser\page\img\\*.bmp)

Adobe variant used in 3DS AR Games (RomFS:\i\_ar\tex\stamp\*.lz77)

```
  000h 2   ID "BM" (Windows Bitmap, aka .bmp)
  002h 4   Total Filesize
  006h 4   Reserved (usually 0)
  00Ah 4   Bitmap Pixeldata Offset
  00Eh 4   Size of Header bytes at 0Eh and up (28h=Normal, 38h=Adobe)
  012h 4   Width in pixels (positive)
  016h 4   Height in pixels (pos=Windows/bottom up, neg=Adobe/top down)
  01Ah 2   Number of Bitplanes (always 1)
  01Ch 2   Bits per Pixel (bpp) (usually 1,4,8,16,24,32)
  01Eh 4   Compression Type (usually 0=Uncompressed) (3=custom RGB bitmasks?)
  022h 4   Compressed Bitmap Size (can be Dummy=0 if uncompressed?)
  026h 4   Horizontal resolution (pixels per metre)  ;\eg. 0B12h or 03E8h
  02Ah 4   Vertical resolution (pixels per metre)    ;/
  02Eh 4   Number of colors in palette (or 0=Default 2^bpp) (or 0=None?)
  032h 4   Number of important colors  (or 0=All)
  036h ..  Extra Adobe stuff (if any)
  ...  ..  Palette (if any)
  ...  ..  Bitmap Pixels
```




# <a name="3dsfilesbase64encoding"></a>3DS Files - BASE64 Encoding



BASE64 is used to encode binary data into 7bit ASCII characters (with 6 bits
per char, aka 3 bytes per 4 chars), eg. for binary attachments in email
messages. The 3DS uses BASE64 in .CSDR shader files, and in 3DS Browser applet
.PEM files.



## BASE64 Character --> Binary


```
  "A..Z" --> value 00..25 (00h..19h)
  "a..z" --> value 26..51 (1Ah..33h)
  "0..9" --> value 52..61 (34h..3Dh)
  "+"    --> value 62     (3Eh)
  "/"    --> value 63     (3Fh)
  "="    --> padding to 4-character boundary (if needed, at end of file)
  CR,LF  --> ignored
```



## 3DS .CSDR Shader files


Found in 3DS Nintendo Zone, 3DS AR Games, 3DS Face Raiders
(RomFS:\shaders\\*.csdr).

```
  <NintendoWareIntermediateFile>
    <GraphicsContentCtr Namespace="" Version="0.7.0">
      <EditData>
        ...
      </EditData>
      <Shaders>
        <ShaderCtr Name="DefaultShader">
          <BinaryData>RFZMQgMAAAAUDgAAZBQ...XplAA==</BinaryData>
          <ShaderKinds>
            ...
          </ShaderKinds>
          <Descriptions>
            ...
          </Descriptions>
        </ShaderCtr>
      </Shaders>
    </GraphicsContentCtr>
  </NintendoWareIntermediateFile>
```

The .CSDR files uses 0Dh,0Ah for linebreaks, and 09h TAB's to indent lines. The
binary data is stored in a single long line without linebreaks, terminated
"\<". The decoded BASE64 data contains a standard "DVLB" 3DS shader file.

- [3DS Files - Video Shaders (DVLB and DVOB Format)](#3dsfilesvideoshadersdvlbanddvobformat)
Unknown if the \<Descriptions> or other fields are containing any useful
additional data. Unknown if a .CSDR file can contain more than one "DVLB"
binary.



## 3DS Browser Applet, RomFS:\browser\rootca.pem


The file starts wirh a small header/comment:

```
  #
  # rootca.pem
  #
```

Then followed by several certificates, each in following format:

```
  # Issuer:
  #   ...
  #   O=Entrust.net
  #   ...
  # Expire date     : May 25 16:39:40 2019 GMT
  # SHA1 Fingerprint: 99 a6 9b e6 1a fe 88 6b 4d 2b 82 ... 7e 15 39
  -----BEGIN CERTIFICATE-----
  MIIE2DCCBEGgAwIBAgIEN0rSQzANBgkqhkiG9w0BAQUFADCBwzELMAkGA1UEBhMC
  VVMxFDASBgNVBAoTC0VudHJ1c3QubmV0MTswOQYDVQQLEzJ3d3cuZW50cnVzdC5u
  ...
  95K+8cPV1ZVqBLssziY2ZcgxxufuP+NXdYR6Ee9GTxj005i7qIcyunL2POI9n9cd
  2cNgQ4xYDiKWL2KjLB+6rQXvqzJ4h6BUcxm1XAX5Uj5tLUUL9wqT6u0G+bI=
  -----END CERTIFICATE-----
```

The 3DS Browser .pem file uses 0Ah for linebreaks, and 64 chars per binary
line, terminated by "-" in the END CERTIFICATE string. The decoded BASE64
blocks contain standard .DER files.

- [DSi SD/MMC Firmware Certificate/Keys (DER)](ds.html#dsisdmmcfirmwarecertificatekeysder)
The comments contain a summary of the DER entries (eg. O=OrganizationName).



## 3DS System Data Archives 1, offline mode, RomFS:\browser\cave.pem



## 3DS Nintendo Zone, RomFS:\certs\dev.pem



## 3DS Nintendo Zone, RomFS:\certs\client.key


Contains only a single DER certificate, with 0Dh,0Ah linebreaks (cave.pem), or
0Ah linebreaks (dev.pem), without any "#" comments:

```
  -----BEGIN CERTIFICATE-----
  MIIEIDCCAwigAwIBAgIBATANBgkqhkiG9w0BAQsFADBtMQswCQYDVQQGEwJVUzET
  MBEGA1UECBMKV2FzaGluZ3RvbjEhMB8GA1UEChMYTmludGVuZG8gb2YgQW1lcmlj
  ...
  MeIurPFOFV/7+3JkZY7cGUBMwqjiou9/9QBHGPvyNhGU34aUoB9vJI164WsMfDXp
  3K7XdX8WCVY0eks4g9LhLrzDmCrdQByABT0TkmhpYykJOQaWVfWzRLJ0qCirZrDQ
  Qfma0w==
  -----END CERTIFICATE-----
```

The client.key file similar, but marked BEGIN RSA PRIVATE KEY instead of BEGIN
CERTIFICATE.




# <a name="3dsfilesvideo3dphotosmpo"></a>3DS Files - Video 3D Photos (MPO)



The Multi-Picture Object (MPO) format developed by CIPA allows to store
multiple images in one file, the 3DS (and other stereoscopic cameras) are using
it to store 3D photos (ie. two images, from two different perspectives; that
is, basically two JPEGs badged together, with Exif or JFIF headers in each
JPEG, and with an additional MPO header in the first JPEG). The official MPO
specs can be found here:

```
  <a href="http://www.cipa.jp/std/documents/e/DC-X007_E.pdf"><font color="#808080">http://www.cipa.jp/std/documents/e/DC-X007_E.pdf</font></a>

```

The 3DS Camera files are using MPOs with Exif headers, including some Nintendo
specific information in the Exif header.

There also some other MPOs found in 3DS titles (eg. 3DS Nintendo Zone has a MPO
with JFIF header, and without Nintendo specific Exif data in
RomFS:\www\included\_html\boss\_page\BOSS\_JP\shared\_images\top\_screen.mpo or 3DS
Camera has non-Nintendo Exif header in RomFS:\depug\_mpo\_\resizable.mpo).



## Nintendo's EXIF Data Structure


```
  ID    Description                   Value
  010Fh Manufacturer                  Nintendo
  0110h Camera                        Nintendo 3DS
  011Ah XResolution                   72:1
  011Bh YResolution                   72:1
  0128h ResolutionUnit                2
  0131h Software                      Depends on the software:
                                        00204 for the Camera (EU)
                                        00227 for the Mii Editor (EU)
                                        00955 for KH3D (EU)
  0132h DateTime                      YYYY:MM:DD HH:mm:SS
  0213h YCbCrPositioning              2
  9000h ExifVersion                   0220
  9003h DateTimeOriginal              YYYY:MM:DD HH:mm:SS
  9004h DateTimeDigitized             YYYY:MM:DD HH:mm:SS
  9101h ComponentsConfiguration       [0x01,0x02,0x03,0x00]
  927Ch MakerNote                     [DATA - 174 bytes] (yet to be understood)
  A000h FlashPixVersion               0100
  A001h ColorSpace                    1
  A002h PixelXDimension               640
  A003h PixelYDimension               480
  5041h InteroperabilityIndex         R98
  5042h ExifInteroperabilityVersion   0100
  1000h InteroperabilityVersion       JPEG Exif Ver 2.2
  501Bh ThumbnailData                 [DATA - 3000+ bytes]
  5023h ThumbnailCompression          6
  502Dh ThumbnailXResolution          72:1
  502Eh ThumbnailYResolution          72:1
  5030h ThumbnailTransferFunction     2
  0201h JPEGInterchangeFormat         682
  0202h JPEGInterchangeFormatLength   3000+
  5091h ChrominanceTable              [DATA - 128 bytes]
  5090h LuminanceTable                [DATA - 128 bytes]
 Nintendo's IFDs (within IFD=927Ch)
  1100h Nintendo Software-specific data
  1101h Nintendo 64-byte Note
```



## IFD=927Ch - Nintendo's EXIF MakerNote Tag


"This still need to be figured out: The MakerNote is made with Tiff Exif
information (Big Endian) first 2 bytes are the IFD Count (IFD is a 12 byte
tag), Regulary there are 2 IFDs."



## IFD=1100h - Nintendo's Software-specific data


Unknown, reportedly "7-Undefined Count Count=1 ? Value : Offset" uh?



## IFD=1101h - Nintendo's 64-Byte Note (little endian, unlike the JPEG headers)


```
  000h 4   ID ("3DS1")
  004h 4   Unknown (can be 1, 2, 4, or 5)
  008h 4   Timestamp (number of seconds since 1st Jan 2000)
  00Ch 4   Padding (0)
  010h 4   Title ID Low ("but without the last two letters" uh?)
  014h 4   Flags
  018h 4   Console ID (unique identifier, unknown where from...?)
  01Ch 12  Padding (0)
  028h 4   3D Parallax "[-52,54]" ;2x float16? or 1x float32 in range -52..+54?
  02Ch 4   Padding (0)
  030h 2   Gender Category??? (1000h=mii, 2000h=man, 4000h=woman)
  032h 2   Filter (unknown meaning)
  034h 12  Padding (0)
```




# <a name="3dsfilessoundarchivecsarformat"></a>3DS Files - Sound Archive (CSAR Format)



CSAR files are usually found in "RomFS:\sound\" folder, with extension ".bcsar"
(Binary CTR Sound Archive).

The CSAR archive contains CSEQ, CWSD, CBNK, CWAR files (and optionally CGRP).
Whereof, the CWAR file contains CWAV files.



## CSAR Header


```
  000h 4     ID "CSAR"
  004h 2     Byte Order (FEFFh)
  006h 2     Header Size (usually 40h)
  008h 4     Version (usually 02000000h) (02030200h in Miiverse-posting)
  00Ch 4     Total Filesize
  010h 4     Number of Blocks (usually 3 = STRG+INFO+FILE)
  014h 4+4+4 STRG Block (RefID=2000h, Offset from CSAR+0, Size)
  020h 4+4+4 INFO Block (RefID=2001h, Offset from CSAR+0, Size)
  02Ch 4+4+4 FILE Block (RefID=2002h, Offset from CSAR+0, Size)
  038h 8     Padding to 20h-byte boundary (0)
```


```
 _________________________________ STRG Block _________________________________
```



## String Block Header


```
  000h 4     ID "STRG"
  004h 4     STRG Block Size (same as in CSAR header)
  008h 4+4   Filename String List  (RefID=2400h, Offset from STRG+8)
  010h 4+4   Filename Search Tree  (RefID=2401h, Offset from STRG+8)
```



## Filename String List


```
  000h 4          Number of Filenames   (eg. 40h)
  004h (4+4+4)*N  Filenames (RefID=1F01h, Offset from this Table, Size)
  ...  ..         Filename strings (uppercase ASCII, terminated by 00h)
```



## Filename Search Tree (Patricia Tree)


This is intended for fast file name lookup. For example, if the String List
contains only two entries with name "Fuck" and "Funeral", then one could find
the desired string with a single bit-test in the 3rd char (to avoid false
matches for strings that do not exist in the list, one could do a string
compare on the final result).

```
  000h       4  First Tree index for search (for testing the leftmost char)
  004h       4  Number of Tree entries      (usually NumNames*2-1)
  008h+N*14h 2  Entry Type               (0=Test, 1=Name)
  00Ah+N*14h 2  Bit number to be tested  (0=Bit7 of 1st char) ;\FFh-filled
  00Ch+N*14h 4  Next Tree index when test Result=0?           ; in Name entries
  010h+N*14h 4  Next Tree index when test Result=1?           ;/
  014h+N*14h 4  Name Index in STRG Block  (0..NumNames-1)     ;\FFh-filled
  018h+N*14h 4  Resource ID in INFO Block (NNxxxxxxh)         ;/in Test entries
```

To view the whole directory, simply ignore the Test entries, and extract the
Name+ID pairs from the Name entries.



## Resource IDs


The Resource IDs refer to entries in the INFO Block (the upper 8bit indicate a
List number, and lower 24bit contain the entry number in that list):

```
  ID          List        File Types                        Common Name prefix
  01xxxxxxh = Audio List  (CSEQ, CWSD files)                ;name SE,BGM
  02xxxxxxh = Set List    (folders for above Audio entries) ;name WSDSET,SEQSET
  03xxxxxxh = Bank List   (CBNK files)                      ;name BANK
  04xxxxxxh = Player List (...whatever?)                    ;name PLAYER
  05xxxxxxh = Wav Archive (CWAR files)  <-- unless nameless ;name WARC ;or none
  06xxxxxxh = Group List  (CGRP files)  <-- if any          ;name GROUP
```

Groups exist only in some files. Wav Archives do exist in all files, but they
are often completely omitted in the string tree (or have only one of them
listed in the string tree).


```
 _________________________________ INFO Block _________________________________
```



## Info Block Header


```
  000h 4     ID "INFO"
  004h 4     INFO Block Size (same as in CSAR header)
  008h 4+4   Audio List      (RefID=2100h, Offset relative to INFO+8) CSEQ,CWSD
  010h 4+4   Set List        (RefID=2104h, Offset relative to INFO+8) Folder?
  018h 4+4   Bank List       (RefID=2101h, Offset relative to INFO+8) CBNK
  020h 4+4   WavArchive List (RefID=2103h, Offset relative to INFO+8) CWAR
  028h 4+4   Group List      (RefID=2105h, Offset relative to INFO+8) CGRP
  030h 4+4   Player List     (RefID=2102h, Offset relative to INFO+8) ?
  038h 4+4   File List       (RefID=2106h, Offset relative to INFO+8) Files
  040h 4+4   Final Entry     (RefID=220Bh, Offset relative to INFO+8) ?
  ...  ..    Lists+Entries   (at Offsets from above INFO header)
  ...  14h   Final Entry     (at Offset from above INFO header)
  ...  ..    Padding to 20h-byte boundary (0)
```



## Audio List (RefID=2100h)


```
  000h 4        Number of List entries
  004h (4+4)*N  Audio Entries (RefID=2200h, Offset from List+0)
```


## Audio Entry (RefID=2200h) (eg. 2Fh entries) (60h bytes per entry)


```
  000h 4     Index in File List (File CSEQ or CWSD) (eg. 0,0,1,2,2,3,etc.)
             (above does often use the same file index for 1-4 audio entries)
  004h 4     Sound player Resource ID (040000xxh)
  008h 4     Volume or so (10h,12h,14h,18h,1Ch,1Eh,28h,38h,40h,48h,60h,64h,7Fh)
  00Ch 4+4   Extended entry (RefID=2202h/2203h, Offset=44h, relative to Audio)
  014h 4     Unknown (80020107h)
  018h 4     Name Index in STRG Block (Names SE_xx,JGL_xx,BGM_xx) (0,1,2,etc.)
  01Ch 4     Unknown (0)
  020h 4     Unknown (40h)
  024h 4     Unknown (30h)
  028h 4     Unknown (0 or 1)
  02Ch 4     Unknown (0=norm, or FFFFh,10000000h,01FF0000h,FE000000h,FFE6EE99h)
  030h 4     Unknown (0Fh)
  034h 4     Unknown (3F000000h)
  038h 4     Unknown (1)
  03Ch 4     Unknown (0)
  040h 4     Unknown (0 or 1)
```

Extended Entry RefID=2202h: (used for CWSD files)

```
  044h 4     Unknown (0, 1, 2, 3)   ;often same for 1-2 entries
  048h 4     Unknown (1)
  04Ch 4     Unknown (101h)
  050h 4     Unknown (40h)
  054h 4     Unknown (14h)
  058h 4     Unknown (27Fh)
  05Ch 4     Unknown (0)
```

Extended Entry RefID=2203h: (used for CSEQ files)

```
  044h 4     Unknown (100h)
  048h 4     Unknown (18h)
  04Ch 4     Unknown (1, 3, 7, 0Fh, 1Fh, 3Fh, or FFFFh)  ;some bitmask?
  050h 4     Unknown (3)
  054h 4     Unknown (3, 30h, 4Ch, 102h, 26Ah, 283h, ..., 3C2h, 3F7h)
  058h 4     Unknown (40h)
  05Ch 4     Number of below 4-byte entries (usually 1, sometimes 2)
  060h 4*N   Resource ID (0300000xh)    ;often same for 1-N entries
```



## Set List (RefID=2104h)


```
  000h 4        Number of List entries
  004h (4+4)*N  Set Entries (RefID=2204h, Offset from List+0)
```


## Set Entry (RefID=2204h) (eg. 5 entries) (38h bytes per entry)


This seems to have no file assigned, instead it's assigned to Sound Resource
IDs (for above Audio Entries), in so far, the Set could be considered being a
Folder instead of a File.

```
  000h 4     First Sound Resource ID in this sequence set (eg. 010000xxh)
  004h 4     Last Sound Resource ID in this sequence set  (eg. 010000xxh)
  008h 4+4   Extended entry (RefID=0100h, Offset=20h, relative to Set Entry+0)
  010h 4+4   Extended entry (RefID=2205h, Offset=28h, relative to Set Entry+0)
             Extended entry (RefID=0000h, Offs=FFFFFFFFh) ;alternately to 2205h
  018h 4     Unknown (1)
  01Ch 4     Name Index in STRG Block (Names SEQSET_xxx or WSDSET_xxx)
```

Extended Entry RefID=0100h:

```
  020h 4     Number of below 4-byte values (usually 1, sometimes 2)
  024h 4*n   Unknown (2, 3, 4, 5, or 6)
```

Extended Entry RefID=2205h: (if present)

```
  ..   4     Unknown (100h)                     ;\exists only for WSDSET_xx,
  ..   4     Unknown (0Ch)                      ; not for SEQSET_xx
  ..   4     Unknown (0)                        ;
  ..   4     Unknown (0)                        ;/
```



## Bank List (RefID=2101h)


```
  000h 4        Number of List entries
  004h (4+4)*N  Bank Entries (RefID=2206h, Offset from List+0)
```


## Bank Entry (RefID=2206h) (eg. 5 entries) (18h bytes per entry)


```
  000h 4     Index in File List       (File CBNK)
  004h 4+4   Extended entry (RefID=0100h, Offset=14h, relative to Bank Entry+0)
  00Ch 4     Unknown (1)
  010h 4     Name Index in STRG Block (Name BANK_xxx)
```

Extended Entry RefID=0100h:

```
  014h 4     Number of below 4-byte entries (can be 0=None)
  018h 4*n   Resource ID (05000000h) (if any, ie. if above is nonzero)
```

Above list contains one entry in AR Games, which also has CGRP, maybe that's
related?



## WavArchive List (RefID=2103h)


```
  000h 4        Number of List entries
  004h (4+4)*N  WAV Archive Entries (RefID=2207h, Offset from List+0)
```


## WavArchive Entry (RefID=2207h) (eg. 7 entries) (0Ch bytes per entry)


```
  000h 4     Index in File List       (File CWAR)
  004h 8     Unknown (0)
  008h 8     Unknown (0 or 1)  ;set when NEXT file is CGRP? or unrelated?
```



## Group List (RefID=2105h)


```
  000h 4        Number of List entries (can be 0 if there aren't any groups)
  004h (4+4)*N  Group Entries (RefID=2208h, Offset from List+0)
```


## Group Entry (RefID=2208h) (exists in ArGames and MiiMaker, for example)


```
  000h 4     Index in File List       (File CGRP)
  004h 4     Unknown (1)
  008h 4     Name Index in STRG Block (Name GROUP_xxx)
```



## Player List (RefID=2102h)


```
  000h 4        Number of List entries
  004h (4+4)*N  Player Entries (RefID=2209h, Offset from List+0)
```


## Player Entry (RefID=2209h) (eg. 7 entries) (10h bytes per entry)


```
  000h 4     Varies 2,8,1,1,4,1,2   ;Index in File List? (would be CSEQ/CSTM)
  004h 4     Unknown (3)
  008h 4     Name Index in STRG Block (Name PLAYER_xxx)
  00Ch 4     Unknown (0)
```



## File List (RefID=2106h)


```
  000h 4        Number of List entries
  004h (4+4)*N  File Entries (RefID=220Ah, Offset from List+0)
```


## File Entry (RefID=220Ah) (eg. only 13h entries, despite of 40h filenames)


```
  000h 4+4    ExtEntry (RefID=220Ch/220Dh, Offset=0Ch, relative to File Entry)
  008h 4      Zero
```

ExtEntry RefID=220Ch:     (eg. CSEQ file, in internal FILE section):

```
  00Ch 4+4+4  File (RefID=1F00h/0000h, Offset relative to FILE+8, Size)
 Note: Above RefID=1F00h is used for Normal Files, whilst Group Files are
 instead using RefID=0000h (the Offset/Size do exist nonetheless, pointing
 to the CGRP file).
```

ExtEntry RefID=220Dh:     (eg. CSTM file, in external .bcstm file):

```
  00Ch ...    External Filename (eg. "stream/xxx.bcstm",00h)
```



## Final Entry (RefID=220Bh)


```
  000h 2  Unknown (18h, 20h, 40h)    x
  002h 2  Unknown (30h, 40h, 60h)    x
  004h 2  Unknown (00h, 04h)
  006h 2  Unknown (00h, 04h)
  008h 2  Unknown (00h, 08h)
  00Ah 2  Unknown (00h, 40h)         x
  00Ch 2  Unknown (00h, 04h, 40h)    x
  00Eh 2  Unknown (0, 1) (1 in Miiverse-posting)
  010h 2  Unknown (0)
  012h 2  Unknown (0)
```


```
 _________________________________ FILE Block _________________________________
```



## File Block Header


```
  000h 4    ID "FILE"
  004h 4    FILE Block Size (same as in CSAR header)
  008h 18h  Padding to 20h-byte boundary (0)
  020h ...  Data Area (contains CSEQ, CWSD, CBNK, CWAR, CGRP files)
```

Note: Some of the files may also contain chunks with name INFO or FILE, that
chunks are unrelated to the INFO/FILE chunks in the CSAR header).



## Tools


- vgmtoolbox's Advanced Cutter/Offset Finder (extract BCWAVs without filenames)

- 3DSUSoundArchiveTool (reference implementation of CSAR extraction)




# <a name="3dsfilessoundseqcseqformat"></a>3DS Files - Sound SEQ (CSEQ Format)



CSEQ is usually found inside of CSAR (but can be also a standalone file, eg. in
3DS Camera Applet, RomFS:\sound\csnd.LZ).



## CSEQ Header


```
  000h 4     ID "CSEQ"
  004h 2     Byte Order (FEFFh)
  006h 2     Header Size (usually 40h)
  008h 4     Version?    (can be 01000000h)
  00Ch 4     Total Filesize
  010h 4     Number of Blocks (usually 2 = DATA+LABL)
  014h 4+4+4 DATA Block (RefID=5000h, Offset from CSEQ+0, Size)
  020h 4+4+4 LABL Block (RefID=5001h, Offset from CSEQ+0, Size)
  02Ch 14h   Padding to 20h-byte boundary (0)
```



## DATA Block


```
  000h 4     ID "DATA"
  004h 4     DATA Block Size (same as in CSEQ Header)
  008h ...   Data (addressed via Offsets in LABL block)
  ...  ..    Padding to 20h-byte boundary (0)
```

The content of the Data area is unknown, probably some midi-like notes?



## LABL Block


```
  000h 4       ID "LABL"
  004h 4       LABL Block Size (same as in CSEQ Header)
  008h 4       Number of following List entries (eg. 26h)
  00Ch (4+4)*N List Entries (RefID=5100h, Offset from LABL+8)
  ...  ..      Padding to 20h-byte boundary (0)
```

List Entry Format:

```
  000h (4+4)*N Data Entry (RefID=1F00h, Offset from DATA+8)
  008h 4       String Length, excluding ending 00h
  00Ch LEN+1   String (ASCII, plus ending 00h) (eg. "SMF_TWL_function_xxx")
  ...  ..      Padding to 4-byte boundary (0)
```




# <a name="3dsfilessoundwsdcwsdformat"></a>3DS Files - Sound WSD (CWSD Format)




## CWSD Header


```
  000h 4     ID "CWSD"
  004h 2     Byte Order (FEFFh)
  006h 2     Header Size (usually 20h)
  008h 4     Version?    (can be 01000000h)
  00Ch 4     Total Filesize
  010h 4     Number of Blocks (usually 1 = INFO)
  014h 4+4+4 INFO Block (RefID=6800h, Offset from CWSD+0, Size)
```



## INFO Block


```
  000h 4     ID "INFO"
  004h 4     INFO Block Size (same as in CWSD Header)
  008h 4+4   ID List    (RefID=0100h, Offset from INFO+8)  ;Offs=10h
  010h 4+4   Crazy List (RefID=0101h, Offset from INFO+8)
```

ID List: (uh, are these Resource ID's pointing to CSAR entries):

```
  000h 4       Nummber of below 8-byte entries
  004h (4+4)*N Resource ID and Index (ID=050000xxh, Index=0, 1, 2, etc.)
```

Crazy List:

```
  000h 4       Nummber of below 8-byte entries
  004h (4+4)*N Crazy Entry N (RefID=4900h, Offset from Crazy List+0)
```

Crazy Entry:

```
  000h 4+4     Crazy Part1 (RefID=4901h, Offset from Crazy Entry+0)
  008h 4+4     Crazy Part2 (RefID=0101h, Offset from Crazy Entry+0)
  010h 4+4     Crazy Part3 (RefID=0101h, Offset from Crazy Entry+0)
```

Crazy Part1:

```
  000h 4       Unknown (303h)
  004h 4       Unknown (40h)
  008h 4       Unknown (3F800000h, 3FE66666h, or 3F4CCCCDh)  ;Int? Float?
  00Ch 4       Unknown (14h)
  010h 4       Unknown (1Ch)
  014h 4       Unknown (27Fh)
  018h 4       Unknown (0)
  01Ch 4       Unknown (0)
  020h 4       Unknown (08h)
  024h 4       Unknown (7F7F7F7Fh)
  028h 4       Unknown (7Fh)
```

Crazy Part2:

```
  000h 4       Unknown (1)   ;Num entries?
  004h 4+4     Child Block (RefID=4903h, Offset from 000h+0) ;Offs=0Ch
  00Ch 4       Unknown (0)
  010h 4       Unknown (08h)
  014h 4       Unknown (1)   ;Num entries?
  018h 4+4     Child Block (RefID=4904h, Offset from 014h+0) ;Offs=0Ch
  020h 4       Unknown (0)
  024h 4       Unknown (0)
  028h 4       Unknown (0)
  02Ch 4       Unknown (0)
```

Crazy Part3:

```
  000h 4       Unknown (1)   ;Num entries?
  004h 4+4     Child Block (RefID=4902h, Offset from Crazy Part3+0) ;Offs=0Ch
  00Ch 4       Unknown (0 or 2)
  010h 4       Unknown (0)
```




# <a name="3dsfilessoundbankcbnkformat"></a>3DS Files - Sound Bank (CBNK Format)




## CBNK Header


```
  000h 4     ID "CBNK"
  004h 2     Byte Order (FEFFh)
  006h 2     Header Size (usually 20h)
  008h 4     Version?    (can be 01000100h)
  00Ch 4     Total Filesize
  010h 4     Number of Blocks (usually 1 = INFO)
  014h 4+4+4 INFO Block (RefID=5800h, Offset from CBNK+0, Size)
```



## INFO Block


```
  000h 4       ID "INFO"
  004h 4       INFO Block Size (same as in CBNK Header)
  008h 4+4     Footer Entry (RefID=0100h, Offset from Info+8) ;Offs=Near end
  010h 4+4     List Entry   (RefID=0101h, Offset from Info+8) ;Offs=10h
  018h 4       Number of following List Entries
  01Ch (4+4)*N List Entries (RefID=59xxh, Offs from INFO+18h or Offs=FFFFFFFFh)
  ...  ..      Entries for above list
  ...  4+8*X   Footer Entry
```



## List Entry with RefID=5903h:


```
  Nothing (these entries have Offset=FFFFFFFFh)
```



## List Entry with RefID=5900h:


```
  000h 4+4     1st Child Entry (RefID=6000h, Offset=8)  ;\these are simply
  008h 4+4     2nd Child Entry (RefID=5901h, Offset=8)  ; pointing to the next
  010h 4+4     3rd Child Entry (RefID=6000h, Offset=8)  ; child, until reaching
  018h 4+4     4th Child Entry (RefID=5902h, Offset=8)  ;/below data...
  020h 4       Bank Entry Number (0, 1, 2, etc.)
  024h 4       Unknown (21Fh)         ;RefID ?
  028h 4       Unknown (03Ch or 48h)  ;Offset? or Volume or so?
  02Ch 4       Unknown (7Fh)
  030h 4       Unknown (40h)
  034h 4       Unknown (3F800000h)
  038h 4       Unknown (0)
  03Ch 4       Unknown (20h)
  040h 4       Unknown (0)
  044h 4       Unknown (08h)
  048h 4       Unknown (7F7F7Fh)
  04Ch 4       Unknown (7Fh)
```



## Footer Entry with RefID=0101h:


```
  000h     4   Number of following 8-byte entries
  004h+N*8 4   Resource ID ? (05000005h, or 05000002h in another CBNK file)
  008h+N*8 4   Footer Index (0, 1, 2, 3, etc.)
```




# <a name="3dsfilessoundwavearchivecwarformat"></a>3DS Files - Sound Wave Archive (CWAR Format)



CWAR files can contain CWAV files. The CWAR files are located inside of CSAR
archives.

Note: The CWARs are often left nameless (the CSAR may contain only one name
entry in its STRG block (or none at all), despite of have multiple CWARs in its
INFO block.



## CWAR Header


```
  000h 4     ID "CWAR"
  004h 2     Byte Order (FEFFh)
  006h 2     Header Size (usually 40h)
  008h 4     Version?    (can be 01000000h)
  00Ch 4     Total Filesize
  010h 4     Number of Blocks (usually 2 = INFO+FILE)
  014h 4+4+4 INFO Block (RefID=6800h, Offset from CWAR+0, Size)
  020h 4+4+4 FILE Block (RefID=6801h, Offset from CWAR+0, Size)
  02Ch 14h   Padding to 20h-byte boundary (0)
```



## INFO Block


```
  000h 4         ID "INFO"
  004h 4         INFO Block Size (same as in CWAR Header)
  008h 4         Number of following List entries
  00Ch (4+4+4)*N List Entries (RefID=1F00h, Offset from FILE+8, Size)
  ...  ..        Padding to 20h-byte boundary (0)
```



## FILE Block


```
  000h 4     ID "FILE"
  004h 4     FILE Block Size (same as in CWAR Header)
  008h 18h   Padding to 20h-byte boundary (0)
  020h ...   Data Area (contains CWAV files)
```




# <a name="3dsfilessoundwavedatacwavformat"></a>3DS Files - Sound Wave Data (CWAV Format)



CWAV files contain audio samples for use as instruments or sound effects,
somewhat resembling .wav files.

The CWAV is usually stored in a CWAR Wave Archive (with the CWAR being stored
in a CSAR Sound Archive). Additionally, a CWAV block can be found inside of
Banner files. And, there are also standalone CWAV files (eg. in 3DS Camera
"RomFS:\sound\\*.bcwav").



## CWAV Header


```
  000h 4      ID "CWAV"
  004h 2      Byte Order (FEFFh)
  006h 2      Header Size (usually 0040h)
  008h 4      Version (02010000h)
  00Ch 4      Total File Size
  010h 2      Number of Blocks (usually 2, INFO+DATA)
  012h 2      Reserved
  014h 4+4+4  INFO Block (RefID=7000h, Offset from CWAV+0, Size)
  020h 4+4+4  DATA Block (RefID=7001h, Offset from CWAV+0, Size)
  02Ch 14h    Padding to 20h-byte boundary (0)
```



## Info Block


```
  000h 4   Chunk ID "INFO"
  004h 4   Chunk Size
  008h 1   Encoding (0=PCM8, 1=PCM16, 2=DSP-ADPCM, 3=IMA-ADPCM)
  009h 1   Loop (0=Don't loop, 1=Loop)
  00Ah 2   Padding (0)
  00Ch 4   Sample Rate (eg. 3E80h = 16000Hz?)
  010h 4   Loop Start Frame (0=Begin of sample?, or 0=None when not looping)
  014h 4   Loop End Frame (eg. 409h ?) (also End Frame when not looping)
  018h 4   Unknown (0)
  01Ch 4   Unknown (1)
  020h 4+4 Sample Info     (RefID=7100h, Offset from INFO+8?) ;Offs=0Ch
  028h 4+4 Sample Data     (RefID=1F00h, Offset from DATA+8)  ;Offs=18h
  ..   ..  Sample Info
  ..   ..  ADPCM Info (if any)
  ..   ..  Padding to 20h-byte boundary (0)
```

Sample Info (RefID=7100h):

```
  000h 4+4 DSP-ADPCM Info  (RefID=0300h, Offset from INFO+?)  ;Offs=14h ;\
           IMA-ADPCM Info  (RefID=0301h, Offset from INFO+?)  ;Offs=14h ;
           No ADPCM Info   (RefID=0000h, Offset=FFFFFFFFh)    ;None     ;/
  008h 4   Unknown (0)
```

ADPCM Info (RefID=0300h) (when Encoding is DSP-ADPCM):

```
  000h 32  16bit Coefficients            ;-Whatever Coefficients
  020h 1   4bit Predictor + 4bit Scale   ;\
  021h 1   Reserved (0)                  ; Initial context
  022h 2   Previous Sample               ;
  024h 2   Second Previous Sample        ;/
  026h 1   4bit Predictor + 4bit Scale   ;\
  027h 1   Reserved (0)                  ; Loop context
  028h 2   Previous Sample               ;
  02Ah 2   Second Previous Sample        ;/
  02Ch 2 ? Padding ??                    ;-uh?
```

ADPCM Info (RefID=0301h) (when Encoding is IMA-ADPCM):

```
  000h 2   Data                          ;\Initial context
  002h 1   Table Index                   ; ...for port 10103418h+(N*20h)?
  003h 1   Padding                       ;/
  004h 2   Data                          ;\Loop context
  006h 1   Table Index                   ; ...for port 1010341Ch+(N*20h)?
  007h 1   Padding                       ;/
```



## Data Block


```
  000h 4   Chunk ID "DATA"
  004h 4   Chunk Size
  008h 18h Padding to 20h-byte boundary (0)
  020h ..  Sample Data (eg. PCM16)    ;at Offsets specified in INFO block
```




# <a name="3dsfilessoundwavestreamscstmformat"></a>3DS Files - Sound Wave Streams (CSTM Format)



CSTM files are very similar to CWAV files, with slightly differently arranged
data, and with an additional SEEK block.

Unknown if/which games or system titles are using CSTM files. They can be
reporedly found in following locations:

```
  - RomFS:\sound\stream\*.bcstm (eg. in Zelda Ocarina of Time)
  - Inside of a CSAR (unknown where exactly, maybe inside of CWAR blocks?)
  - CSAR's can contain RefID=220Dh entries for external CSTM file (eg. Zelda)
```

CSTM seems to be intended for streaming medium length recordings (longer than
normal CWAV instruments/effects, and shorter than fully fledged AAC/OGG/MP3
recordings).



## CSTM Header


```
  000h 4      ID "CSTM"
  004h 2      Byte Order (FEFFh)
  006h 2      Header Size (usually 40h)
  008h 4      Version (02000000h)
  00Ch 4      File Size
  010h 2      Number of Blocks (usually 3, INFO+SEEK+DATA)
  012h 2      Reserved
  014h 4+4+4  INFO Block Reference (RefID=4000h, Offset from CSTM+0, Size)
  020h 4+4+4  SEEK Block Reference (RefID=4001h, Offset from CSTM+0, Size)
  02Ch 4+4+4  DATA Block Reference (RefID=4002h, Offset from CSTM+0, Size)
  038h 8      Padding to 20h-byte boundary
```


```
 ________________________________ INFO Block _________________________________
```



## Info Block


```
  000h 4    Chunk ID "INFO"
  004h 4    Chunk Size
  008h  4+4 Stream Info Entry (RefID=4100h, Offset relative to INFO+8)
  010h  4+4 Track Info List   (RefID=4101h, Offset relative to INFO+8)
  018h  4+4 Channel Info List (RefID=4102h, Offset relative to INFO+8)
  020h  38h Stream Info Entry      ;\
  058h  ..  Track Info List        ; from above Header  ;<-- 4+(N*8) ?
  ..    ..  Channel Info List      ;/                   ;<-- 4+(N*8) ?
  ..    ..  Track Info Entries     ;\from above Lists
  ..    ..  Channel Info Entries   ;/
```

If encoding is DSP-ADPCM:

```
  ..    ..  DSP-ADPCM Info Entries
```

If encoding is IMA-ADPCM:

```
  ..    ..  IMA-ADPCM Info Entries
```

The info block is aligned to 20h bytes. uh, that is, the "Stream Info" block?



## Stream Info Entry


```
  000h 1    Encoding      (0=PCM8, 1=PCM16, 2=DSP-ADPCM, 3=IMA-ADPCM)
  001h 1    Loop          (0=Don't loop, 1=Loop)
  002h 1    Channel Count
  003h 1    Padding
  004h 4    Sample Rate
  008h 4    Loop Start Frame
  00Ch 4    Loop End Frame
  010h 4    Sample Block Count
  014h 4    Sample Block Size
  018h 4    Sample Block Sample Count
  01Ch 4    Last Sample Block Size
  020h 4    Last Sample Block Sample Count
  024h 4    Last Sample Block Padded Size
  028h 4    Seek Data Size
  02Ch 4    Seek Interval Sample Count
  030h 4+4  Sample Data   (RefID=1F00h, Offset from "Data Block Data field")
```



## Track Info Entry


```
  000h 1    Volume
  001h 1    Pan
  002h 2    Padding
  004h 4+4  Channel Index Byte Table (RefID=0100h, Offset from Volume field)
  00Ch ..   Channel Index Byte Table (at above Offset)
  ..   ..   Padding to 4-byte boundary (0)
```

Byte Table:

```
  000h 4      Count
  004h Count  Elements
```



## Channel Info Entry (aka Sample Info)


```
  000h 4+4  DSP-ADPCM Info  (RefID=0300h, Offset from here?)  ;\depending
            IMA-ADPCM Info  (RefID=0301h, Offset from here?)  ; on Encoding
            No ADPCM Info?  (RefID=0000h, Offset=FFFFFFFFh)   ;/
```

DSP-ADPCM Info:

```
  000h 32  Param (16bit Coefficients)    ;-Whatever Coefficients
  020h 1   4bit Predictor + 4bit Scale   ;\
  021h 1   Reserved (0)                  ; Initial context
  022h 2   Previous Sample               ;
  024h 2   Second Previous Sample        ;/
  026h 1   4bit Predictor + 4bit Scale   ;\
  027h 1   Reserved (0)                  ; Loop context
  028h 2   Previous Sample               ;
  02Ah 2   Second Previous Sample        ;/
  02Ch 2 ? Padding ??                    ;-uh?
```

IMA-ADPCM Info:

```
  000h 2   Data                          ;\Initial context
  002h 1   Table Index                   ; ...for port 10103418h+(N*20h)?
  003h 1   Padding                       ;/
  004h 2   Data                          ;\Loop context
  006h 1   Table Index                   ; ...for port 1010341Ch+(N*20h)?
  007h 1   Padding                       ;/
```


```
 ________________________________ SEEK Block _________________________________
```



## Seek Block


```
  000h 4    Chunk ID "SEEK"
  004h 4    Chunk Size
  008h ..   Data ... whatever ?
```

The seek block is aligned to 20h bytes.


```
 ________________________________ DATA Block _________________________________
```



## Data Block


```
  000h 4    Chunk ID "DATA"
  004h 4    Chunk Size
  008h ..   Data ... probably sample data ?
```

The data block is aligned to 20h bytes, as well as the data field's actual
sample data.


```
 ________________________________ Notes..... _________________________________
```



## Whatever Reference Type


```
  RefID=0101h = Reference Table ?
```



## Tools


The following tools can play BCSTMs and convert them to other formats:

```
  Isabelle Sound Editor
  vgmstream
  Every File Explorer
```




# <a name="3dsfilessoundgroupcgrpformat"></a>3DS Files - Sound Group (CGRP Format)



CGRP files are included in some CSAR files, but not always (for example, a CGRP
can be found in the "AR Games" system title).

The purpose of CGRP is unknown. The INFO block seems to be mainly good for
re-ordering whatever indices. And the FILE block is somewhat empty.



## CGRP Header


```
  000h 4     ID "CGRP"
  004h 2     Byte Order (FEFFh)
  006h 2     Header Size (usually 40h)
  008h 4     Version?    (can be 01000000h)
  00Ch 4     Total Filesize
  010h 4     Number of Blocks (usually 2 = INFO+FILE)
  014h 4+4+4 INFO Block (RefID=7800h, Offset from CGRP+0, Size)
  020h 4+4+4 FILE Block (RefID=7801h, Offset from CGRP+0, Size)
  02Ch 14h   Padding to 20h-byte boundary (0)
```



## INFO Block


```
  000h 4       ID "INFO"
  004h 4       INFO Block Size (same as in CGRP Header)
  008h 4       Number of following List entries (eg. 40h)
  00Ch (4+4)*N List Entries (RefID=7900h, Offset from INFO+8)
  ...  ..      Padding to 20h-byte boundary (0)
```

List Entry Format:

```
  000h 4     Unknown (0..NumListEntries, in no specific order)
                     (and apparently one value skipped, since using values
                      in range 0..Num would be Num+1 values in total)
  004h 4     Unknown (FFFFFFFFh)
  008h 4     Unknown (FFFFFFFFh)
  00Ch 4     Unknown (0)
```



## FILE Block


```
  000h 4     ID "FILE"
  004h 4     FILE Block Size (same as in CGRP Header) (=20h)
  008h 18h   Padding to 20h-byte boundary (0)
```

Apart from the above header, there is no actual data in the FILE block, unless
it's meant to be a prefix for the following CWAR blocks in the CSAR file?




# <a name="3dsfilessoundidscsidformat"></a>3DS Files - Sound IDs (CSID Format)



Some titles have the CSAR file bundled with a separate CSID file with .csid
extension (eg. 3DS Health Safety RomFS:\sound\Main.csid and 3DS Instruction
Manual applet RomFS:\sound\Main.csid), which appears to be a relict from
devkit, used before/after generating the CSAR file.

The file contains Symbols and 32bit Resource IDs in ASCII, oddly, with an UTF-8
Byte Order Mark (EFh,BBh,BFh) in the file header.




# <a name="3dsfilessounddspbinarydsp1akacdc"></a>3DS Files - Sound DSP Binary (DSP1 aka .cdc)



Teak DSP binaries are usually having extension .cdc (supposedly unrelated to
the "cdc" codec services). DSP binaries are found in some titles (eg. 3DS eShop
RomFS:\sound\dspaudio.cdc, 3DS Browser Applet RomFS:\snd\dspaudio.cdc, and
(LZ11-compressed) 3DS Nintendo Zone RomFS:\dspaudio.cdc.nwcx).

Unknown if there is some kind of default DSP driver for use by other titles.



## Header (300h bytes)


```
  000h       100h RSA Signature across header bytes [100h-2FFh]
  100h       4    ID ("DSP1")
  104h       4    Total Filesize
  108h       1    Code Memory (bit0-7, for 8 32Kbyte blocks) (usually FFh)
  109h       1    Data Memory (bit0-7, for 8 32Kbyte blocks) (usually FFh)
  10Ah       3    Zero (00h,00h,00h)
  10Dh       1    Special Segment DSP Area (00h..02h) (usually 02h=Data)
  10Eh       1    Number of segments (must be 01h..0Ah)
  10Fh       1    Flags (bit0=RecvData, bit1=WithSpecialSegment)
  110h       4    Special Segment DSP Address in 16bit words
  114h       4    Special Segment Size in bytes (usually 214h)
  118h       8    Zero
 Segment record 0..9:
  120h+N*30h 4    Segment N File Offset in bytes (300h and up)
  124h+N*30h 4    Segment N DSP Address in 16bit words (max 1FFFFh or 0FFFFh)
  128h+N*30h 4    Segment N Size in bytes
  12Ch+N*30h 3    Segment N Zero
  12Fh+N*30h 1    Segment N DSP Area (00h..02h)
  130h+N*30h 20h  Segment N SHA256 across Segment Data
  300h       ..   Segment Data..
```


DSP Areas at [10Dh] and [124h+N\*30h] can be:

```
  0 = DSP Code Memory (at ARM:1FF00000h and up) (DSP:00000h..1FFFFh)
  1 = DSP Code Memory (at ARM:1FF00000h and up) (DSP:00000h..0FFFFh only?)
  2 = DSP Data Memory (at ARM:1FF40000h and up) (DSP:00000h..0FFFFh only?)
```



## Flags.bit0=RecvData


If set, DSP module calls DSP:RecvData on "all three registers" and expects them
to reply value, uh, that is... probably done as handshake AFTER uploading the
DSP binary?



## Flags.bit1=WithSpecialSegment


If set, 214h bytes are read from CfgS:GetConfigInfoBlk8 block 70000h, and then
copied to the special segment area/address. If the reading fails, zeroes are
written in its place. The purpose of this segment is currently unknown.




# <a name="3dsfilesmodulenwmwifidriver"></a>3DS Files - Module NWM (Wifi Driver)




## NWM File/versions


The wifi driver can be found in following locations (each console should have
one normal mode file, and one safe mode file):

```
  3ds:\title\00040130\00002d02\content\000000vv.app  ;NWM Normal mode (all 3DS)
  3ds:\title\00040130\00002d03\content\0000000v.app  ;NWM Safe mode (Old3DS)
  3ds:\title\00040130\20002d03\content\0000000v.app  ;NWM Safe mode (New3DS)
```

The .app file contains a compressed .code file (inside of the NCCH ExeFS). That
.code file contains ARM11 code and six datablocks with the actual Xtensa wifi
firmware (similar as in the DSi wifi firmware):

```
  Stub.data   038h bytes                   ;\Database and EEPROM reading stub
  Stub.code   316h bytes                   ; (always same size/content)
  Database    1E8h bytes                   ;/
  Main.type1  0FD3h, 10F7h, or 1B1Bh bytes ;\Main firmware (compressed)
  Main.type4  A053h, A482h, or A5EBh bytes ; (size/content varies per version)
  Main.type5  78F6h, or 7A2Eh bytes        ;/
```

There are a few safe mode versions, and dozen(s) of normal mode versions. The
versions may contain different ARM11 code, and/or different Xtensa code (as
shown above, there are at least three revisions of the Xtensa "Main" code
blocks (spotted in four different NWM files, so there may be much more
variations)).



## NWM Main Type1/4/5


There are three variants of the Main firmware, called Type1/4/5 (because the
ARM11 code uses "CMP r0,1/4/5" opcodes to determine which one to use).


## Type1 = Standard functions for normal internet access

  - Type1 supports the same commands/events as on DSi

## Type4 = Special AP Mode and whatever:

  - WMIcmd(004Ah..0052h) seem to be AP mode (alike Atheros cmd F00Bh..F013h)
  - WMIcmd(0053h,0055h..005Fh) unknown
  - WMIevent(101Dh,101Fh,1020h,1022h,1024h,1025h) unknown
  - Type4 can be used for normal internet access (when ignoring event 1025h)

## Type5 = Special MacFilter, GameID, and built-in SHA1 function

  - Contains ascii strings "MACFilter" and "GameID", and a built-in SHA1 function
  - WMIcmd(0060h..0073h) unknown
  - WMIevent(1021h,1023h,1026h,1027h) unknown
  - Type5 doesn't seem to support normal internet access (it can't even find APs)

Type4/5 are probably for Nintendo-specific special local network multiplayer
features, possibly related to "Streetpass" (in sleep mode?) and "DownloadPlay"
(for single gamepak), and/or other purposes.



## Addresses in ARM11 Pool


The ARM11 code does reference the Xtensa datablocks with "LDR Rd,=address"
opcodes, hence having the datablock addresses stored in the literal pool. The
pool isn't exactly intended to be used as "table of contents", but it can be
misused for that purpose:

Search for constant 00524C00h, check that constant 000003EDh is located at the
expected offset, then extract the datablock start/end addresses from the
corresponding pool locations, subtract 10000h to convert addresses to .code
file offsets.

The NWM file does contain two pools: One pool with the Main type1/4/5
addresses, followed by by larger pool with the same addresses, plus addresses
for the Database and EEPROM reading stub code/data.

Most files (3 of 4 known files) are using this pool structure:


## Newer Small Pool:

  - 00h main.dst (and stub.data.dst) ;CONST (00524C00h)
  - 04h whatever value               ;CONST (000003EDh)
  - 08h main.src.type1.end    ;\Type1 (basic internet)
  - 0Ch main.src.type1.start  ;/
  - 10h main.src.type4.end    ;\Type4 (ApMode and whatever)
  - 14h main.src.type4.start  ;/
  - 18h main.src.type5.end    ;\Type5 (MacFilter,GameId,Sha1)
  - 1Ch main.src.type5.start  ;/

## Newer Large Pool:

  - 00h whatever.addr.plus00h         ;\
  - 04h whatever.addr.plus04h         ; INCREASING addresses
  - 08h whatever.addr.plus08h         ;
  - 0Ch whatever.addr.plus0Ch         ;/
  - 10h whatever.other.addr
  - 14h main.dst (and stub.data.dst) ;CONST (00524C00h)
  - 18h whatever value               ;CONST (000003EDh)
  - 1Ch main.src.type1.end   ;\Type1 (basic internet)
  - 20h main.src.type1.start ;/
  - 24h main.src.type4.end   ;\Type4 (ApMode and whatever)
  - 28h main.src.type4.start ;/
  - 2Ch main.src.type5.end   ;\Type5 (MacFilter,GameId,Sha1)
  - 30h main.src.type5.start ;/
  - 34h database.src.end     ;\Datab ;SAME as stub.code.src.start
  - 38h database.src.start   ;/
  - 3Ch database.dst                 ;CONST (0053FE18h)
  - 40h stub.code.src.end    ;\Stubc
  - 44h stub.code.src.start  ;/      ;SAME as database.src.end
  - 48h stub.code.dst                ;CONST (00527000h)
  - 4Ch stub.data.src.end    ;\Stubd
  - 50h stub.data.src.start  ;/
  - 54h whatever.thumb.code.addr1
  - 58h whatever.thumb.code.addr2
  - 5Ch whatever.thumb.code.addr3

There is at least one older file using this pool structure:


## Older Small Pool:

  - 00h main.dst (and stub.data.dst) ;CONST (00524C00h)
  - 04h maintype5.src.end
  - 08h maintype5.src.start
  - 0Ch maintype1.src.end
  - 10h maintype1.src.start
  - 14h maintype4.src.end
  - 18h maintype4.src.start
  - 1Ch whatever value               ;-CONST (000003EDh)

## Older Large Pool:

  - 00h whatever.addr.plus00h        ;\
  - 04h whatever.addr.plus04h        ;
  - 08h whatever.addr.plus08h        ; INCREASING addresses
  - 0Ch whatever.addr.plus0Ch        ;
  - 10h whatever.addr.plus10h        ;/
  - 14h whatever.other.addr
  - 18h main.dst (and stub.data.dst) ;CONST (00524C00h)
  - 1Ch maintype5.src.end
  - 20h maintype5.src.start
  - 24h database.dst                 ;CONST (53FE18h)
  - 28h database.src.end             ;SAME as stub.code.src.start
  - 2Ch database.src.start
  - 30h stub.code.dst                ;CONST (527000h)
  - 34h stub.code.src.end
  - 38h stub.code.src.start          ;SAME as database.src.end
  - 3Ch stub.data.src.end
  - 40h stub.data.src.start
  - 44h whatever.thumb.code.addr1
  - 48h whatever.thumb.code.addr2
  - 4Ch whatever.thumb.code.addr3
  - 50h maintype1.src.end
  - 54h maintype1.src.start
  - 58h maintype4.src.end
  - 5Ch maintype4.src.start
  - 60h whatever value               ;CONST (000003EDh)

Moreover, there are dozens of unknown files, which may (or may not) use yet
different pool structures.




# <a name="nondsfilesrarcarchives"></a>Non-DS Files - RARC Archives



RARC archives are used in Wii and GameCube games like Super Mario Galaxy 1
& 2 and Supermario Sunshine. The RARC format is unique in terms of storing
duplicated folder data in both Folder List and Directory Entries.



## RARC Header (...probably bug-endian?)


```
  000h 4   ID "RARC"
  004h 4   Total Filesize
  008h 4   Size of RARC Header (always 20h)
  00Ch 4   Size of Info Block (plus Folder List, Directory List, String Table)
  010h 4   Size of File Data area
  014h 4   Size of File Data again? (always same as the previous value)
  018h 8   Unknown (zerofilled)
  020h ..  Info Block (plus Folder List, Directory List, String Table)
  ...  ..  File Data
```



## Info Block (20h-bytes, plus Folder List, Directory List, String Table)


```
  000h 4   Folder List Size/10h    (number of folders)
  004h 4   Folder List Offset      (relative to the start of Info block)
  008h 4   Directory List Size/14h (number of files+folders)
  00Ch 4   Directory List Offset   (relative to the start of Info block)
  010h 4   String Table Size/1     (in bytes)
  014h 4   String Table Offset     (relative to the start of Info block)
  018h 2   Number of directory entries that are Files (number of files)
  01Ah 6   Unknown (zerofilled)
  020h ..  Folder List (10h bytes per entry)
  ...  ..  Directory List (14h bytes per entry)
  ...  ..  String Table
```



## Folder List Entries (10h-bytes each) (first entry is root folder)


```
  000h 4   Short name (first 4 chars of name, uppercase, spc-padded, eg. ROOT)
  004h 4   Name Offset (relative to start of string table)
  008h 2   Name Checksum
  00Ah 2   Number of Directory entries in this folder
  00Ch 4   Index of first Directory entry for this folder
```



## Directory Entries (14h-bytes each) (contains both Files and Folders)


```
  000h 2   Index of this directory entry (aka File ID or so) (or FFFFh=Folder)
  002h 2   Name Checksum
  004h 2   Type/Attributes? (1100h=File, 0200h=Folder)
  006h 2   Name Offset (relative to start of string table)
  008h 4   File Data Offset   (or, for folders: Index in Folder List)
  00Ch 4   File Size in bytes (or, for folders: unused)
  010h 4   Unknown (zerofilled)
```



## String Table & Name Checksums


The string table consists of null-terminated ASCII(?) strings. The Name
Checksums (in Folder List and Directory Entries) are calculated as so:

```
  sum=0, i=0, while name[i]<>00h do sum=((sum*3)+name[i]) AND FFFFh, i=i+1
```




# <a name="nondsfilesu8archives"></a>Non-DS Files - U8 Archives



U8 archives are used in Mario Kart Wii and maybe other games (something called
Wii discs is reportedly using a similar format, too).



## U8 Format (big endian)


```
  000h 4     ID (55AA382Dh) (appears as U.8- in hex editors) (nicknamed U8)
  004h 4     Offset to Directory (aka 20h?)
  008h 4     Size of Directory including String Table
  00Ch 4     Offset to File Data
  010h 10h   Reserved
  020h N*0Ch Directory Entries (0Ch-bytes each)
  ...  ..    String Table (ASCII strings, terminated by 00h)
  ...  ..    File Data
```



## Directory Entries (starting with root entry)


```
  000h 1    Type (00h=File, 01h=Directory) (other values never seen)
  001h 3    24bit Filename Offset (relative to begin of String Table)
  004h 4    File: Offset to data
            Directory: Index of the parent directory
  008h 4    File: Size of data
            Directory: Index of the first node that is not part of this
              directory (skip to node)
```


Note: The U8 format is about same as 3DS "darc" format (with different header,
different byte-order, and ASCII instead of UTF-16 names).

- [3DS Files - Archive DARC](#3dsfilesarchivedarc)



# <a name="3dsconsoleids"></a>3DS Console IDs




## Hardware IDs


The main Console ID is stored in OTP memory:

- [3DS Crypto - PRNG and OTP Registers](#3dscryptoprngandotpregisters)
The eMMC CID is used for generating console specific encryption keys. The SD
card CID is also used for generating a SD card specific \<ID1> folder
name.



## 3ds:\rw\sys\LocalFriendCodeSeed\_B (or Seed\_A, if it exists) (110h bytes)


```
  000h 100h  RSA-2048 signature across following 10h-bytes  ;\
  100h 1     Zero                                           ; same values are
  101h 1     Devkit (00h=Retail, 01h=Devkit)                ; also stored in
  102h 6     Zero                                           ; movable.sed
  108h 8     Decrypted OTP[08h..0Fh]                        ;/
```

This can be also retrieved via "PSPXI:GetLocalFriendCodeSeed".



## 3ds:\private\movable.sed (120h or 140h bytes)


```
  000h 4     ID "SEED"
  004h 1     Zero
  005h 1     Zero (or 01h if extra bytes at [120h..13Fh] are appended)
  006h 2     Zero
  008h 100h  RSA-2048 signature across following 10h-bytes  ;\same values are
  108h 1     Zero                                           ; also stored in
  109h 1     Devkit (00h=Retail, 01h=Devkit)                ; LocalFriendCode
  10Ah 6     Zero                                           ; Seed_B (or _A)
  110h 8     Decrypted OTP[08h..0Fh]        ;\used as AES   ;/
  118h 4     Decrypted OTP[10h..13h]+Offset ; KeyY for 3
  11Ch 4     Decrypted OTP[14h..17h]        ;/keyslots
 The original movable.sed from the factory is only 120h-bytes.
 Below extra data is written to the file when doing a System Format.
  120h 4     Offset (added to above Decrypted OTP[10h..13h] entry)
  124h 0Ch   Zero
  130h 10h   AES-MAC (NAND dbs keyslot) across SHA256 across bytes [000h..12Fh]
```

Bytes [110h..11Fh] are used as KeyY for AES keyslots 30h, 34h, and 3Ah:

```
  Keyslot 30h  AES-CMACs for non-DSiWare in sd:\Nintendo 3DS\ and 3ds:\data\
  Keyslot 34h  AES encryption in sd:\Nintendo 3DS\
  Keyslot 3Ah  AES-CMACs for DSiWare in sd:\Nintendo 3DS\
```

Bytes [110h..11Fh] are also used to derive the \<ID0> folder name (see
below).

Movable.sed is transferred to the destination 3DS during a System Transfer. The
movable.sed keyY high u64 is updated on the source 3DS during a System
Transfer, and when doing a system format with System Settings.



## 3ds:\data\\<ID0>\ (\<ID0> folder on 3DS partition)



## sd:\Nintendo 3DS\\<ID0>\\<ID1>\ (\<ID0>\\<ID1> folder on SD card)


The \<ID0> folder name is derived by computing the SHA256 across
moveable.sed bytes [110h..11Fh], and then converting the first 4 words of the
SHA256 into a lowercase ASCII string (with the byte order reversed in each of
the four words, and with the last 4 words left unused).

The \<ID1> folder name is derived by swapping around the byte order of the
SD card CID: The CID is rotated 8-bits to the left (uh, that means the ending
00h padding byte is moved to begin?). Then, the word-order is reversed. And
then, the halfwords are converted into ascii string (with byte-order for each
byte-pair reversed), or so?



## 3ds:\rw\sys\SecureInfo\_A (111h bytes) (Region and Serial/Barcode)


```
  000h 100h  RSA-2048 signature across following 11h-bytes
  100h 1     Region (0=JPN, 1=USA, 2=EUR, 3=Reserved, 4=CHN, 5=KOR, 6=TWN)
  101h 1     Normally zero
  102h 0Fh   Serial/Barcode, without ending check digit (ASCII, zeropadded)
```

The serial/barcode consists of 2-3 letters, followed by 8 digits, followed by a
checksum digit.

The first letter indicates the console model:

```
  3DS             C  (or E for devunits)
  3DS XL/LL       S  (or R for devunits)
  2DS             A  (or P for devunits)
  New 3DS         Y  (or Yxx00 for devunits)
  New 3DS XL/LL   Q  (or Qxx00 for devunits)
  New 2DS XL/LL   N  (or Nxx01 for devunits)
```

The next 1-2 letter(s) indicate the region:

```
  JPN Japan                          JF,JH,JM
  USA North America                  W
  USA Middle East, Southeast Asia    S
  EUR Europe                         EF,EH,EM
  EUR Australia                      AG,AH
  CHN China (iQue)                   CF,CH,CM
  KOR South Korea                    KF,KH,KM
  TWN Taiwan                         ...unknown?
```

The checksum digit is found on the consoles barcode sticker, but isn't included
in the SecureInfo\_A file. However, the checksum can be calculated across
1st-8th digit (and ignoring the leading letters):

```
  9th = (250 - (1st+3rd+5th+7th) - 3*(2nd+4th+6th+8th)) mod 10
```

The RSA private key for retail is unknown. The private key for devkits is
included in the devkit system updater package.




# <a name="3dsemmcandmcuimages"></a>3DS eMMC and MCU Images




## eMMC Images


no$gba can load 3DS eMMC images from following files in no$gba folder
(currently that merely allows to view eMMC images in Window/Filesystem, ie.
there isn't any actual 3DS emulation supported in no$gba):

```
  3DS-#.mmc      ;\with "#" being the machine number ("1".."C")
  New3DS-#.mmc   ;/
```

For decrypting the image, CID and OTP needs to be stored at following eMMC
offsets:

```
  DC00h 20h   ID '3DS CID/OTP/NCSD/FIRM BackupData'
  DC20h 10h   eMMC CID (from eMMC command CMD10)
  DC30h D0h   Reserved
  DD00h 100h  OTP   (from ARM9 I/O address 10012000h)
  DE00h 200h  Copy of original NCSD  (from eMMC offset 00000000h)
  E000h 1000h Copy of original FIRM0 (from eMMC offset 0B130000h)
  F000h 1000h Copy of original FIRM1 (from eMMC offset 0B530000h)
```

The copy of original NCSD/FIRM0/FIRM1 allows to uninstall sighax-based stuff
(or to install such stuff; doing that works even without having OTP dump, as
long as the unencrypted content of the NCSD/FIRM0/FIRM1 sectors is known).



## MCU Firmware Images


The MCU image can be viewed in no$gba's RL78 disassembler (via Alt+W, R). The
image is loaded from following files in no$gba directory:

```
  3DS.mcu
  New3DS.mcu
```

The file should contain a copy of the whole 8000h-byte MCU flash memory:

```
  0000h 1000h Part 1 current version
  1000h 1000h Part 1 old version backup
  2000h 3000h Part 2 current version
  5000h 3000h Part 2 old version backup
```

If the old version areas aren't dumped, best leave them empty.



## Atheros Wifi ROM image


The Wifi ROM image can be viewed in no$gba's Xtensa disassembler (via Alt+W,
X). The image is loaded from following file (in no$gba directory):

```
  AR6014G.ROM  ;3DS wifi chip     (256Kbytes)
```




# <a name="3dscomponentlists"></a>3DS Component Lists




## 3DS Component List


- PCB "C/CTR-CPU-01"
  - U1   bga   "1048 0H, CPU CTR, (M)(C)2010, Nintendo, JAPAN ARM" (main cpu)
  - U2   bga   "F JAPAN, MB82M8080-07L, 1040 M90, E1"              (main ram)
  - U3   bga   "Texas Instruments, 93045A4, 0AAH86W GI" (PCB back, below YXAB)
  - U4   bga   "Texas Instruments, PAIC301DB, 0AA37DW, GI"         (TSC)
  - U5   bga   "TOSHIBA THGBM2G3P1FBAI8, VX2306, TAIWAN, 10459AE"  (eMMC)
  - U6   bga   "UC CTR, 041KM73, KG10"                             (MCU)
  - U?? 16pin  "CKP, TI 09W, ZF1T"     (PCB back, above YXAB)  (battery charger)
  - U8   8pin  "17040, 08A45" MAX17040 (PCB back, above PWR button) (fuel gauge)
  - U9  xxpin  "2048, 33DH, X1MAQ" or so (small, below/right of PAIC) (accelero)
  - U10  3pin  "HOX" or "XOH" (PCB back, below/right of YXAB) (magnet sensor?)
  - U11 xxpin  unsharp... INVENSENSE or so (right of main cpu)  (gyroscope?)
  - U12  6pin  "EPB" (between main cpu and wifi socket)
  - U13  6pin  "?" (right of PAIC)
  - Q1   6pin  "JG" (PCB back, right of POWER button)
  - Q4   6pin  "?" (between PAIC and UC CTR)
  - X1   4pin  "16.756" osc (near main CPU)
  - X2   4pin  "CA038" osc (near UC CTR)
- Wifi board "DWM-W028"
  - Un  80pin Wifi "Atheros, AR6014G.AL1C, N2T689,00B, 1036, TAIWAN" ;76+4pin
  - Un   8pin Wifi SPI FLASH "32A, 0VX, 46"
  - Un   8pin Wifi I2C EEPROM "08B, H1, 0DQ"
  - Un   4pin voltage regulator? "M12, KA"
  - Qn   4pin Crystal "40.000"
  - Pn  50pin Connector to mainboard
  - Pn   2pin Antenna connector
- IrDA board "CTR-IR-01 "
  - U1   xpin IR photo led/transistor unit
  - U2  24pin IrDA chip "NXP, S750, 0803, TSD031C"
- SD/MMC slot board
  - Pn   Xpin Connector to mainboard
  - Pn   Xpin Connector to full-size SD/MMC card
- XXXxxx...
  - and probably much more unknown stuff...



## 3DS XL



## 2DS



## New3DS



## New2DS XL


Unknown. These consoles seem to be quite rare, and no PCB photos exist...?



## New3DS LL Component List (aka japanese version of New3DS XL)


Mainboard (PCB "RED-CPU-01 SIDE B 11-1, [05: 14 071], RED-CPU-01 SIDE A")

- Chips on Side B (top side, access requires removing mainboard):
- Un  bga   CPU "1485 16, CPU LGR A, (C) 2014, Nintendo, JAPAN ARM"  ;\
- Un  bga   RAM "F JAPAN, 82MK9A9A, 7L FCRAM, 1429969, E1"           ;
- Un  6pin  MAX8570EUT+T for upper backlight "ABTJ"                  ; Side B
- Un  sqr   Wifi "ATHEROS, AR6014G-AL1C, NKY197.00B, 1422, TAIWAN"   ;
- Un  bga   eMMC "dotcode, SAMSUNG 410, KLM4G1YE0C-B301, CDA519GLN"  ;
- Un  8pin  Wifi-EEPROM I2C "408F, B347" (HN58X2408F; 1Kx8)          ;
- Un  bga   MCU "UC KTR, 423KM01, 'TK14"                             ;
- Un  bga   Powerman? "TexasInstr, 93045A4, 3CAK08W L, GI"           ;/
- Chips on Side A (bottom side, easily accessible):
- Un  16pin BQ24072 battery charger "CKP, TI 3A1, CBYS" (near ext.supply input)
- Un  6pin  power/charge? "9D" (or "06"?) (near ext.supply input)
- Un  6pin  power "635Q" (under powerman) (...maybe lower backlight?)
- Un  24pin IrDA "U8997, 3522" (nocash), or "NXP, S750, 1603, TSD438C" (ifixit)
- Un  16pin Gyroscope? less-near infra red "IT3B,315BA1,LT425A" (like ITG-1010?)
- Un  32pin NFC Broadcom BCM20791 "20791UZ, KMLG 25, TD1430, 3976901W"
- Un  8pin  Wifi-FLASH SPI(?) "32B, 3XH, .01" (4Kx8) (near AIC)
- Un  bga   AIC "TexasInstr, AIC3010D, 3BC473W, GI" (mic/sound/touchscr)
- Un  16pin Accelerometer? near AIC and headphone "KXTKK, 40860, .3413" Kionix?
- Un  bga   TCA6416A IO Expander "PH416A, TI 46T" ;near top-screen connectors
- Other stuff:
- Xn  4pin "CA405" or so (near UC KTR, probably for RTC)
- Xn  4pin "40000, K42BY" (under atheros, probably for Wifi)
- Xn  4pin "13000, K413Y" (under cpu, probably whatever) (to near-field chip?)
- Xn  4pin "D164G" or so  (under cpu, probably whatever) (for CPU?)
- Ix  Infrared receiver/transmitter
- Fn  Fuse (for external charger + pin, near charger connector)
- Pn  2pin External Power supply
- Pn  3pin External Headphone
- Pn  2pin Connector to antenna
- Pn ??pin Connector to Button board (many pins)
- Pn ??pin Connector to MicroSD slot (medium pins)
- Pn  4pin Connector to Front panel Reset button? and MIC
- Pn  4pin Connector to Front panel Home button? (4pins, only 2 wires attached)
- Pn  Connector to bottom-shell (left shoulder (8pin+shield?, only 4 wires used)
- Pn  Connector to bottom-shell (right shoulder (8pin+shld?, only 4 wires used)
- Pn  4pin Connector to NFC (rectangle under bottom screen) (only 2 wires used)
- Pn  4pin Connector to analog stick (above dpad)
- Pn  4pin Connector to bottom screen, touchscreen
- Pn  4pin Connector to bottom screen, backlight (4pin, only 2 wires used)
- Pn ??pin Connector to bottom screen, video (many pins)
- Pn ??pin Connector to top screen? ;\presumably video,backlight,cameras,sound
- Pn ??pin Connector to top screen? ; (many pins on each connector)
- Pn ??pin Connector to top screen? ;/
- Pn  1pin Goldplate as additonal connection to cartridge board GND
- Transistors/resistors/capacitors and the like
- Barcode/sticker "22946012 Q01011K N"

Button board (PCB "F-7, PWB, /ABXY, /AU-C, /RED-01, CS, 01, 3814")

```
 Un  44pin ?? Chip "428A2, HF374, 7NU9"  ;for C-stick and ZL/ZR-buttons?
 Un  3pin "(M)UN" (large thing, right of start button) (magnet sensor?)
 Un  8pin "7048, xxxxxx?" (tiny bga chip, right of select button) (fuel gauge)
 Pn  Connector to mainboard
 Pn  Connector to battery (3pin)
 Pn  Connector to rubber nibble (C-Stick) (4pin)
 Pn  Connector to shoulder (8pin)
 Sw  Six buttons (A,B,X,Y,Sel,Start)
 Sw  Front button (Power)
 Fn  Fuse (for battery + pin, above wifi led)
 Led Four Front LEDs (two single ones, and one LED-pair)
 Led Notification LED (small 4pin RGB LED? under shoulder-connector)
 Transistors/resistors and the like
 Barcode/sticker "30946012 Z0101E9 X"
```

DPAD board (PCB "F-KEY 01, R, ZD, HF, 4354.")

```
 Pn  Connector to cartridge slot board (5pin)
 Sw  Four switches (Up,Down,Left,Right)
```

Cartridge Slot board (PCB "(DC)17P-01, C-3, 1 '14 12")

```
 Pn  Cartridge Slot ("4081911")
 Pn  Connector to mainboard
 Pn  Connector to DPAD board (5pin)
 Pn  Goldplate as additonal connection to mainboard GND
```

Battery:

- Name "Nintendo SPR-003, Rechargeable Battery, 3.7V 1750mAh 6.5Wh"
- Dotcode with text "MKH905D10"
- Back side "Li-ion 00, SPR-A-BPAA-C1"

Bottom Screen:

- Name "1912TSS140725, 21P4808L, B0014747QTFD" (4.18")

Top-screen unit

```
 black ribbon cable: to camera unit      ;outer/rear cable
 orange ribbon cable: to slider boards   ;middle cable
 orange ribbon cable: to lcd screen      ;inner/front cable
 red cable: to wifi antenna
 1x  LCD with Dotcode/sticker "LAM049M003A1, 0020S4911848"
 2x  2pin speaker's "G4830V23A" or "G4B30V23A" or so
 1x  2pin wifi-antenna (nameless pcb)
 1x  camera unit (with two pcbs, 3 cameras, and shielding, see below)
 2x  slider boards (see below)
```

Left slider/speaker board:

```
 1x  volume slider (9.8Kohm)
 1x  wires to left speaker
 1x  13pin connector to lcd screen (maybe parallax or whatever)
 1x  4pin connector to lcd screen (maybe backlight and/or whatever)
```

Right slider/speaker board:

```
 1x  3d slider (8.4Kohm)
 1x  wires to right speaker
```

Front facing camera board:

- two cameras, capacitors (C1..C12), FB1, FB2

Self facing camera board:

- one camera, capacitors (C1..C5), FB1, R1, Q1, D1 (ir-led?)

Case/bottom

- "(new), Nintendo, o3DS LL, (C)2014 Nintendo Made in China RED-001"
- "[MIC/KS], EC-14016, RED-RB-JPN-C0"
- "[R]007-AC0104, [T]D14-0144001, V(Ci Li-ion, (Nintendo)"
- Barcode/sticker "QJF10203741 6"




# <a name="3dschipsetpinouts"></a>3DS Chipset Pinouts




## New Gyroscope (ITG-1010)


```
  1    VDDIO    Digital I/O supply voltage
  2    SCL/SCLK I2C serial clock (SCL); SPI serial clock (SCLK)
  3    SDA/SDI  I2C serial data (SDA); SPI serial data input (SDI)
  4    AD0/SDO  I2C Slave Address LSB (AD0); SPI serial data output (SDO)
  5    /CS      SPI chip select (Low=SPI mode, High=I2C mode)
  6    RESV     Reserved. Connect to Ground
  7    INT      Interrupt digital output (totem pole or open-drain)
  8    FSYNC    Frame synchronization digital input. Connect to GND if not used
  9-12 NC       Not internally connected, may be used for PCB trace routing
  13   GND      Power supply ground
  14   REGOUT   Regulator filter capacitor connection
  15   RESV-G   Reserved. Connect to Ground
  16   VDD      Power supply voltage
```



## Old Gyroscope (ITG-3200)


```
  1     CLKIN   Optional external ref clock input, connect to GND if unused
  2-5   NC      Not internally connected, may be used for PCB trace routing
  6-7   RESV    Reserved. Do not connect
  8     VLOGIC  Digital IO supply voltage. VLOGIC must be = VDD at all times
  9     AD0     I2C Slave Address LSB
  10    REGOUT  Regulator filter capacitor connection
  11    RESV-G  Reserved - Connect to ground.
  12    INT     Interrupt digital output (totem pole or open-drain)
  13    VDD     Power supply voltage
  14-17 NC      Not internally connected, may be used for PCB trace routing
  18    GND     Power supply ground
  19    RESV    Reserved. Do not connect
  20    CPOUT   Charge pump capacitor connection
  21-22 RESV    Reserved. Do not connect
  23    SCL     I2C serial clock
  24    SDA     I2C serial data
```



## Accelerometer (LIS331DLH)


```
  1  Vdd_IO      Power supply for I/O pins
  2  NC          Not connected
  3  NC          Not connected
  4  SCL,SPC     I2C.clock (or SPI.clock)
  5  GND         0V supply
  6  SDA,SDI,SDO I2C.data (or SPI.data.in, or 3-wire.data.out)
  7  SA0,SDO     I2C.device.id (or SPI.data.out)
  8  CS          Mode (high=I2C, low=SPI)
  9  INT 2       Inertial interrupt 2
  10 Reserved    Connect to GND
  11 INT 1       Inertial interrupt 1
  12 GND         0V supply
  13 GND         0V supply
  14 Vdd         Power supply
  15 Reserved    Connect to Vdd
  16 GND         0V supply
```



## IrDA (NXP SC16IS750, 24pin HVQFN24 package)


```
  1  I  /RESET     Reset
  2  I  XTAL1      Crystal input, or external clock input
  3  O  XTAL2      Crystal output, or clock output
  4  -  Vdd        Supply
  5  I  I2C,/SPI   Interface mode select
  6  I  /CS,A0     SPI chip select, or I2C device id
  7  I  SI,A1      SPI data in, or I2C device id
  8  O  SO         SPI data out
  9  I  SCL,SCLK   SPI clk, or I2C clk
  10 IO SDA        I2C data
  11 O  /IRQ       Interrupt
  12 IO GPIO0      I/O
  13 IO GPIO1      I/O
  14 IO GPIO2      I/O
  15 IO GPIO3      I/O
  16 -  Vss        GND
  17 IO GPIO4,/DSR I/O, or modem data set ready
  18 IO GPIO5,/DTR I/O, or modem data terminal ready
  19 IO GPIO6,/CD  I/O, or modem carrier detect
  20 IO GPIO7,/RI  I/O, or modem ring indicator
  21 O  /RTS       UART request to send
  22 I  /CTS       UART clear to send
  23 O  TX         UART data out
  24 I  RX         UART data in
```



## NFC (Broadcom BCM2079x)


Caution: below is for 34pin BCM20793S (which is NOT used in New3DS)

Caution: actual New3DS uses 32pin BCM20791 (maybe similar, but has only 32pin)

The pinout difference might be as simple as omitting the two N/C pins, or some
of the four EEPROM/VDD\_EE pins...?

```
  1  VDDSWP_IN     Platform UICC supply in
  2  VDDSWP_OUT0   UICC supply out
  3  SWPIO_0       SWP I/O 0
  4  SWPIO_1       SWP I/O 1
  5  VDDSWP_OUT1   Supply to embedded secure element
  6  VDD_ADC       Decoupling, need linking to VDDC_CAP via target PCB
  7  NFC_WAKE      Signal from host to the BCM20793S
  8  TM2           ATE test mode (grounded for normal operation)
  9  VDD_EEPROM_IN 1.8V power input to the co-packaged EEPROM (get from VDD_EE)
  10 HOST_WAKE     Interrupt signal from the BCM20793S to host
  11 CLK_REQ       Clock request
  12 UART_TXD      UART transmit       ;or BSC/I2C_SDA, or SPI_MOSI
  13 VDDIO         I/O supply; externally regulated
  14 UART_RTS_N    UART ready to send  ;or BSC/I2C_SCL, or SPI_MISO
  15 SPI_INT       Host interface select (Low=UART, High=BSC/I2C, NC=SPI+IRQ)
  16 UART_CTS_N    UART clear to send  ;or BSC/I2C_REQ(?), or SPI_CS
  17 UART_RXD      UART receive        ;or SPI_CLK
  18 N/C           No connect
  19 XTAL_XON      Crystal N
  20 XTAL_XOP      Crystal P/clock reference input
  21 VDD_XTAL      Decoupling, need linking to VDDC_CAP via target PCB
  22 LPO           Frequency selection, strap high or low (see page 45)
  23 VDD_VCO       Decoupling, need linking to VDDC_CAP via target PCB
  24 VDDC_CAP      Decoupling, links VDDADC, VDD_XTAL, VDD_VCO via target PCB
  25 REG_PU        Regulator power control from host
  26 VBAT          Battery supply
  27 VDDA_CAP      Analog LDO supply decoupling (1.88V/2.5V)
  28 TX2           Coil output 2
  29 TX1           Coil output 1
  30 VDD_ANT       Rectifier output, external cap
  31 N/C           Do not connect
  32 VDD_EE        Output 1.8V supply voltage (to be linked to VDD_SE_IN)
  33 SDA (eeprom)  BSC/I2C data internally connected to co-packaged EEPROM
  34 SCL (eeprom)  BSC/I2C clock internally connected to co-packaged EEPROM
```

EEPROM: CAT24C64 EEPROM Die

Unknown if the EEPROM exists in New3DS, it might require REG\_PU wake or so? Or
the EEPROM is accessed INTERNALLY by the NFC chip (and the two EXTERNAL I2C/BSC
EEPROM pins or meant to be used only optionally, for factory/init/test or so?)
(that way the NFC could be also accessed via SPI/UART whilst internally talking
to the I2C/BSC EEPROM).



## MAX17040 Fuel Gauge (used in Old3DS)


```
  1 CTG   Connect to GND
  2 CELL  Battery Voltage Input
  3 VDD   Power Supply
  4 GND   Ground
  5 SEO   External 32kHz clock enable
  6 EO    External 32kHz clock
  7 SCL   I2C Clock
  8 SDA   I2C Data
```



## MAX17048 Fuel Gauge (this, or something similar(?) is used in New3DS)


```
   ______________________
  |o                     |
  |  CTG  CELL VDD  GND  |
  |  SDA  SCL  QRST /ALRT|
  |______________________|
```




# <a name="armcpureference"></a>ARM CPU Reference




## General ARM7TDMI Information


- [ARM CPU Overview](#armcpuoverview)
- [ARM CPU Register Set](#armcpuregisterset)
- [ARM CPU Flags & Condition Field (cond)](#armcpuflagsconditionfieldcond)
- [ARM CPU 26bit Memory Interface](#armcpu26bitmemoryinterface)
- [ARM CPU Exceptions](#armcpuexceptions)
- [ARM CPU Memory Alignments](#armcpumemoryalignments)


## ARM 32bit Instruction Set (ARM Code)


- [ARM Instruction Summary](#arminstructionsummary)
- [ARM Opcodes: Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)](#armopcodesbranchandbranchwithlinkbblbxblxswibkpt)
- [ARM Opcodes: Data Processing (ALU)](#armopcodesdataprocessingalu)
- [ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)](#armopcodesmultiplyandmultiplyaccumulatemulmla)
- [ARM Opcodes: Special ARM9 Instructions (CLZ, QADD/QSUB)](#armopcodesspecialarm9instructionsclzqaddqsub)
- [ARM Opcodes: Special ARM11 Instructions (Misc)](#armopcodesspecialarm11instructionsmisc)
- [ARM Opcodes: Special ARM11 Instructions (SIMD)](#armopcodesspecialarm11instructionssimd)
- [ARM Opcodes: PSR Transfer (MRS, MSR)](#armopcodespsrtransfermrsmsr)
- [ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)](#armopcodesmemorysingledatatransferldrstrpld)
- [ARM Opcodes: Memory: Halfword, Doubleword, and Signed Data Transfer](#armopcodesmemoryhalfworddoublewordandsigneddatatransfer)
- [ARM Opcodes: Memory: Block Data Transfer (LDM, STM)](#armopcodesmemoryblockdatatransferldmstm)
- [ARM Opcodes: Memory: Single Data Swap (SWP)](#armopcodesmemorysingledataswapswp)
- [ARM Opcodes: Coprocessor Instructions (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)](#armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc)


## ARM 16bit Instruction Set (THUMB Code)


When operating in THUMB state, cut-down 16bit opcodes are used.

THUMB is supported on T-variants of ARMv4 and up, ie. ARMv4T, ARMv5T, etc.

- [THUMB Instruction Summary](#thumbinstructionsummary)
- [THUMB Opcodes: Register Operations (ALU, BX)](#thumbopcodesregisteroperationsalubx)
- [THUMB Opcodes: Memory Load/Store (LDR/STR)](#thumbopcodesmemoryloadstoreldrstr)
- [THUMB Opcodes: Memory Addressing (ADD PC/SP)](#thumbopcodesmemoryaddressingaddpcsp)
- [THUMB Opcodes: Memory Multiple Load/Store (PUSH/POP and LDM/STM)](#thumbopcodesmemorymultipleloadstorepushpopandldmstm)
- [THUMB Opcodes: Jumps and Calls](#thumbopcodesjumpsandcalls)
- [THUMB Opcodes: New THUMB Opcodes in ARM11](#thumbopcodesnewthumbopcodesinarm11)


## Note


Switching between ARM and THUMB state can be done by using the Branch and
Exchange (BX) instruction.



## Further Information


- [ARM Pseudo Instructions and Directives](#armpseudoinstructionsanddirectives)
- [ARM CP15 System Control Coprocessor](#armcp15systemcontrolcoprocessor)
- [ARM Vector Floating-point Unit (VFP)](#armvectorfloatingpointunitvfp)
- [ARM CPU Instruction Cycle Times](#armcpuinstructioncycletimes)
- [ARM CPU Versions](#armcpuversions)
- [ARM CPU Data Sheet](#armcpudatasheet)



# <a name="armcpuoverview"></a>ARM CPU Overview



The ARM7TDMI is a 32bit RISC (Reduced Instruction Set Computer) CPU, designed
by ARM (Advanced RISC Machines), and designed for both high performance and low
power consumption.



## Fast Execution


Depending on the CPU state, all opcodes are sized 32bit or 16bit (that's
counting both the opcode bits and its parameters bits) providing fast decoding
and execution. Additionally, pipelining allows - (a) one instruction to be
executed while (b) the next instruction is decoded and (c) the next instruction
is fetched from memory - all at the same time.



## Data Formats


The CPU manages to deal with 8bit, 16bit, and 32bit data, that are called:

```
   8bit - Byte
  16bit - Halfword
  32bit - Word
```



## The two CPU states


As mentioned above, two CPU states exist:

- ARM state: Uses the full 32bit instruction set (32bit opcodes)

- THUMB state: Uses a cutdown 16bit instruction set (16bit opcodes)

Regardless of the opcode-width, both states are using 32bit registers, allowing
32bit memory addressing as well as 32bit arithmetic/logical operations.



## When to use ARM state


Basically, there are two advantages in ARM state:

- - Each single opcode provides more functionality, resulting
    - in faster execution when using a 32bit bus memory system
    - (such like opcodes stored in GBA Work RAM).
- - All registers R0-R15 can be accessed directly.

The downsides are:

- - Not so fast when using 16bit memory system
    - (but it still works though).
- - Program code occupies more memory space.



## When to use THUMB state


There are two major advantages in THUMB state:

- - Faster execution up to approx 160% when using a 16bit bus
    - memory system (such like opcodes stored in GBA GamePak ROM).
- - Reduces code size, decreases memory overload down to approx 65%.

The disadvantages are:

- - Not as multi-functional opcodes as in ARM state, so it will
    - be sometimes required use more than one opcode to gain a
    - similar result as for a single opcode in ARM state.
- - Most opcodes allow only registers R0-R7 to be used directly.



## Combining ARM and THUMB state


Switching between ARM and THUMB state is done by a normal branch (BX)
instruction which takes only a handful of cycles to execute (allowing to change
states as often as desired - with almost no overload).


Also, as both ARM and THUMB are using the same register set, it is possible to
pass data between ARM and THUMB mode very easily.


The best memory & execution performance can be gained by combining both
states: THUMB for normal program code, and ARM code for timing critical
subroutines (such like interrupt handlers, or complicated algorithms).


Note: ARM and THUMB code cannot be executed simultaneously.



## Automatic state changes


Beside for the above manual state switching by using BX instructions, the
following situations involve automatic state changes:

- CPU switches to ARM state when executing an exception

- User switches back to old state when leaving an exception




# <a name="armcpuregisterset"></a>ARM CPU Register Set




## Overview


The following table shows the ARM7TDMI register set which is available in each
mode. There's a total of 37 registers (32bit each), 31 general registers (Rxx)
and 6 status registers (xPSR).

Note that only some registers are 'banked', for example, each mode has it's own
R14 register: called R14, R14\_fiq, R14\_svc, etc. for each mode respectively.

However, other registers are not banked, for example, each mode is using the
same R0 register, so writing to R0 will always affect the content of R0 in
other modes also.


```
  System/User FIQ       Supervisor Abort     IRQ       Undefined
  --------------------------------------------------------------
  R0          R0        R0         R0        R0        R0
  R1          R1        R1         R1        R1        R1
  R2          R2        R2         R2        R2        R2
  R3          R3        R3         R3        R3        R3
  R4          R4        R4         R4        R4        R4
  R5          R5        R5         R5        R5        R5
  R6          R6        R6         R6        R6        R6
  R7          R7        R7         R7        R7        R7
  --------------------------------------------------------------
  R8          R8_fiq    R8         R8        R8        R8
  R9          R9_fiq    R9         R9        R9        R9
  R10         R10_fiq   R10        R10       R10       R10
  R11         R11_fiq   R11        R11       R11       R11
  R12         R12_fiq   R12        R12       R12       R12
  R13 (SP)    R13_fiq   R13_svc    R13_abt   R13_irq   R13_und
  R14 (LR)    R14_fiq   R14_svc    R14_abt   R14_irq   R14_und
  R15 (PC)    R15       R15        R15       R15       R15
  --------------------------------------------------------------
  CPSR        CPSR      CPSR       CPSR      CPSR      CPSR
  --          SPSR_fiq  SPSR_svc   SPSR_abt  SPSR_irq  SPSR_und
  --------------------------------------------------------------
```



## R0-R12 Registers (General Purpose Registers)


These thirteen registers may be used for whatever general purposes. Basically,
each is having same functionality and performance, ie. there is no 'fast
accumulator' for arithmetic operations, and no 'special pointer register' for
memory addressing.

However, in THUMB mode only R0-R7 (Lo registers) may be accessed freely, while
R8-R12 and up (Hi registers) can be accessed only by some instructions.



## R13 Register (SP)


This register is used as Stack Pointer (SP) in THUMB state. While in ARM state
the user may decided to use R13 and/or other register(s) as stack pointer(s),
or as general purpose register.

As shown in the table above, there's a separate R13 register in each mode, and
(when used as SP) each exception handler may (and MUST!) use its own stack.



## R14 Register (LR)


This register is used as Link Register (LR). That is, when calling to a
sub-routine by a Branch with Link (BL) instruction, then the return address
(ie. old value of PC) is saved in this register.

Storing the return address in the LR register is obviously faster than pushing
it into memory, however, as there's only one LR register for each mode, the
user must manually push its content before issuing 'nested' subroutines.

Same happens when an exception is called, PC is saved in LR of new mode.

Note: In ARM mode, R14 may be used as general purpose register also, provided
that above usage as LR register isn't required.



## R15 Register (PC)


R15 is always used as program counter (PC). Note that when reading R15, this
will usually return a value of PC+nn because of read-ahead (pipelining),
whereas 'nn' depends on the instruction and on the CPU state (ARM or THUMB).



## CPSR and SPSR (Program Status Registers) (ARMv3 and up)


The current condition codes (flags) and CPU control bits are stored in the CPSR
register. When an exception arises, the old CPSR is saved in the SPSR of the
respective exception-mode (much like PC is saved in LR).

For details refer to chapter about CPU Flags.




# <a name="armcpuflagsconditionfieldcond"></a>ARM CPU Flags & Condition Field (cond)




## ARM Condition Field {cond}


The opcode {cond} suffixes can be used for conditionally executed code based on
the C,N,Z,V flags in CPSR register. For example: BEQ = Branch if Equal, MOVMI =
Move if Signed.

In ARM mode, {cond} can be used with all opcodes (except for a few newer ARMv5
instructions: BKPT, PLD, CDP2, LDC2, MCR2, MRC2, STC2, and BLX\_imm are
nonconditional; however BLX\_reg can be conditional).

In THUMB mode, {cond} can be used only for branch opcodes.

```
  Code Suffix Flags         Meaning
  0:   EQ     Z=1           equal (zero) (same)
  1:   NE     Z=0           not equal (nonzero) (not same)
  2:   CS/HS  C=1           unsigned higher or same (carry set)
  3:   CC/LO  C=0           unsigned lower (carry cleared)
  4:   MI     N=1           signed negative (minus)
  5:   PL     N=0           signed positive or zero (plus)
  6:   VS     V=1           signed overflow (V set)
  7:   VC     V=0           signed no overflow (V cleared)
  8:   HI     C=1 and Z=0   unsigned higher
  9:   LS     C=0 or Z=1    unsigned lower or same
  A:   GE     N=V           signed greater or equal
  B:   LT     N<>V          signed less than
  C:   GT     Z=0 and N=V   signed greater than
  D:   LE     Z=1 or N<>V   signed less or equal
  E:   AL     -             always (the "AL" suffix can be omitted)
  F:   NV     -             never (ARMv1,v2 only) (Reserved ARMv3 and up)
```

Execution Time: If condition=false: 1S cycle. Otherwise: as specified for the
respective opcode.



## Current Program Status Register (CPSR)


```
  Bit   Expl.
  31    N - Sign Flag       (0=Not Signed, 1=Signed)               ;\
  30    Z - Zero Flag       (0=Not Zero, 1=Zero)                   ; Condition
  29    C - Carry Flag      (0=Borrow/No Carry, 1=Carry/No Borrow) ; Code Flags
  28    V - Overflow Flag   (0=No Overflow, 1=Overflow)            ;/
  27    Q - Sticky Overflow (1=Sticky Overflow, ARMv5TE and up only)
  26-8  Reserved            (For future use) - Do not change manually!
  7     I - IRQ disable     (0=Enable, 1=Disable)                     ;\
  6     F - FIQ disable     (0=Enable, 1=Disable)                     ; Control
  5     T - State Bit       (0=ARM, 1=THUMB) - Do not change manually!; Bits
  4-0   M4-M0 - Mode Bits   (See below)                               ;/
```



## Bit 31-28: Condition Code Flags (N,Z,C,V)


These bits reflect results of logical or arithmetic instructions. In ARM mode,
it is often optionally whether an instruction should modify flags or not, for
example, it is possible to execute a SUB instruction that does NOT modify the
condition flags.

In ARM state, all instructions can be executed conditionally depending on the
settings of the flags, such like MOVEQ (Move if Z=1). While In THUMB state,
only Branch instructions (jumps) can be made conditionally.



## Bit 27: Sticky Overflow Flag (Q) - ARMv5TE and ARMv5TExP and up only


Used by QADD, QSUB, QDADD, QDSUB, SMLAxy, and SMLAWy only. These opcodes set
the Q-flag in case of overflows, but leave it unchanged otherwise. The Q-flag
can be tested/reset by MSR/MRS opcodes only.



## Bit 27-8: Reserved Bits (except Bit 27 on ARMv5TE and up, see above)


These bits are reserved for possible future implementations. For best forwards
compatibility, the user should never change the state of these bits, and should
not expect these bits to be set to a specific value.



## Bit 7-0: Control Bits (I,F,T,M4-M0)


These bits may change when an exception occurs. In privileged modes (non-user
modes) they may be also changed manually.

The interrupt bits I and F are used to disable IRQ and FIQ interrupts
respectively (a setting of "1" means disabled).

The T Bit signalizes the current state of the CPU (0=ARM, 1=THUMB), this bit
should never be changed manually - instead, changing between ARM and THUMB
state must be done by BX instructions.

The Mode Bits M4-M0 contain the current operating mode.

```
  Binary Hex Dec  Expl.
  0xx00b 00h 0  - Old User       ;\26bit Backward Compatibility modes
  0xx01b 01h 1  - Old FIQ        ; (supported only on ARMv3, except ARMv3G,
  0xx10b 02h 2  - Old IRQ        ; and on some non-T variants of ARMv4)
  0xx11b 03h 3  - Old Supervisor ;/
  10000b 10h 16 - User (non-privileged)
  10001b 11h 17 - FIQ
  10010b 12h 18 - IRQ
  10011b 13h 19 - Supervisor (SWI)
  10111b 17h 23 - Abort
  11011b 1Bh 27 - Undefined
  11111b 1Fh 31 - System (privileged 'User' mode) (ARMv4 and up)
```

Writing any other values into the Mode bits is not allowed.



## Saved Program Status Registers (SPSR\_\<mode>)


Additionally to above CPSR, five Saved Program Status Registers exist:

SPSR\_fiq, SPSR\_svc, SPSR\_abt, SPSR\_irq, SPSR\_und

Whenever the CPU enters an exception, the current status register (CPSR) is
copied to the respective SPSR\_\<mode> register. Note that there is only
one SPSR for each mode, so nested exceptions inside of the same mode are
allowed only if the exception handler saves the content of SPSR in memory.

For example, for an IRQ exception: IRQ-mode is entered, and CPSR is copied to
SPSR\_irq. If the interrupt handler wants to enable nested IRQs, then it must
first push SPSR\_irq before doing so.




# <a name="armcpu26bitmemoryinterface"></a>ARM CPU 26bit Memory Interface



The 26bit Memory Interface was used by ARMv1 and ARMv2. The 32bit interface is
used by ARMv3 and newer, however, 26bit backward compatibility was included in
all ARMv3 (except ARMv3G), and optionally in some non-T variants of ARMv4.



## Format of R15 in 26bit Mode (Program Counter Register)


```
  Bit   Name     Expl.
  31-28 N,Z,C,V  Flags (Sign, Zero, Carry, Overflow)
  27-26 I,F      Interrupt Disable bits (IRQ, FIQ) (1=Disable)
  25-2  PC       Program Counter, 24bit, Step 4 (64M range)
  1-0   M1,M0    Mode (0=User, 1=FIQ, 2=IRQ, 3=Supervisor)
```

Branches with +/-32M range wrap the PC register, and can reach all 64M memory.



## Reading from R15


If R15 is specified in bit16-19 of an opcode, then NZCVIF and M0,1 are masked
(zero), otherwise the full 32bits are used.



## Writing to R15


ALU opcodes with S=1, and LDM opcodes with PSR=1 can write to all 32bits in R15
(in 26bit mode, that is allowed even in user mode, though it does then affect
only NZCF, not the write protected IFMM bits ???), other opcodes which write to
R15 will modify only the program counter bits. Also, special CMP/CMN/TST/TEQ{P}
opcodes can be used to write to the PSR bits in R15 without modifying the PC
bits.



## Exceptions


SWIs, Reset, Data/Prefetch Aborts and Undefined instructions enter Supervisor
mode. Interrupts enter IRQ and FIQ mode. Additionally, a special 26bit Address
Exception exists, which enters Supervisor mode on accesses to memory
addresses>=64M as follows:

```
  R14_svc = PC ($+8, including old PSR bits)
  M1,M0 = 11b = supervisor mode, F=same, I=1, PC=14h,
  to continue at the fault location, return by SUBS PC,LR,8.
```

32bit CPUs with 26bit compatibility mode can be configured to switch into 32bit
mode when encountering exceptions.




# <a name="armcpuexceptions"></a>ARM CPU Exceptions




## Exception Vectors


The following are the exception vectors in memory. That is, when an exception
arises, CPU is switched into ARM state, and the program counter (PC) is loaded
by the respective address.

```
  Address  Prio  Exception                  Mode on Entry      Interrupt Flags
  BASE+00h 1     Reset                      Supervisor (_svc)  I=1, F=1
  BASE+04h 7     Undefined Instruction      Undefined  (_und)  I=1, F=unchanged
  BASE+08h 6     Software Interrupt (SWI)   Supervisor (_svc)  I=1, F=unchanged
  BASE+0Ch 5     Prefetch Abort             Abort      (_abt)  I=1, F=unchanged
  BASE+10h 2     Data Abort                 Abort      (_abt)  I=1, F=unchanged
  BASE+14h ??    Address Exceeds 26bit      Supervisor (_svc)  I=1, F=unchanged
  BASE+18h 4     Normal Interrupt (IRQ)     IRQ        (_irq)  I=1, F=unchanged
  BASE+1Ch 3     Fast Interrupt (FIQ)       FIQ        (_fiq)  I=1, F=1
```

BASE is normally 00000000h, but may be optionally FFFF0000h in some ARM CPUs.
Priority for simultaneously occuring exceptions ranges from Prio=1=Highest to
Prio=7=Lowest.

As there's only space for one ARM opcode at each of the above addresses, it'd
be usually recommended to deposit a Branch opcode into each vector, which'd
then redirect to the actual exception handlers address.



## Actions performed by CPU when entering an exception


```
  - R14_<new mode>=PC+nn   ;save old PC, ie. return address
  - SPSR_<new mode>=CPSR   ;save old flags
  - CPSR new T,M bits      ;set to T=0 (ARM state), and M4-0=new mode
  - CPSR new I bit         ;IRQs disabled (I=1), done by ALL exceptions
  - CPSR new F bit         ;FIQs disabled (F=1), done by Reset and FIQ only
  - PC=exception_vector    ;see table above
```

Above "PC+nn" depends on the type of exception. Basically, in ARM state that
nn-offset is caused by pipelining, and in THUMB state an identical ARM-style
'offset' is generated (even though the 'base address' may be only
halfword-aligned).



## Required user-handler actions when returning from an exception


Restore any general registers (R0-R14) which might have been modified by the
exception handler. Use return-instruction as listed in the respective
descriptions below, this will both restore PC and CPSR - that automatically
involves that the old CPU state (THUMB or ARM) as well as old state of FIQ and
IRQ disable flags are restored.

As mentioned above (see action on entering...), the return address is always
saved in ARM-style format, so that exception handler may use the same
return-instruction, regardless of whether the exception has been generated from
inside of ARM or THUMB state.



## FIQ (Fast Interrupt Request)


This interrupt is generated by a LOW level on the nFIQ input. It is supposed to
process timing critical interrupts at a high priority, as fast as possible.

Additionally to the common banked registers (R13\_fiq,R14\_fiq), five extra
banked registers (R8\_fiq-R12\_fiq) are available in FIQ mode. The exception
handler may freely access these registers without modifying the main programs
R8-R12 registers (and without having to save that registers on stack).

In privileged (non-user) modes, FIQs may be also manually disabled by setting
the F Bit in CPSR.



## IRQ (Normal Interrupt Request)


This interrupt is generated by a LOW level on the nIRQ input. Unlike FIQ, the
IRQ mode is not having its own banked R8-R12 registers.

IRQ is having lower priority than FIQ, and IRQs are automatically disabled when
a FIQ exception becomes executed. In privileged (non-user) modes, IRQs may be
also manually disabled by setting the I Bit in CPSR.

To return from IRQ Mode (continuing at following opcode):

```
  SUBS PC,R14,4   ;both PC=R14_irq-4, and CPSR=SPSR_irq
```



## Software Interrupt


Generated by a software interrupt instruction (SWI). Recommended to request a
supervisor (operating system) function. The SWI instruction may also contain a
parameter in the 'comment field' of the opcode:

In case that your main program issues SWIs from both inside of THUMB and ARM
states, then your exception handler must separate between 24bit comment fields
in ARM opcodes, and 8bit comment fields in THUMB opcodes (if necessary
determine old state by examining T Bit in SPSR\_svc); However, in Little Endian
mode, you could use only the most significant 8bits of the 24bit ARM comment
field (as done in the GBA, for example) - the exception handler could then
process the BYTE at [R14-2], regardless of whether it's been called from ARM or
THUMB state.

To return from Supervisor Mode (continuing at following opcode):

```
  MOVS PC,R14   ;both PC=R14_svc, and CPSR=SPSR_svc
```

Note: Like all other exceptions, SWIs are always executed in ARM state, no
matter whether it's been caused by an ARM or THUMB state SWI instruction.



## Undefined Instruction Exception (supported by ARMv3 and up)


This exception is generated when the CPU comes across an instruction which it
cannot handle. Most likely signalizing that the program has locked up, and that
an errormessage should be displayed.

However, it might be also used to emulate custom functions, ie. as an
additional 'SWI' instruction (which'd use R14\_und and SPSR\_und though, and it'd
thus allow to execute the Undefined Instruction handler from inside of
Supervisor mode without having to save R14\_svc and SPSR\_svc).

To return from Undefined Mode (continuing at following opcode):

```
  MOVS PC,R14   ;both PC=R14_und, and CPSR=SPSR_und
```

Note that not all unused opcodes are necessarily producing an exception, for
example, an ARM state Multiply instruction with Bit6=1 would be blindly
accepted as 'legal' opcode.



## Abort (supported by ARMv3 and up)


Aborts (page faults) are mostly supposed for virtual memory systems (ie. not
used in GBA, as far as I know), otherwise they might be used just to display an
error message. Two types of aborts exists:

- Prefetch Abort (occurs during an instruction prefetch)

- Prefetch Abort (also occurs on BKPT opcodes, ARMv5 and up)

- Data Abort (occurs during a data access)

A virtual memory systems abort handler would then most likely determine the
fault address: For prefetch abort that's just "R14\_abt-4". For Data abort, the
THUMB or ARM instruction at "R14\_abt-8" needs to be 'disassembled' in order to
determine the addressed data in memory.

The handler would then fix the error by loading the respective memory page into
physical memory, and then retry to execute the SAME instruction again, by
returning as follows:

```
  prefetch abort: SUBS PC,R14,#4   ;PC=R14_abt-4, and CPSR=SPSR_abt
  data abort:     SUBS PC,R14,#8   ;PC=R14_abt-8, and CPSR=SPSR_abt
```

Separate exception vectors for prefetch/data abort exists, each should use the
respective return instruction as shown above.



## Address Exceeds 26bit


This exception can occur only on old ARM CPUs with 26bit address scheme (or in
26bit backwards compatibility mode).



## Reset


Forces PC=VVVV0000h, and forces control bits of CPSR to T=0 (ARM state), F=1
and I=1 (disable FIQ and IRQ), and M4-0=10011b (Supervisor mode).




# <a name="armcpumemoryalignments"></a>ARM CPU Memory Alignments



The CPU does NOT support accessing mis-aligned addresses (which would be rather
slow because it'd have to merge/split that data into two accesses).

When reading/writing code/data to/from memory, Words and Halfwords must be
located at well-aligned memory address, ie. 32bit words aligned by 4, and 16bit
halfwords aligned by 2.



## Mis-aligned STR,STRH,STM,LDM,LDRD,STRD,PUSH,POP (forced align)


The mis-aligned low bit(s) are ignored, the memory access goes to a forcibly
aligned (rounded-down) memory address.

For LDRD/STRD, it isn't clearly defined if the address must be aligned by 8 (on
the NDS, align-4 seems to be okay) (align-8 may be required on other CPUs with
64bit databus).



## Mis-aligned LDR,SWP (rotated read)


Reads from forcibly aligned address "addr AND (NOT 3)", and does then rotate
the data as "ROR (addr AND 3)\*8". That effect is internally used by LDRB and
LDRH opcodes (which do then mask-out the unused bits).

The SWP opcode works like a combination of LDR and STR, that means, it does
read-rotated, but does write-unrotated.



## Mis-aligned LDRH,LDRSH (does or does not do strange things)


On ARM9 aka ARMv5 aka NDS9:

```
  LDRH Rd,[odd]   -->  LDRH Rd,[odd-1]        ;forced align
  LDRSH Rd,[odd]  -->  LDRSH Rd,[odd-1]       ;forced align
```

On ARM7 aka ARMv4 aka NDS7/GBA:

```
  LDRH Rd,[odd]   -->  LDRH Rd,[odd-1] ROR 8  ;read to bit0-7 and bit24-31
  LDRSH Rd,[odd]  -->  LDRSB Rd,[odd]         ;sign-expand BYTE value
```



## Mis-aligned PC/R15 (branch opcodes, or MOV/ALU/LDR with Rd=R15)


For ARM code, the low bits of the target address should be usually zero,
otherwise, R15 is forcibly aligned by clearing the lower two bits.

For THUMB code, the low bit of the target address may/should/must be set, the
bit is (or is not) interpreted as thumb-bit (depending on the opcode), and R15
is then forcibly aligned by clearing the lower bit.

In short, R15 will be always forcibly aligned, so mis-aligned branches won't
have effect on subsequent opcodes that use R15, or [R15+disp] as operand.




# <a name="arminstructionsummary"></a>ARM Instruction Summary



Modification of CPSR flags is optional for all {S} instructions.



## Logical ALU Operations


```
  Instruction                      Cycles   Flags  Expl.
  MOV{cond}{S} Rd,Op2              1S+x+y    NZc-  Rd = Op2
  MVN{cond}{S} Rd,Op2              1S+x+y    NZc-  Rd = NOT Op2
  ORR{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn OR Op2
  EOR{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn XOR Op2
  AND{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn AND Op2
  BIC{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn AND NOT Op2
  TST{cond}{P}    Rn,Op2           1S+x      NZc-  Void = Rn AND Op2
  TEQ{cond}{P}    Rn,Op2           1S+x      NZc-  Void = Rn XOR Op2
```

Add x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if Rd=R15.

Carry flag affected only if Op2 contains a non-zero shift amount.



## Arithmetic ALU Operations


```
  Instruction                      Cycles   Flags  Expl.
  ADD{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn+Op2
  ADC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn+Op2+Cy
  SUB{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn-Op2
  SBC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn-Op2+Cy-1
  RSB{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Op2-Rn
  RSC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Op2-Rn+Cy-1
  CMP{cond}{P}    Rn,Op2           1S+x      NZCV  Void = Rn-Op2
  CMN{cond}{P}    Rn,Op2           1S+x      NZCV  Void = Rn+Op2
```

Add x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if Rd=R15.



## Multiply


```
  Instruction                      Cycles   Flags  Expl.
  MUL{cond}{S} Rd,Rm,Rs            1S+mI     NZx-  Rd = Rm*Rs
  MLA{cond}{S} Rd,Rm,Rs,Rn         1S+mI+1I  NZx-  Rd = Rm*Rs+Rn
  UMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx-  RdHiLo = Rm*Rs
  UMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx-  RdHiLo = Rm*Rs+RdHiLo
  SMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx-  RdHiLo = Rm*Rs
  SMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx-  RdHiLo = Rm*Rs+RdHiLo
  SMLAxy{cond}  Rd,Rm,Rs,Rn     ARMv5TE(xP)  ----q Rd=HalfRm*HalfRs+Rn
  SMLAWy{cond}  Rd,Rm,Rs,Rn     ARMv5TE(xP)  ----q Rd=(Rm*HalfRs)/10000h+Rn
  SMULWy{cond}  Rd,Rm,Rs        ARMv5TE(xP)  ----  Rd=(Rm*HalfRs)/10000h
  SMLALxy{cond} RdLo,RdHi,Rm,Rs ARMv5TE(xP)  ----  RdHiLo=RdHiLo+HalfRm*HalfRs
  SMULxy{cond}  Rd,Rm,Rs        ARMv5TE(xP)  ----  Rd=HalfRm*HalfRs
```



## Memory Load/Store


```
  Instruction                      Cycles    Flags  Expl.
  LDR{cond}{B}{T} Rd,<Address>     1S+1N+1I+y ----  Rd=[Rn+/-<offset>]
  LDR{cond}H      Rd,<Address>     1S+1N+1I+y ----  Load Unsigned halfword
  LDR{cond}D      Rd,<Address>                ----  Load Dword ARMv5TE
  LDR{cond}SB     Rd,<Address>     1S+1N+1I+y ----  Load Signed byte
  LDR{cond}SH     Rd,<Address>     1S+1N+1I+y ----  Load Signed halfword
  LDM{cond}{amod} Rn{!},<Rlist>{^} nS+1N+1I+y ----  Load Multiple
  STR{cond}{B}{T} Rd,<Address>     2N         ----  [Rn+/-<offset>]=Rd
  STR{cond}H      Rd,<Address>     2N         ----  Store halfword
  STR{cond}D      Rd,<Address>                ----  Store Dword ARMv5TE
  STM{cond}{amod} Rn{!},<Rlist>{^} (n-1)S+2N  ----  Store Multiple
  SWP{cond}{B}    Rd,Rm,[Rn]       1S+2N+1I   ----  Rd=[Rn], [Rn]=Rm
  PLD             <Address>        1S         ----  Prepare Cache ARMv5TE
```

For LDR/LDM, add y=1S+1N if Rd=R15, or if R15 in Rlist.



## Jumps, Calls, CPSR Mode, and others


```
  Instruction                  Cycles  Flags  Expl.
  B{cond}   label              2S+1N    ----  PC=$+8+/-32M
  BL{cond}  label              2S+1N    ----  PC=$+8+/-32M, LR=$+4
  BX{cond}  Rn                 2S+1N    ----  PC=Rn, T=Rn.0 (THUMB/ARM)
  BLX{cond} Rn                 2S+1N    ----  PC=Rn, T=Rn.0, LR=PC+4, ARM9
  BLX       label              2S+1N    ----  PC=PC+$+/-32M, LR=$+4, T=1, ARM9
  MRS{cond} Rd,Psr             1S       ----  Rd=Psr
  MSR{cond} Psr{_field},Op     1S      (psr)  Psr[field]=Op
  SWI{cond} Imm24bit           2S+1N    ----  PC=8, ARM Svc mode, LR=$+4
  BKPT      Imm16bit           ???      ----  PC=C, ARM Abt mode, LR=$+4 ARM9
  The Undefined Instruction    2S+1I+1N ----  PC=4, ARM Und mode, LR=$+4
  cond=false                   1S       ----  Any opcode with condition=false
  NOP                          1S       ----  R0=R0
```


```
  CLZ{cond} Rd,Rm              ???      ----    Count Leading Zeros ARMv5
  QADD{cond} Rd,Rm,Rn                   ----q   Rd=Rm+Rn       ARMv5TE(xP)
  QSUB{cond} Rd,Rm,Rn                   ----q   Rd=Rm-Rn       ARMv5TE(xP)
  QDADD{cond} Rd,Rm,Rn                  ----q   Rd=Rm+Rn*2     ARMv5TE(xP)
  QDSUB{cond} Rd,Rm,Rn                  ----q   Rd=Rm-Rn*2     ARMv5TE(xP)
```



## Coprocessor Functions (if any)


```
  Instruction                         Cycles  Flags  Expl.
  CDP{cond} Pn,<cpopc>,Cd,Cn,Cm{,<cp>} 1S+bI   ----  Coprocessor specific
  STC{cond}{L} Pn,Cd,<Address>         (n-1)S+2N+bI  [address] = CRd
  LDC{cond}{L} Pn,Cd,<Address>         (n-1)S+2N+bI  CRd = [address]
  MCR{cond} Pn,<cpopc>,Rd,Cn,Cm{,<cp>} 1S+bI+1C      CRn = Rn {<op> CRm}
  MRC{cond} Pn,<cpopc>,Rd,Cn,Cm{,<cp>} 1S+(b+1)I+1C  Rn = CRn {<op> CRm}
  CDP2,STC2,LDC2,MCR2,MRC2 - ARMv5 Extensions similar above, without {cond}
  MCRR{cond} Pn,<cpopc>,Rd,Rn,Cm  ;write Rd,Rn to coproc ARMv5TE
  MRRC{cond} Pn,<cpopc>,Rd,Rn,Cm  ;read Rd,Rn from coproc ARMv5TE
```



## ARM Binary Opcode Format


```
  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0|
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| DataProc
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Rs___|0|Typ|1|__Rm___| DataProc
  |_Cond__|0_0_1|___Op__|S|__Rn___|__Rd___|_Shift_|___Immediate___| DataProc
  |_Cond__|0_0_1_1_0_0_1_0_0_0_0_0_1_1_1_1_0_0_0_0|_____Hint______| ARM11:Hint
  |_Cond__|0_0_1_1_0|P|1|0|_Field_|__Rd___|_Shift_|___Immediate___| PSR Imm
  |_Cond__|0_0_0_1_0|P|L|0|_Field_|__Rd___|0_0_0_0|0_0_0_0|__Rm___| PSR Reg
  |_Cond__|0_0_0_1_0_0_1_0_1_1_1_1_1_1_1_1_1_1_1_1|0_0|L|1|__Rn___| BX,BLX
  |1_1_1_0|0_0_0_1_0_0_1_0|_____immediate_________|0_1_1_1|_immed_| ARM9:BKPT
  |_Cond__|0_0_0_1_0_1_1_0_1_1_1_1|__Rd___|1_1_1_1|0_0_0_1|__Rm___| ARM9:CLZ
  |_Cond__|0_0_0_1_0|Op_|0|__Rn___|__Rd___|0_0_0_0|0_1_0_1|__Rm___| ARM9:QALU
  |_Cond__|0_0_0_0_0_0|A|S|__Rd___|__Rn___|__Rs___|1_0_0_1|__Rm___| Multiply
  |_Cond__|0_0_0_0_0_1_0_0|_RdHi__|_RdLo__|__Rs___|1_0_0_1|__Rm___| ARM11:UMAAL
  |_Cond__|0_0_0_0_1|U|A|S|_RdHi__|_RdLo__|__Rs___|1_0_0_1|__Rm___| MulLong
  |_Cond__|0_0_0_1_0|Op_|0|Rd/RdHi|Rn/RdLo|__Rs___|1|y|x|0|__Rm___| MulHalfARM9
  |_Cond__|0_0_0_1_0|B|0_0|__Rn___|__Rd___|0_0_0_0|1_0_0_1|__Rm___| TransSwp12
  |_Cond__|0_0_0_1_1|_Op__|__Rn___|__Rd___|1_1_1_1|1_0_0_1|__Rm___| ARM11:LDREX
  |_Cond__|0_0_0|P|U|0|W|L|__Rn___|__Rd___|0_0_0_0|1|S|H|1|__Rm___| TransReg10
  |_Cond__|0_0_0|P|U|1|W|L|__Rn___|__Rd___|OffsetH|1|S|H|1|OffsetL| TransImm10
  |_Cond__|0_1_0|P|U|B|W|L|__Rn___|__Rd___|_________Offset________| TransImm9
  |_Cond__|0_1_1|P|U|B|W|L|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| TransReg9
  |_Cond__|0_1_1|________________xxx____________________|1|__xxx__| Undefined
  |_Cond__|0_1_1|Op_|x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x_x|1|x_x_x_x| ARM11:Media
  |1_1_1_1_0_1_0_1_0_1_1_1_1_1_1_1_1_1_1_1_0_0_0_0_0_0_0_1_1_1_1_1| ARM11:CLREX
  |_Cond__|1_0_0|P|U|S|W|L|__Rn___|__________Register_List________| BlockTrans
  |_Cond__|1_0_1|L|___________________Offset______________________| B,BL,BLX
  |_Cond__|1_1_0|P|U|N|W|L|__Rn___|__CRd__|__CP#__|____Offset_____| CoDataTrans
  |_Cond__|1_1_0_0_0_1_0|L|__Rn___|__Rd___|__CP#__|_CPopc_|__CRm__| CoRR ARM9
  |_Cond__|1_1_1_0|_CPopc_|__CRn__|__CRd__|__CP#__|_CP__|0|__CRm__| CoDataOp
  |_Cond__|1_1_1_0|CPopc|L|__CRn__|__Rd___|__CP#__|_CP__|1|__CRm__| CoRegTrans
  |_Cond__|1_1_1_1|_____________Ignored_by_Processor______________| SWI
```



## ARM11 SIMD Media instructions (ARM11/ARMv6) (formerly Undef opcode space)


```
  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0|
  |_Cond__|0_1_1|0_0|_Op__|__Rn___|__Rd___|1_1_1_1|_Op__|1|__Rm___| ParaAddSub
  |_Cond__|0_1_1|0_1|0_0_0|__Rn___|__Rd___|_shift___|x|0_1|__Rm___| HalfPack
  |_Cond__|0_1_1|0_1|U|1|____sat__|__Rd___|_shift___|x|0_1|__Rm___| WordSat
  |_Cond__|0_1_1|0_1|U|1_0|__sat__|__Rd___|1_1_1_1|0_0_1_1|__Rm___| ParaHalfSat
  |_Cond__|0_1_1|0_1|0_1_1|1_1_1_1|__Rd___|1_1_1_1|0_0_1_1|__Rm___| RevWord
  |_Cond__|0_1_1|0_1|0_1_1|1_1_1_1|__Rd___|1_1_1_1|1_0_1_1|__Rm___| RevPackHalf
  |_Cond__|0_1_1|0_1|1_1_1|1_1_1_1|__Rd___|1_1_1_1|1_0_1_1|__Rm___| RevSignHalf
  |_Cond__|0_1_1|0_1|0_0_0|__Rn___|__Rd___|1_1_1_1|1_0_1_1|__Rm___| SelectBytes
  |_Cond__|0_1_1|0_1|_Op__|__Rn___|__Rd___|rot|0_0|0_1_1_1|__Rm___| Extend U/S
  |_Cond__|0_1_1|1_0|_Op__|Rd/RdHi|Rn/RdLo|__Rs___|_Op__|1|__Rm___| Multiplies
  |_Cond__|0_1_1|1_1|0_0_0|__Rd___|__Rn___|__Rs___|0_0_0_1|__Rm___| DiffSum
  |_Cond__|0_1_1|1_1|0_0_0|__Rd___|1_1_1_1|__Rs___|0_0_0_1|__Rm___| DiffSumAcc
  |_Cond__|0_1_1_1_1_1_1_1|x_x_x_x_x_x_x_x_x_x_x_x|1_1_1_1|x_x_x_x| Undef
```




# <a name="armopcodesbranchandbranchwithlinkbblbxblxswibkpt"></a>ARM Opcodes: Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)




## Branch and Branch with Link (B, BL, BLX\_imm)


Branch (B) is supposed to jump to a subroutine. Branch with Link is meant to be
used to call to a subroutine, return address is then saved in R14.

```
  Bit    Expl.
  31-28  Condition (must be 1111b for BLX)
  27-25  Must be "101" for this instruction
  24     Opcode (0-1) (or Halfword Offset for BLX)
          0: B{cond} label    ;branch            PC=PC+8+nn*4
          1: BL{cond} label   ;branch/link       PC=PC+8+nn*4, LR=PC+4
          H: BLX label ;ARM9  ;branch/link/thumb PC=PC+8+nn*4+H*2, LR=PC+4, T=1
  23-0   nn - Signed Offset, step 4      (-32M..+32M in steps of 4)
```

Branch with Link can be used to 'call' to a sub-routine, which may then
'return' by MOV PC,R14 for example.

Execution Time: 2S + 1N

Return: No flags affected.



## Branch and Exchange (BX, BLX\_reg)


```
  Bit    Expl.
  31-28  Condition
  27-8   Must be "0001.0010.1111.1111.1111" for this instruction
  7-4    Opcode
          0001b: BX{cond}  Rn    ;PC=Rn, T=Rn.0   (ARMv4T and ARMv5 and up)
          0010b: BXJ{cond} Rn    ;Change to Jazelle bytecode (ARMv5TEJ and up)
          0011b: BLX{cond} Rn    ;PC=Rn, T=Rn.0, LR=PC+4     (ARMv5 and up)
  3-0    Rn - Operand Register  (R0-R14)
```

Switching to THUMB Mode: Set Bit 0 of the value in Rn to 1, program continues
then at Rn-1 in THUMB mode.

Using BLX R14 is possible (sets PC=Old\_LR, and New\_LR=retadr).

Using BX R15 acts as BX $+8 (tested and working on ARM7/ARM9, although it isn't
officially defined as predictable behaviour).

Execution Time: 2S + 1N

Return: No flags affected.



## Notes on BXJ (Branch or change to Jazelle bytecode state):


If Jazelle is suppored/enabled: Executes Java bytecode at address R14

If Jazelle is NOT suppored/enabled: Behaves exactly same as BX Rn

That is, R14 is the byte code address, and Rn is an ARM/THUMB error handler.

Supported on ARMv5TEJ and ARMv6 and up.



## Branch via ALU, LDR, LDM


Most ALU, LDR, LDM opcodes can also change PC/R15.



## Software Interrupt (SWI/BKPT) (svc/abt exceptions)


SWI supposed for calls to the operating system - Enter Supervisor mode (SVC) in
ARM state. BKPT intended for debugging - enters Abort mode in ARM state via
Prefetch Abort vector.

```
  Bit    Expl.
  31-28  Condition (must be 1110b for BKPT, ie. Condition=always)
  27-24  Opcode
          1111b: SWI{cond} nn   ;software interrupt
          0001b: BKPT      nn   ;breakpoint (ARMv5 and up)
  For SWI:
   23-0   nn - Comment Field, ignored by processor (24bit value)
  For BKPT:
   23-20  Must be 0010b for BKPT
   19-8   nn - upper 12bits of comment field, ignored by processor
   7-4    Must be 0111b for BKPT
   3-0    nn - lower 4bits of comment field, ignored by processor
```

Execution Time: 2S+1N

The exception handler may interprete the SWI Comment Field by examining the
lower 24bit of the 32bit opcode opcode at [R14\_svc-4]. If your are also using
SWI's from inside of THUMB, then the SWI handler must examine the T Bit
SPSR\_svc in order to determine whether it's been a THUMB SWI - and if so,
examine the lower 8bit of the 16bit opcode opcode at [R14\_svc-2].

For Returning from SWI use "MOVS PC,R14", that instruction does restore both PC
and CPSR, ie. PC=R14\_svc, and CPSR=SPSR\_svc.

Nesting SWIs: SPSR\_svc and R14\_svc should be saved on stack before either
invoking nested SWIs, or (if the IRQ handler uses SWIs) before enabling IRQs.

Execution SWI/BKPT:

```
  R14_svc=PC+4     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=<changed>   CPSR=<changed> ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
```



## Undefined Instruction (und exception)


```
  Bit    Expl.
  31-28  Condition
  27-25  Must be 011b for this instruction
  24-5   Reserved for future use
  4      Must be 1b for this instruction
  3-0    Reserved for future use
```

No assembler mnemonic exists, following bitstreams are (not) reserved.

```
  cond011xxxxxxxxxxxxxxxxxxxx1xxxx - reserved for future use (except below).
  cond01111111xxxxxxxxxxxx1111xxxx - free for user.
```

Note: ARMv6 does use the "reserved for future" space for the new SIMD opcodes
(but still has the "free for user" space available as "undefined").

Execution time: 2S+1I+1N.




# <a name="armopcodesdataprocessingalu"></a>ARM Opcodes: Data Processing (ALU)




## Opcode Format


```
  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate 2nd Operand Flag (0=Register, 1=Immediate)
  24-21  Opcode (0-Fh)               ;*=Arithmetic, otherwise Logical
           0: AND{cond}{S} Rd,Rn,Op2    ;AND logical       Rd = Rn AND Op2
           1: EOR{cond}{S} Rd,Rn,Op2    ;XOR logical       Rd = Rn XOR Op2
           2: SUB{cond}{S} Rd,Rn,Op2 ;* ;subtract          Rd = Rn-Op2
           3: RSB{cond}{S} Rd,Rn,Op2 ;* ;subtract reversed Rd = Op2-Rn
           4: ADD{cond}{S} Rd,Rn,Op2 ;* ;add               Rd = Rn+Op2
           5: ADC{cond}{S} Rd,Rn,Op2 ;* ;add with carry    Rd = Rn+Op2+Cy
           6: SBC{cond}{S} Rd,Rn,Op2 ;* ;sub with carry    Rd = Rn-Op2+Cy-1
           7: RSC{cond}{S} Rd,Rn,Op2 ;* ;sub cy. reversed  Rd = Op2-Rn+Cy-1
           8: TST{cond}{P}    Rn,Op2    ;test            Void = Rn AND Op2
           9: TEQ{cond}{P}    Rn,Op2    ;test exclusive  Void = Rn XOR Op2
           A: CMP{cond}{P}    Rn,Op2 ;* ;compare         Void = Rn-Op2
           B: CMN{cond}{P}    Rn,Op2 ;* ;compare neg.    Void = Rn+Op2
           C: ORR{cond}{S} Rd,Rn,Op2    ;OR logical        Rd = Rn OR Op2
           D: MOV{cond}{S} Rd,Op2       ;move              Rd = Op2
           E: BIC{cond}{S} Rd,Rn,Op2    ;bit clear         Rd = Rn AND NOT Op2
           F: MVN{cond}{S} Rd,Op2       ;not               Rd = NOT Op2
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 1 for opcode 8-B)
  19-16  Rn - 1st Operand Register (R0..R15) (including PC=R15)
              Must be 0000b for MOV/MVN.
  15-12  Rd - Destination Register (R0..R15) (including PC=R15)
              Must be 0000b (or 1111b) for CMP/CMN/TST/TEQ{P}.
  When above Bit 25 I=0 (Register as 2nd Operand)
    When below Bit 4 R=0 - Shift by Immediate
      11-7   Is - Shift amount   (1-31, 0=Special/See below)
    When below Bit 4 R=1 - Shift by Register
      11-8   Rs - Shift register (R0-R14) - only lower 8bit 0-255 used
      7      Reserved, must be zero  (otherwise multiply or LDREX or undefined)
    6-5    Shift Type (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      R - Shift by Register Flag (0=Immediate, 1=Register)
    3-0    Rm - 2nd Operand Register (R0..R15) (including PC=R15)
  When above Bit 25 I=1 (Immediate as 2nd Operand)
    11-8   Is - ROR-Shift applied to nn (0-30, in steps of 2)
    7-0    nn - 2nd Operand Unsigned 8bit Immediate
```



## Second Operand (Op2)


This may be a shifted register, or a shifted immediate. See Bit 25 and 11-0.

Unshifted Register: Specify Op2 as "Rm", assembler converts to "Rm,LSL#0".

Shifted Register: Specify as "Rm,SSS#Is" or "Rm,SSS Rs" (SSS=LSL/LSR/ASR/ROR).

Immediate: Specify as 32bit value, for example: "#000NN000h", assembler should
automatically convert into "#0NNh,ROR#0ssh" as far as possible (ie. as far as a
section of not more than 8bits of the immediate is non-zero).



## Zero Shift Amount (Shift Register by Immediate, with Immediate=0)


```
  LSL#0: No shift performed, ie. directly Op2=Rm, the C flag is NOT affected.
  LSR#0: Interpreted as LSR#32, ie. Op2 becomes zero, C becomes Bit 31 of Rm.
  ASR#0: Interpreted as ASR#32, ie. Op2 and C are filled by Bit 31 of Rm.
  ROR#0: Interpreted as RRX#1 (RCR), like ROR#1, but Op2 Bit 31 set to old C.
```

In source code, LSR#32, ASR#32, and RRX#1 should be specified as such -
attempts to specify LSR#0, ASR#0, or ROR#0 will be internally converted to
LSL#0 by the assembler.



## Using R15 (PC)


When using R15 as Destination (Rd), note below CPSR description and Execution
time description.

When using R15 as operand (Rm or Rn), the returned value depends on the
instruction: PC+12 if I=0,R=1 (shift by register), otherwise PC+8 (shift by
immediate).



## Returned CPSR Flags


If S=1, Rd\<>R15, logical operations (AND,EOR,TST,TEQ,ORR,MOV,BIC,MVN):

```
  V=not affected
  C=carryflag of shift operation (not affected if LSL#0 or Rs=00h)
  Z=zeroflag of result
  N=signflag of result (result bit 31)
```

If S=1, Rd\<>R15, arithmetic operations (SUB,RSB,ADD,ADC,SBC,RSC,CMP,CMN):

```
  V=overflowflag of result
  C=carryflag of result
  Z=zeroflag of result
  N=signflag of result (result bit 31)
```

IF S=1, with unused Rd bits=1111b, {P} opcodes (CMPP/CMNP/TSTP/TEQP):

```
  R15=result  ;modify PSR bits in R15, ARMv2 and below only.
  In user mode only N,Z,C,V bits of R15 can be changed.
  In other modes additionally I,F,M1,M0 can be changed.
  The PC bits in R15 are left unchanged in all modes.
```

If S=1, Rd=R15; should not be used in user mode:

```
  CPSR = SPSR_<current mode>
  PC = result
  For example: MOVS PC,R14  ;return from SWI (PC=R14_svc, CPSR=SPSR_svc).
```

If S=0: Flags are not affected (not allowed for CMP,CMN,TEQ,TST).


The instruction "MOV R0,R0" is used as "NOP" opcode in 32bit ARM state.

Execution Time: (1+p)S+rI+pN. Whereas r=1 if I=0 and R=1 (ie. shift by
register); otherwise r=0. And p=1 if Rd=R15; otherwise p=0.




# <a name="armopcodesmultiplyandmultiplyaccumulatemulmla"></a>ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)




## Opcode Format


```
  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24-21  Opcode
          0000b: MUL{cond}{S}   Rd,Rm,Rs        ;Rd=Rm*Rs     ;\works as both
          0001b: MLA{cond}{S}   Rd,Rm,Rs,Rn     ;Rd=Rm*Rs+Rn  ;/signed+unsigned
          0010b: UMAAL{cond}    RdLo,RdHi,Rm Rs ;RdHiLo=Rm*Rs+RdHi+RdLo;\un-
          0100b: UMULL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs          ; signed
          0101b: UMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs+RdHiLo   ;/
          0110b: SMULL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs
          0111b: SMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs+RdHiLo
          1000b: SMLAxy{cond}   Rd,Rm,Rs,Rn     ;Rd=HalfRm*HalfRs+Rn
          1001b: SMLAWy{cond}   Rd,Rm,Rs,Rn     ;Rd=(Rm*HalfRs)/10000h+Rn
          1001b: SMULWy{cond}   Rd,Rm,Rs        ;Rd=(Rm*HalfRs)/10000h
          1010b: SMLALxy{cond}  RdLo,RdHi,Rm,Rs ;RdHiLo=RdHiLo+HalfRm*HalfRs
          1011b: SMULxy{cond}   Rd,Rm,Rs        ;Rd=HalfRm*HalfRs
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 0 for Halfword & UMAAL)
  19-16  Rd (or RdHi) - Destination Register (R0-R14)
  15-12  Rn (or RdLo) - Accumulate Register  (R0-R14) (Set to 0000b if unused)
  11-8   Rs - Operand Register               (R0-R14)
  For Non-Halfword Multiplies
    7-4  Must be 1001b for these instructions
  For Halfword Multiplies
    7    Must be 1 for these instructions
    6    y - Rs Top/Bottom flag (0=B=Lower 16bit, 1=T=Upper 16bit)
    5    x - Rm Top/Bottom flag (as above), or 0 for SMLAW, or 1 for SMULW
    4    Must be 0 for these instructions
  3-0    Rm - Operand Register               (R0-R14)
```



## Multiply and Multiply-Accumulate (MUL, MLA)


Restrictions: Rd may not be same as Rm. Rd,Rn,Rs,Rm may not be R15.

Note: Only the lower 32bit of the internal 64bit result are stored in Rd, thus
no sign/zero extension is required and MUL and MLA can be used for both signed
and unsigned calculations!

Execution Time: 1S+mI for MUL, and 1S+(m+1)I for MLA. Whereas 'm' depends on
whether/how many most significant bits of Rs are all zero or all one. That is
m=1 for Bit 31-8, m=2 for Bit 31-16, m=3 for Bit 31-24, and m=4 otherwise.

Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or C=not
affected (ARMv5 and up), V=not affected. MUL/MLA supported by ARMv2 and up.



## Multiply Long and Multiply-Accumulate Long (MULL, MLAL)


Optionally supported, INCLUDED in ARMv3M, EXCLUDED in ARMv4xM/ARMv5xM.

Restrictions: RdHi,RdLo,Rm must be different registers. R15 may not be used.

Execution Time: 1S+(m+1)I for MULL, and 1S+(m+2)I for MLAL. Whereas 'm' depends
on whether/how many most significant bits of Rs are "all zero" (UMULL/UMLAL) or
"all zero or all one" (SMULL,SMLAL). That is m=1 for Bit31-8, m=2 for Bit31-16,
m=3 for Bit31-24, and m=4 otherwise.

Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or C=not
affected (ARMv5 and up), V=destroyed??? (ARMv4 and below???) or V=not affected
(ARMv5 and up).



## Signed Halfword Multiply (SMLAxy,SMLAWy,SMLALxy,SMULxy,SMULWy)


Supported by E variants of ARMv5 and up, ie. ARMv5TE(xP).

Q-flag gets set on 32bit SMLAxy/SMLAWy addition overflows, however, the result
is NOT truncated (as it'd be done with QADD opcodes).

Q-flag is NOT affected on (rare) 64bit SMLALxy addition overflows.

SMULxy/SMULWy cannot overflow, and thus leave Q-flag unchanged as well.

NZCV-flags are not affected by Halfword multiplies.

Execution Time: 1S+Interlock (SMULxy,SMLAxy,SMULWx,SMLAWx)

Execution Time: 1S+1I+Interlock (SMLALxy)



## Unsigned Multiply Accumulate Accumulate Long (UMAAL)


Multiply with two 32bit additions, supposed to be used for cryptography.

Flags are not affected.

ARMv6 and above.




# <a name="armopcodesspecialarm9instructionsclzqaddqsub"></a>ARM Opcodes: Special ARM9 Instructions (CLZ, QADD/QSUB)




## Count Leading Zeros (CLZ)


```
  Bit    Expl.
  31-28  Condition
  27-16  Must be 0001.0110.1111b for this instruction
         Opcode (fixed)
           CLZ{cond} Rd,Rm  ;Rd=Number of leading zeros in Rm
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 1111.0001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
```

CLZ supported by ARMv5 and up. Execution time: 1S.

Return: No Flags affected. Rd=0..32.



## Opcode Format (QADD/QSUB)


```
  Bit    Expl.
  31-28  Condition
  27-24  Must be 0001b for this instruction
  23-20  Opcode
          0000b: QADD{cond}  Rd,Rm,Rn    ;Rd=Rm+Rn
          0010b: QSUB{cond}  Rd,Rm,Rn    ;Rd=Rm-Rn
          0100b: QDADD{cond} Rd,Rm,Rn    ;Rd=Rm+Rn*2 (doubled)
          0110b: QDSUB{cond} Rd,Rm,Rn    ;Rd=Rm-Rn*2 (doubled)
  19-16  Rn - Second Source Register            (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00000101b for this instruction
  3-0    Rm - First Source Register             (R0-R14)
```

Supported by E variants of ARMv5 and up, ie. ARMv5TE(xP).

Execution time: 1S+Interlock.

Results truncated to signed 32bit range in case of overflows, with the Q-flag
being set (and being left unchanged otherwise). NZCV flags are not affected.

Note: Rn\*2 is internally processed first, and may get truncated - even if the
final result would fit into range.




# <a name="armopcodesspecialarm11instructionsmisc"></a>ARM Opcodes: Special ARM11 Instructions (Misc)




## Load/Store Byte/Halfword/Doubleword Exclusive (LDREX/STREX)


```
  Bit    Expl.
  31-28  Condition
  27-23  Must be 00011b for this instruction
  22-20  Opcode
           0: STREX{cond}  Rd, Rm, [Rn]  ;[Rn]=Rm, Rd=flag       ;32bit
           1: LDREX{cond}  Rd, [Rn]      ;Rd=[Rm]                ;32bit
           2: STREXD{cond} Rd, Rm, [Rn]  ;[Rn]=Rm,Rm+1, Rd=flag  ;64bit
           3: LDREXD{cond} Rd, [Rn]      ;Rd,Rd+1=[Rm]           ;64bit
           4: STREXB{cond} Rd, Rm, [Rn]  ;[Rn]=Rm, Rd=flag       ;8bit
           5: LDREXB{cond} Rd, [Rn]      ;Rd=[Rm]                ;8bit
           6: STREXH{cond} Rd, Rm, [Rn]  ;[Rn]=Rm, Rd=flag       ;16bit
           7: LDREXH{cond} Rd, [Rn]      ;Rd=[Rm]                ;16bit
  19-16  Rn - Base Register                      (R0-R14)
  15-12  Rd - Destination Register               (R0-R14)
  11-4   Must be 1111.1001b for this instruction
  3-0    Rm - Source Register (1111b for LDREX)  (R0-R14)
```

For exclusive access to shared memory regions (ie. in dual-core CPUs?)

Unknown what "exclusive" means?

Return: No Flags affected.

ARMv6 and up supports LDREX/STREX (with 32bit operand).

ARMv6K and up supports LDREX/STREX{B|H|D} (with 8/16/64bit operand).



## Clear Exclusive (CLREX)


```
  Bit    Expl.
  31-0   Opcode 1111.0101.0111.1111.1111.0000.0001.1111b for CLREX
```

Supported on ARMv6K and up.



## Hint (TrueNOP, YIELD, WFE, WFI, SEV)


```
  Bit    Expl.
  31-28  Condition (should be always 0Eh=Always for NOP)
  27-8   Must be 0011.0010.0000.1111.0000b
  7-0    Opcode/Hint
           00h: TrueNOP      ;no operation
           01h: YIELD{cond}
           02h: WFE{cond}    ;wait for event
           03h: WFI{cond}    ;wait for interrupt
           04h: SEV{cond}    ;send event
```

Supported on ARMv6K and up.



## Change Processor State aka CPSR Mode/Flags (CPS, CPSID, CPSIE)


```
  31-20  Must be 1111.0001.0000b
  19-17  Opcode
          001b: CPS   #<mode>           ;change mode
          100b: CPSIE {A}{I}{F}         ;interrupt bit(s) enable
          101b: CPSIE {A}{I}{F},#<mode> ;interrupt bit(s) enable & change mode
          110b: CPSID {A}{I}{F}         ;interrupt bit(s) disable
          111b: CPSID {A}{I}{F},#<mode> ;interrupt bit(s) disable & change mode
  16-9   Must be 0000.0000b
  8      Change A flag (what?) (0=No, 1=Yes)  ;\must be all zero for CPS,
  7      Change I flag         (0=No, 1=Yes)  ; must be at least one flag set
  6      Change F flag         (0=No, 1=Yes)  ;/for CPSID/CPSIE
  5      Must be 0
  4-0    Mode (00h..1Fh) (must be 00h if bit17=0)
```



## Set Endianness for Data Access (SETEND)


```
  31-10  Fixed, 1111000100000001000000b
  9      Opcode/operand
          0: SETEND LE  ;clears the CPSR E bit
          1: SETEND BE  ;sets the CPSR E bit
  8-0    Fixed, 000000000b
```

Changes the byte order for data access to Big/Little endian. Does probably not
affect opcode fetches, but probably affect all other memory including push/pop?
Or affects "LDR" only?

Supported on ARMv6 and above.



## Store Return State (SRS) (stores the R14 and SPSR of the current mode)


to the word at the specified address and the following word respectively. The
address is determined from the banked version of R13 belonging to a specified
mode.

```
  Syntax
  SRS<addressing_mode> #<mode>{!}   ;<-- original (pre-UAL)
  SRS<addressing_mode> sp!,#<mode>  ;<-- more common (UAL)
```

\<addressing\_mode>: Is similar to the \<addressing\_mode> in LDM and
STM instructions, see Addressing Mode 4 - Load and Store Multiple on page
A5-41, but with the following differences:

- The base register, Rn, is the banked version of R13 for the mode specified by
\<mode>, rather than the current mode.

- The number of registers to store is 2.

- The register list is {R14, SPSR}, with both R14 and the SPSR being the
versions belonging to the current mode.

\<mode> Specifies the number of the mode whose banked register is used as
the base register for \<addressing\_mode>. The mode number is the 5-bit
encoding of the chosen mode in a PSR, as described in The mode bits on page
A2-14.

! If present, sets the W bit. This causes the instruction to write a modified
value back to its base register, in a manner similar to that specified for
Addressing Mode 4 - Load and Store Multiple on page A5-41. If ! is omitted, the
W bit is 0 and the instruction does not change the base register.

```
  31-25  Fixed, 1111100b
  24     P
  23     U
  22     Fixed, 1
  21     W
  20     Fixed, 0 (store)
  19-5   Fixed, 110100000101000b
  4-0    mode
```

Supported on ARMv6 and above.



## Return From Exception (RFE) (RFEDA, RFEDB, RFEIA, RFEIB)


loads the PC and the CPSR from the word at the specified address and the

following word respectively.

```
  Syntax
  RFE<addressing_mode> Rn{!}
```

\<addressing\_mode>: Is similar to the \<addressing\_mode> in LDM and
STM instructions, see Addressing Mode 4 - Load and Store Multiple on page
A5-41, but with the following differences:

- The number of registers to load is 2.

- The register list is {PC, CPSR}.

\<Rn> Specifies the base register to be used by \<addressing\_mode>.
If R15 is specified as the base register, the result is UNPREDICTABLE.

! If present, sets the W bit. This causes the instruction to write a modified
value back to its base register, in a manner similar to that specified for
Addressing Mode 4 - Load and Store Multiple on page A5-41. If ! is omitted, the
W bit is 0 and the instruction does not change the base register.

While RFE supports different base registers, a general usage case is where Rn
== sp (the stack pointer), held in R13. The instruction can then be used as the
return method associated with instructions SRS and CPS. See New instructions to
improve exception handling on page A2-28 for more details.

```
  31-25  Fixed, 1111100b
  24     P
  23     U
  22     Fixed, 0
  21     W
  20     Fixed, 1 (load)
  19-16  Rn
  15-0   Fixed, 0000101000000000b
```

Supported on ARMv6 and above.



## SVC (formerly SWI)


SWI was renamed to SVC in new UAL syntax.



## CPY


CPY Rd,Rm is an alias for MOV Rd,Rm (without flags affected).

```
  31-28  Condition
  27-16  Fixed, 000110100000
  15-12  Rd - Destination Register
  11-4   Fixed, 00000000
  3-0    Rm
```

The alias was invented in ARMv6 for THUMB and ARM code (apparently because
pre-UAL THUMB syntax couldn't distinguish between MOV and MOVS) (ie. in ARM
it's useless, but in THUMB it does allow using a formerly undocumented opcode).

ARMv6 and above.




# <a name="armopcodesspecialarm11instructionssimd"></a>ARM Opcodes: Special ARM11 Instructions (SIMD)




## Sign Extend / Zero Extend, with optional Addition (SXT, UXT)


```
  31-28  Condition
  27-23  Fixed, 01101b
  22-20  Opcode:
          0: SXTAB16{cond} Rd, Rn, Rm{,ROR #imm} ;\
          2: SXTAB{cond}   Rd, Rn, Rm{,ROR #imm} ;
          3: SXTAH{cond}   Rd, Rn, Rm{,ROR #imm} ; with add
          4: UXTAB16{cond} Rd, Rn, Rm{,ROR #imm} ;
          6: UXTAB{cond}   Rd, Rn, Rm{,ROR #imm} ;
          7: UXTAH{cond}   Rd, Rn, Rm{,ROR #imm} ;/
          0: SXTB16{cond}  Rd,     Rm{,ROR #imm} ;\
          2: SXTB{cond}    Rd,     Rm{,ROR #imm} ;
          3: SXTH{cond}    Rd,     Rm{,ROR #imm} ; without add
          4: UXTB16{cond}  Rd,     Rm{,ROR #imm} ;
          6: UXTB{cond}    Rd,     Rm{,ROR #imm} ;
          7: UXTH{cond}    Rd,     Rm{,ROR #imm} ;/
  19-16  Rn - Addition Register (or 1111b when no addition)            (R0-R14)
  15-12  Rd - Destination Register                                     (R0-R14)
  11-10  Rotation (0=None/ROR#0, 1=ROR#8, 2=ROR#16, 3=ROR#24)
  9-4    Fixed, 000111b
  3-0    Rm - Source register (to be rotated/extracted from)           (R0-R14)
```

Supported on ARMv6 and above.



## Select Bytes from 1st/2nd operand, depending on GE flags (SEL)


Syntax

```
  SEL{cond} Rd, Rn, Rm
```

Operation

if ConditionPassed(cond) then

Rd[7:0] = if GE[0] == 1 then Rn[7:0] else Rm[7:0]

Rd[15:8] = if GE[1] == 1 then Rn[15:8] else Rm[15:8]

Rd[23:16] = if GE[2] == 1 then Rn[23:16] else Rm[23:16]

Rd[31:24] = if GE[3] == 1 then Rn[31:24] else Rm[31:24]

Usage

Use SEL after instructions such as SADD8, SADD16, SSUB8, SSUB16, UADD8, UADD16,
USUB8, USUB16, SADDSUBX, SSUBADDX, UADDSUBX and USUBADDX, that set the GE
flags. For example, the following sequence of instructions sets each byte of Rd
equal to the unsigned minimum of the corresponding bytes of Ra and Rb:

```
  USUB8 Rd, Ra, Rb
  SEL Rd, Rb, Ra
```

Notes

Specifying R15 for register Rd, Rm, or Rn has UNPREDICTABLE results.

```
  31-28  Condition
  27-20  Fixed, 01101000b
  19-16  Rn - First Source Register (8bit snippets used when GE bits = 1)
  15-12  Rd - Destination Register
  11-4   Fixed, 11111011b
  3-0    Rm - Second Source Register (8bit snippets used when GE bits = 0)
```

ARMv6 and above.



## SADD16


SADD16 (Signed Add) performs two 16-bit signed integer additions. It sets the
GE bits in the CPSR according to the results of the additions.

ARMv6 and above.

Operation

sum = Rn[15:0] + Rm[15:0] /\* Signed addition \*/

Rd[15:0] = sum[15:0]

GE[1:0] = if sum >= 0 then 0b11 else 0

sum = Rn[31:16] + Rm[31:16] /\* Signed addition \*/

Rd[31:16] = sum[15:0]

GE[3:2] = if sum >= 0 then 0b11 else 0

```
  31-28  Condition
  27-23  Fixed, 01100b
  22-20  Opcode, part 1:
          001b: for Sxx           (signed, with GE flags)
          010b: for Qxx           (signed, with saturation)
          011b: for SHxx          (signed, with halving)
          101b: for Uxx           (unsigned, with GE flags)
          110b: for UQxx          (unsigned, with saturation)
          111b: for UHxx          (unsigned, with halving)
  19-16  Rn - First Source Register                                    (R0-R14)
  15-12  Rd - Destination Register                                     (R0-R14)
  11-8   Fixed, 1111b
  7-5    Opcode, part 2:
          000b: xxADD16{cond}   Rd, Rn, Rm
          001b: xxADDSUBX{cond} Rd, Rn, Rm
          010b: xxSUBADDX{cond} Rd, Rn, Rm
          011b: xxSUB16{cond}   Rd, Rn, Rm
          100b: xxADD8{cond}    Rd, Rn, Rm
          111b: xxSUB8{cond}    Rd, Rn, Rm
  4      Fixed, 1
  3-0    Rm - Second Source register                                   (R0-R14)
```



## SMLAD


SMLAD (Signed Multiply Accumulate Dual) performs two signed 16 x 16-bit
multiplications. It adds the products to a 32-bit accumulate operand.

Optionally, you can exchange the halfwords of the second operand before
performing the arithmetic. This produces top x bottom and bottom x top
multiplication.

This instruction sets the Q flag if the accumulate operation overflows.
Overflow cannot occur during the multiplications.

X Sets the X bit of the instruction to 1, and the multiplications are bottom x
top and top x bottom.

If the X is omitted, sets the X bit to 0, and the multiplications are bottom x
bottom and top x top.

\<Rm> Specifies the register that contains the first operand.

\<Rs> Specifies the register that contains the second operand.

\<Rn> Specifies the register that contains the accumulate operand.

```
  31-28  Condition
  27-23  Fixed, 01110
  22-20  Opcode part 1 (part2 in bit7-6)
         Merged part1.part2:
           000.00: SMUAD{X}{cond}  Rd,Rm,Rs
           000.00: SMLAD{X}{cond}  Rd,Rm,Rs,Rn
           000.01: SMUSD{X}{cond}  Rd,Rm,Rs
           000.01: SMLSD{X}{cond}  Rd,Rm,Rs,Rn
           100.00: SMLALD{X}{cond} RdLo,RdHi,Rm,Rs
           100.01: SMLSLD{X}{cond} RdLo,RdHi,Rm,Rs
           101.00: SMMUL{R}{cond}  Rd,Rm,Rs        ;Rd=(Rm*Rs)/100000000h
           101.00: SMMLA{R}{cond}  Rd,Rm,Rs,Rn     ;Rd=(Rm*Rs)/100000000h+Rz
           101.11: SMMLS{R}{cond}  Rd,Rm,Rs,Rn     ;Rd=(Rm*Rs)/100000000h-Rz
  19-16  Rd or RdHi - Destination Register
  15-12  Rn or RdLo or unused (must be 0Fh for SMUAD/SMUSD/SMMUL)
  11-8   Rs
  7-6    Opcode part 2 (part1 in bit22-20, see there)
  5      X or R flag   (X=Exchange, R=Rounded)
  4      Fixed, 1
  3-0    Rm
```

ARMv6 and above.


## Most significant word multiply


There are three signed 32-bit x 32-bit Multiply instructions that produce top
32-bit results:

```
  SMMUL Multiplies the 32-bit values of two registers together, and stores
        the top 32 bits of the signed 64-bit result in a third register.
  SMMLA Multiplies the 32-bit values of two registers together, extracts the
        top 32 bits, adds the 32-bit value from a third register, and stores
        the signed 32-bit result in a fourth register.
  SMMLS Multiplies the 32-bit value of two registers together, extracts the
        top 32 bits, subtracts this from a 32-bit value from a third
        register, and stores the signed 32-bit result in a fourth register.
```

The above three instructions do not affect any flags.


## Dual halfword multiply


There are six dual, signed 16-bit x 16-bit Multiply instructions:

```
  SMUAD Multiplies the values of the top halfwords of two registers together,
        multiplies the values of the bottom halfwords of the same two
        registers together, adds the products, and stores the 32-bit result
        in a third register.
  SMUSD Multiplies the values of the top halfwords of two registers together,
        multiplies the values of the bottom halfwords of the same two
        registers together, subtracts one product from the other, and stores
        the 32-bit result in a third register.
  ---(descriptions below seem to be bugged, seem to describe 32bit SMMxx)---
  SMLAD Multiplies the 32-bit value of two registers together, extracts the
        top 32 bits, subtracts this from a 32-bit value from a third
        register, and stores the signed 32-bit result in a fourth register.
  SMLSD Multiplies the 32-bit values of two registers together, extracts the
        top 32 bits, adds the 32-bit value from a third register, and stores
        the signed 32-bit result in a fourth register.
  SMLALD Multiplies the 32-bit value of two registers together, extracts the
         top 32 bits, subtracts this from a 32-bit value from a third
         register, and stores the signed 32-bit result in a fourth register.
  SMLSLD Multiplies the 32-bit value of two registers together, extracts the
         top 32 bits, subtracts this from a 32-bit value from a third
         register, and stores the signed 32-bit result in a fourth register.
```

SMUAD, SMLAD, and SMLSLD can set the Q flag if overflow occurs in the
operation. All other instructions do not affect any flags.



## Signed/Unsigned Saturate (SSAT, USAT)


Saturates a 32bit value (with optional shift) to the specified range (of 1..32
bits).

```
  31-28  Condition
  27-21  Fixed, 0110101b: SSAT{cond} Rd, #<range>, Rm {,LSL/ASR #imm}
                0110111b: USAT{cond} Rd, #<range>, Rm {,LSL/ASR #imm}
  20-16  Immediate: range-1 (0..31 = Saturate to 1..32 bits range)
  15-12  Rd - Destination Register
  11-7   shift_imm (1..31 for LSL/ASR#1..31, or 0 for LSL#0, or 0 for ASR#32)
  6      Shift type (0=LSL, 1=ASR) (note: really ASR, even "unsigned" USAT)
  5-4    Fixed, 01b
  3-0    Rm - Source Register
```

The Q flag is set if the operation saturates.

ARMv6 and above.



## Signed/Unsigned Saturate on Halfwords (SSAT16, USAT16)


Saturates two 16bit values to the specified range (of 1..16 bits).

```
  31-28  Condition
  27-21  Fixed, 0110101b: SSAT16{cond} Rd, #<range>, Rm
                0110111b: USAT16{cond} Rd, #<range>, Rm
  20     Fixed, 0
  19-16  Immediate: range-1 (0..15 = Saturate to 1..16 bits range)
  15-12  Rd - Destination Register
  11-4   Fixed, 11110011b
  3-0    Rm - Source Register
```

The Q flag is set if either halfword operation saturates.

ARMv6 and above.



## Unsigned Sum of Absolute Differences, optional Accumulate (USAD8, USADA8)


Performs four unsigned 8bit subtractions, and adds the absolute values of the
differences together.

```
  31-28  Condition
  27-20  Fixed, 01111000b
  19-16  Rd - Destination Register
  15-12  Rn (if any) (otherwise fixed, 1111)
           USAD8{cond}  Rd, Rm, Rs        ;without Rn   ;Rd=sum
           USADA8{cond} Rd, Rm, Rs, Rn    ;with Rn      ;Rd=sum + Rn
  11-8   Rs
  7-4    Fixed, 0001b
  3-0    Rm
```

ARMv6 and above.



## Pack Halfword, Bottom-Top or Top-Bottom (PKHBT, PKHTB)


PKHBT (Pack Halfword Bottom Top) combines the bottom (least significant)
halfword of its first operand with the top (most significant) halfword of its
shifted second operand. The shift is a left shift, by any amount from 0 to 31.

\<Rn> Specifies the register that contains the first operand. Bits[15:0]
of this operand become bits[15:0] of the result of the operation.

\<Rm> Specifies the register that contains the second operand. This is
shifted left by the specified amount, then bits[31:16] of this operand become
bits[31:16] of the result of the operation.

\<shift\_imm> Specifies the amount by which Rm is to be shifted left. This
is a value from 0 to 31.

If the shift specifier is omitted, a left shift by 0 is used.

Operation

if ConditionPassed(cond) then

Rd[15:0] = Rn[15:0]

Rd[31:16] = (Rm Logical\_Shift\_Left shift\_imm)[31:16]

```
  31-28  Condition
  27-20  Fixed, 01101000b
  19-16  Rn
  15-12  Rd - Destination Register
  11-7   shift_imm (0..31)
  6-4    Fixed, 001  PKHBT {cond} Rd, Rn, Rm {, LSL #<shift_imm>}
                101  PKHTB {cond} Rd, Rn, Rm {, ASR #<shift_imm>}
  3-0    Rm
```

ARMv6 and above.



## Reverse Byte Order for Big/Little-Endian Conversion (REV, REV16, REVSH)


Specifying R15 for register Rd or Rm has UNPREDICTABLE results.

```
  31-28  Condition
  27-23  Fixed, 01101b
  22     Opcode (with bit7)
          Bit22=0, Bit7=0: REV{cond}   Rd, Rm   ;reverse 32bit
          Bit22=0, Bit7=1: REV16{cond} Rd, Rm
          Bit22=1, Bit7=1: REVSH{cond} Rd, Rm
  21-16  Fixed, 111111b
  15-12  Rd - Destination Register
  11-8   Fixed, 1111b
  7      Opcode (with bit22, see there)
  6-4    Fixed, 011b
  3-0    Rm - Source Register
```

ARMv6 and above.




# <a name="armopcodespsrtransfermrsmsr"></a>ARM Opcodes: PSR Transfer (MRS, MSR)




## Opcode Format


These instructions occupy an unused area (TEQ,TST,CMP,CMN with S=0) of ALU
opcodes.

```
  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate Operand Flag  (0=Register, 1=Immediate) (Zero for MRS)
  24-23  Must be 10b for this instruction
  22     Psr - Source/Destination PSR  (0=CPSR, 1=SPSR_<current mode>)
  21     Opcode
           0: MRS{cond} Rd,Psr          ;Rd = Psr
           1: MSR{cond} Psr{_field},Op  ;Psr[field] = Op
  20     Must be 0b for this instruction (otherwise TST,TEQ,CMP,CMN)
  For MRS:
    19-16   Must be 1111b for this instruction (otherwise SWP)
    15-12   Rd - Destination Register  (R0-R14)
    11-0    Not used, must be zero.
  For MSR:
    19      f  write to flags field     Bit 31-24 (aka _flg)
    18      s  write to status field    Bit 23-16 (reserved, don't change)
    17      x  write to extension field Bit 15-8  (reserved, don't change)
    16      c  write to control field   Bit 7-0   (aka _ctl)
    15-12   Not used, must be 1111b.
  For MSR Psr,Rm (I=0)
    11-4    Not used, must be zero. (otherwise BX)
    3-0     Rm - Source Register <op>  (R0-R14)
  For MSR Psr,Imm (I=1)
    11-8    Shift applied to Imm   (ROR in steps of two 0-30)
    7-0     Imm - Unsigned 8bit Immediate
    In source code, a 32bit immediate should be specified as operand.
    The assembler should then convert that into a shifted 8bit value.
```

MSR/MRS and CPSR/SPSR supported by ARMv3 and up.

ARMv2 and below contained PSR flags in R15, accessed by CMP/CMN/TST/TEQ{P}.

The field mask bits specify which bits of the destination Psr are write-able
(or write-protected), one or more of these bits should be set, for example,
CPSR\_fsxc (aka CPSR aka CPSR\_all) unlocks all bits (see below user mode
restriction though).

Restrictions:

In non-privileged mode (user mode): only condition code bits of CPSR can be
changed, control bits can't.

Only the SPSR of the current mode can be accessed; In User and System modes no
SPSR exists.

The T-bit may not be changed; for THUMB/ARM switching use BX instruction.

Unused Bits in CPSR are reserved for future use and should never be changed
(except for unused bits in the flags field).

Execution Time: 1S.


Note: The A22i assembler recognizes MOV as alias for both MSR and MRS because
it is practically not possible to remember whether MSR or MRS was the load or
store opcode, and/or whether it does load to or from the Psr register.




# <a name="armopcodesmemorysingledatatransferldrstrpld"></a>ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)




## Opcode Format


```
  Bit    Expl.
  31-28  Condition (Must be 1111b for PLD)
  27-26  Must be 01b for this instruction
  25     I - Immediate Offset Flag (0=Immediate, 1=Shifted Register)
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     B - Byte/Word bit (0=transfer 32bit/word, 1=transfer 8bit/byte)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     T - Memory Management (0=Normal, 1=Force non-privileged access)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STR{cond}{B}{T} Rd,<Address>   ;[Rn+/-<offset>]=Rd
          1: LDR{cond}{B}{T} Rd,<Address>   ;Rd=[Rn+/-<offset>]
         (1: PLD <Address> ;Prepare Cache for Load, see notes below)
          Whereas, B=Byte, T=Force User Mode (only for POST-Indexing)
  19-16  Rn - Base register               (R0..R15) (including R15=PC+8)
  15-12  Rd - Source/Destination Register (R0..R15) (including R15=PC+12)
  When above I=0 (Immediate as Offset)
    11-0   Unsigned 12bit Immediate Offset (0-4095, steps of 1)
  When above I=1 (Register shifted by Immediate as Offset)
    11-7   Is - Shift amount      (1-31, 0=Special/See below)
    6-5    Shift Type             (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      Must be 0 (Reserved, see The Undefined Instruction)
    3-0    Rm - Offset Register   (R0..R14) (not including PC=R15)
```



## Instruction Formats for \<Address>


An expression which generates an address:

```
  <expression>                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-4095+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
```

Pre-indexed addressing specification:

```
  [Rn]                          ;offset = zero
  [Rn, <#{+/-}expression>]{!}   ;offset = immediate
  [Rn, {+/-}Rm{,<shift>} ]{!}   ;offset = register shifted by immediate
```

Post-indexed addressing specification:

```
  [Rn], <#{+/-}expression>      ;offset = immediate
  [Rn], {+/-}Rm{,<shift>}       ;offset = register shifted by immediate
```

Whereas...

```
  <shift>  immediate shift such like LSL#4, ROR#2, etc. (see ALU opcodes).
  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
```



## Notes


Shift amount 0 has special meaning, as described for ALU opcodes.

When writing a word (32bit) to memory, the address should be word-aligned.

When reading a byte from memory, upper 24 bits of Rd are zero-extended.

LDR PC,\<op> on ARMv4 leaves CPSR.T unchanged.

LDR PC,\<op> on ARMv5 sets CPSR.T to
\<op> Bit0, (1=Switch to Thumb).


When reading a word from a halfword-aligned address (which is located in the
middle between two word-aligned addresses), the lower 16bit of Rd will contain
[address] ie. the addressed halfword, and the upper 16bit of Rd will contain
[Rd-2] ie. more or less unwanted garbage. However, by isolating lower bits this
may be used to read a halfword from memory. (Above applies to little endian
mode, as used in GBA.)


In a virtual memory based environment (ie. not in the GBA), aborts (ie. page
faults) may take place during execution, if so, Rm and Rn should not specify
the same register when post-indexing is used, as the abort-handler might have
problems to reconstruct the original value of the register.


Return: CPSR flags are not affected.

Execution Time: For normal LDR: 1S+1N+1I. For LDR PC: 2S+2N+1I. For STR: 2N.



## PLD \<Address> ;Prepare Cache for Load


PLD must use following settings cond=1111b, P=1, B=1, W=0, L=1, Rd=1111b, the
address may not use post-indexing, and may not use writeback, the opcode is
encoded identical as LDRNVB R15,\<Address>.

PLD signalizes to the memory system that a specific memory address will be soon
accessed, the memory system may use this hint to prepare caching/pipelining,
aside from that, PLD does not have any affect to the program logic, and behaves
identical as NOP.

PLD supported by ARMv5TE and up only, not ARMv5, not ARMv5TExP.




# <a name="armopcodesmemoryhalfworddoublewordandsigneddatatransfer"></a>ARM Opcodes: Memory: Halfword, Doubleword, and Signed Data Transfer




## Opcode Format


```
  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     I - Immediate Offset Flag (0=Register Offset, 1=Immediate Offset)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     Not used, must be zero (0)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
  19-16  Rn - Base register                (R0-R15) (Including R15=PC+8)
  15-12  Rd - Source/Destination Register  (R0-R15) (Including R15=PC+12)
  11-8   When above Bit 22 I=0 (Register as Offset):
           Not used. Must be 0000b
         When above Bit 22 I=1 (immediate as Offset):
           Immediate Offset (upper 4bits)
  7      Reserved, must be set (1)
  6-5    Opcode (0-3)
         When Bit 20 L=0 (Store) (and Doubleword Load/Store):
          0: Reserved for SWP instruction
          1: STR{cond}H  Rd,<Address>  ;Store halfword   [a]=Rd
          2: LDR{cond}D  Rd,<Address>  ;Load Doubleword  R(d)=[a], R(d+1)=[a+4]
          3: STR{cond}D  Rd,<Address>  ;Store Doubleword [a]=R(d), [a+4]=R(d+1)
         When Bit 20 L=1 (Load):
          0: Reserved.
          1: LDR{cond}H  Rd,<Address>  ;Load Unsigned halfword (zero-extended)
          2: LDR{cond}SB Rd,<Address>  ;Load Signed byte (sign extended)
          3: LDR{cond}SH Rd,<Address>  ;Load Signed halfword (sign extended)
  4      Reserved, must be set (1)
  3-0    When above Bit 22 I=0:
           Rm - Offset Register            (R0-R14) (not including R15)
         When above Bit 22 I=1:
           Immediate Offset (lower 4bits)  (0-255, together with upper bits)
```

STRH,LDRH,LDRSB,LDRSH supported on ARMv4 and up.

STRD/LDRD supported on ARMv5TE and up only, not ARMv5, not ARMv5TExP.

STRD/LDRD: base writeback: Rn should not be same as R(d) or R(d+1).

STRD: index register: Rm should not be same as R(d) or R(d+1).

STRD/LDRD: Rd must be an even numbered register (R0,R2,R4,R6,R8,R10,R12).

STRD/LDRD: Address must be double-word aligned (multiple of eight).



## Instruction Formats for \<Address>


An expression which generates an address:

```
  <expression>                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-255+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
```

Pre-indexed addressing specification:

```
  [Rn]                          ;offset = zero
  [Rn, <#{+/-}expression>]{!}   ;offset = immediate
  [Rn, {+/-}Rm]{!}              ;offset = register
```

Post-indexed addressing specification:

```
  [Rn], <#{+/-}expression>      ;offset = immediate
  [Rn], {+/-}Rm                 ;offset = register
```

Whereas...

```
  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
```


Return: No Flags affected.

Execution Time: For Normal LDR, 1S+1N+1I. For LDR PC, 2S+2N+1I. For STRH 2N.




# <a name="armopcodesmemoryblockdatatransferldmstm"></a>ARM Opcodes: Memory: Block Data Transfer (LDM, STM)




## Opcode Format


```
  Bit    Expl.
  31-28  Condition
  27-25  Must be 100b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     S - PSR & force user bit (0=No, 1=load PSR or force user mode)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STM{cond}{amod} Rn{!},<Rlist>{^}  ;Store (Push)
          1: LDM{cond}{amod} Rn{!},<Rlist>{^}  ;Load  (Pop)
          Whereas, {!}=Write-Back (W), and {^}=PSR/User Mode (S)
  19-16  Rn - Base register                (R0-R14) (not including R15)
  15-0   Rlist - Register List
  (Above 'offset' is meant to be the number of words specified in Rlist.)
```

Return: No Flags affected.

Execution Time: For normal LDM, nS+1N+1I. For LDM PC, (n+1)S+2N+1I. For STM
(n-1)S+2N. Where n is the number of words transferred.



## Addressing Modes {amod}


The IB,IA,DB,DA suffixes directly specify the desired U and P bits:

```
  IB  increment before          ;P=1, U=1
  IA  increment after           ;P=0, U=1
  DB  decrement before          ;P=1, U=0
  DA  decrement after           ;P=0, U=0
```

Alternately, FD,ED,FA,EA could be used, mostly to simplify mnemonics for stack
transfers.

```
  ED  empty stack, descending   ;LDM: P=1, U=1  ;STM: P=0, U=0
  FD  full stack,  descending   ;     P=0, U=1  ;     P=1, U=0
  EA  empty stack, ascending    ;     P=1, U=0  ;     P=0, U=1
  FA  full stack,  ascending    ;     P=0, U=0  ;     P=1, U=1
```

Ie. the following expressions are aliases for each other:

```
  STMFD=STMDB=PUSH   STMED=STMDA   STMFA=STMIB   STMEA=STMIA
  LDMFD=LDMIA=POP    LDMED=LDMIB   LDMFA=LDMDA   LDMEA=LDMDB
```

Note: The equivalent THUMB functions use fixed organization:

```
  PUSH/POP: full descending     ;base register SP (R13)
  LDM/STM:  increment after     ;base register R0..R7
```

Descending is common stack organization as used in 80x86 and Z80 CPUs, SP is
decremented when pushing/storing data, and incremented when popping/loading
data.



## When S Bit is set (S=1)


If instruction is LDM and R15 is in the list: (Mode Changes)

```
  While R15 loaded, additionally: CPSR=SPSR_<current mode>
```

Otherwise: (User bank transfer)

```
  Rlist is referring to User Bank Registers, R0-R15 (rather than
  register related to the current mode, such like R14_svc etc.)
  Base write-back should not be used for User bank transfer.
  Caution - When instruction is LDM:
  If the following instruction reads from a banked register (eg. R14_svc),
  then CPU might still read R14 instead; if necessary insert a dummy NOP.
```



## Notes


The base address should be usually word-aligned.

LDM Rn,...,PC on ARMv4 leaves CPSR.T unchanged.

LDR Rn,...,PC on ARMv5 sets CPSR.T to \<op> Bit0, (1=Switch to Thumb).



## Transfer Order


The lowest Register in Rlist (R0 if its in the list) will be loaded/stored
to/from the lowest memory address.

Internally, the rlist register are always processed with INCREASING addresses
(ie. for DECREASING addressing modes, the CPU does first calculate the lowest
address, and does then process rlist with increasing addresses; this detail can
be important when accessing memory mapped I/O ports).



## Strange Effects on Invalid Rlist's


Empty Rlist: R15 loaded/stored (ARMv4 only), and Rb=Rb+/-40h (ARMv4-v5).

Writeback with Rb included in Rlist: Store OLD base if Rb is FIRST entry in
Rlist, otherwise store NEW base (STM/ARMv4), always store OLD base (STM/ARMv5),
no writeback (LDM/ARMv4), writeback if Rb is "the ONLY register, or NOT the
LAST register" in Rlist (LDM/ARMv5).




# <a name="armopcodesmemorysingledataswapswp"></a>ARM Opcodes: Memory: Single Data Swap (SWP)




## Opcode Format


```
  Bit    Expl.
  31-28  Condition
  27-23  Must be 00010b for this instruction
         Opcode (fixed)
           SWP{cond}{B} Rd,Rm,[Rn]      ;Rd=[Rn], [Rn]=Rm
  22     B - Byte/Word bit (0=swap 32bit/word, 1=swap 8bit/byte)
  21-20  Must be 00b for this instruction
  19-16  Rn - Base register                     (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00001001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
```

SWP/SWPB supported by ARMv2a and up. SWP/SWPB has been deprecated in ARMv6,
made optional in ARMv7 (with the possibility of disabling it if still
available), and removed in ARMv8.

Swap works properly including if Rm and Rn specify the same register.

R15 may not be used for either Rn,Rd,Rm. (Rn=R15 would be MRS opcode).

Upper bits of Rd are zero-expanded when using Byte quantity. For info about
byte and word data memory addressing, read LDR and STR opcode description.

Execution Time: 1S+2N+1I. That is, 2N data cycles, 1S code cycle, plus 1I.




# <a name="armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc"></a>ARM Opcodes: Coprocessor Instructions (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)




## Coprocessor Register Transfers (MRC, MCR) (with ARM Register read/write)


```
  Bit    Expl.
  31-28  Condition (or 1111b for MRC2/MCR2 opcodes on ARMv5 and up)
  27-24  Must be 1110b for this instruction
  23-21  CP Opc - Coprocessor operation code         (0-7)
  20     ARM-Opcode (0-1)
          0: MCR{cond} Pn,<cpopc>,Rd,Cn,Cm{,<cp>}   ;move from ARM to CoPro
          0: MCR2      Pn,<cpopc>,Rd,Cn,Cm{,<cp>}   ;move from ARM to CoPro
          1: MRC{cond} Pn,<cpopc>,Rd,Cn,Cm{,<cp>}   ;move from CoPro to ARM
          1: MRC2      Pn,<cpopc>,Rd,Cn,Cm{,<cp>}   ;move from CoPro to ARM
  19-16  Cn     - Coprocessor source/dest. Register  (C0-C15)
  15-12  Rd     - ARM source/destination Register    (R0-R15)
  11-8   Pn     - Coprocessor number                 (P0-P15)
  7-5    CP     - Coprocessor information            (0-7)
  4      Reserved, must be one (1) (otherwise CDP opcode)
  3-0    Cm     - Coprocessor operand Register       (C0-C15)
```

MCR/MRC supported by ARMv2 and up, MCR2/MRC2 by ARMv5 and up.

A22i syntax allows to use MOV with Rd specified as first (dest), or last
(source) operand. Native MCR/MRC syntax uses Rd as middle operand, \<cp>
can be ommited if \<cp> is zero.

When using MCR with R15: Coprocessor will receive a data value of PC+12.

When using MRC with R15: Bit 31-28 of data are copied to Bit 31-28 of CPSR (ie.
N,Z,C,V flags), other data bits are ignored, CPSR Bit 27-0 are not affected,
R15 (PC) is not affected.

Execution time: 1S+bI+1C for MCR, 1S+(b+1)I+1C for MRC.

Return: For MRC only: Either R0-R14 modified, or flags affected (see above).

For details refer to original ARM docs. The opcodes are irrelevant for GBA/NDS7
because no coprocessor exists (except for a dummy CP14 unit). However, NDS9
includes a working CP15 unit. And, 3DS ARM11 uses CP10/CP11 as VFP floating
point unit.

- [ARM CP14 ICEbreaker Debug Communications Channel](#armcp14icebreakerdebugcommunicationschannel)
- [ARM CP15 System Control Coprocessor](#armcp15systemcontrolcoprocessor)
- [ARM Vector Floating-point Unit (VFP)](#armvectorfloatingpointunitvfp)


## Coprocessor Data Transfers (LDC, STC) (with Memory read/write)


```
  Bit    Expl.
  31-28  Condition (or 1111b for LDC2/STC2 opcodes on ARMv5 and up)
  27-25  Must be 110b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     N - Transfer length (0-1, interpretation depends on co-processor)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     Opcode (0-1)
          0: STC{cond}{L} Pn,Cd,<Address>  ;Store to memory (from coprocessor)
          0: STC2{L}      Pn,Cd,<Address>  ;Store to memory (from coprocessor)
          1: LDC{cond}{L} Pn,Cd,<Address>  ;Read from memory (to coprocessor)
          1: LDC2{L}      Pn,Cd,<Address>  ;Read from memory (to coprocessor)
          whereas {L} indicates long transfer (Bit 22: N=1)
  19-16  Rn     - ARM Base Register              (R0-R15)     (R15=PC+8)
  15-12  Cd     - Coprocessor src/dest Register  (C0-C15)
  11-8   Pn     - Coprocessor number             (P0-P15)
  7-0    Offset - Unsigned Immediate, step 4     (0-1020, in steps of 4)
```

LDC/STC supported by ARMv2 and up, LDC2/STC2 by ARMv5 and up.

Execution time: (n-1)S+2N+bI, n=number of words transferred.

For details refer to original ARM docs, irrelevant in GBA because no
coprocessor exists.



## Coprocessor Data Operations (CDP) (without Memory or ARM Register operand)


```
  Bit    Expl.
  31-28  Condition (or 1111b for CDP2 opcode on ARMv5 and up)
  27-24  Must be 1110b for this instruction
         ARM-Opcode (fixed)
           CDP{cond} Pn,<cpopc>,Cd,Cn,Cm{,<cp>}
           CDP2      Pn,<cpopc>,Cd,Cn,Cm{,<cp>}
  23-20  CP Opc - Coprocessor operation code       (0-15)
  19-16  Cn     - Coprocessor operand Register     (C0-C15)
  15-12  Cd     - Coprocessor destination Register (C0-C15)
  11-8   Pn     - Coprocessor number               (P0-P15)
  7-5    CP     - Coprocessor information          (0-7)
  4      Reserved, must be zero (otherwise MCR/MRC opcode)
  3-0    Cm     - Coprocessor operand Register     (C0-C15)
```

CDP supported by ARMv2 and up, CDP2 by ARMv5 and up.

Execution time: 1S+bI, b=number of cycles in coprocessor busy-wait loop.

Return: No flags affected, no ARM-registers used/modified.

For details refer to original ARM docs, irrelevant in GBA because no
coprocessor exists.



## Coprocessor Double-Register Transfer (MCRR, MRRC) - ARMv5TE and up only


```
  Bit    Expl.
  31-28  Condition
  27-21  Must be 1100010b for this instruction
  20     L - Opcode (Load/Store)
          0: MCRR{cond} Pn,opcode,Rd,Rn,Cm  ;write Rd,Rn to coproc
          0: MCRR2      Pn,opcode,Rd,Rn,Cm  ;write Rd,Rn to coproc
          1: MRRC{cond} Pn,opcode,Rd,Rn,Cm  ;read Rd,Rn from coproc
          1: MRRC2      Pn,opcode,Rd,Rn,Cm  ;read Rd,Rn from coproc
  19-16  Rn - Second source/dest register      (R0-R14)
  15-12  Rd - First source/dest register       (R0-R14)
  11-8   Pn     - Coprocessor number           (P0-P15)
  7-4    CP Opc - Coprocessor operation code   (0-15)
  3-0    Cm     - Coprocessor operand Register (C0-C15)
```

MCRR/MRRC are supported by ARMv5TE and up (not ARMv5, not ARMv5TExP).

MCRR2/MRRC2 are supported by ARMv6 and up.




# <a name="thumbinstructionsummary"></a>THUMB Instruction Summary



The table below lists all THUMB mode instructions with clock cycles, affected
CPSR flags, Format/chapter number, and description.

Only register R0..R7 can be used in thumb mode (unless R8-15,SP,PC are
explicitly mentioned).



## Logical Operations


```
  Instruction        Cycles Flags Format Expl.
  MOV Rd,Imm8bit      1S     NZ--  3   Rd=nn
  MOV Rd,Rs           1S     NZ00  2   Rd=Rs+0
  MOV R0..14,R8..15   1S     ----  5   Rd=Rs
  MOV R8..14,R0..15   1S     ----  5   Rd=Rs
  MOV R15,R0..15      2S+1N  ----  5   PC=Rs
  MVN Rd,Rs           1S     NZ--  4   Rd=NOT Rs
  AND Rd,Rs           1S     NZ--  4   Rd=Rd AND Rs
  TST Rd,Rs           1S     NZ--  4 Void=Rd AND Rs
  BIC Rd,Rs           1S     NZ--  4   Rd=Rd AND NOT Rs
  ORR Rd,Rs           1S     NZ--  4   Rd=Rd OR Rs
  EOR Rd,Rs           1S     NZ--  4   Rd=Rd XOR Rs
  LSL Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHL nn
  LSL Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHL (Rs AND 0FFh)
  LSR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHR nn
  LSR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHR (Rs AND 0FFh)
  ASR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SAR nn
  ASR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SAR (Rs AND 0FFh)
  ROR Rd,Rs           1S+1I  NZc-  4   Rd=Rd ROR (Rs AND 0FFh)
  NOP                 1S     ----  5   R8=R8
```

Carry flag affected only if shift amount is non-zero.



## Arithmetic Operations and Multiply


```
  Instruction        Cycles Flags Format Expl.
  ADD Rd,Rs,Imm3bit   1S     NZCV  2   Rd=Rs+nn
  ADD Rd,Imm8bit      1S     NZCV  3   Rd=Rd+nn
  ADD Rd,Rs,Rn        1S     NZCV  2   Rd=Rs+Rn
  ADD R0..14,R8..15   1S     ----  5   Rd=Rd+Rs
  ADD R8..14,R0..15   1S     ----  5   Rd=Rd+Rs
  ADD R15,R0..15      2S+1N  ----  5   PC=Rd+Rs
  ADD Rd,PC,Imm8bit*4 1S     ---- 12   Rd=(($+4) AND NOT 2)+nn
  ADD Rd,SP,Imm8bit*4 1S     ---- 12   Rd=SP+nn
  ADD SP,Imm7bit*4    1S     ---- 13   SP=SP+nn
  ADD SP,-Imm7bit*4   1S     ---- 13   SP=SP-nn
  ADC Rd,Rs           1S     NZCV  4   Rd=Rd+Rs+Cy
  SUB Rd,Rs,Imm3Bit   1S     NZCV  2   Rd=Rs-nn
  SUB Rd,Imm8bit      1S     NZCV  3   Rd=Rd-nn
  SUB Rd,Rs,Rn        1S     NZCV  2   Rd=Rs-Rn
  SBC Rd,Rs           1S     NZCV  4   Rd=Rd-Rs-NOT Cy
  NEG Rd,Rs           1S     NZCV  4   Rd=0-Rs
  CMP Rd,Imm8bit      1S     NZCV  3 Void=Rd-nn
  CMP Rd,Rs           1S     NZCV  4 Void=Rd-Rs
  CMP R0-15,R8-15     1S     NZCV  5 Void=Rd-Rs
  CMP R8-15,R0-15     1S     NZCV  5 Void=Rd-Rs
  CMN Rd,Rs           1S     NZCV  4 Void=Rd+Rs
  MUL Rd,Rs           1S+mI  NZx-  4   Rd=Rd*Rs
```



## Jumps and Calls


```
  Instruction        Cycles    Flags Format Expl.
  B disp              2S+1N     ---- 18  PC=$+/-2048
  BL disp             3S+1N     ---- 19  PC=$+/-4M, LR=$+5
  B{cond=true} disp   2S+1N     ---- 16  PC=$+/-0..256
  B{cond=false} disp  1S        ---- 16  N/A
  BX R0..15           2S+1N     ----  5  PC=Rs, ARM/THUMB (Rs bit0)
  SWI Imm8bit         2S+1N     ---- 17  PC=8, ARM SVC mode, LR=$+2
  BKPT Imm8bit        ???       ---- 17  ??? ARM9 Prefetch Abort
  BLX disp            ???       ---- ??? ??? ARM9
  BLX R0..R14         ???       ---- ??? ??? ARM9
  POP {Rlist,}PC   (n+1)S+2N+1I ---- 14
  MOV R15,R0..15      2S+1N     ----  5  PC=Rs
  ADD R15,R0..15      2S+1N     ----  5  PC=Rd+Rs
```

The thumb BL instruction occupies two 16bit opcodes, 32bit in total.



## Memory Load/Store


```
  Instruction        Cycles    Flags Format Expl.
  LDR  Rd,[Rb,5bit*4] 1S+1N+1I  ----  9  Rd = WORD[Rb+nn]
  LDR  Rd,[PC,8bit*4] 1S+1N+1I  ----  6  Rd = WORD[PC+nn]
  LDR  Rd,[SP,8bit*4] 1S+1N+1I  ---- 11  Rd = WORD[SP+nn]
  LDR  Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = WORD[Rb+Ro]
  LDRB Rd,[Rb,5bit*1] 1S+1N+1I  ----  9  Rd = BYTE[Rb+nn]
  LDRB Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = BYTE[Rb+Ro]
  LDRH Rd,[Rb,5bit*2] 1S+1N+1I  ---- 10  Rd = HALFWORD[Rb+nn]
  LDRH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = HALFWORD[Rb+Ro]
  LDSB Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_BYTE[Rb+Ro]
  LDSH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_HALFWORD[Rb+Ro]
  STR  Rd,[Rb,5bit*4] 2N        ----  9  WORD[Rb+nn] = Rd
  STR  Rd,[SP,8bit*4] 2N        ---- 11  WORD[SP+nn] = Rd
  STR  Rd,[Rb,Ro]     2N        ----  7  WORD[Rb+Ro] = Rd
  STRB Rd,[Rb,5bit*1] 2N        ----  9  BYTE[Rb+nn] = Rd
  STRB Rd,[Rb,Ro]     2N        ----  7  BYTE[Rb+Ro] = Rd
  STRH Rd,[Rb,5bit*2] 2N        ---- 10  HALFWORD[Rb+nn] = Rd
  STRH Rd,[Rb,Ro]     2N        ----  8  HALFWORD[Rb+Ro]=Rd
  PUSH {Rlist}{LR}    (n-1)S+2N ---- 14
  POP  {Rlist}{PC}              ---- 14  (ARM9: with mode switch)
  STMIA Rb!,{Rlist}   (n-1)S+2N ---- 15
  LDMIA Rb!,{Rlist}   nS+1N+1I  ---- 15
```



## THUMB Binary Opcode Format


This table summarizes the position of opcode/parameter bits for THUMB mode
instructions, Format 1-19.


```
 Form|_15|_14|_13|_12|_11|_10|_9_|_8_|_7_|_6_|_5_|_4_|_3_|_2_|_1_|_0_|
 __1_|_0___0___0_|__Op___|_______Offset______|____Rs_____|____Rd_____|Shifted
 __2_|_0___0___0___1___1_|_I,_Op_|___Rn/nn___|____Rs_____|____Rd_____|ADD/SUB
 __3_|_0___0___1_|__Op___|____Rd_____|_____________Offset____________|Immedi.
 __4_|_0___1___0___0___0___0_|______Op_______|____Rs_____|____Rd_____|AluOp
 __5_|_0___1___0___0___0___1_|__Op___|Hd_|Hs_|____Rs_____|____Rd_____|HiReg/BX
 __6_|_0___1___0___0___1_|____Rd_____|_____________Word______________|LDR PC
 __7_|_0___1___0___1_|__Op___|_0_|___Ro______|____Rb_____|____Rd_____|LDR/STR
 __8_|_0___1___0___1_|__Op___|_1_|___Ro______|____Rb_____|____Rd_____|""H/SB/SH
 __9_|_0___1___1_|__Op___|_______Offset______|____Rb_____|____Rd_____|""{B}
 _10_|_1___0___0___0_|Op_|_______Offset______|____Rb_____|____Rd_____|""H
 _11_|_1___0___0___1_|Op_|____Rd_____|_____________Word______________|"" SP
 _12_|_1___0___1___0_|Op_|____Rd_____|_____________Word______________|ADD PC/SP
 _13_|_1___0___1___1___0___0___0___0_|_S_|___________Word____________|ADD SP,nn
 _14_|_1___0___1___1_|Op_|_1___0_|_R_|____________Rlist______________|PUSH/POP
 _17_|_1___0___1___1___1___1___1___0_|___________User_Data___________|ARM9:BKPT
 _X__|_1___0___1___1___   ..............................             |ARM11...
  0110 011 Change Processor State        CPS on page B4-2
  0001 xxx Compare and Branch on Zero    CBNZ, CBZ on page A6-52
  1011 xxx Compare and Branch on Nonzero CBNZ, CBZ on page A6-52
  0011 xxx Compare and Branch on Zero    CBNZ, CBZ on page A6-52
  1001 xxx Compare and Branch on Nonzero CBNZ, CBZ on page A6-52
  0010 00x Signed Extend Halfword        SXTH on page A6-256
  0010 01x Signed Extend Byte            SXTB on page A6-254
  0010 10x Unsigned Extend Halfword      UXTH on page A6-274
  0010 11x Unsigned Extend Byte          UXTB on page A6-272
  1010 00x Byte-Reverse Word             REV on page A6-191
  1010 01x Byte-Reverse Packed Halfword  REV16 on page A6-192
  1010 11x Byte-Reverse Signed Halfword  REVSH on page A6-193
  1111 xxx If-Then, and hints If-Then, and hints on page A5-11
 _15_|_1___1___0___0_|Op_|____Rb_____|____________Rlist______________|STM/LDM
 _16_|_1___1___0___1_|_____Cond______|_________Signed_Offset_________|B{cond}
 _U__|_1___1___0___1___1___1___1___0_|_____________var_______________|UndefARM9
 _17_|_1___1___0___1___1___1___1___1_|___________User_Data___________|SWI
 _18_|_1___1___1___0___0_|________________Offset_____________________|B
 _19_|_1___1___1___0___1_|_________________________var___________|_0_|BLX.ARM9
 _U__|_1___1___1___0___1_|_________________________var___________|_1_|UndefARM9
 _19_|_1___1___1___1_|_H_|______________Offset_Low/High______________|BL,BLX
```


Further UNDEFS ??? ARM9?

- 1011 0001 xxxxxxxx (reserved)
- 1011 0x1x xxxxxxxx (reserved)
- 1011 10xx xxxxxxxx (reserved)
- 1011 1111 xxxxxxxx (reserved)
- 1101 1110 xxxxxxxx (free for user)




# <a name="thumbopcodesregisteroperationsalubx"></a>THUMB Opcodes: Register Operations (ALU, BX)




## THUMB.1: move shifted register


```
  15-13  Must be 000b for 'move shifted register' instructions
  12-11  Opcode
           00b: LSL{S} Rd,Rs,#Offset   (logical/arithmetic shift left)
           01b: LSR{S} Rd,Rs,#Offset   (logical    shift right)
           10b: ASR{S} Rd,Rs,#Offset   (arithmetic shift right)
           11b: Reserved (used for add/subtract instructions)
  10-6   Offset                     (0-31)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
```

Example: LSL Rd,Rs,#nn ; Rd = Rs \<\< nn ; ARM equivalent: MOVS Rd,Rs,LSL
#nn

Zero shift amount is having special meaning (same as for ARM shifts), LSL#0
performs no shift (the carry flag remains unchanged), LSR/ASR#0 are interpreted
as LSR/ASR#32. Attempts to specify LSR/ASR#0 in source code are automatically
redirected as LSL#0, and source LSR/ASR#32 is redirected as opcode LSR/ASR#0.

Execution Time: 1S

Flags: Z=zeroflag, N=sign, C=carry (except LSL#0: C=unchanged), V=unchanged.



## THUMB.2: add/subtract


```
  15-11  Must be 00011b for 'add/subtract' instructions
  10-9   Opcode (0-3)
           0: ADD{S} Rd,Rs,Rn   ;add register        Rd=Rs+Rn
           1: SUB{S} Rd,Rs,Rn   ;subtract register   Rd=Rs-Rn
           2: ADD{S} Rd,Rs,#nn  ;add immediate       Rd=Rs+nn
           3: SUB{S} Rd,Rs,#nn  ;subtract immediate  Rd=Rs-nn
         Pseudo/alias opcode with Imm=0:
           2: MOV{ADDS} Rd,Rs      ;move (affects cpsr) Rd=Rs+0
  8-6    For Register Operand:
           Rn - Register Operand (R0..R7)
         For Immediate Operand:
           nn - Immediate Value  (0-7)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
```

Return: Rd contains result, N,Z,C,V affected (including MOV).

Execution Time: 1S



## THUMB.3: move/compare/add/subtract immediate


```
  15-13  Must be 001b for this type of instructions
  12-11  Opcode
           00b: MOV{S} Rd,#nn      ;move     Rd   = #nn
           01b: CMP{S} Rd,#nn      ;compare  Void = Rd - #nn
           10b: ADD{S} Rd,#nn      ;add      Rd   = Rd + #nn
           11b: SUB{S} Rd,#nn      ;subtract Rd   = Rd - #nn
  10-8   Rd - Destination Register  (R0..R7)
  7-0    nn - Unsigned Immediate    (0-255)
```

ARM equivalents for MOV/CMP/ADD/SUB are MOVS/CMP/ADDS/SUBS same format.

Execution Time: 1S

Return: Rd contains result (except CMP), N,Z,C,V affected (for MOV only N,Z).



## THUMB.4: ALU operations


```
  15-10  Must be 010000b for this type of instructions
  9-6    Opcode (0-Fh)
           0: AND{S} Rd,Rs     ;AND logical       Rd = Rd AND Rs
           1: EOR{S} Rd,Rs     ;XOR logical       Rd = Rd XOR Rs
           2: LSL{S} Rd,Rs     ;log. shift left   Rd = Rd << (Rs AND 0FFh)
           3: LSR{S} Rd,Rs     ;log. shift right  Rd = Rd >> (Rs AND 0FFh)
           4: ASR{S} Rd,Rs     ;arit shift right  Rd = Rd SAR (Rs AND 0FFh)
           5: ADC{S} Rd,Rs     ;add with carry    Rd = Rd + Rs + Cy
           6: SBC{S} Rd,Rs     ;sub with carry    Rd = Rd - Rs - NOT Cy
           7: ROR{S} Rd,Rs     ;rotate right      Rd = Rd ROR (Rs AND 0FFh)
           8: TST    Rd,Rs     ;test            Void = Rd AND Rs
           9: NEG{S} Rd,Rs     ;negate            Rd = 0 - Rs
           A: CMP    Rd,Rs     ;compare         Void = Rd - Rs
           B: CMN    Rd,Rs     ;neg.compare     Void = Rd + Rs
           C: ORR{S} Rd,Rs     ;OR logical        Rd = Rd OR Rs
           D: MUL{S} Rd,Rs     ;multiply          Rd = Rd * Rs
           E: BIC{S} Rd,Rs     ;bit clear         Rd = Rd AND NOT Rs
           F: MVN{S} Rd,Rs     ;not               Rd = NOT Rs
  5-3    Rs - Source Register       (R0..R7)
  2-0    Rd - Destination Register  (R0..R7)
```

ARM equivalent for NEG would be RSBS.

Return: Rd contains result (except TST,CMP,CMN),

Affected Flags:

```
  N,Z,C,V for  ADC,SBC,NEG,CMP,CMN
  N,Z,C   for  LSL,LSR,ASR,ROR (carry flag unchanged if zero shift amount)
  N,Z,C   for  MUL on ARMv4 and below: carry flag destroyed
  N,Z     for  MUL on ARMv5 and above: carry flag unchanged
  N,Z     for  AND,EOR,TST,ORR,BIC,MVN
```

Execution Time:

```
  1S      for  AND,EOR,ADC,SBC,TST,NEG,CMP,CMN,ORR,BIC,MVN
  1S+1I   for  LSL,LSR,ASR,ROR
  1S+mI   for  MUL on ARMv4 (m=1..4; depending on MSBs of incoming Rd value)
  1S+mI   for  MUL on ARMv5 (m=3; fucking slow, no matter of MSBs of Rd value)
```



## THUMB.5: Hi register operations/branch exchange


```
  15-10  Must be 010001b for this type of instructions
  9-8    Opcode (0-3)
           0: ADD Rd,Rs   ;add        Rd = Rd+Rs
           1: CMP Rd,Rs   ;compare  Void = Rd-Rs  ;CPSR affected
           2: MOV Rd,Rs   ;move       Rd = Rs
           2: NOP         ;nop        R8 = R8
           3: BX  Rs      ;jump       PC = Rs     ;may switch THUMB/ARM
           3: BLX Rs      ;call       PC = Rs     ;may switch THUMB/ARM (ARM9)
  7      MSBd - Destination Register most significant bit (or BL/BLX flag)
  6      MSBs - Source Register most significant bit
  5-3    Rs - Source Register        (together with MSBs: R0..R15)
  2-0    Rd - Destination Register   (together with MSBd: R0..R15)
```

Restrictions: For ADD/CMP/MOV, MSBs and/or MSBd must be set, ie. it is not
allowed that both are cleared.

When using R15 (PC) as operand, the value will be the address of the
instruction plus 4 (ie. $+4). Except for BX R15: CPU switches to ARM state, and
PC is auto-aligned as (($+4) AND NOT 2).

For BX, MSBs may be 0 or 1, MSBd must be zero, Rd is not used/zero.

For BLX, MSBs may be 0 or 1, MSBd must be set, Rd is not used/zero.

For BX/BLX, when Bit 0 of the value in Rs is zero:

```
  Processor will be switched into ARM mode!
  If so, Bit 1 of Rs must be cleared (32bit word aligned).
  Thus, BX PC (switch to ARM) may be issued from word-aligned address
  only, the destination is PC+4 (ie. the following halfword is skipped).
```

BLX may not use R15. BLX saves the return address as LR=PC+3 (with thumb bit).

Using BLX R14 is possible (sets PC=Old\_LR, and New\_LR=retadr).

Assemblers/Disassemblers should use MOV R8,R8 as NOP (in THUMB mode).

Return: Only CMP affects CPSR condition flags!

Execution Time:

```
 1S     for ADD/MOV/CMP
 2S+1N  for ADD/MOV with Rd=R15, and for BX
```




# <a name="thumbopcodesmemoryloadstoreldrstr"></a>THUMB Opcodes: Memory Load/Store (LDR/STR)




## THUMB.6: load PC-relative (for loading immediates from literal pool)


```
  15-11  Must be 01001b for this type of instructions
  N/A    Opcode (fixed)
           LDR Rd,[PC,#nn]      ;load 32bit    Rd = WORD[PC+nn]
  10-8   Rd - Destination Register   (R0..R7)
  7-0    nn - Unsigned offset        (0-1020 in steps of 4)
```

The value of PC will be interpreted as (($+4) AND NOT 2).

Return: No flags affected, data loaded into Rd.

Execution Time: 1S+1N+1I



## THUMB.7: load/store with register offset


```
  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STR  Rd,[Rb,Ro]   ;store 32bit data  WORD[Rb+Ro] = Rd
          1: STRB Rd,[Rb,Ro]   ;store  8bit data  BYTE[Rb+Ro] = Rd
          2: LDR  Rd,[Rb,Ro]   ;load  32bit data  Rd = WORD[Rb+Ro]
          3: LDRB Rd,[Rb,Ro]   ;load   8bit data  Rd = BYTE[Rb+Ro]
  9      Must be zero (0) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
```

Return: No flags affected, data loaded either into Rd or into memory.

Execution Time: 1S+1N+1I for LDR, or 2N for STR



## THUMB.8: load/store sign-extended byte/halfword


```
  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STRH Rd,[Rb,Ro]  ;store 16bit data          HALFWORD[Rb+Ro] = Rd
          1: LDSB Rd,[Rb,Ro]  ;load sign-extended 8bit   Rd = BYTE[Rb+Ro]
          2: LDRH Rd,[Rb,Ro]  ;load zero-extended 16bit  Rd = HALFWORD[Rb+Ro]
          3: LDSH Rd,[Rb,Ro]  ;load sign-extended 16bit  Rd = HALFWORD[Rb+Ro]
  9      Must be set (1) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
```

Return: No flags affected, data loaded either into Rd or into memory.

Execution Time: 1S+1N+1I for LDR, or 2N for STR



## THUMB.9: load/store with immediate offset


```
  15-13  Must be 011b for this type of instructions
  12-11  Opcode (0-3)
          0: STR  Rd,[Rb,#nn]  ;store 32bit data   WORD[Rb+nn] = Rd
          1: LDR  Rd,[Rb,#nn]  ;load  32bit data   Rd = WORD[Rb+nn]
          2: STRB Rd,[Rb,#nn]  ;store  8bit data   BYTE[Rb+nn] = Rd
          3: LDRB Rd,[Rb,#nn]  ;load   8bit data   Rd = BYTE[Rb+nn]
  10-6   nn - Unsigned Offset              (0-31 for BYTE, 0-124 for WORD)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
```

Return: No flags affected, data loaded either into Rd or into memory.

Execution Time: 1S+1N+1I for LDR, or 2N for STR



## THUMB.10: load/store halfword


```
  15-12  Must be 1000b for this type of instructions
  11     Opcode (0-1)
          0: STRH Rd,[Rb,#nn]  ;store 16bit data   HALFWORD[Rb+nn] = Rd
          1: LDRH Rd,[Rb,#nn]  ;load  16bit data   Rd = HALFWORD[Rb+nn]
  10-6   nn - Unsigned Offset              (0-62, step 2)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
```

Return: No flags affected, data loaded either into Rd or into memory.

Execution Time: 1S+1N+1I for LDR, or 2N for STR



## THUMB.11: load/store SP-relative


```
  15-12  Must be 1001b for this type of instructions
  11     Opcode (0-1)
          0: STR  Rd,[SP,#nn]  ;store 32bit data   WORD[SP+nn] = Rd
          1: LDR  Rd,[SP,#nn]  ;load  32bit data   Rd = WORD[SP+nn]
  10-8   Rd - Source/Destination Register  (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
```

Return: No flags affected, data loaded either into Rd or into memory.

Execution Time: 1S+1N+1I for LDR, or 2N for STR




# <a name="thumbopcodesmemoryaddressingaddpcsp"></a>THUMB Opcodes: Memory Addressing (ADD PC/SP)




## THUMB.12: get relative address


```
  15-12  Must be 1010b for this type of instructions
  11     Opcode/Source Register (0-1)
          0: ADD  Rd,PC,#nn    ;Rd = (($+4) AND NOT 2) + nn
          1: ADD  Rd,SP,#nn    ;Rd = SP + nn
  10-8   Rd - Destination Register         (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
```

Return: No flags affected, result in Rd.

Execution Time: 1S



## THUMB.13: add offset to stack pointer


```
  15-8   Must be 10110000b for this type of instructions
  7      Opcode/Sign
          0: ADD  SP,#nn       ;SP = SP + nn
          1: ADD  SP,#-nn      ;SP = SP - nn
  6-0    nn - Unsigned Offset    (0-508, step 4)
```

Return: No flags affected, SP adjusted.

Execution Time: 1S




# <a name="thumbopcodesmemorymultipleloadstorepushpopandldmstm"></a>THUMB Opcodes: Memory Multiple Load/Store (PUSH/POP and LDM/STM)




## THUMB.14: push/pop registers


```
  15-12  Must be 1011b for this type of instructions
  11     Opcode (0-1)
          0: PUSH {Rlist}{LR}   ;store in memory, decrements SP (R13)
          1: POP  {Rlist}{PC}   ;load from memory, increments SP (R13)
  10-9   Must be 10b for this type of instructions
  8      PC/LR Bit (0-1)
          0: No
          1: PUSH LR (R14), or POP PC (R15)
  7-0    Rlist - List of Registers (R7..R0)
```

In THUMB mode stack is always meant to be 'full descending', ie. PUSH is
equivalent to 'STMFD/STMDB' and POP to 'LDMFD/LDMIA' in ARM mode.

Examples:

```
 PUSH {R0-R3}     ;push R0,R1,R2,R3
 PUSH {R0,R2,LR}  ;push R0,R2,LR
 POP  {R4,R7}     ;pop R4,R7
 POP  {R2-R4,PC}  ;pop R2,R3,R4,PC
```

Note: When calling to a sub-routine, the return address is stored in LR
register, when calling further sub-routines, PUSH {LR} must be used to save
higher return address on stack. If so, POP {PC} can be later used to return
from the sub-routine.

POP {PC} ignores the least significant bit of the return address (processor
remains in thumb state even if bit0 was cleared), when intending to return with
optional mode switch, use a POP/BX combination (eg. POP {R3} / BX R3).

ARM9: POP {PC} copies the LSB to thumb bit (switches to ARM if bit0=0).

Return: No flags affected, SP adjusted, registers loaded/stored.

Execution Time: nS+1N+1I (POP), (n+1)S+2N+1I (POP PC), or (n-1)S+2N (PUSH).



## THUMB.15: multiple load/store


```
  15-12  Must be 1100b for this type of instructions
  11     Opcode (0-1)
          0: STMIA Rb!,{Rlist}   ;store in memory, increments Rb
          1: LDMIA Rb!,{Rlist}   ;load from memory, increments Rb
  10-8   Rb - Base register (modified) (R0-R7)
  7-0    Rlist - List of Registers     (R7..R0)
```

Both STM and LDM are incrementing the Base Register.

The lowest register in the list (ie. R0, if it's in the list) is stored/loaded
at the lowest memory address.

Examples:

```
 STMIA R7!,{R0-R2}  ;store R0,R1,R2
 LDMIA R0!,{R1,R5}  ;store R1,R5
```

Return: No flags affected, Rb adjusted, registers loaded/stored.

Execution Time: nS+1N+1I for LDM, or (n-1)S+2N for STM.



## Strange Effects on Invalid Rlist's


Empty Rlist: R15 loaded/stored (ARMv4 only), and Rb=Rb+40h (ARMv4-v5).

Writeback with Rb included in Rlist: Store OLD base if Rb is FIRST entry in
Rlist, otherwise store NEW base (STM/ARMv4), always store OLD base (STM/ARMv5),
no writeback (LDM/ARMv4/ARMv5; at this point, THUMB opcodes work different than
ARM opcodes).




# <a name="thumbopcodesjumpsandcalls"></a>THUMB Opcodes: Jumps and Calls




## THUMB.16: conditional branch


```
  15-12  Must be 1101b for this type of instructions
  11-8   Opcode/Condition (0-Fh)
          0: BEQ label        ;Z=1         ;equal (zero) (same)
          1: BNE label        ;Z=0         ;not equal (nonzero) (not same)
          2: BCS/BHS label    ;C=1         ;unsigned higher or same (carry set)
          3: BCC/BLO label    ;C=0         ;unsigned lower (carry cleared)
          4: BMI label        ;N=1         ;signed  negative (minus)
          5: BPL label        ;N=0         ;signed  positive or zero (plus)
          6: BVS label        ;V=1         ;signed  overflow (V set)
          7: BVC label        ;V=0         ;signed  no overflow (V cleared)
          8: BHI label        ;C=1 and Z=0 ;unsigned higher
          9: BLS label        ;C=0 or Z=1  ;unsigned lower or same
          A: BGE label        ;N=V         ;signed greater or equal
          B: BLT label        ;N<>V        ;signed less than
          C: BGT label        ;Z=0 and N=V ;signed greater than
          D: BLE label        ;Z=1 or N<>V ;signed less or equal
          E: Undefined, should not be used
          F: Reserved for SWI instruction (see SWI opcode)
  7-0    Signed Offset, step 2 ($+4-256..$+4+254)
```

Destination address must by halfword aligned (ie. bit 0 cleared)

Return: No flags affected, PC adjusted if condition true

Execution Time:

```
  2S+1N   if condition true (jump executed)
  1S      if condition false
```



## BX and ADD/MOV PC


See also THUMB.5: BX Rs, and ADD/MOV PC,Rs.



## THUMB.18: unconditional branch


```
  15-11  Must be 11100b for this type of instructions
  N/A    Opcode (fixed)
          B label   ;branch (jump)
  10-0   Signed Offset, step 2 ($+4-2048..$+4+2046)
```

Return: No flags affected, PC adjusted.

Execution Time: 2S+1N



## THUMB.19: long branch with link


This may be used to call (or jump) to a subroutine, return address is saved in
LR (R14).

Unlike all other THUMB mode instructions, this instruction occupies 32bit of
memory which are split into two 16bit THUMB opcodes.

- First Instruction - LR = PC+4+(nn SHL 12)
  - 15-11  Must be 11110b for BL/BLX type of instructions
  - 10-0   nn - Upper 11 bits of Target Address
- Second Instruction - PC = LR + (nn SHL 1), and LR = PC+2 OR 1 (and BLX: T=0)
  - 15-11  Opcode
                  - 11111b: BL label   ;branch long with link
                  - 11101b: BLX label  ;branch long with link switch to ARM mode (ARM9)
  - 10-0   nn - Lower 11 bits of Target Address (BLX: Bit0 Must be zero)

The destination address range is (PC+4)-400000h..+3FFFFEh, ie. PC+/-4M.

Target must be halfword-aligned. As Bit 0 in LR is set, it may be used to
return by a BX LR instruction (keeping CPU in THUMB mode).

Return: No flags affected, PC adjusted, return address in LR.

Execution Time: 3S+1N (first opcode 1S, second opcode 2S+1N).

Note: Exceptions may or may not occur between first and second opcode, this is
"implementation defined" (unknown how this is implemented in GBA and NDS).

Using only the 2nd half of BL as "BL LR+imm" is possible (for example, Mario
Golf Advance Tour for GBA uses opcode F800h as "BL LR+0").



## THUMB.17: software interrupt and breakpoint


SWI supposed for calls to the operating system - Enter Supervisor mode (SVC) in
ARM state. BKPT intended for debugging - enters Abort mode in ARM state via
Prefetch Abort vector.

```
  15-8   Opcode
          11011111b: SWI nn   ;software interrupt
          10111110b: BKPT nn  ;software breakpoint (ARMv5 and up)
  7-0    nn - Comment Field, ignored by processor (8bit value) (0-255)
```

Execution Time: 2S+1N

The exception handler may interprete the SWI Comment Field by examining the
lower 8bit of the 16bit opcode opcode at [R14\_svc-2].

If your are also using SWI's from inside of ARM mode, then the SWI handler must
examine the T Bit SPSR\_svc in order to determine whether it's been a ARM SWI -
and if so, examine the lower 24bit of the 32bit opcode opcode at [R14\_svc-4].

For Returning from SWI use "MOVS PC,R14", that instruction does restore both PC
and CPSR, ie. PC=R14\_svc, and CPSR=SPSR\_svc, and (as called from THUMB mode),
it'll also restore THUMB mode.

Nesting SWIs: SPSR\_svc and R14\_svc should be saved on stack before either
invoking nested SWIs, or (if the IRQ handler uses SWIs) before enabling IRQs.

Execution SWI/BKPT:

```
  R14_svc=PC+2     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=<changed>   CPSR=<changed> ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
```




# <a name="thumbopcodesnewthumbopcodesinarm11"></a>THUMB Opcodes: New THUMB Opcodes in ARM11




## THUMB.X: signed/unsigned extend byte/halfword (ARMv6)


These unneccessary opcodes are apparently meant to reduce typical compiler
overload (eg. for ensuring that "for i=0 to 7" won't end up with
i>255).

```
  15-8   Must be 1011.0010b for this type of instructions
  7-6    Opcode
          00b  SXTH  Rd,Rm      ;sign-extend halfword
          01b  SXTB  Rd,Rm      ;sign-extend byte
          10b  UXTH  Rd,Rm      ;zero-extend halfword
          11b  UXTB  Rd,Rm      ;zero-extend byte
  5-3    Rm Source Register                    (R0-R7)
  2-0    Rd Destination Register               (R0-R7)
```

Return: No flags affected (though unspecified?).

Execution Time: ?



## THUMB.X: byte-reverse word/halfword(s) (ARMv6)


```
  15-8   Must be 1011.1010b for this type of instructions
  7-6    Opcode
          00b  REV   Rd,Rm      ;swap byte3/byte0 and byte2/byte1  ;word
          01b  REV16 Rd,Rm      ;swap byte3/byte2 and byte1/byte0  ;packed half
          11b  REVSH Rd,Rm      ;swap byte1/byte0 and sign-extend  ;signed half
  5-3    Rm Source Register                    (R0-R7)
  2-0    Rd Destination Register               (R0-R7)
```

Return: No flags affected (though unspecified?).

Execution Time: ?



## SETEND (ARMv6)


```
  15-4   Must be 101101100101b
  3      Opcode:
           0: SETEND LE   ;clear CPSR.E bit (little endian data access)
           1: SETEND BE   ;set CPSR.E bit (big endian data access)
  2-0    Should be 000b
```



## THUMB.X: change processor state (ARMv6)


```
  15-5   Must be 10110110011b
  4      Opcode:
           0: CPSIE {A}{I}{F}   ;Interrupt Enable
           1: CPSID {A}{I}{F}   ;Interrupt Disable
  3      Must be 0b
  2      A  Affect CPSR.A (?)    (0=No, 1=Yes)
  1      I  Affect CPSR.I (IRQ)  (0=No, 1=Yes)
  0      F  Affect CPSR.F (FIQ)  (0=No, 1=Yes)
```



## CPY


```
  15-8   Must be 01000110b for CPY Rd,Rm
  7      MSB of Rd
  6      MSB of Rm
  5-3    Rm Source Register
  2-0    Rd Destination Register
```

Move without changing flags. It's called CPY because THUMB syntax didn't
distinguish between MOV and MOVS (until UAL syntax was invented, which makes
the name CPY irrelevant).

CPY is officially supported in "T variants of ARMv6 and above" (in practice, it
should work on ARMv4T and up, but wasn't officially documented until ARMv6).





# <a name="armpseudoinstructionsanddirectives"></a>ARM Pseudo Instructions and Directives




## ARM Pseudo Instructions


```
  nop              mov r0,r0
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field
  add Rd,=addr     add/sub Rd,r15,disp
  adr Rd,addr      add/sub Rd,r15,disp
  adrl Rd,addr     two add/sub opcodes with disp=xx00h+00yyh
  mov Rd,Imm       mvn Rd,NOT Imm    ;or vice-versa
  and Rd,Rn,Imm    bic Rd,Rn,NOT Imm ;or vice-versa
  cmp Rd,Rn,Imm    cmn Rd,Rn,-Imm    ;or vice-versa
  add Rd,Rn,Imm    sub Rd,Rn,-Imm    ;or vice-versa
```

All above opcodes may be made conditional by specifying a {cond} field.



## THUMB Pseudo Instructions


```
  nop              mov r8,r8
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field
  add Rd,=addr     add Rd,r15,disp
  adr Rd,addr      add Rd,r15,disp
  mov Rd,Rs        add Rd,Rs,0       ;with Rd,Rs in range r0-r7 each
```



## A22i Directives


```
  org  adr     assume following code from this address on
  .gba         indicate GBA program
  .nds         indicate NDS program
  .dsi         indicate DSi program
  .firm3ds     indicate 3DS program (.firm format)
  .fix         fix GBA/NDS/DSi header checksum
  .ereader_create_bmp      create GBA e-Reader dotcode .BMP file(s) (bitmaps)
  .ereader_create_raw      create GBA e-Reader dotcode .RAW file (useless)
  .ereader_create_bin      create GBA e-Reader dotcode .BIN file (smallest)
  .ereader_japan_plus      japanese/plus     (default is non-japanese)
  .ereader_japan_original  japanese/original (with Z80-stub for GBA-code)
  .title 'Txt' defines a title (used for e-Reader dotcodes)
  .teak        select TeakLiteII instruction set (for DSi DSP)
  .xtensa      select Xtensa instruction set (for DSi Atheros Wifi)
  .rl78        select RL78 instruction set (for 3DS MCU)
  .norewrite   do not delete existing output file (keep following data in file)
  .data?       following defines RAM data structure (assembled to nowhere)
  .code        following is normal ROM code/data (assembled to ROM image)
  .include     includes specified source code file (no nesting/error handling)
  .import      imports specified binary file (optional parameters: ,begin,len)
  .radix nn    changes default numeric format (nn=2,8,10,16 = bin/oct/dec/hex)
  .errif expr  generates an error message if expression is nonzero
  .if expr     assembles following code only if expression is nonzero
  .else        invert previous .if condition
  .endif       terminate .if/.ifdef/.ifndef
  .ifdef sym   assemble following only if symbol is defined
  .ifndef sym  assemble following only if symbol is not defined
  .align nn    aligns to an address divisible-by-nn, inserts 00's
  .msg         defines a no$gba debugmessage string, such like .msg 'Init Okay'
  .brk         defines a no$gba source code break opcode
  l equ n      l=n
  l:   [cmd]   l=$   (global label)
  @@l: [cmd]   @@l=$ (local label, all locals are reset at next global label)
  end          end of source code
  db ...       define 8bit data (bytes)
  dw ...       define 16bit data (halfwords)
  dd ...       define 32bit data (words)
  defs nn      define nn bytes space (zero-filled)
  ;...         defines a comment (ignored by the assembler)
  //           alias for CRLF, eg. allows <db 'Text',0 // dw addr> in one line
```



## A22i Alias Directives (for compatibility with other assemblers)


```
  align        .align 4          code16    .thumb
  align nn     .align nn         .code 16  .thumb
  % nn         defs nn           code32    .arm
  .space nn    defs nn           .code 32  .arm
  ..ds nn      defs nn           ltorg     .pool
  x=n          x equ n           .ltorg    .pool
  .equ x,n     x equ n           ..ltorg   .pool
  .define x n  x equ n           dcb       db (8bit data)
  incbin       .import           defb      db (8bit data)
  @@@...       ;comment          .byte     db (8bit data)
  @ ...        ;comment          .ascii    db (8bit string)
  @*...        ;comment          dcw       dw (16bit data)
  @...         ;comment          defw      dw (16bit data)
  .text        .code             .hword    dw (16bit data)
  .bss         .data?            dcd       dd (32bit data)
  .global      (ignored)         defd      dd (32bit data)
  .extern      (ignored)         .long     dd (32bit data)
  .thumb_func  (ignored)         .word     dw/dd, don't use
  #directive   .directive        .end      end
  .fill nn,1,0 defs nn
```



## Alias Conditions, Opcodes, Operands


```
  hs   cs   ;condition higher or same = carry set
  lo   cc   ;condition lower = carry cleared
  asl  lsl  ;arithmetic shift left = logical shift left
```



## A22i Numeric Formats & Dialects


```
  Type          Normal       Alias
  Decimal       85           #85  &d85
  Hexadecimal   55h          #55h  0x55  #0x55  $55  &h55
  Octal         125o         0o125  &o125
  Ascii         'U'          "U"
  Binary        01010101b    %01010101  0b01010101  &b01010101
  Roman         &rLXXXV      (very useful for arrays of kings and chapters)
```

Note: The default numeric format can be changed by the .radix directive
(usually 10=decimal). For example, with radix 16, values like "85" and "0101b"
are treated as hexadecimal numbers (in that case, decimal and binary numbers
can be still defined with prefixes &d and &b).



## A22i Numeric Operators Priority


```
  Prio  Operator           Aliases
  8     (,) brackets
  7     +,- sign
  6     *,/,MOD,SHL,SHR    MUL,DIV,<<,>>
  5     +,- operation
  4     EQ,GE,GT,LE,LT,NE  =,>=,>,<=,<,<>,==,!=
  3     NOT
  2     AND
  1     OR,XOR             EOR
```

Operators of same priority are processed from left to right.

Boolean operators (priority 4) return 1=TRUE, 0=FALSE.



## A22i Nocash Syntax


Even though A22i does recognize the official ARM syntax, it's also allowing to
use friendly code:

```
  mov   r0,0ffh         ;no C64-style "#", and no C-style "0x" required
  stmia [r7]!,r0,r4-r5  ;square [base] brackets, no fancy {rlist} brackets
  mov   r0,cpsr         ;no confusing MSR and MRS (whatever which is which)
  mov   r0,p0,0,c0,c0,0 ;no confusing MCR and MRC (whatever which is which)
  ldr   r0,[score]      ;allows to use clean brackets for relative addresses
  push  rlist           ;alias for stmfd [r13]!,rlist (and same for pop/ldmfd)
  label:                ;label definitions recommended to use ":" colons
```


[A22i is the no$gba debug version's built-in source code assembler.]




# <a name="armcp14icebreakerdebugcommunicationschannel"></a>ARM CP14 ICEbreaker Debug Communications Channel



The ICEbreaker aka EmbeddedICE module may be found in ARM7TDMI and possibly
also in other ARM processors. The main functionality of the module relies on
external inputs (BREAKPT signal, etc.) being controlled by external debugging
hardware. At software side, ICEbreaker contains a Debug Communications Channel
(again to access external hardware), which can be accessed as coprocessor 14
via following opcodes:

```
  MRC{cond} P14,0,Rd,C0,C0,0  ;Read Debug Comms Control Register
  MRC{cond} P14,0,Rd,C1,C0,0  ;Read Debug Comms Data Register
  MRC{cond} P14,0,Rd,C2,C0,0  ;Read Debug Comms Status Register
  MCR{cond} P14,0,Rd,C1,C0,0  ;Write Debug Comms Data Register
  MCR{cond} P14,0,Rd,C2,C0,0  ;Write Debug Comms Status Register
```

The Control register consists of Bit31-28=ICEbreaker version (0001b for
ARM7TDMI), Bit27-2=Not specified, Bit0/Bit1=Data Read/Write Status Flags.


The NDS7 and GBA allow to access CP14 (unlike as for CP0..CP13 & CP15,
access to CP14 doesn't generate any exceptions), however, the ICEbreaker module
appears to be disabled (or completely unimplemented), any reads from
P14,0,Rd,C0,C0,0 through P14,7,Rd,C15,C15,7 are simply returning the prefetched
opcode value from [$+8]. ICEbreaker might be eventually used and enabled in
Nintendo's hardware debuggers, although external breakpoints are reportedly
implemented via /FIQ input rather than via ICEbreaker hardware.

The NDS9 doesn't include a CP14 unit (or it is fully disabled), any attempts to
access it are causing invalid instruction exceptions.




# <a name="armcp15systemcontrolcoprocessor"></a>ARM CP15 System Control Coprocessor



- [ARM CP15 Overview](#armcp15overview)
- [ARM CP15 ID Codes](#armcp15idcodes)
- [ARM CP15 Control Register](#armcp15controlregister)
- [ARM CP15 Memory Managment Unit (MMU)](#armcp15memorymanagmentunitmmu)
- [ARM CP15 Protection Unit (PU)](#armcp15protectionunitpu)
- [ARM CP15 Cache Control](#armcp15cachecontrol)
- [ARM CP15 Tightly Coupled Memory (TCM)](#armcp15tightlycoupledmemorytcm)
- [ARM CP15 Misc](#armcp15misc)



# <a name="armcp15overview"></a>ARM CP15 Overview




## CP15


In many ARM CPUs, particulary such with memory control facilities, coprocessor
number 15 (CP15) is used as built-in System Control Coprocessor.

CPUs without memory control functions typically don't include a CP15 at all, in
that case even an attempt to read the Main ID register will cause an Undefined
Instruction exception.



## CP15 Opcodes


CP15 can be accessed via MCR and MRC opcodes, with Pn=P15, and \<cpopc>=0.

```
  MCR{cond} P15,<cpopc>,Rd,Cn,Cm,<cp>   ;move from ARM to CP15
  MRC{cond} P15,<cpopc>,Rd,Cn,Cm,<cp>   ;move from CP15 to ARM
```

Rd can be any ARM register in range R0-R14, R15 should not be used with P15.

\<cpopc>,Cn,Cm,\<cp> are used to select a CP15 register, eg.
0,C0,C0,0 = Main ID Register.

Other coprocessor opcodes (CDP, LDC, STC) cannot be used with P15.



## CP15 Register List


```
  Register       Expl.
  0,C0,C0,0      Main ID Register (R)
  0,C0,C0,1      Cache Type and Size (R)
  0,C0,C0,2      TCM Physical Size (R)
  0,C0,C0,3      ARM11: TLB Type Register
  0,C0,C1,0      ARM11: Processor Feature Register 0
  0,C0,C1,1      ARM11: Processor Feature Register 1
  0,C0,C1,2      ARM11: Debug Feature Register 0
  0,C0,C1,3      ARM11: Auxiliary Feature Register 0
  0,C0,C1,4      ARM11: Memory Model Feature Register 0
  0,C0,C1,5      ARM11: Memory Model Feature Register 1
  0,C0,C1,6      ARM11: Memory Model Feature Register 2
  0,C0,C1,7      ARM11: Memory Model Feature Register 3
  0,C0,C2,0      ARM11: Set Attributes Register 0
  0,C0,C2,1      ARM11: Set Attributes Register 1
  0,C0,C2,2      ARM11: Set Attributes Register 2
  0,C0,C2,3      ARM11: Set Attributes Register 3
  0,C0,C2,4      ARM11: Set Attributes Register 4
  0,C0,C2,5      ARM11: Set Attributes Register 5
```


```
  0,C1,C0,0      Control Register (R/W, or R=Fixed)
  0,C1,C0,1      ARM11: Auxiliary Control Register
  0,C1,C0,2      ARM11: Coprocessor Access Control Register
  0,C2,C0,0      ARM11: Translation Table Base Register 0
  0,C2,C0,1      ARM11: Translation Table Base Register 1
  0,C2,C0,2      ARM11: Translation Table Base Control Register
  0,C3,C0,0      ARM11: Domain Access Control Register
  0,C5,C0,0      ARM11: Data Fault Status Register
  0,C5,C0,1      ARM11: Instruction Fault Status Register
  0,C6,C0,0      ARM11: Fault Address Register (FAR)
  0,C6,C0,1      ARM11: Watchpoint Fault Address Register (WFAR)
  0,C2,C0,0      PU Cachability Bits for Data/Unified Protection Region
  0,C2,C0,1      PU Cachability Bits for Instruction Protection Region
  0,C3,C0,0      PU Cache Write-Bufferability Bits for Data Protection Regions
  0,C5,C0,0      PU Access Permission Data/Unified Protection Region
  0,C5,C0,1      PU Access Permission Instruction Protection Region
  0,C5,C0,2      PU Extended Access Permission Data/Unified Protection Region
  0,C5,C0,3      PU Extended Access Permission Instruction Protection Region
  0,C6,C0..C7,0  PU Protection Unit Data/Unified Region 0..7
  0,C6,C0..C7,1  PU Protection Unit Instruction Region 0..7
  0,C7,Cm,Op2    Cache Commands and Halt Function (W)
  0,C9,C0,0      Cache Data Lockdown
  0,C9,C0,1      Cache Instruction Lockdown
  0,C9,C1,0      TCM Data TCM Base and Virtual Size
  0,C9,C1,1      TCM Instruction TCM Base and Virtual Size
  0,C13,Cm,Op2   Misc Process ID registers
  0,C15,Cm,Op2   Misc Implementation Defined and Test/Debug registers
```



## Data/Unified Registers


Some Cache/PU/TCM registers are declared as "Data/Unified".

That registers are used for Data accesses in case that the CPU contains
separate Data and Instruction registers, otherwise the registers are used for
both (unified) Data and Instruction accesses.




# <a name="armcp15idcodes"></a>ARM CP15 ID Codes




## C0,C0,0 - Main ID Register (R)


```
  12-15 ARM Era (0=Pre-ARM7, 7=ARM7, other=Post-ARM7)
```

Post-ARM7 Processors

```
  0-3   Revision Number
  4-15  Primary Part Number (Bit12-15 must be other than 0 or 7)
        (eg. 946h for ARM946)
  16-19 Architecture        (1=v4, 2=v4T, 3=v5, 4=v5T, 5=v5TE, 6=v6, ?=v7)
  20-23 Variant Number
  24-31 Implementor         (41h=ARM, 44h=Digital Equipment Corp, 69h=Intel)
```

ARM7 Processors

```
  0-3   Revision Number
  4-15  Primary Part Number (Bit12-15 must be 7)
  16-22 Variant Number
  23    Architecture        (0=v3, 1=v4T)
  24-31 Implementor         (41h=ARM, 44h=Digital Equipment Corp, 69h=Intel)
```

Pre-ARM7 Processors

```
  0-3   Revision Number
  4-11  Processor ID LSBs (30h=ARM3/v2, 60h,61h,62=ARM600,610,620/v3)
  12-31 Processor ID MSBs (fixed, 41560h)
```

Note: On the NDS9, this register is 41059461h (ARMv5TE, ARM946, rev1). NDS7 and
GBA don't have CP15s.



## C0,C0,1 - Cache Type Register (R)


```
  0-11  Instruction Cache (bits 0-1=len, 2=m, 3-5=assoc, 6-8=size, 9-11=zero)
  12-23 Data Cache        (bits 0-1=len, 2=m, 3-5=assoc, 6-8=size, 9-11=zero)
  24    Separate Cache Flag (0=Unified, 1=Separate Data/Instruction Caches)
  25-28 Cache Type (0,1,2,6,7=see below, other=reserved)
         Type Method         Cache cleaning         Cache lock-down
         0    Write-through  Not needed             Not supported
         1    Write-back     Read data block        Not supported
         2    Write-back     Register 7 operations  Not supported
         6    Write-back     Register 7 operations  Format A
         7    Write-back     Register 7 operations  Format B      ;<-- NDS9
  29-31 Reserved (zero)
```

The 12bit Instruction/Data values are decoded as shown below,

```
  Cache Absent  = (ASSOC=0 and M=1)       ;in that case overriding below
  Cache Size    = 200h+(100h*M) shl SIZE  ;min 0.5Kbytes, max 96Kbytes
  Associativity = (1+(0.5*M)) shl ASSOC   ;min 1-way,     max 192-way
  Line Length   = 8 shl LEN               ;min 8 bytes,   max 64 bytes
```

For Unified cache (Bit 24=0), Instruction and Data values are identical.

Note: On the NDS9, this register is 0F0D2112h (Code=2000h bytes, Data=1000h
bytes, assoc=whatever, and line size 32 bytes each). NDS7 and GBA don't have
CP15s (nor any code/data cache).



## C0,C0,2 - Tightly Coupled Memory (TCM) Size Register (R)


```
  0-1   Reserved    (0)
  2     ITCM Absent (0=Present, 1=Absent)
  3-5   Reserved    (0)
  6-9   ITCM Size   (Size = 512 SHL N) (or 0=None)
  10-13 Reserved    (0)
  14    DTCM Absent (0=Present, 1=Absent)
  15-17 Reserved    (0)
  18-21 DTCM Size   (Size = 512 SHL N) (or 0=None)
  22-31 Reserved    (0)
```

Note: On the NDS9, this register is 00140180h (ITCM=8000h bytes, DTCM=4000h
bytes)). NDS7 and GBA don't have CP15s (nor any ITCM/DTCM).



## C0,C0,3..7 - Reserved (R)


Unused/Reserved registers, containing the same value as C0,C0,0.




# <a name="armcp15controlregister"></a>ARM CP15 Control Register




## C1,C0,0 - Control Register (R/W, or R=Fixed)


```
  0  MMU/PU Enable         (0=Disable, 1=Enable) (Fixed 0 if none)
  1  Alignment Fault Check (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  2  Data/Unified Cache    (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  3  Write Buffer          (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  4  Exception Handling    (0=26bit, 1=32bit)    (Fixed 1 if always 32bit)
  5  26bit-address faults  (0=Enable, 1=Disable) (Fixed 1 if always 32bit)
  6  Abort Model (pre v4)  (0=Early, 1=Late Abort) (Fixed 1 if ARMv4 and up)
  7  Endian                (0=Little, 1=Big)     (Fixed 0/1 if fixed)
  8  System Protection bit (MMU-only)
  9  ROM Protection bit    (MMU-only)
  10 Implementation defined
  11 Branch Prediction     (0=Disable, 1=Enable)
  12 Instruction Cache     (0=Disable, 1=Enable) (ignored if Unified cache)
  13 Exception Vectors     (0=00000000h, 1=FFFF0000h)
  14 Cache Replacement     (0=Normal/PseudoRandom, 1=Predictable/RoundRobin)
  15 Pre-ARMv5 Mode        (0=Normal, 1=Pre ARMv5; LDM/LDR/POP_PC.Bit0/Thumb)
  16 DTCM Enable           (0=Disable, 1=Enable)
  17 DTCM Load Mode        (0=R/W, 1=DTCM Write-only)
  18 ITCM Enable           (0=Disable, 1=Enable)
  19 ITCM Load Mode        (0=R/W, 1=ITCM Write-only)
  20 Reserved              (0)
  21 Reserved              (0)
  22 Unaligned Access      (?=Enable unaligned access and mixed endian)
  23 Extended Page Table   (0=Subpage AP Bits Enabled, 1=Disabled)
  24 Reserved              (0)
  25 CPSR E on exceptions  (0=Clear E bit, 1=Set E bit)
  26 Reserved              (0)
  27 FIQ Behaviour         (0=Normal FIQ behaviour, 1=FIQs behave as NMFI)
  28 TEX Remap bit         (0=No remapping, 1=Remap registers used)
  29 Force AP              (0=Access Bit not used, 1=AP[0] used as Access bit)
  30 Reserved              (0)
  31 Reserved              (0)
```

Various bits in this register may be read-only (fixed 0 if unsupported, or
fixed 1 if always activated).

On NDS ARM9, bit0,2,7,12..19 are R/W, bit3..6 are always set, all other bits
are always zero.

On 3DS ARM11, bit0..2,8..9,11..13,15,22..23,25,28..29 are R/W, bit3..6,14,16,18
are always set, all other bits are always zero.




# <a name="armcp15memorymanagmentunitmmu"></a>ARM CP15 Memory Managment Unit (MMU)



Nintendo consoles have a MMU on the ARM11 processor (in 3DS).


The MMU allows to assign virtual memory addresses, and to disable the data
cache in sensitive memory areas (eg. I/O area, and memory that is shared for
ARM9/ARM11). Additionally, it can trigger page fault exceptions (eg. for error
handling or memory mapped files).



## Related CP15 registers used in 3DS bootrom MMU init


```
  p15,0,c8,c5,0 ;Invalidate Instruction TLB               (=0)
  p15,0,c8,c6,0 ;Invalidate Data TLB                      (=0)
  p15,0,c2,c0,0 ;Translation Table Base 0 (for process)   (=1FFF4000h+2)
  p15,0,c2,c0,1 ;Translation Table Base 1 (for OS and I/O)(=1FFF4000h+2)
  p15,0,c2,c0,2 ;Translation Table Base Control           (=0)
  p15,0,c3,c0,0 ;Domain Access Control                    (=55555555h)
  p15,0,c1,c0,2 ;Coprocessor Access Control (unrelated?)  (=0F00000h)
```



## MMU Tables


1st Level table (size 4000h) divides 4Gbyte address space into 1Mbyte sections

2nd Level table(s) (size 400h each) divides a 1Mbyte section into 4Kbyte pages


```
 ________________________________ ARMv6 Tables ________________________________
```



## ARMv6 First-Level Page Table entries


```
   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
   1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0
  |__Ignored__________________________________________________|0_0| Fault
  |__Second-Level-Table-Address_______________|P|Domain_|_SBZ_|0_1| Coarse
  |__Address______________|0|0|n_S_A|_TEX_|AP_|P|Domain_|X_C_B|1_0| Section 1MB
  |__Address______|___SBZ___|1|_SBZ_|_TEX_|AP_|P|Ignored|X_C_B|1_0| Super 16MB
  |___________________________________________________________|1_1| Reserved
```

BUG: The Supersections do probably also have "n,S,A" flags, probably in
bit17-15, too (the 3DS bootrom seems to set those bits as so).



## ARMv6 Second-Level Page Table entries


```
   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
   1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0
  |__Ignored__________________________________________________|0_0| Fault
  |__Address______________________|X|_TEX_|n_S_A|_SBZ_|AP_|C_B|0_1| Large 64K
  |__Address______________________________|n_S_A|_TEX_|AP_|C_B|1_X| Small 4K
```


```
 ______________________________ Pre-ARMv6 Tables ______________________________
```


This is an older format, similar to the newer ARMv6 tables, but without the
"n,S,A,X" bits, and, instead, somehow allowing to divide 4K pages into smaller
1K snippets (with separate access privileges in AP0/AP1/AP2/AP3 bits, but
without TEX bits).



## Backwards-compatible First-Level Page Table entries


```
   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
   1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0
  |__Ignored__________________________________________________|0_0| Fault
  |__Second-Level-Table-Address_______________|P|Domain_|_SBZ_|0_1| Coarse
  |__Address______________|0|0|_SBZ_|_TEX_|AP_|P|Domain_|0_C_B|1_0| Section 1MB
  |__Address______|___SBZ___|1|_SBZ_|_TEX_|AP_|P|Ignored|0_C_B|1_0| Super 16MB
  |___________________________________________________________|1_1| Reserved
```



## Backwards-compatible Second-Level Page Table entries


```
   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
   1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0
  |__Ignored__________________________________________________|0_0| Fault
  |__Address______________________|_?TEX?_|AP3|AP2|AP1|AP0|C_B|0_1| Large 4x16K
  |__Address______________________________|AP3|AP2|AP1|AP0|C_B|1_0| Small 4x1K
  |__Address______________________________|_SBZ_|_TEX_|AP_|C_B|1_1| Extended 4K
```

BUG: The 4bit ?TEX? value is probably meant to be a 3bit TEX value, probably
with an unused/zero bit; in bit15 or so.


```
 ___________________________________ Notes ___________________________________
```



## Supersections and Large Pages


16Mbyte Supersections and 64Kbyte Large pages consist of 16 identical table
entries. Which is basically same as 16 Sections or 16 Pages with continously
increasing entries.

The advantage is internal caching: If one table entry is cached, then the
hardware knows that the other 15 nearby entries are supposed to be same; and
that they won't need to be loaded into internal cache.




# <a name="armcp15protectionunitpu"></a>ARM CP15 Protection Unit (PU)



Nintendo consoles have a PU on the ARM9 processor (in NDS, DSi, 3DS).


Protection Unit can be enabled in Bit0 of C1,C0,0 (Control Register).



## C2,C0,0 - Cachability Bits for Data/Unified Protection Region (R/W)



## C2,C0,1 - Cachability Bits for Instruction Protection Region (if any) (R/W)


```
  0-7  Cachable (C) bits for region 0-7
  8-31 Reserved/zero
```



## C3,C0,0 - Cache Write-Bufferability Bits for Data Protection Regions (R/W)


Allows to select what to do when writing to a cached memory snippet:

Write-Through stores the data in the cache line (so subsequent cache reads
return correct data), and additionally writes the data to underlaying memory.

Write-Back stores the data in the cache line only, and marks the line as dirty,
but doesn't update the underlaying memory (underlaying memory is updated only
when the CPU decides to use the cache line for other purposes, or when the user
is manually "Cleaning" the cache line).

```
  0-7  Bufferable (B) bits for region 0-7  (0=Write-Through, 1=Write-Back)
  8-31 Reserved/zero
```

Instruction fetches are, obviously, always read-operations. So, there are no
write-bufferability bits for Instruction Protection Regions.

Note: Unrelated to the "Cache Write-Bufferability", the ARM does also have a
"Write Buffer" (a small FIFO that can queue only a few writes).



## C5,C0,0 - Access Permission Data/Unified Protection Region (R/W)



## C5,C0,1 - Access Permission Instruction Protection Region (if any) (R/W)



## C5,C0,2 - Extended Access Permission Data/Unified Protection Region (R/W)



## C5,C0,3 - Extended Access Permission Instruction Protection Region (if any) (R/W)


For C5,C0,0 and C5,C0,1:

```
  0-15  Access Permission (AP) bits for region 0-7 (Bits 0-1=AP0, 2-3=AP1, etc)
  16-31 Reserved/zero
```

For C5,C0,2 and C5,C0,3 (Extended):

```
  0-31  Access Permission (AP) bits for region 0-7 (Bits 0-3=AP0, 4-7=AP1, etc)
```

The possible AP settings (0-3 for C5,C0,0..1, or 0-15 for C5,C0,2..3) are:

```
  AP  Privileged User
  0   -          -
  1   R/W        -
  2   R/W        R
  3   R/W        R/W
  5   R          -
  6   R          R
```

Settings 5,6 only for Extended Registers, settings 4,7..15 are Reserved.



## C6,C0..C7,0 - Protection Unit Data/Unified Region 0..7 (R/W)



## C6,C0..C7,1 - Protection Unit Instruction Region 0..7 (R/W) if any


```
  0     Protection Region Enable (0=Disable, 1=Enable)
  1-5   Protection Region Size   (2 SHL X) ;min=(X=11)=4KB, max=(X=31)=4GB
  6-11  Reserved/zero
  12-31 Protection Region Base address (Addr = Y*4K; must be SIZE-aligned)
```

Overlapping Regions are allowed, Region 7 is having highest priority, region 0
lowest priority.



## Background Region


Additionally, any memory areas outside of the eight Protection Regions are
handled as Background Region, this region has neither Read nor Write access.



## Unified Region Note


On the NDS, the Region registers are unified (C6,C0..C7,1 are read/write-able
mirrors of C6,C0..C7,0). Nethertheless, the Cachabilty and Permission registers
are NOT unified (separate registers exists for code and data settings).




# <a name="armcp15cachecontrol"></a>ARM CP15 Cache Control



Cache is enabled/controlled by Bit 2,3,12,14 in Control Register.

Cache regions are controlled via Protection Unit (PU).

Cache type can be detected via Cache Type Register.



## C7,C0..C15,0..7 - Cache Commands (W)


Write-only Cache Command Register. Cm,Op2 operands used to select a specific
command, with parameter value in Rd.

```
  Cn,Cm,Op2 Rd   ARM9 Command
  C7,C0,4   0    Yes  Wait For Interrupt (Halt)
  C7,C5,0   0    Yes  Invalidate Entire Instruction Cache
  C7,C5,1   VA   Yes  Invalidate Instruction Cache Line
  C7,C5,2   S/I  -    Invalidate Instruction Cache Line
  C7,C5,4   0    -    Flush Prefetch Buffer
  C7,C5,6   0    -    Flush Entire Branch Target Cache
  C7,C5,7   IMP? -    Flush Branch Target Cache Entry
  C7,C6,0   0    Yes  Invalidate Entire Data Cache
  C7,C6,1   VA   Yes  Invalidate Data Cache Line
  C7,C6,2   S/I  -    Invalidate Data Cache Line
  C7,C7,0   0    -    Invalidate Entire Unified Cache
  C7,C7,1   VA   -    Invalidate Unified Cache Line
  C7,C7,2   S/I  -    Invalidate Unified Cache Line
  C7,C8,2   0    Yes  Wait For Interrupt (Halt), alternately to C7,C0,4
  C7,C10,1  VA   Yes  Clean Data Cache Line
  C7,C10,2  S/I  Yes  Clean Data Cache Line
  C7,C10,4  0    -    Drain Write Buffer
  C7,C11,1  VA   -    Clean Unified Cache Line
  C7,C11,2  S/I  -    Clean Unified Cache Line
  C7,C13,1  VA   Yes  Prefetch Instruction Cache Line
  C7,C14,1  VA   Yes  Clean and Invalidate Data Cache Line
  C7,C14,2  S/I  Yes  Clean and Invalidate Data Cache Line
  C7,C15,1  VA   -    Clean and Invalidate Unified Cache Line
  C7,C15,2  S/I  -    Clean and Invalidate Unified Cache Line
```

Parameter values (Rd) formats:

```
  0    Not used, should be zero
  VA   Virtual Address
  S/I  Set/index; Bit 31..(32-A) = Index, Bit (L+S-1)..L = Set ?
```

Note:

```
  Invalidate means to forget all data
  Clean means to write-back dirty cache lines to underlaying memory
  (Clean is important when having "Cache Write-Bufferability" enabled in PU)
```



## C9,C0,0 - Data Cache Lockdown



## C9,C0,1 - Instruction Cache Lockdown


(Width (W) of index field depends on cache ASSOCIATIVETY.)

Format A:

```
  0..(31-W)  Reserved/zero
  (32-W)..31 Lockdown Block Index
```

Format B:

```
  0..(W-1)   Lockdown Block Index
  W..30      Reserved/zero
  31         L
```


Cache/Write-buffer should not be enabled for the whole 4GB memory area,
high-speed TCM memory doesn't require caching, and caching would have fatal
results on I/O ports. So, cache can be used only in combination with the
Protection Unit, which allows to enable/disable caching in specified regions.



## Note


ARMv5 instruction set supports a Cache Prepare for Load opcode (PLD), see

- [ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)](#armopcodesmemorysingledatatransferldrstrpld)


## Note


Data cache always requires PU/MMU. Code cache requires PU/MMU on ARM9, but also
works without PU/MMU on ARM11.




# <a name="armcp15tightlycoupledmemorytcm"></a>ARM CP15 Tightly Coupled Memory (TCM)



TCM is high-speed memory, directly contained in the ARM CPU core.



## TCM and DMA


TCM doesn't use the ARM bus. A minor disadvantage is that TCM cannot be
accessed by DMA. However, the main advantage is that, when using TCM, the CPU
can be kept running without any waitstates even while the bus is used for DMA
transfers. Operation during DMA works only if all code/data is located in TCM,
waitstates are generated if any code/data outside TCM is accessed; in worst
case (if there are no gaps in the DMA) then the CPU is halted until the DMA
finishes.



## TCM and DMA and IRQ


No idea if/how IRQs are handled during DMA? Eventually (unlikely) code in TCM
is kept executed until DMA finishes (ie. until the IRQ vector can be accessed.
Eventually the IRQ vector is instantly accessed (causing to halt the CPU until
DMA finishes). In both cases: Assuming that IRQs are enabled, and that the IRQ
vector and/or IRQ handler are located outside TCM.



## Separate Instruction (ITCM) and Data (DTCM) Memory


DTCM can be used only for Data accesses, typically used for stacks and other
frequently accessed data.

ITCM is primarily intended for instruction accesses, but it can be also used
for Data accesses (among others allowing to copy code to ITCM), however,
performance isn't optimal when simultaneously accessing ITCM for code and data
(such like opcodes in ITCM that use literal pool values in ITCM).



## TCM Enable, TCM Load Mode


CP15 Control Register allows to enable ITCM and DTCM, and to switch ITCM/DTCM
into Load Mode. In Load Mode (when TCM is enabled), TCM becomes write-only;
this allows to read data from source addresses in main memory, and to write
data to destination addresses in TCM by using the same addresses; useful for
initializing TCM with overlapping source/dest addresses; Load mode works with
all Load/Store opcodes, it does NOT work with SWP/SWPB opcodes.


TCM Physical Size can be detected in 3rd ID Code Register. (C0,C0,2)



## C9,C1,0 - Data TCM Size/Base (R/W)



## C9,C1,1 - Instruction TCM Size/Base (R/W)


```
  0     Reserved     (0)
  1-5   Virtual Size (Size = 512 SHL N) ;min=(N=3)=4KB, max=(N=23)=4GB
  6-11  Reserved     (0)
  12-31 Region Base  (Base = X SHL 12)  ;Base must be Size-aligned
```

The Virtual size settings should be normally same as the Physical sizes (see
C0,C0,2). However, smaller sizes are allowed (using only the 1st some KB), as
well as bigger sizes (TCM area is then filled with mirrors of physical TCM).

The ITCM region base may be fixed (read-only), for example, on the NDS, ITCM
base is always 00000000h, nethertheless the virtual size may be changed
(allowing to mirror ITCM to higher addresses).

If DTCM and ITCM do overlap, then ITCM appears to have priority.



## TCM and PU


TCM can be used without Protection Unit.

When the protection unit is enabled, TCM is controlled by the PU just like
normal memory, the PU should provide R/W Access Permission for TCM regions;
cache and write-buffer are not required for high-speed TCM (so both should be
disabled for TCM regions).




# <a name="armcp15misc"></a>ARM CP15 Misc




## C13,C0,0 - Process ID for Fast Context Switch Extension (FCSE) (R/W)


```
  0-24  Reserved/zero
  25-31 Process ID (PID) (0-127) (0=Disable)
```

The FCSE allows different processes (each assembled with ORG 0) to be located
at virtual addresses in the 1st 32MB area. The FCSE splits the total 4GB
address space into blocks of 32MB, accesses to Block(0) are redirected to
Block(PID):

```
  IF addr<32M then addr=addr+PID*32M
  Respectively, with PID=0, the address remains unchanged (FCSE disabled).
```

The CPU-to-Memory address handling is shown below:

```
  1. CPU outputs a virtual address (VA)
  2. FCSE adjusts the VA to a modified virtual address (MVA)
  3. Cache hits determined by examining the MVA, continue below if no hit
  4. MMU translates MVA to physical address (PA) (if no MMU present: PA=MVA)
  5. Memory access occurs at PA
```

The FCSE allows limited virtual addressing even if no MMU is present.

If the MMU is present, then either the FCSE and/or the MMU can be used for
virtual addressing; the advantage of using the FCSE (a single write to
C13,C0,0) is less overload; using the MMU for the same purpose would require to
change virtual address translation table in memory, and to flush the cache.

The NDS doesn't have a FCSE (the FCSE register is read-only, always zero).



## C13,C0,1 - Trace Process ID (R/W)



## C13,C1,1 - Trace Process ID (Mirror) (R/W)


This value is output to ETMPROCID pins (if any), allowing to notify external
hardware about the currently executed process within multi-tasking programs.

```
  0-31  Process ID
```

C13,C1,1 is a mirror of C13,C0,1 (for compatibility with other ARM processors).

Both registers are read/write-able on NDS9, but there are no external pin-outs.



## \<cpopc>


Unlike for all other CP15 registers, the \<cpopc> operand of the MRC/MCR
opcodes isn't always zero for below registers, so below registers are using
"cpopc,Cn,Cm,op2" notation (instead of the normal "Cn,Cm,op2" notation).



## Built-In-Self-Test (BIST)


Allows to test internal memory (ie. TCM, Cache Memory, and Cache TAGs). The
tests are filling (and verifying) the selected memory region thrice (once with
the fillvalue, then with the inverted fillvalue, and then again with the
fillvalue). The BIST functions are intended for diagnostics purposes only, not
for use in normal program code (ARM doesn't guarantee future processors to have
backwards compatible BIST functions).



## 0,C15,C0,1 - BIST TAG Control Register (R/W)



## 1,C15,C0,1 - BIST TCM Control Register (R/W)



## 2,C15,C0,1 - BIST Cache Control Register (R/W)


```
  0-15  Data Control (see below)
  16-31 Instruction Control (see below)
```

The above 16bit control values are:

```
  0     Start bit     (Write: 1=Start) (Read: 1=Busy)
  1     Pause bit     (1=Pause)
  2     Enable bit    (1=Enable)
  3     Fail Flag     (1=Error) (Read Only)
  4     Complete Flag (1=Ready) (Read Only)
  5-15  Size (2^(N+2) bytes) (min=N=1=8bytes, max=N=24=64MB)
```

Size and Pause are not supported in all implementations.

Caution: While and as long as the Enable bit is set, the corresponding memory
region(s) will be disabled. Eg. when testing \<either> DTCM \<and/or>
ITCM, \<both> DTCM \<and> ITCM are forcefully disabled in C1,C0,0
(Control Register), after the test the software must first clear the BIST
enable bit, and then restore DTCM/ITCM bits in C1,C0,0. And of course, the
content of the tested memory region must be restored when needed.



## 0,C15,C0,2 - BIST Instruction TAG Address (R/W)



## 1,C15,C0,2 - BIST Instruction TCM Address (R/W)



## 2,C15,C0,2 - BIST Instruction Cache Address (R/W)



## 0,C15,C0,6 - BIST Data TAG Address (R/W)



## 1,C15,C0,6 - BIST Data TCM Address (R/W)



## 2,C15,C0,6 - BIST Data Cache Address (R/W)


```
  0-31  Word-aligned Destination Address within Memory Block (eg. within ITCM)
```

On the NDS9, bit0-1, and bit21-31 are always zero.



## 0,C15,C0,3 - BIST Instruction TAG Fillvalue (R/W)



## 1,C15,C0,3 - BIST Instruction TCM Fillvalue (R/W)



## 2,C15,C0,3 - BIST Instruction Cache Fillvalue (R/W)



## 0,C15,C0,7 - BIST Data TAG Fillvalue (R/W)



## 1,C15,C0,7 - BIST Data TCM Fillvalue (R/W)



## 2,C15,C0,7 - BIST Data Cache Fillvalue (R/W)


```
  0-31  Fillvalue for BIST
```

After BIST, the selected memory region is filled by that value. That is, on the
NDS9 at least, all words will be filled with the SAME value (ie. NOT with
increasing or randomly generated numbers).



## 0,C15,C0,0 - Cache Debug Test State Register (R/W)


```
  0-8    Reserved (zero)
  9      Disable Instruction Cache Linefill
  10     Disable Data Cache Linefill
  11     Disable Instruction Cache Streaming
  12     Disable Data Cache Streaming
  13-31  Reserved (zero/unpredictable)
```



## 3,C15,C0,0 - Cache Debug Index Register (R/W)


```
  0..1    Reserved (zero)
  2..4    Word Address
  5..N    Index
  N+1..29 Reserved (zero)
  30..31  Segment
```



## 3,C15,C1,0 - Cache Debug Instruction TAG (R/W)



## 3,C15,C2,0 - Cache Debug Data TAG (R/W)



## 3,C15,C3,0 - Cache Debug Instruction Cache (R/W)



## 3,C15,C4,0 - Cache Debug Data Cache (R/W)


```
  0..1    Set
  2..3    Dirty Bits
  4       Valid
  5..N    Index
  N+1..31 TAG Address
```




# <a name="armcpuinstructioncycletimes"></a>ARM CPU Instruction Cycle Times



Instruction Cycle Summary


```
  Instruction      Cycles      Additional
  ---------------------------------------------------------------------
  ALU              1S          +1S+1N if R15 loaded, +1I if SHIFT(Rs)
  MSR,MRS          1S
  LDR              1S+1N+1I    +1S+1N if R15 loaded
  STR              2N
  LDM              nS+1N+1I    +1S+1N if R15 loaded
  STM              (n-1)S+2N
  SWP              1S+2N+1I
  BL (THUMB)       3S+1N
  B,BL             2S+1N
  SWI,trap         2S+1N
  MUL              1S+ml
  MLA              1S+(m+1)I
  MULL             1S+(m+1)I
  MLAL             1S+(m+2)I
  CDP              1S+bI
  LDC,STC          (n-1)S+2N+bI
  MCR              1N+bI+1C
  MRC              1S+(b+1)I+1C
  {cond} false     1S
```



ARM9:

```
  Q{D}ADD/SUB      1S+Interlock.
  CLZ              1S.
  LDR              1S+1N+1L
  LDRB,LDRH,LDRmis 1S+1N+2L
  LDR PC ...
  STR              1S+1N        (not 2N, and both in parallel)
```

Execution Time: 1S+Interlock    (SMULxy,SMLAxy,SMULWx,SMLAWx)

Execution Time: 1S+1I+Interlock (SMLALxy)


ARM11:

```
  Observe that Branch Prediction (enabled in CP15 Control register) can affect
  timings for conditional jumps (and presumably non-conditional ones, too).
  Without prediction: A waitloop made of "SUBS+BNE" takes 4 clks per loop cycle
  With prediction: A waitloop made of "SUBS+BNE" takes 2.5 clks per loop cycle
  (apparently the prediction assumes 75% of the jumps to be taken)
```


Whereas,

```
  n = number of words transferred
  b = number of cycles spent in coprocessor busy-wait loop
  m = depends on most significant byte(s) of multiplier operand
```

Above 'trap' is meant to be the execution time for exceptions. And '{cond}
false' is meant to be the execution time for conditional instructions which
haven't been actually executed because the condition has been false.


The separate meaning of the N,S,I,C cycles is:



## N - Non-sequential cycle


Requests a transfer to/from an address which is NOT related to the address used
in the previous cycle. (Called 1st Access in GBA language).

The execution time for 1N is 1 clock cycle (plus non-sequential access
waitstates).



## S - Sequential cycle


Requests a transfer to/from an address which is located directly after the
address used in the previous cycle. Ie. for 16bit or 32bit accesses at
incrementing addresses, the first access is Non-sequential, the following
accesses are sequential. (Called 2nd Access in GBA language).

The execution time for 1S is 1 clock cycle (plus sequential access waitstates).



## I - Internal Cycle


CPU is just too busy, not even requesting a memory transfer for now.

The execution time for 1I is 1 clock cycle (without any waitstates).



## C - Coprocessor Cycle


The CPU uses the data bus to communicate with the coprocessor (if any), but no
memory transfers are requested.



## Memory Waitstates


Ideally, memory may be accessed free of waitstates (1N and 1S are then equal to
1 clock cycle each). However, a memory system may generate waitstates for
several reasons: The memory may be just too slow. Memory is currently accessed
by DMA, eg. sound, video, memory transfers, etc. Or when data is squeezed
through a 16bit data bus (in that special case, 32bit access may have more
waitstates than 8bit and 16bit accesses). Also, the memory system may separate
between S and N cycles (if so, S cycles would be typically faster than N
cycles).



## Memory Waitstates for Different Memory Areas


Different memory areas (eg. ROM and RAM) may have different waitstates. When
executing code in one area which accesses data in another area, then the S+N
cycles must be split into code and data accesses: 1N is used for data access,
plus (n-1)S for LDM/STM, the remaining S+N are code access. If an instruction
jumps to a different memory area, then all code cycles for that opcode are
having waitstate characteristics of the NEW memory area (except Thumb BL which
still executes 1S in OLD area).




# <a name="armcpuversions"></a>ARM CPU Versions




## Version Numbers


ARM CPUs are distributed by name ARM#, and are described as ARMv# in
specifications, whereas "#" is NOT the same than "v#", for example, ARM7TDMI is
ARMv4TM. That is so confusing, that ARM didn't even attempt to clarify the
relationship between the various "#" and "v#" values.



## Version Variants


Suffixes like "M" (long multiply), "T" (Thumb support), "E" (Enhanced DSP)
indicate presence of special features, additionally to the standard instruction
set of a given version, or, when preceded by an "x", indicate the absence of
that features.



## ARMv1 aka ARM1


Some sort of a beta version, according to ARM never been used in any commercial
products.



## ARMv2 and up


MUL,MLA

CDP,LDC,MCR,MRC,STC

SWP/SWPB (ARMv2a and up only)

Two new FIQ registers



## ARMv3 and up


MRS,MSR opcodes (instead CMP/CMN/TST/TEQ{P} opcodes)

CPSR,SPSR registers (instead PSR bits in R15)

Removed never condition, cond=NV no longer valid

32bit addressing (instead 26bit addressing in older versions)

26bit addressing backwards comptibility mode (except v3G)

Abt and Und modes (instead handling aborts/undefined in Svc mode)

SMLAL,SMULL,UMLAL,UMULL (optionally, INCLUDED in v3M, EXCLUDED in v4xM/v5xM)



## ARMv4 aka ARM7 and up


LDRH,LDRSB,LDRSH,STRH

Sys mode (privileged user mode)

BX (only ARMv4T, and any ARMv5 or ARMv5T and up)

THUMB code (only T variants, ie. ARMv4T, ARMv5T)



## ARMv5 aka ARM9 and up


BKPT,BLX,CLZ (BKPT,BLX also in THUMB mode)

LDM/LDR/POP PC with mode switch (POP PC also in THUMB mode)

CDP2,LDC2,MCR2,MRC2,STC2 (new coprocessor opcodes)

C-flag unchanged by MUL (instead undefined flag value)

changed instruction cycle timings / interlock ??? or not ???

QADD,QDADD,QDSUB,QSUB opcodes, CPSR.Q flag (v5TE and V5TExP only)

SMLAxy,SMLALxy,SMLAWy,SMULxy,SMULWy (v5TE and V5TExP only)

LDRD,STRD,PLD,MCRR,MRRC (v5TE only, not v5, not v5TExP)

BXJ (jump to Jazelle bytecode) (v5TEJ only)



## ARMv6 aka ARM11 and up (see ARM DDI 0100I)


Supports all ARMv5TEJ features (=including Jazelle?).

The following ARM instructions are added:

- CPS, SRS and RFE instructions for improved exception handling

- REV, REV16 and REVSH byte reversal instructions

- SETEND for a revised endian (memory) model

- LDREX and STREX exclusive access instructions

- SXTB, SXTH, UXTB, UXTH byte/halfword extend instructions

- A set of Single Instruction Multiple Data (SIMD) media instructions

- Additional forms of multiply with accumulation into a 64-bit result

The following Thumb instructions are added:

- CPS, CPY (a form of MOV), REV, REV16, REVSH, SETEND, SXTB, SXTH, UXTB, UXTH

SWP/SWPB has been deprecated in ARMv6, made optional in ARMv7 (with the
possibility of disabling it if still available), and removed in ARMv8.



## ARMv6K aka "ARM11 MPCore" (see ARM DDI 0360F) (used in 3DS)


Unknown how this is abbreviated (ARMv6-M would be something else: Cortex-M).

The MPCore processor provides support for extensions to ARMv6 that include:

- LDREX/STREX{B|H|D} for 8bit/16bit/64bit and CLREX

- HINT (TrueNOP, YIELD, WFI, WFE, SEV)

- Architectural remap registers.

- Revised use of TEX remap bits. The ARMv6 MMU page table descriptors use a
large number of bits to describe all of the options for inner and outer
cachability. In reality, no application requires all of these options
simultaneously. Therefore it is possible to use the TEX remap mechanism to
configure the MP11 CPUs to support only a small number of options. This implies
a level of indirection in the page table mappings.

The TEX CB encoding table provides two OS managed page table bits. For binary
compatibility with existing ARMv6 ports of OSs, this gives a separate mode of
operation of the MMU. This is called the TEX Remap configuration and is
controlled by bit [28] TR in CP15 Register 1.

- Revised use of AP bits. In the MP11 CPUs the APX and AP[1:0] encoding b111 is
Privileged or User mode read-only access. AP[0] indicates an abort type, Access
Bit fault, when CP15 c1[29] is 1.

For more information see the ARM Architecture Reference Manual.



## ARMv6T2 aka THUMB-2


This doesn't seem to be supported in 3DS. THUMB-2 adds more 2x16bit opcodes in
THUMB mode, ie. THUMB code can contain classic 16bit opcodes, mixed with new
2x16bit opcodes. As far as I understand, the old 2x16bit "BL" and "BLX" do no
longer exists, or are replaced by differently encode THUMB-2 opcodes?



## ARMv6Z


ARMv6K with Security Extensions. Aka TrustZone, see Processor Feature Register
1.



## A Milestone in Computer History


Original ARMv2 has been used in the relative rare and expensive Archimedes
deluxe home computers in the late eighties, the Archimedes has caught a lot of
attention, particularly for being the first home computer that used a BIOS
being programmed in BASIC language - which has been a absolutely revolutionary
decadency at that time.

Inspired, programmers all over the world have successfully developed even
slower and much more inefficient programming languages, which are nowadays
consequently used by nearly all ARM programmers, and by most non-ARM
programmers as well.




# <a name="armcpudatasheet"></a>ARM CPU Data Sheet



This present document is an attempt to supply a brief ARM7TDMI reference,
hopefully including all information which is relevant for programmers.


Some details that I have treated as meaningless for GBA programming aren't
included - such like Big Endian format, and Virtual Memory data aborts, and
most of the chapters listed below.


Have a look at the complete data sheet (URL see below) for more detailed
verbose information about ARM7TDMI instructions. That document also includes:

- - Signal Description
    - Pins of the original CPU, probably other for GBA.
- - Memory Interface
    - Optional virtual memory circuits, etc. not for GBA.
- - Coprocessor Interface
    - As far as I know, none such in GBA.
- - Debug Interface
    - For external hardware-based debugging.
- - ICEBreaker Module
    - For external hardware-based debugging also.
- - Instruction Cycle Operations
    - Detailed: What happens during each cycle of each instruction.
- - DC Parameters (Power supply)
- - AC Parameters (Signal timings)

The official ARM7TDMI data sheet can be downloaded from ARMs webpage,

- [http://www.arm.com/Documentation/UserMans/PDF/ARM7TDMI.html](http://www.arm.com/Documentation/UserMans/PDF/ARM7TDMI.html)

Be prepared for bloated PDF Format, approx 1.3 MB, about 200 pages.




# <a name="biosfunctions"></a>BIOS Functions



The BIOS includes several System Call Functions which can be accessed by SWI
instructions. Incoming parameters are usually passed through registers
R0,R1,R2,R3. Outgoing registers R0,R1,R3 are typically containing either
garbage, or return value(s). All other registers (R2,R4-R14) are kept
unchanged.



## Caution


When invoking SWIs from inside of ARM state specify SWI NN\*10000h, instead of
SWI NN as in THUMB state.



## Overview


- [BIOS Function Summary](#biosfunctionsummary)
- [BIOS Differences between GBA and NDS functions](#biosdifferencesbetweengbaandndsfunctions)


## All Functions Described


- [BIOS Arithmetic Functions](#biosarithmeticfunctions)
- [BIOS Rotation/Scaling Functions](#biosrotationscalingfunctions)
- [BIOS Decompression Functions](#biosdecompressionfunctions)
- [BIOS Memory Copy](#biosmemorycopy)
- [BIOS Halt Functions](#bioshaltfunctions)
- [BIOS Reset Functions](#biosresetfunctions)
- [BIOS Misc Functions](#biosmiscfunctions)
- [BIOS Multi Boot (Single Game Pak)](#biosmultibootsinglegamepak)
- [BIOS Sound Functions](#biossoundfunctions)
- [BIOS SHA1 Functions (DSi only)](#biossha1functionsdsionly)
- [BIOS RSA Functions (DSi only)](#biosrsafunctionsdsionly)


## 3DS bootroms


- [BIOS 3DS Exception Vectors](#bios3dsexceptionvectors)


## RAM Usage, BIOS Dumps


- [BIOS RAM Usage](#biosramusage)
- [BIOS Dumping](#biosdumping)


## How BIOS Processes SWIs


SWIs can be called from both within THUMB and ARM mode. In ARM mode, only the
upper 8bit of the 24bit comment field are interpreted.

Each time when calling a BIOS function 4 words (SPSR, R11, R12, R14) are saved
on Supervisor stack (\_svc). Once it has saved that data, the SWI handler
switches into System mode, so that all further stack operations are using user
stack.

In some cases the BIOS may allow interrupts to be executed from inside of the
SWI procedure. If so, and if the interrupt handler calls further SWIs, then
care should be taken that the Supervisor Stack does not overflow.




# <a name="biosfunctionsummary"></a>BIOS Function Summary



```
  GBA  NDS7 NDS9 DSi7 DSi9 Basic Functions
  00h  00h  00h  -    -    SoftReset
  01h  -    -    -    -    RegisterRamReset
  02h  06h  06h  06h  06h  Halt
  03h  07h  -    07h  -    Stop/Sleep
  04h  04h  04h  04h  04h  IntrWait       ;DSi7/DSi9: both bugged?
  05h  05h  05h  05h  05h  VBlankIntrWait ;DSi7/DSi9: both bugged?
  06h  09h  09h  09h  09h  Div
  07h  -    -    -    -    DivArm
  08h  0Dh  0Dh  0Dh  0Dh  Sqrt
  09h  -    -    -    -    ArcTan
  0Ah  -    -    -    -    ArcTan2
  0Bh  0Bh  0Bh  0Bh  0Bh  CpuSet
  0Ch  0Ch  0Ch  0Ch  0Ch  CpuFastSet
  0Dh  -    -    -    -    GetBiosChecksum
  0Eh  -    -    -    -    BgAffineSet
  0Fh  -    -    -    -    ObjAffineSet
  GBA  NDS7 NDS9 DSi7 DSi9 Decompression Functions
  10h  10h  10h  10h  10h  BitUnPack
  11h  11h  11h  11h  11h  LZ77UnCompReadNormalWrite8bit   ;"Wram"
  12h  -    -    -    -    LZ77UnCompReadNormalWrite16bit  ;"Vram"
  -    -    -    01h  01h  LZ77UnCompReadByCallbackWrite8bit
  -    12h  12h  02h  02h  LZ77UnCompReadByCallbackWrite16bit
  -    -    -    19h  19h  LZ77UnCompReadByCallbackWrite16bit (same as above)
  13h  -    -    -    -    HuffUnCompReadNormal
  -    13h  13h  13h  13h  HuffUnCompReadByCallback
  14h  14h  14h  14h  14h  RLUnCompReadNormalWrite8bit     ;"Wram"
  15h  -    -    -    -    RLUnCompReadNormalWrite16bit    ;"Vram"
  -    15h  15h  15h  15h  RLUnCompReadByCallbackWrite16bit
  16h  -    16h  -    16h  Diff8bitUnFilterWrite8bit       ;"Wram"
  17h  -    -    -    -    Diff8bitUnFilterWrite16bit      ;"Vram"
  18h  -    18h  -    18h  Diff16bitUnFilter
  GBA  NDS7 NDS9 DSi7 DSi9 Sound (and Multiboot/HardReset/CustomHalt)
  19h  08h  -    08h  -    SoundBias
  1Ah  -    -    -    -    SoundDriverInit
  1Bh  -    -    -    -    SoundDriverMode
  1Ch  -    -    -    -    SoundDriverMain
  1Dh  -    -    -    -    SoundDriverVSync
  1Eh  -    -    -    -    SoundChannelClear
  1Fh  -    -    -    -    MidiKey2Freq
  20h  -    -    -    -    SoundWhatever0
  21h  -    -    -    -    SoundWhatever1
  22h  -    -    -    -    SoundWhatever2
  23h  -    -    -    -    SoundWhatever3
  24h  -    -    -    -    SoundWhatever4
  25h  -    -    -    -    MultiBoot
  26h  -    -    -    -    HardReset
  27h  1Fh  -    1Fh  -    CustomHalt
  28h  -    -    -    -    SoundDriverVSyncOff
  29h  -    -    -    -    SoundDriverVSyncOn
  2Ah  -    -    -    -    SoundGetJumpList
  GBA  NDS7 NDS9 DSi7 DSi9 New NDS Functions
  -    03h  03h  03h  03h  WaitByLoop
  -    0Eh  0Eh  0Eh  0Eh  GetCRC16
  -    0Fh  0Fh  -    -    IsDebugger
  -    1Ah  -    1Ah  -    GetSineTable
  -    1Bh  -    1Bh  -    GetPitchTable (DSi7: bugged)
  -    1Ch  -    1Ch  -    GetVolumeTable
  -    1Dh  -    1Dh  -    GetBootProcs (DSi7: only 1 proc)
  -    -    1Fh  -    1Fh  CustomPost
  GBA  NDS7 NDS9 DSi7 DSi9 New DSi Functions (RSA/SHA1)
  -    -    -    20h  20h  RSA_Init_crypto_heap
  -    -    -    21h  21h  RSA_Decrypt
  -    -    -    22h  22h  RSA_Decrypt_Unpad
  -    -    -    23h  23h  RSA_Decrypt_Unpad_OpenPGP_SHA1
  -    -    -    24h  24h  SHA1_Init
  -    -    -    25h  25h  SHA1_Update
  -    -    -    26h  26h  SHA1_Finish
  -    -    -    27h  27h  SHA1_Init_update_fin
  -    -    -    28h  28h  SHA1_Compare_20_bytes
  -    -    -    29h  29h  SHA1_Random_maybe
  GBA  NDS7 NDS9 DSi7 DSi9 Invalid Functions
  2Bh+ 20h+ 20h+ -    -    Crash (SWI xxh..FFh do jump to garbage addresses)
  -    xxh  xxh  -    -    Jump to 0   (on any SWI numbers not listed above)
  -    -    -    12h  12h  No function (ignored)
  -    -    -    2Bh  2Bh  No function (ignored)
  -    -    -    40h+ 40h+ Mirror      (SWI 40h..FFh mirror to 00h..3Fh)
  -    -    -    xxh  xxh  Hang        (on any SWI numbers not listed above)
```

Invalid NDS functions: NDS7 SWI 01h, 02h, 0Ah, 16h-19h, 1Eh, and NDS9 SWI 01h,
02h, 07h, 08h, 0Ah, 17h, 19h-1Eh will jump to zero (ie. to the NDS7 reset
vector, or to NDS9 unused (usually PU-locked ITCM) memory, which will be both
redirected to the debug handler, if any).

Invalid DSi functions: DSi9 SWI 00h, 07h-08h, 0Ah, 0Fh, 17h, 1Ah-1Eh, 2Ah,
2Ch-3Fh do hang in endless loop.




# <a name="biosdifferencesbetweengbaandndsfunctions"></a>BIOS Differences between GBA and NDS functions




## Differences between GBA and NDS BIOS functions


- SoftReset uses different addresses

- SWI numbers for Halt, Stop/Sleep, Div, Sqrt have changed

- Halt destroys r0 on NDS9, IntrWait bugged on NDS9

- CpuFastSet allows 4-byte blocks (nice), but...

- CpuFastSet works very SLOW because of a programming bug (uncool)

- Some of the decompression functions are now using callbacks

- SoundBias uses new delay parameter

And, a number of GBA functions have been removed, and some new NDS functions
have been added, see:

- [BIOS Function Summary](#biosfunctionsummary)



# <a name="biosarithmeticfunctions"></a>BIOS Arithmetic Functions



Div

DivArm

Sqrt

ArcTan

ArcTan2



## SWI 06h (GBA) or SWI 09h (NDS7/NDS9/DSi7/DSi9) - Div


Signed Division, r0/r1.

```
  r0  signed 32bit Number
  r1  signed 32bit Denom
```

Return:

```
  r0  Number DIV Denom ;signed
  r1  Number MOD Denom ;signed
  r3  ABS (Number DIV Denom) ;unsigned
```

For example, incoming -1234, 10 should return -123, -4, +123.

The function usually gets caught in an endless loop upon division by zero.

Note: The NDS9 and DSi9 additionally support hardware division, by math
coprocessor, accessed via I/O Ports, however, the SWI function is a raw
software division.



## SWI 07h (GBA) - DivArm


Same as above (SWI 06h Div), but incoming parameters are exchanged, r1/r0
(r0=Denom, r1=number). For compatibility with ARM's library. Slightly slower (3
clock cycles) than SWI 06h.



## SWI 08h (GBA) or SWI 0Dh (NDS7/NDS9/DSi7/DSi9) - Sqrt


Calculate square root.

```
  r0   unsigned 32bit number
```

Return:

```
  r0   unsigned 16bit number
```

The result is an integer value, so Sqrt(2) would return 1, to avoid this
inaccuracy, shift left incoming number by 2\*N as much as possible (the result
is then shifted left by 1\*N). Ie. Sqrt(2 shl 30) would return 1.41421 shl 15.

Note: The NDS9 and DSi9 additionally support hardware square root calculation,
by math coprocessor, accessed via I/O Ports, however, the SWI function is a raw
software calculation.



## SWI 09h (GBA) - ArcTan


Calculates the arc tangent.

```
  r0   Tan, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
```

Return:

```
  r0   "-PI/2<THETA/<PI/2" in a range of C000h-4000h.
```

Note: there is a problem in accuracy with "THETA\<-PI/4, PI/4\<THETA".



## SWI 0Ah (GBA) - ArcTan2


Calculates the arc tangent after correction processing.

Use this in normal situations.

```
  r0   X, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
  r1   Y, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
```

Return:

```
  r0   0000h-FFFFh for 0<=THETA<2PI.
```




# <a name="biosrotationscalingfunctions"></a>BIOS Rotation/Scaling Functions



BgAffineSet

ObjAffineSet



## SWI 0Eh (GBA) - BgAffineSet


Used to calculate BG Rotation/Scaling parameters.

```
  r0   Pointer to Source Data Field with entries as follows:
        s32  Original data's center X coordinate (8bit fractional portion)
        s32  Original data's center Y coordinate (8bit fractional portion)
        s16  Display's center X coordinate
        s16  Display's center Y coordinate
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Pointer to Destination Data Field with entries as follows:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
        s32  Start X coordinate
        s32  Start Y coordinate
  r2   Number of Calculations
```

Return: No return value, Data written to destination address.



## SWI 0Fh (GBA) - ObjAffineSet


Calculates and sets the OBJ's affine parameters from the scaling ratio and
angle of rotation.

The affine parameters are calculated from the parameters set in Srcp.

The four affine parameters are set every Offset bytes, starting from the Destp
address.

If the Offset value is 2, the parameters are stored contiguously. If the value
is 8, they match the structure of OAM.

When Srcp is arrayed, the calculation can be performed continuously by
specifying Num.

```
  r0   Source Address, pointing to data structure as such:
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Destination Address, pointing to data structure as such:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
  r2   Number of calculations
  r3   Offset in bytes for parameter addresses (2=continuous, 8=OAM)
```

Return: No return value, Data written to destination address.


For both Bg- and ObjAffineSet, Rotation angles are specified as 0-FFFFh
(covering a range of 360 degrees), however, the GBA BIOS recurses only the
upper 8bit; the lower 8bit may contain a fractional portion, but it is ignored
by the BIOS.




# <a name="biosdecompressionfunctions"></a>BIOS Decompression Functions



BitUnPack

Diff8bitUnFilter

HuffUnComp

LZ77UnComp

RLUnComp



## Decompression Read/Write Variants


```
  ReadNormal:      Fast (src must be memory mapped)
  ReadByCallback:  Slow (src can be non-memory, eg. serial Firmware SPI bus)
  Write8bitUnits:  Fast (dest must support 8bit writes, eg. not VRAM)
  Write16bitUnits: Slow (dest must be halfword-aligned) (for VRAM)
```



## BitUnPack - SWI 10h (GBA/NDS7/NDS9/DSi7/DSi9)


Used to increase the color depth of bitmaps or tile data. For example, to
convert a 1bit monochrome font into 4bit or 8bit GBA tiles. The Unpack Info is
specified separately, allowing to convert the same source data into different
formats.

```
  r0  Source Address      (no alignment required)
  r1  Destination Address (must be 32bit-word aligned)
  r2  Pointer to UnPack information:
       16bit  Length of Source Data in bytes     (0-FFFFh)
       8bit   Width of Source Units in bits      (only 1,2,4,8 supported)
       8bit   Width of Destination Units in bits (only 1,2,4,8,16,32 supported)
       32bit  Data Offset (Bit 0-30), and Zero Data Flag (Bit 31)
      The Data Offset is always added to all non-zero source units.
      If the Zero Data Flag was set, it is also added to zero units.
```

Data is written in 32bit units, Destination can be Wram or Vram. The size of
unpacked data must be a multiple of 4 bytes. The width of source units (plus
the offset) should not exceed the destination width.

Return: No return value, Data written to destination address.



## Diff8bitUnFilterWrite8bit (Wram) - SWI 16h (GBA/NDS9/DSi9)



## Diff8bitUnFilterWrite16bit (Vram) - SWI 17h (GBA)



## Diff16bitUnFilter - SWI 18h (GBA/NDS9/DSi9)


These aren't actually real decompression functions, destination data will have
exactly the same size as source data. However, assume a bitmap or wave form to
contain a stream of increasing numbers such like 10..19, the
filtered/unfiltered data would be:

```
  unfiltered:   10  11  12  13  14  15  16  17  18  19
  filtered:     10  +1  +1  +1  +1  +1  +1  +1  +1  +1
```

In this case using filtered data (combined with actual compression algorithms)
will obviously produce better compression results.

Data units may be either 8bit or 16bit used with Diff8bit or Diff16bit
functions respectively.

```
  r0  Source address (must be aligned by 4) pointing to data as follows:
       Data Header (32bit)
         Bit 0-3   Data size (must be 1 for Diff8bit, 2 for Diff16bit)
         Bit 4-7   Type (must be 8 for DiffFiltered)
         Bit 8-31  24bit size after decompression
       Data Units (each 8bit or 16bit depending on used SWI function)
         Data0          ;original data
         Data1-Data0    ;difference data
         Data2-Data1    ;...
         Data3-Data2
         ...
  r1  Destination address
```

Return: No return value, Data written to destination address.



## HuffUnCompReadNormal - SWI 13h (GBA)



## HuffUnCompReadByCallback - SWI 13h (NDS/DSi)


The decoder starts in root node, the separate bits in the bitstream specify if
the next node is node0 or node1, if that node is a data node, then the data is
stored in memory, and the decoder is reset to the root node. The most often
used data should be as close to the root node as possible. For example, the
4-byte string "Huff" could be compressed to 6 bits: 10-11-0-0, with root.0
pointing directly to data "f", and root.1 pointing to a child node, whose nodes
point to data "H" and data "u".

Data is written in units of 32bits, if the size of the compressed data is not a
multiple of 4, please adjust it as much as possible by padding with 0.

Align the source address to a 4Byte boundary.

```
  r0  Source Address, aligned by 4, pointing to:
       Data Header (32bit)
         Bit0-3   Data size in bit units (normally 4 or 8)
         Bit4-7   Compressed type (must be 2 for Huffman)
         Bit8-31  24bit size of decompressed data in bytes
       Tree Size (8bit)
         Bit0-7   Size of Tree Table/2-1 (ie. Offset to Compressed Bitstream)
       Tree Table (list of 8bit nodes, starting with the root node)
        Root Node and Non-Data-Child Nodes are:
         Bit0-5   Offset to next child node,
                  Next child node0 is at (CurrentAddr AND NOT 1)+Offset*2+2
                  Next child node1 is at (CurrentAddr AND NOT 1)+Offset*2+2+1
         Bit6     Node1 End Flag (1=Next child node is data)
         Bit7     Node0 End Flag (1=Next child node is data)
        Data nodes are (when End Flag was set in parent node):
         Bit0-7   Data (upper bits should be zero if Data Size is less than 8)
       Compressed Bitstream (stored in units of 32bits)
         Bit0-31  Node Bits (Bit31=First Bit)  (0=Node0, 1=Node1)
  r1  Destination Address
  r2  Callback temp buffer      ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
```

Return: No return value, Data written to destination address.



## LZ77UnCompReadNormalWrite8bit (Wram) - SWI 11h (GBA/NDS7/NDS9/DSi7/DSi9)



## LZ77UnCompReadNormalWrite16bit (Vram) - SWI 12h (GBA)



## LZ77UnCompReadByCallbackWrite8bit - SWI 01h (DSi7/DSi9)



## LZ77UnCompReadByCallbackWrite16bit - SWI 12h (NDS), SWI 02h or 19h (DSi)


Expands LZ77-compressed data. The Wram function is faster, and writes in units
of 8bits. For the Vram function the destination must be halfword aligned, data
is written in units of 16bits.

- [LZ Decompression Functions](#lzdecompressionfunctions)
CAUTION: Writing 16bit units to [dest-1] instead of 8bit units to [dest] means
that reading from [dest-1] won't work, ie. the "Vram" function works only with
disp=001h..FFFh, but not with disp=000h.

If the size of the compressed data is not a multiple of 4, please adjust it as
much as possible by padding with 0. Align the source address to a 4-Byte
boundary.

```
  r0  Source address, pointing to data as such:
       Data header (32bit)
         Bit 0-3   Reserved (0)
         Bit 4-7   Compressed type (must be 1 for LZ77)
         Bit 8-31  Size of decompressed data
       Repeat below. Each Flag Byte followed by eight Blocks.
       Flag data (8bit)
         Bit 0-7   Type Flags for next 8 Blocks, MSB first
       Block Type 0 - Uncompressed - Copy 1 Byte from Source to Dest
         Bit 0-7   One data byte to be copied to dest
       Block Type 1 - Compressed - Copy N+3 Bytes from Dest-Disp-1 to Dest
         Bit 0-3   Disp MSBs
         Bit 4-7   Number of bytes to copy (minus 3)
         Bit 8-15  Disp LSBs
  r1  Destination address
  r2  Callback parameter        ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
```

Return: No return value.



## RLUnCompReadNormalWrite8bit (Wram) - SWI 14h (GBA/NDS7/NDS9/DSi7/DSi9)



## RLUnCompReadNormalWrite16bit (Vram) - SWI 15h (GBA)



## RLUnCompReadByCallbackWrite16bit - SWI 15h (NDS7/NDS9/DSi7/DSi9)


Expands run-length compressed data. The Wram function is faster, and writes in
units of 8bits. For the Vram function the destination must be halfword aligned,
data is written in units of 16bits.

If the size of the compressed data is not a multiple of 4, please adjust it as
much as possible by padding with 0. Align the source address to a 4Byte
boundary.

```
  r0  Source Address, pointing to data as such:
       Data header (32bit)
         Bit 0-3   Reserved
         Bit 4-7   Compressed type (must be 3 for run-length)
         Bit 8-31  Size of decompressed data
       Repeat below. Each Flag Byte followed by one or more Data Bytes.
       Flag data (8bit)
         Bit 0-6   Expanded Data Length (uncompressed N-1, compressed N-3)
         Bit 7     Flag (0=uncompressed, 1=compressed)
       Data Byte(s) - N uncompressed bytes, or 1 byte repeated N times
  r1  Destination Address
  r2  Callback parameter        ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
```

Return: No return value, Data written to destination address.



## NDS/DSi Decompression Callbacks


On NDS and DSi, the "ReadByCallback" variants are reading source data from
callback functions (rather than directly from memory). The callback functions
may read normal data from memory, or from other devices, such like directly
from the gamepak bus, without storing the source data in memory. The downside
is that the callback mechanism makes the function very slow, furthermore,
NDS7/NDS9 SWI 12h, 13h, 15h are using THUMB code, and variables on stack,
alltogether that makes the whole shit very-very-very slow.

```
  r2 = user defined callback parameter (passed on to Open function)
        (or, for Huffman: pointer to temp buffer, max 200h bytes needed)
  r3 = pointer to callback structure
```

Callback structure (five 32bit pointers to callback functions)

```
  Open_and_get_32bit (eg. LDR r0,[r0], get header)
  Close              (optional, 0=none)
  Get_8bit           (eg. LDRB r0,[r0])
  Get_16bit          (not used)
  Get_32bit          (used by Huffman only)
```

All functions may use ARM or THUMB code (indicated by address bit0). The
current source address (r0) is passed to all callback functions. Additionally,
the initial destination address (r1), and a user defined parameter (r2) are
passed to the Open function. For Huffman r2 must point to a temp buffer (max
200h bytes needed, internally used by the SWI function to make a copy of the
huffman tree; needed for random-access to the tree, which wouldn't work with
the sequentially reading callbacks).

All functions have return values in r0. The Open function normally returns the
first word (containing positive length and type), alternatively it may return a
negative error code to abort/reject decompression. The Close function, if it is
defined, should return zero (or any positive value), or a negative errorcode.
The other functions return raw data, without errorcodes. The SWI returns the
length of decompressed data, or the signed errorcode from the Open/Close
functions.




# <a name="biosmemorycopy"></a>BIOS Memory Copy



CpuFastSet

CpuSet



## SWI 0Ch (GBA/NDS7/NDS9/DSi7/DSi9) - CpuFastSet


Memory copy/fill in units of 32 bytes. Memcopy is implemented as repeated
LDMIA/STMIA [Rb]!,r2-r9 instructions. Memfill as single LDR followed by
repeated STMIA [Rb]!,r2-r9.

After processing all 32-byte-blocks, the NDS/DSi additonally processes the
remaining words as 4-byte blocks. BUG: The NDS/DSi uses the fast 32-byte-block
processing only for the first N bytes (not for the first N words), so only the
first quarter of the memory block is FAST, the remaining three quarters are
SLOWLY copied word-by-word.

The length is specifed as wordcount, ie. the number of bytes divided by 4.

On the GBA, the length should be a multiple of 8 words (32 bytes) (otherwise
the GBA is forcefully rounding-up the length). On NDS/DSi, the length may be
any number of words (4 bytes).

```
  r0    Source address        (must be aligned by 4)
  r1    Destination address   (must be aligned by 4)
  r2    Length/Mode
          Bit 0-20  Wordcount (GBA: rounded-up to multiple of 8 words)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by WORD[r0])
```

Return: No return value, Data written to destination address.



## SWI 0Bh (GBA/NDS7/NDS9/DSi7/DSi9) - CpuSet


Memory copy/fill in units of 4 bytes or 2 bytes. Memcopy is implemented as
repeated LDMIA/STMIA [Rb]!,r3 or LDRH/STRH r3,[r0,r5] instructions. Memfill as
single LDMIA or LDRH followed by repeated STMIA [Rb]!,r3 or STRH r3,[r0,r5].

The length must be a multiple of 4 bytes (32bit mode) or 2 bytes (16bit mode).
The (half)wordcount in r2 must be length/4 (32bit mode) or length/2 (16bit
mode), ie. length in word/halfword units rather than byte units.

```
  r0    Source address        (must be aligned by 4 for 32bit, by 2 for 16bit)
  r1    Destination address   (must be aligned by 4 for 32bit, by 2 for 16bit)
  r2    Length/Mode
          Bit 0-20  Wordcount (for 32bit), or Halfwordcount (for 16bit)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by {HALF}WORD[r0])
          Bit 26    Datasize (0=16bit, 1=32bit)
```

Return: No return value, Data written to destination address.


Note: On GBA, NDS7 and DSi7, these two functions will silently reject to do
anything if the source start or end addresses are reaching into the BIOS area.
The NDS9 and DSi9 don't have such read-proctections.




# <a name="bioshaltfunctions"></a>BIOS Halt Functions



Halt

IntrWait

VBlankIntrWait

Stop/Sleep

CustomHalt



## SWI 02h (GBA) or SWI 06h (NDS7/NDS9/DSi7/DSi9) - Halt


Halts the CPU until an interrupt request occurs. The CPU is switched into
low-power mode, all other circuits (video, sound, timers, serial, keypad,
system clock) are kept operating.

Halt mode is terminated when any enabled interrupts are requested, that is when
(IE AND IF) is not zero, the GBA locks up if that condition doesn't get true.
However, the state of CPUs IRQ disable bit in CPSR register, and the IME
register are don't care, Halt passes through even if either one has disabled
interrupts.

On GBA and NDS7/DSi7, Halt is implemented by writing to HALTCNT, Port 4000301h.
On NDS9/DSi9, Halt is implemted by writing to System Control Coprocessor (mov
p15,0,c7,c0,4,r0 opcode), this opcode hangs if IME=0.

No parameters, no return value.

(GBA/NDS7/DSi7: all registers unchanged, NDS9/DSi9: R0 destroyed)



## SWI 04h (GBA/NDS7/NDS9/DSi7/DSi9) - IntrWait ;DSi7/DSi9=bugged?


Continues to wait in Halt state until one (or more) of the specified
interrupt(s) do occur. The function forcefully sets IME=1. When using multiple
interrupts at the same time, this function is having less overhead than
repeatedly calling the Halt function.

```
  r0    0=Return immediately if an old flag was already set (NDS9: bugged!)
        1=Discard old flags, wait until a NEW flag becomes set
  r1    Interrupt flag(s) to wait for (same format as IE/IF registers)
  r2    DSi7 only: Extra flags (same format as DSi7's IE2/IF2 registers)
```

Caution: When using IntrWait or VBlankIntrWait, the user interrupt handler MUST
update the BIOS Interrupt Flags value in RAM; when acknowleding processed
interrupt(s) by writing a value to the IF register, the same value should be
also ORed to the BIOS Interrupt Flags value, at following memory location:

```
  Host     GBA (16bit)  NDS7 (32bit)  NDS9 (32bit)  DSi7-IF2 (32bit)
  Address  [3007FF8h]   [380FFF8h]    [DTCM+3FF8h]  [380FFC0h]
```

NDS9: BUG: No Discard (r0=0) doesn't work. The function always waits for at
least one IRQ to occur (no matter which, including IRQs that are not selected
in r1), even if the desired flag was already set. NB. the same bug is also
found in the GBA/NDS7 functions, but it's compensated by a second bug, ie. the
GBA/NDS7 functions are working okay because their "bug doesn't work".

Return: No return value, the selected flag(s) are automatically reset in BIOS
Interrupt Flags value in RAM upon return.

DSi9: BUG: The function tries to enter Halt state via Port 4000301h (which
would be okay on ARM7, but it's probably ignored on ARM9, which should normally
use CP15 to enter Halt state; if Port 4000301h is really ignored, then the
function will "successfully" wait for interrupts, but without actually entering
any kind of low power mode).

DSi7: BUG: The function tries to wait for IF and IF2 interrupts, but it does
accidently ignore the old IF interrupts, and works only with new IF2 ones.



## SWI 05h (GBA/NDS7/NDS9/DSi7/DSi9) - VBlankIntrWait ;DSi7/DSi9=bugged?


Continues to wait in Halt status until a new V-Blank interrupt occurs.

The function sets r0=1 and r1=1 (plus r2=0 on DSi7) and does then execute
IntrWait (SWI 04h), see IntrWait for details.

No parameters, no return value.



## SWI 03h (GBA) - Stop


Switches the GBA into very low power mode (to be used similar as a
screen-saver). The CPU, System Clock, Sound, Video, SIO-Shift Clock, DMAs, and
Timers are stopped.

Stop state can be terminated by the following interrupts only (as far as
enabled in IE register): Joypad, Game Pak, or General-Purpose-SIO.

"The system clock is stopped so the IF flag is not set."

Preparation for Stop:

Disable Video before implementing Stop (otherwise Video just freezes, but still
keeps consuming battery power). Possibly required to disable Sound also?
Obviously, it'd be also recommended to disable any external hardware (such like
Rumble or Infra-Red) as far as possible.

No parameters, no return value.



## SWI 07h (NDS7/DSi7) - Sleep


No info, probably similar as GBA SWI 03h (Stop). Sleep is implemented for ARM7
only, not for ARM9. But maybe the ARM7 function does stop \<both> ARM7 and
ARM9 (?)



## SWI 27h (GBA) or SWI 1Fh (NDS7/DSi7) - CustomHalt (Undocumented)


Writes the 8bit parameter value to HALTCNT, below values are equivalent to Halt
and Stop/Sleep functions, other values reserved, purpose unknown.

```
  r2  8bit parameter (GBA: 00h=Halt, 80h=Stop) (NDS7/DSi7: 80h=Halt, C0h=Sleep)
```

No return value.




# <a name="biosresetfunctions"></a>BIOS Reset Functions



SoftReset

RegisterRamReset

HardReset



## SWI 00h (GBA/NDS7/NDS9) - SoftReset


Clears 200h bytes of RAM (containing stacks, and BIOS IRQ vector/flags),
initializes system, supervisor, and irq stack pointers, sets R0-R12, LR\_svc,
SPSR\_svc, LR\_irq, and SPSR\_irq to zero, and enters system mode.

Note that the NDS9 stack registers are hardcoded (the DTCM base should be set
to the default setting of 0800000h). The NDS9 function additionally flushes
caches and write buffer, and sets the CP15 control register to 12078h.

```
  Host  sp_svc    sp_irq    sp_sys    zerofilled area       return address
  GBA   3007FE0h  3007FA0h  3007F00h  [3007E00h..3007FFFh]  Flag[3007FFAh]
  NDS7  380FFDCh  380FFB0h  380FF00h  [380FE00h..380FFFFh]  Addr[27FFE34h]
  NDS9  0803FC0h  0803FA0h  0803EC0h  [DTCM+3E00h..3FFFh]   Addr[27FFE24h]
```

The NDS7/NDS9 return addresses at [27FFE34h/27FFE24h] are usually containing
copies of Cartridge Header [034h/024h] entry points, which may select ARM/THUMB
state via bit0. The GBA return address 8bit flag is interpreted as 00h=8000000h
(ROM), or 01h-FFh=2000000h (RAM), entered in ARM state.

Note: The reset is applied only to the CPU that has executed the SWI (ie. on
the NDS, the other CPU will remain unaffected).

Return: Does not return to calling procedure, instead, loads the above return
address into R14, and then jumps to that address by a "BX R14" opcode.



## SWI 01h (GBA) - RegisterRamReset


Resets the I/O registers and RAM specified in ResetFlags. However, it does not
clear the CPU internal RAM area from 3007E00h-3007FFFh.

```
  r0  ResetFlags
       Bit   Expl.
       0     Clear 256K on-board WRAM  ;-don't use when returning to WRAM
       1     Clear 32K on-chip WRAM    ;-excluding last 200h bytes
       2     Clear Palette
       3     Clear VRAM
       4     Clear OAM              ;-zerofilled! does NOT disable OBJs!
       5     Reset SIO registers    ;-switches to general purpose mode!
       6     Reset Sound registers
       7     Reset all other registers (except SIO, Sound)
```

Return: No return value.

Bug: LSBs of SIODATA32 are always destroyed, even if Bit5 of R0 was cleared.

The function always switches the screen into forced blank by setting
DISPCNT=0080h (regardless of incoming R0, screen becomes white).



## SWI 26h (GBA) - HardReset (Undocumented)


This function reboots the GBA (including for getting through the time-consuming
nintendo intro, which is making the function particularly useless and
annoying).

Parameters: None. Return: Never/Reboot.

Execution Time: About 2 seconds (!)




# <a name="biosmiscfunctions"></a>BIOS Misc Functions



GetBiosChecksum

WaitByLoop

GetCRC16

IsDebugger

GetSineTable

GetPitchTable

GetVolumeTable

CustomPost

GetBootProcs



## SWI 0Dh (GBA) - GetBiosChecksum (Undocumented)


Calculates the checksum of the BIOS ROM (by reading in 32bit units, and adding
up these values). IRQ and FIQ are disabled during execution.

The checksum is BAAE187Fh (GBA and GBA SP), or BAAE1880h (NDS/3DS in GBA mode,
whereas the only difference is that the byte at [3F0Ch] is changed from 00h to
01h, otherwise the BIOS is 1:1 same as GBA BIOS, it does even include multiboot
code).

Parameters: None. Return: r0=Checksum.



## SWI 03h (NDS7/NDS9/DSi7/DSi9) - WaitByLoop


Performs a "LOP: SUB R0,1 / BGT LOP" wait loop, the loop is executed in BIOS
memory, which provides reliable timings (regardless of the memory waitstates
& cache state of the calling procedure). Intended only for short delays
(eg. flash memory programming cycles).

```
  r0  Delay value (should be in range 1..7FFFFFFFh)
```

Execution time varies for ARM7 vs ARM9. On ARM9 it does also depend on whether
ROM is cached, and on DSi it does further depended on the ARM9 CPU clock, and
on whether using NDS or DSi BIOS ROM (NDS uses faster THUMB code, whilst DSi
uses ARM code, which is slow on uncached ARM9 ROM reads). For example, to get a
1 millisecond delay, use following values:

```
  CPU  Clock     Cache   BIOS     Value for 1ms
  ARM7 33.51MHz  none    NDS/DSi  r0=20BAh    ;=20BAh  ;-ARM7
  ARM9 67.03MHz  on      NDS/DSi  r0=20BAh*2  ;=4174h  ;\ARM9 with cache
  ARM9 134.06MHz on      DSi      r0=20BAh*4  ;=82E8h  ;/
  ARM9 67.03MHz  off     NDS      r0=20BAh/2  ;=105Dh  ;\
  ARM9 67.03MHz  off     DSi      r0=20BAh/4  ;=082Eh  ; ARM9 without cache
  ARM9 134.06MHz off     DSi      r0=20BAh/3  ;=0AE8h  ;/
```

Return: No return value.



## SWI 0Eh (NDS7/NDS9/DSi7/DSi9) - GetCRC16


```
  r0  Initial CRC value (16bit, usually FFFFh)
  r1  Start Address   (must be aligned by 2)
  r2  Length in bytes (must be aligned by 2)
```

CRC16 checksums can be calculated as such:

```
  val[0..7] = C0C1h,C181h,C301h,C601h,CC01h,D801h,F001h,A001h
  for i=start to end
    crc=crc xor byte[i]
    for j=0 to 7
      crc=crc shr 1:if carry then crc=crc xor (val[j] shl (7-j))
    next j
  next i
```

Return:

```
  r0  Calculated 16bit CRC Value
```

Additionally, if the length is nonzero, r3 contains the last processed halfword
at [addr+len-2]. Unlike most other NDS7/DSi7 SWI functions (which do reject
reading from BIOS memory), this allows to dump the NDS7/DSi7 BIOS (except for
the memory region that is locked via BIOSPROT Port 4000308h).



## SWI 0Fh (NDS7/NDS9) - IsDebugger


Detects if 4MB (normal) or 8MB (debug version) Main RAM installed.

Caution: Fails on ARM9 when cache is enabled (always returns 8MB state).

Return: r0 = result (0=normal console 4MB, 1=debug version 8MB)

Destroys halfword at [27FFFFAh] (NDS7) or [27FFFF8h] (NDS9)!

The SWI 0Fh function doesn't work stable if it gets interrupted by an interrupt
which is calling SWI 0Fh, which would destroy the above halfword scratch value
(unless the IRQ handler has saved/restored the halfword).



## SWI 1Ah (NDS7/DSi7) - GetSineTable


```
  r0  Index (0..3Fh) (must be in that range, otherwise returns garbage)
```

Return: r0 = Desired Entry (0000h..7FF5h) ;SIN(0 .. 88.6 degrees)\*8000h



## SWI 1Bh (NDS7/DSi7) - GetPitchTable (DSi7: bugged)


```
  r0  Index (0..2FFh) (must be in that range, otherwise returns garbage)
```

BUG: DSi7 accidently reads from SineTable instead of PitchTable, as workaround
for obtaining PitchTable values, one can set "r0=(0..2FFh)-46Ah" on DSi.

Return: r0 = Desired Entry (0000h..FF8Ah) (unsigned)



## SWI 1Ch (NDS7/DSi7) - GetVolumeTable


```
  r0  Index (0..2D3h) (must be in that range, otherwise returns garbage)
```

Return: r0 = Desired Entry (00h..7Fh) (unsigned)



## SWI 1Fh (NDS9/DSi9) - CustomPost


Writes to the POSTFLG register, probably for use by Firmware boot procedure.

```
  r0  32bit value, to be written to POSTFLG, Port 4000300h
```

Return: No return value.



## SWI 1Dh (NDS7/DSi7) - GetBootProcs


Returns addresses of Gamecart boot procedure/interrupt handler, probably for
use by Firmware boot procedure. Most of the returned NDS7 functions won't work
if the POSTFLG register is set.

The return values are somewhat XORed by each other (on DSi7 most of the values
are zero; which does rather negate the XORing effect, and, as a special
gimmick, one of the zero values is XORed by incoming r2).




# <a name="biosmultibootsinglegamepak"></a>BIOS Multi Boot (Single Game Pak)



MultiBoot



## SWI 25h (GBA) - MultiBoot


This function uploads & starts program code to slave GBAs, allowing to
launch programs on slave units even if no cartridge is inserted into the slaves
(this works because all GBA BIOSes contain built-in download procedures in
ROM).

However, the SWI 25h BIOS upload function covers only 45% of the required
Transmission Protocol, the other 55% must be coded in the master cartridge (see
Transmission Protocol below).

```
  r0  Pointer to MultiBootParam structure
  r1  Transfer Mode (undocumented)
       0=256KHz, 32bit, Normal mode    (fast and stable)
       1=115KHz, 16bit, MultiPlay mode (default, slow, up to three slaves)
       2=2MHz,   32bit, Normal mode    (fastest but maybe unstable)
  Note: HLL-programmers that are using the MultiBoot(param_ptr) macro cannot
  specify the transfer mode and will be forcefully using MultiPlay mode.
```

Return:

```
  r0  0=okay, 1=failed
```

See below for more details.



## Multiboot Parameter Structure


Size of parameter structure should be 4Ch bytes (the current GBA BIOS uses only
first 44h bytes though). The following entries must be set before calling SWI
25h:

```
  Addr Size Name/Expl.
  14h  1    handshake_data (entry used for normal mode only)
  19h  3    client_data[1,2,3]
  1Ch  1    palette_data
  1Eh  1    client_bit (Bit 1-3 set if child 1-3 detected)
  20h  4    boot_srcp  (typically 8000000h+0C0h)
  24h  4    boot_endp  (typically 8000000h+0C0h+length)
```

The transfer length (excluding header data) should be a multiple of 10h,
minimum length 100h, max 3FF40h (ca. 256KBytes). Set palette\_data as
"81h+color\*10h+direction\*8+speed\*2", or as "0f1h+color\*2" for fixed palette,
whereas color=0..6, speed=0..3, direction=0..1. The other entries
(handshake\_data, client\_data[1-3], and client\_bit) must be same as specified in
Transmission Protocol (see below hh,cc,y).



## Multiboot Transfer Protocol


Below describes the complete transfer protocol, normally only the Initiation
part must be programmed in the master cartridge, the main data transfer can be
then performed by calling SWI 25h, the slave program is started after SWI 25h
completion.

The ending handshake is normally not required, when using it, note that you
will need custom code in BOTH master and slave programs.

```
  Times  Send   Receive  Expl.
  -----------------------Required Transfer Initiation in master program
  ...    6200   FFFF     Slave not in multiplay/normal mode yet
  1      6200   0000     Slave entered correct mode now
  15     6200   720x     Repeat 15 times, if failed: delay 1/16s and restart
  1      610y   720x     Recognition okay, exchange master/slave info
  60h    xxxx   NN0x     Transfer C0h bytes header data in units of 16bits
  1      6200   000x     Transfer of header data completed
  1      620y   720x     Exchange master/slave info again
  ...    63pp   720x     Wait until all slaves reply 73cc instead 720x
  1      63pp   73cc     Send palette_data and receive client_data[1-3]
  1      64hh   73uu     Send handshake_data for final transfer completion
  -----------------------Below is SWI 25h MultiBoot handler in BIOS
  DELAY  -      -        Wait 1/16 seconds at master side
  1      llll   73rr     Send length information and receive random data[1-3]
  LEN    yyyy   nnnn     Transfer main data block in units of 16 or 32 bits
  1      0065   nnnn     Transfer of main data block completed, request CRC
  ...    0065   0074     Wait until all slaves reply 0075 instead 0074
  1      0065   0075     All slaves ready for CRC transfer
  1      0066   0075     Signalize that transfer of CRC follows
  1      zzzz   zzzz     Exchange CRC must be same for master and slaves
  -----------------------Optional Handshake (NOT part of master/slave BIOS)
  ...    ....   ....     Exchange whatever custom data
```

Legend for above Protocol

```
  y     client_bit, bit(s) 1-3 set if slave(s) 1-3 detected
  x     bit 1,2,or 3 set if slave 1,2,or 3
  xxxx  header data, transferred in 16bit (!) units (even in 32bit normal mode)
  nn    response value for header transfer, decreasing 60h..01h
  pp    palette_data
  cc    random client_data[1..3] from slave 1-3, FFh if slave not exists
  hh    handshake_data, 11h+client_data[1]+client_data[2]+client_data[3]
  uu    random data, not used, ignore this value
```

Below automatically calculated by SWI 25h BIOS function (don't care about)

```
  llll  download length/4-34h
  rr    random data from each slave for encryption, FFh if slave not exists
  yyyy  encoded data in 16bit (multiplay) or 32bit (normal mode) units
  nnnn  response value, lower 16bit of destadr in GBA memory (00C0h and up)
  zzzz  16bit download CRC value, must be same for master and slaves
```

Pseudo Code for SWI 25h Transfer with Checksum and Encryption calculations

```
  if normal_mode    then c=C387h:x=C37Bh:k=43202F2Fh
  if multiplay_mode then c=FFF8h:x=A517h:k=6465646Fh
  m=dword(pp,cc,cc,cc):f=dword(hh,rr,rr,rr)
  for ptr=000000C0h to (file_size-4) step 4
    c=c xor data[ptr]:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
    m=(6F646573h*m)+1
    send_32_or_2x16 (data[ptr] xor (-2000000h-ptr) xor m xor k)
  next
  c=c xor f:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
  wait_all_units_ready_for_checksum:send_32_or_1x16 (c)
```

Whereas, explained: c=chksum,x=chkxor,f=chkfin,k=keyxor,m=keymul



## Multiboot Communication


In Multiplay mode, master sends 16bit data, and receives 16bit data from each
slave (or FFFFh if none). In Normal mode, master sends 32bit data (upper 16bit
zero, lower 16bit as for multiplay mode), and receives 32bit data (upper 16bit
as for multiplay mode, and lower 16bit same as lower 16bit previously sent by
master). Because SIODATA32 occupies same addresses as SIOMULTI0-1, the same
transfer code can be used for both multiplay and normal mode (in normal mode
SIOMULTI2-3 should be forced to FFFFh though). After each transfer, master
should wait for Start bit cleared in SIOCNT register, followed by a 36us delay.

Note: The multiboot slave would also recognize data being sent in Joybus mode,
however, master GBAs cannot use joybus mode (because GBA hardware cannot act as
master in joybus mode).



## Multiboot Slave Header


The transferred Header block is written to 2000000-20000BFh in slave RAM, the
header must contain valid data (identically as for normal ROM-cartridge
headers, including a copy of the Nintendo logo, correct header CRC, etc.), in
most cases it'd be recommended just to transfer a copy of the master cartridges
header from 8000000h-80000BFh.



## Multiboot Slave Program/Data


The transferred main program/data block is written to 20000C0h and up (max
203FFFFh) in slave RAM, note that absolute addresses in the program must be
then originated at 2000000h rather than 8000000h. In case that the master
cartridge is 256K or less, it could just transfer a copy of the whole cartridge
at 80000C0h and up, the master should then copy & execute its own ROM data
into RAM as well.



## Multiboot Slave Extended Header


For Multiboot slaves, separate Entry Point(s) must be defined at the beginning
of the Program/Data block (the Entry Point in the normal header is ignored),
also some reserved bytes in this section are overwritten by the Multiboot
procedure. For more information see chapter about Cartridge Header.



## Multiboot Slave with Cartridge


Beside for slaves without cartridge, multiboot can be also used for slaves
which do have a cartridge inserted, if so, SELECT and START must be kept held
down during power-on in order to switch the slave GBA into Multiboot mode (ie.
to prevent it from starting the cartridge as normally).

The general idea is to enable newer programs to link to any existing older GBA
programs, even if these older programs originally didn't have been intended to
support linking.

The uploaded program may access the slaves SRAM, Flash ROM, or EEPROM (if any,
allowing to read out or modify slave game positions), as well as cartridge ROM
at 80000A0h-8000FFFh (the first 4KBytes, excluding the nintendo logo, allowing
to read out the cartridge name from the header, for example).

The main part of the cartridge ROM is meant to be locked out in order to
prevent software pirates from uploading "intruder" programs which would send
back a copy of the whole cartridge to the master, however, for good or evil, at
present time, current GBA models and GBA carts do not seem to contain any such
protection.



## Uploading Programs from PC


Beside for the ability to upload a program from one GBA to another, this
feature can be also used to upload small programs from a PC to a GBA. For more
information see chapter about External Connectors.



## Nintendo DS


The GBA multiboot function requires a link port, and so, works on GBA and GBA
SP only. The Nintendo DS in GBA mode does include the multiboot BIOS function,
but it won't be of any use as the DS doesn't have a link port.




# <a name="biossoundfunctions"></a>BIOS Sound Functions



MidiKey2Freq

SoundBias

SoundChannelClear

SoundDriverInit

SoundDriverMain

SoundDriverMode

SoundDriverVSync

SoundDriverVSyncOff

SoundDriverVSyncOn

SoundWhatever0..4

SoundGetJumpList



## SWI 1Fh (GBA) - MidiKey2Freq


Calculates the value of the assignment to ((SoundArea)sa).vchn[x].fr when
playing the wave data, wa, with the interval (MIDI KEY) mk and the fine
adjustment value (halftones=256) fp.

```
  r0  WaveData* wa
  r1  u8 mk
  r2  u8 fp
```

Return:

```
  r0  u32
```

This function is particularly popular because it allows to read from BIOS
memory without copy protection range checks. The formula to read one byte (a)
from address (i, 0..3FFF) is:

a = (MidiKey2Freq(i-(((i AND 3)+1)OR 3), 168, 0) \* 2) SHR 24



## SWI 19h (GBA) or SWI 08h (NDS7/DSi7) - SoundBias


Increments or decrements the current level of the SOUNDBIAS register (with
short delays) until reaching the desired new level. The upper bits of the
register are kept unchanged.

```
  r0   BIAS level (0=Level 000h, any other value=Level 200h)
  r1   Delay Count (NDS/DSi only) (GBA uses a fixed delay count of 8)
```

Return: No return value.



## SWI 1Eh (GBA) - SoundChannelClear


Clears all direct sound channels and stops the sound.

This function may not operate properly when the library which expands the sound
driver feature is combined afterwards. In this case, do not use it.

No parameters, no return value.



## SWI 1Ah (GBA) - SoundDriverInit


Initializes the sound driver. Call this only once when the game starts up.

It is essential that the work area already be secured at the time this function
is called.

You cannot execute this driver multiple times, even if separate work areas have
been prepared.

```
  r0  Pointer to work area for sound driver, SoundArea structure as follows:
       SoundArea (sa) Structure
        u32    ident      Flag the system checks to see whether the
                          work area has been initialized and whether it
                          is currently being accessed.
        vu8    DmaCount   User access prohibited
        u8     reverb     Variable for applying reverb effects to direct sound
        u16    d1         User access prohibited
        void   (*func)()  User access prohibited
        int    intp       User access prohibited
        void*  NoUse      User access prohibited
        SndCh  vchn[MAX]  The structure array for controlling the direct
                          sound channels (currently 8 channels are
                          available). The term "channel" here does
                          not refer to hardware channels, but rather to
                          virtual constructs inside the sound driver.
        s8     pcmbuf[PCM_BF*2]
       SoundChannel Structure
        u8         sf     The flag indicating the status of this channel.
                          When 0 sound is stopped.
                          To start sound, set other parameters and
                          then write 80h to here.
                          To stop sound, logical OR 40h for a
                          release-attached off (key-off), or write zero
                          for a pause. The use of other bits is
                          prohibited.
        u8         r1     User access prohibited
        u8         rv     Sound volume output to right side
        u8         lv     Sound volume output to left side
        u8         at     The attack value of the envelope. When the
                          sound starts, the volume begins at zero and
                          increases every 1/60 second. When it
                          reaches 255, the process moves on to the
                          next decay value.
        u8         de     The decay value of the envelope. It is
                          multiplied by "this value/256" every 1/60
                          sec. and when sustain value is reached, the
                          process moves to the sustain condition.
        u8         su     The sustain value of the envelope. The
                          sound is sustained by this amount.
                          (Actually, multiplied by rv/256, lv/256 and
                          output left and right.)
        u8         re     The release value of the envelope. Key-off
                          (logical OR 40h in sf) to enter this state.
                          The value is multiplied by "this value/256"
                          every 1/60 sec. and when it reaches zero,
                          this channel is completely stopped.
        u8         r2[4]  User access prohibited
        u32        fr     The frequency of the produced sound.
                          Write the value obtained with the
                          MidiKey2Freq function here.
        WaveData*  wp     Pointer to the sound's waveform data. The waveform
                          data can be generated automatically from the AIFF
                          file using the tool (aif2agb.exe), so users normally
                          do not need to create this themselves.
        u32        r3[6]  User access prohibited
        u8         r4[4]  User access prohibited
       WaveData Structure
        u16   type    Indicates the data type. This is currently not used.
        u16   stat    At the present time, non-looped (1 shot) waveform
                      is 0000h and forward loop is 4000h.
        u32   freq    This value is used to calculate the frequency.
                      It is obtained using the following formula:
                      sampling rate x 2^((180-original MIDI key)/12)
        u32   loop    Loop pointer (start of loop)
        u32   size    Number of samples (end position)
        s8    data[]  The actual waveform data. Takes (number of samples+1)
                      bytes of 8bit signed linear uncompressed data. The last
                      byte is zero for a non-looped waveform, and the same
                      value as the loop pointer data for a looped waveform.
```

Return: No return value.



## SWI 1Ch (GBA) - SoundDriverMain


Main of the sound driver.

Call every 1/60 of a second. The flow of the process is to call
SoundDriverVSync, which is explained later, immediately after the V-Blank
interrupt.

After that, this routine is called after BG and OBJ processing is executed.

No parameters, no return value.



## SWI 1Bh (GBA) - SoundDriverMode


Sets the sound driver operation mode.

```
  r0  Sound driver operation mode
       Bit    Expl.
       0-6    Direct Sound Reverb value (0-127, default=0) (ignored if Bit7=0)
       7      Direct Sound Reverb set (0=ignore, 1=apply reverb value)
       8-11   Direct Sound Simultaneously-produced (1-12 channels, default 8)
       12-15  Direct Sound Master volume (1-15, default 15)
       16-19  Direct Sound Playback Frequency (1-12 = 5734,7884,10512,13379,
              15768,18157,21024,26758,31536,36314,40137,42048, def 4=13379 Hz)
       20-23  Final number of D/A converter bits (8-11 = 9-6bits, def. 9=8bits)
       24-31  Not used.
```

Return: No return value.



## SWI 1Dh (GBA) - SoundDriverVSync


An extremely short system call that resets the sound DMA. The timing is
extremely critical, so call this function immediately after the V-Blank
interrupt every 1/60 second.

No parameters, no return value.



## SWI 28h (GBA) - SoundDriverVSyncOff


Due to problems with the main program if the V-Blank interrupts are stopped,
and SoundDriverVSync cannot be called every 1/60 a second, this function must
be used to stop sound DMA.

Otherwise, even if you exceed the limit of the buffer the DMA will not stop and
noise will result.

No parameters, no return value.



## SWI 29h (GBA) - SoundDriverVSyncOn


This function restarts the sound DMA stopped with the previously described
SoundDriverVSyncOff.

After calling this function, have a V-Blank occur within 2/60 of a second and
call SoundDriverVSync.

No parameters, no return value.



## SWI 20h..24h (GBA) - SoundWhatever0..4 (Undocumented)


Whatever undocumented sound-related BIOS functions.



## SWI 2Ah (GBA) - SoundGetJumpList (Undocumented)


Receives pointers to 36 additional sound-related BIOS functions.

```
  r0  Destination address (must be aligned by 4) (120h bytes buffer)
```




# <a name="biossha1functionsdsionly"></a>BIOS SHA1 Functions (DSi only)



SHA1\_Init(struct)

SHA1\_Update(struct,src,srclen)

SHA1\_Finish(dst,struct)

SHA1\_Init\_Update\_Finish(dst,src,srclen)

SHA1\_Init\_Update\_Finish\_Mess(dst,dstlen,src,srclen)

SHA1\_Compare\_20\_Bytes(src1,src2)

SHA1\_Default\_Callback(struct,src,len)



## SWI 24h (DSi9/DSi7) - SHA1\_Init(struct)


Initializes a 64h-byte structure for SHA1 calculations:

```
  [struct+00h] = 67452301h      ;\
  [struct+04h] = EFCDAB89h      ;
  [struct+08h] = 98BADCFEh      ; initial SHA1 checksum value
  [struct+0Ch] = 10325476h      ;
  [struct+10h] = C3D2E1F0h      ;/
  [struct+14h] = 00000000h ;lsw ;\total len in bits, initially zero
  [struct+18h] = 00000000h ;msw ;/
  [struct+1Ch] = uninitialzed   ;-buffer for incomplete fragment (40h bytes)
  [struct+5Ch] = 00000000h      ;-incomplete fragment size
  if [struct+60h] = 00000000h then [struct+60h] = SHA1_Default_Callback
```

Observe that the incoming [struct+60h] value should be 00000000h, otherwise the
default callback isn't installed (using a different callback doesn't make too
much sense, and it's probably not done by any DSi programs) (the callback
feature might be intended to mount hardware accelleration, or to hook,
customize, encrypt, or replace the SHA1 functionality).



## SWI 25h (DSi9/DSi7) - SHA1\_Update(struct,src,srclen)


This function should be placed between Init and Finish. The Update function can
be called multiple times if the source data is split into separate blocks.
There's no alignment requirement (though the function works faster if src is
4-byte aligned).

```
  [struct+14h]=[struct+14h]+len*8  ;64bit value ;-raise total len in bits
  if [struct+5Ch]<>0 and [struct+5Ch]+len>=40h  ;\
    for i=[struct+5Ch] to 3Fh                   ; merge old incomplete chunk
      [struct+1Ch+i]=[src], src=src+1, len=len-1; with new data and process it
    SHA1_Callback(struct,struct+1Ch,40h)        ; (if it gives a full chunk)
    [struct+5Ch]=0                              ;/
  if len>=40h then                              ;\process full 40h-byte chunks
    SHA1_Callback(struct,src,len AND NOT 3Fh)   ; (if src isn't 4-byte aligned
    src=src+(len AND NOT 3Fh)                   ; then the DSi BIOS internally
    len=len AND 3Fh                             ;/copies all chunks to struct)
  if len>0 then                                 ;\
    for i=[struct+5Ch] to [struct+5Ch]+len-1    ; memorize remaining bytes
      [struct+1Ch+i]=[src], src=src+1, len=len-1; as incomplete chunk
      [struct+5Ch]=[struct+5Ch]+1               ;/
```



## SWI 26h (DSi9/DSi7) - SHA1\_Finish(dst,struct)


```
  [total_len]=bswap8byte([struct+14h]) ;get total len in bits in big-endian
  SHA1_Update(struct,value_80h,1)                            ;append end byte
  while [struct+5Ch]<>38h do SHA1_Update(struct,value_00h,1) ;append padding
  SHA1_Update(struct,total_len,8)                            ;append 64bit len
  [struct+14h]=bswap8byte([total_len]) ;restore total len, exclude above update
  [dst+00h]=bswap([struct+00h]  ;msw   ;\
  [dst+04h]=bswap([struct+04h]         ; store SHA1 result at dst
  [dst+08h]=bswap([struct+08h]         ; (in big-endian)
  [dst+0Ch]=bswap([struct+0Ch]         ;
  [dst+10h]=bswap([struct+10h]  ;lsw   ;/
```



## SHA1\_Default\_Callback(struct,src,len)


```
  for j=1 to len/40h
    a=[struct+0], b=[struct+4], c=[struct+8], d=[struct+0Ch], e=[struct+10h]
    for i=0 to 79
      if i=0..15  then w[i] = bswap([src]), src=src+4
      if i=16..79 then w[i] = (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) rol 1
      if i=0..19  then f=5A827999h + e + (d xor (b and (c xor d)))
      if i=20..39 then f=6ED9EBA1h + e + (b xor c xor d)
      if i=40..59 then f=8F1BBCDCh + e + ((b and c) or (d and (b or c)))
      if i=60..79 then f=CA62C1D6h + e + (b xor c xor d)
      e=d, d=c, c=(b ror 2), b=a, a=f + (a rol 5) + w[i]
    [struct+0]=[struct+0]+a, [struct+4]=[struct+4]+b, [struct+8]=[struct+8]+c
    [struct+0Ch]=[struct+0Ch]+d, [struct+10h]=[struct+10h]+e
```



## SWI 27h (DSi9/DSi7) - SHA1\_Init\_Update\_Finish(dst,src,srclen)


```
  [struct+60h]=00000000h  ;want Init to install the default SHA1 callback
  SHA1_Init(struct)
  SHA1_Update(struct,src,srclen)
  SHA1_Finish(dst,struct)
```

Always returns r0=1.



## SWI 29h (DSi9/DSi7) - SHA1\_Init\_Update\_Finish\_Mess(dst,dstlen,src,srclen)


```
  if dst=0 then exit(r0=1)  ;uh, that's same return value as when okay
  if src=0 and srclen<>0 then exit(r0=0)
  [struct+60h]=00000000h                ;\
  SHA1_Init(struct)                     ; first compute normal SHA1
  SHA1_Update(struct,src,srclen)        ; (same as SHA1_Init_Update_Finish)
  SHA1_Finish(first_sha1,struct)        ;/
 @@lop1:
  i=13h  ;start with LSB of big-endian 20-byte value  ;\increment SHA1 value
 @@lop2:                                              ; by one (with somewhat
  [first_sha1+i]=[first_sha1+i]+1, i=i-1              ; uncommon/bugged carry-
  if i>=0 and [first_sha1+i+1]=01h then goto @@lop2   ;/out to higher bytes)
  SHA1_Update(struct,first_sha1,14h)    ;\compute 2nd SHA1 across 1st SHA1,
  SHA1_Finish(second_sha1,struct)       ;/done without re-initializing struct
  for i=0 to min(14h,dstlen)-1, [dst]=[second_sha1+i], dst=dst+1
  dstlen=dstlen-min(14h,dstlen)
  if dstlen<>0 then goto @@lop1 else exit(r0=1)
```



## SHA1\_Init\_Update\_Finish\_HMAC(dst,key,src,srclen)


```
  if len(key)>40h then key=SHA1(key) ;convert LONG keys to 14h-bytes length
  if len(key)<40h then zero-pad key to 40h-bytes length
  for i=0 to 3Fh, [inner_key+i]=[key+i] xor 36h ;\
  [struct+60h]=00000000h                        ;
  SHA1_Init(struct)                             ; compute 1st SHA1
  SHA1_Update(struct,inner_key,40h)             ; across inner key and data
  SHA1_Update(struct,src,srclen)                ;
  SHA1_Finish(first_sha1,struct)                ;/
  for i=0 to 3Fh, [outer_key+i]=[key+i] xor 5Ch ;\
  [struct+60h]=00000000h                        ;
  SHA1_Init(struct)                             ; compute final SHA1
  SHA1_Update(struct,outer_key,40h)             ; across outer key and 1st SHA1
  SHA1_Update(struct,first_sha1,14h)            ;
  SHA1_Finish(dst,struct)                       ;/
```



## SWI 28h (DSi9/DSi7) - SHA1\_Compare\_20\_Bytes(src1,src2)


Out: r0=1=match, r0=0=mismatch/error (error occurs if src1=0 or src2=0).




# <a name="biosrsafunctionsdsionly"></a>BIOS RSA Functions (DSi only)



RSA\_Init\_crypto\_heap(heap\_nfo,heap\_start,heap\_size)

RSA\_Decrypt(heap\_nfo,struct,dest4)

RSA\_Decrypt\_Unpad(heap\_nfo,dst,src,key)

RSA\_Decrypt\_Unpad\_OpenPGP\_SHA1(heap\_nfo,dst,src,key)


RSA is important because the DSi cartridge header and system files do contain
RSA signatures. Which makes it impossible to create unlicensed software
(without knowing Nintendo's private key).

- [BIOS RSA Basics](#biosrsabasics)
- [BIOS RSA Pseudo Code](#biosrsapseudocode)


## SWI 20h (DSi9/DSi7) - RSA\_Init\_crypto\_heap(heap\_nfo,heap\_start,heap\_size)


Initializes the heap for use with SWI 21h..23h. heap\_nfo is a 0Ch-byte
structure, which gets set to:

```
  [heap_nfo+0] = heap_start (rounded-up to 4-byte boundary)
  [heap_nfo+4] = heap_end   (start+size, rounded-down to 4-byte boundary)
  [heap_nfo+8] = heap_size  (matched to above rounded values)
```

heap\_start should point to a free memory block which will be used as heap,
heap\_size should be usually 1000h.



## SWI 21h (DSi9/DSi7) - RSA\_Decrypt(heap\_nfo,ptr\_nfo,len\_dest)


```
  [ptr_nfo+0] = dst (usually 7Fh bytes, max 80h bytes)
  [ptr_nfo+4] = src (80h bytes)
  [ptr_nfo+8] = key (80h bytes)
```

This is a subfunction for SWI 22h/23h. It's returning raw decrypted data
without unpadding (aside from stripping leading 00h bytes; most (or all)
signatures are containing one leading 00h byte, so the returned [len\_dest]
value will be usually 7Fh).

Return value (r0) is: 0=failed, 1=okay. The length of the decrypted data is
returned at [len\_dest].



## SWI 22h (DSi9/DSi7) - RSA\_Decrypt\_Unpad(heap\_nfo,dst,src,key)


Same as SWI 21h, and additionally removes the "01h,min eight FFh,00h" padding.
src,dst,key should be 80h-bytes. The output at dst can be theoretically max
80h-bytes (or shorter due to removed padding). In practice, the DSi is often
using only the first 14h-bytes at dst (aka the last 14h-bytes from src) as SHA1
or SHA1-HMAC value (RSA-SHA1). Return value (r0) is: 0=failed, 1=okay.



## SWI 23h (DSi9/DSi7) - RSA\_Decrypt\_Unpad\_OpenPGP\_SHA1(heap\_nfo,dst,src,key)


Same as SWI 22h, but with some extra processing for extracting a SHA1 value
from an OpenPGP header: The data must consist of five ASN.1 (DER) chunks (with
Tag IDs 30h,30h,06h,05h,04h), the last chunk (with ID=04h) must be 14h bytes in
size, and the 14h-byte chunk data is then copied to dst. The other four chunks
must exist, but their content is just skipped.

```
  00h 1    Leading zero       (00h)                           ;\
  01h 1    Block type         (01h)                           ; padding
  02h 5Ah  Padding Bytes      (FFh-filled)                    ;
  5Ch 1    Padding End        (00h)                           ;/
  5Dh 2    30h,junk(1)        (30h,21h)                       ;-sequence
  5Fh 2    30h,junk(1)        (30h,09h)                       ;-sequence
  61h 7    06h,len,junk(len)  (06h,05h, 2Bh,0Eh,03h,02h,1Ah)  ;-OID for SHA1
  68h 2    05h,junk(1)        (05h,00h)                       ;-null
  6Ah 16h  04h,len,sha1(len)  (04h,14h, sha1[14h bytes])      ;-SHA1
```

The "junk" bytes aren't actually used/verified by the DSi. Handling chunks with
len>7Fh looks quite weird/bugged. The DSi firmware contains some functions
where it could optionally use SWI 22h or SWI 23h for RSA signatures (although,
there aren't any known cases where it would actually use SWI 23h). Note: The
DSi's Flipnote ".ppm" files are using the SWI 23h style SHA1 format (but
Flipnote contains it's own RSA functions instead of using the BIOS SWI
functions). DS Download Play (and equivalent code in NDS Firmware) is SWI 23h
style, too (but also uses its own RSA function instead of the BIOS SWI).

Note: The format is based on the OpenPGP Message Format (RFC 4880), that format
allows to use similar headers for MD5, SHA256, etc. (the DSi supports only SHA1
though).



## Unencrypted Signatures


Emulators can hook the RSA BIOS functions to copy unencrypted signatures as-is
(instead of trying to decrypt them). That allows to create "authentic" files
that are fully compatible with the DSi firmware, and which would be actually
working on real hardware (when knowing the private key).

Unencrypted 80h-byte signatures should be stored in following format (as
defined in RFC 2313):

```
  00h   1      "00" Leading zero (00h)
  01h   1      "BT" Block type (always 01h on DSi)
  02h   8+n    "PS" Padding (FFh-filled, min 8 bytes, usually 69h bytes on DSi)
  0Ah+n 1      "00" Padding end (00h)
  0Bh+n 75h-n  "D"  Data (max 75h bytes, usually a 14h-byte SHA1 value on DSi)
```

If the hooked BIOS function sees a RSA source to contain "00h, 01h, at least
eight FFh, followed by 00h", then it could treat it as unencrypted data (it's
nearly impossible that an encrypted signature could contain those values).



## Key.Bit0


The DSi BIOS contains two different RSA core modes (either one of them is used,
depending on whether BIT0 of the FIRST BYTE of the "key" is set or cleared).
The purpose & difference between those two modes is unknown. Also, dunno if
that BIT0 thing is something common in the RSA world?



## DSi Public RSA Keys (for verifying signatures)


```
  TWL_FIRM       (F1,F5,1A,FF..) eMMC Boot Info (same key for retail+debug)
  BIOS:FFFF87F4h (C3,02,93,DE..) Key0: System Menu (Launcher) of Retail version
  BIOS:FFFF8874h (B6,18,D8,61..) Key1: System Fun Tools and Wifi Firmware
  BIOS:FFFF88F4h (DA,94,09,01..) Key2: System Base Tools (Settings, Shop)
  BIOS:FFFF8974h (95,6F,79,0D..) Key3: DSiWare and DSi ROM Cartridges
  BIOS:FFFF89F4h (D4,30,E3,7D..) Key4: Unknown ;\probably more/unused RSA keys
  BIOS:FFFF8A74h (BD,29,02,38..) Key5: Unknown ; (DSi only)
  BIOS:FFFF8AF4h (CF,8A,4B,15..) Key6: Unknown ; (doesn't exist on 3DS)
  BIOS:FFFF8B74h (A3,BC,C1,7C..) Key7: Unknown ;/
  BIOS:FFFF9920h (30,33,26,D5..) Unknown (probably NOT a RSA key)
  Launcher       (BA,F1,98,A4..) HWINFO_S.dat (with RSA-SHA1-HMAC)
  Launcher       (9F,80,BC,5F..) Version Data and TWLFontTable.dat
  Launcher       (C7,F4,1D,27..) DS Cart Whitelist (missing RSA in v1.4E)
  Launcher+NDS   (9E,C1,CC,C0..) For wifi-booted NDS titles (DsDownloadPlay)
  Flipnote       (C2,3C,BC,13..) Public key for Flipnote .ppm files
  Unknown        (?)             HWID.sgn
  Unknown        (?)             Newer NDS ROM Cartridges (have RSA, too?)
  DSi Shop       (9D,69,36,28..) Unknown, seems to be RSA        (100h bytes)
  Launcher       (F8,24,6C,58..) Root key for cert.sys CA00000001(200h bytes)
  cert.sys       (B2,79,C9,E2..) CA00000001 key for cert.sys keys(100h bytes)
  cert.sys       (93,BC,0D,1F..) CP00000007 key for tmd's        (100h bytes)
  cert.sys       (AD,07,A9,37..) XS00000003 key for shop-tickets (100h bytes)
  cert.sys       (92,FF,96,40..) XS00000006 key for free-tickets (100h bytes)
  cert.sys       (01,93,6D,08..) MS00000008 key for dev.kp       (ECC, non-RSA)
  dev.kp         (per-console)   TWxxxxxxxx... key for tad files (ECC, non-RSA)
  *.bin          (random?)       AP00030015484e42gg in tad files (ECC, non-RSA)
  Launcher+Boot  (BC,FD,A1,FF..) Debug0: System Menu (Launcher, Debug version)
  Launcher       (E9,9E,A7,9F..) Debug1:
  Launcher       (A7,9F,54,A0..) Debug2:
  Launcher       (AC,93,BB,3C..) Debug3: Public key for Debug DSiware/ROMs
  Debug Updater  (E5,1C,BF,C7..) Debug Public key for HWInfo
  Debug Updater  (C8,4B,38,2C..) Debug Public key for HWID.sgn    (100h bytes)
  Launcher       (D0,1F,E1,00..) Debug Root key for CA00000002 key(200h bytes)
  debug cert.sys (...)           Debug CA00000002 key for cert.sys(100h bytes)
  debug cert.sys (...)           Debug CP00000005 key for ...?    (100h bytes)
  debug cert.sys (...)           Debug CP00000007 key for ...     (100h bytes)
  debug cert.sys (...)           Debug XS00000006 key for ...     (100h bytes)
  verdata        (...)           Public keys in Version Data file?
  Unknown        (?)             further keys...?
```



## DSi Private RSA Keys (for creating signatures)


Nintendo's private keys should be known only by Nintendo. However, the console
does have a few "own" private keys (for sending signed data to Nintendo
(verdata), for storing signed data on SD card (flipnote), plus some more keys
for the developer's debug version).

```
  Flipnote       (26,A7,53,7E..) Private key for Flipnote .ppm files
  dev.kp         (per-console)   TWxxxxxxxx... key for tad files (ECC, non-RSA)
  (temp/unsaved?)(random?)       AP00030015484e42gg    tad files (ECC, non-RSA)
  verdata        (...)           Private keys in Version Data file?
  Debug Updater  (77,FC,77,9E..) Private key for Debug HWID.sgn (100h bytes)
  Debug Updater  (B5,7C,C2,85..) Private key for Debug HWInfo
  Debug SDK      (95,DC,C8,18..) Private key for Debug DSiware/ROMs (Debug3)
  Unknown        (?)             further keys...?
```

The private keys are usually stored in DER format; that's including entries for
the public key/exponent, and the original prime numbers that the key was
generated from, plus some numbers that were temporarily used during key
creation, and with all entries preceeded by tag/length values, whereas values
with MSB set are preceeded by a 00h byte to make them "unsigned" (eg. most
80h-byte keys will occupy 81h bytes in DER format).




# <a name="biosrsabasics"></a>BIOS RSA Basics




## RSA Basics


The RSA formulas are quite simple: Applying an exponent and modulus to the
source data. There are two formulas used for encryption/decryption. The first
formula requires only the Public Key (and an exponent, which is usually some
fixed constant; on the DSi it's always 10001h aka 65537 decimal). The second
formula is almost same, but requires the Private Key instead of the constant
exponent (and also requires the Public Key as modulus):

```
  Public Key formula:      dest = src^10001h mod pubkey
  Private Key formula:     dest = src^prvkey mod pubkey
```

That formulas can be used for encrypting secret messages, as so:

```
  Recipient's Public Key   --> Encrypt a message
  Recipient's Private Key  --> Decrypt a message
```

Or, using the formulas the other way around, to create digital signatures:

```
  Sender's Private Key     --> Encrypt/create a signature
  Sender's Public Key      --> Decrypt/verify a signature
```

The overall idea is that only the owner of the Private Key can decrypt
messages, or create signatures. The Public Key can be shared freely, so that
everybody can encrypt messages, or verify signatures.



## RSA Big Number Maths


The exponent/modulus can be implemented with simple unsigned multiply/divide
operations. However, RSA requires dealing with big 1024bit integers (or even
bigger numbers when using larger keys), this does usually require some software
functions since regular CPUs cannot directly deal with such large numbers.



## RSA Byte Order


The DSi is storing all RSA keys and signatures in Big-Endian format, so one
will need to reverse the byte order before doing the actual maths on
Little-Endian CPUs.



## RSA Signatures (used on DSi)


Digital signatures can be used for signing documents or other binaries. The
signature does usually consist of a secure checksum (SHA-1, MD5, SHA256, etc.)
computed on the document/binary, and then encrypted via the RSA Private Key
formula.

The checksum can be then decrypted via Public Key, if the decrypted checksum
does match up, then one can be sure that the document/binary hasn't been
modified, and that it was really created by the Private Key owner.



## RSA Encrypted Messages (not used on DSi)


Encrypted RSA messages are restricted to the size of the Public Key (eg. with a
1024bit key, the message should be smaller than 128 bytes). For bigger
messages, one could either split the message into smaller snippets, or, one
could combine RSA with some other encryption mechanism (eg. store an AES key in
the RSA message, and decrypt the actual document via AES; that would add
private/public key security to AES).



## RSA Padding


RSA can be weak if the message is a small number (especially very small values
like "0" or "1" obviously wouldn't work well with the "msg^exp" maths; other
small values can be also weak, eg. with the common/small public exponent
10001h). To avoid that problem, the MSBs of the message should be padded with
nonzero bytes, typically as so (as defined in RFC 2313):

```
  00h   1      "00" Leading zero (00h)
  01h   1      "BT" Block type (always 01h on DSi)
  02h   8+n    "PS" Padding (FFh-filled, min 8 bytes, usually 69h bytes on DSi)
  0Ah+n 1      "00" Padding end (00h)
  0Bh+n 75h-n  "D"  Data (max 75h bytes, usually a 14h-byte SHA1 value on DSi)
```

That, for 80h-byte messages. For other sizes replace "75h" by "F5h, 1F5h, etc."



## RSA Key Generation


Generating a RSA key pair is more difficult than the encryption/decryption
part. First of, one needs two unsigned random prime numbers; for a 1024bit key,
that would be usually two large 512bit prime numbers (whereas, finding real
prime numbers is complicated, and it's more common to use values that have a
"high probability" of being prime numbers).

The public key is then simply generated by multiplying the two prime numbers (P
and Q) with each other:

```
  pubkey = P * Q
```

The private key is also based on the same prime numbers, but the maths there
are more complicated (and not described here).

When knowing one prime number, one could theoretically compute the other as
"Q=pubkey/P", however, prime numbers aren't as rare as one might think, and
it's quite impossible to guess (or brute-force) one of the prime numbers.




# <a name="biosrsapseudocode"></a>BIOS RSA Pseudo Code




## rsa\_mpi\_pow\_mod(dst,src,pubkey,exp,num\_exp\_bits) ;[dst]=[src]^[exp] mod [key]


```
  base(rsa__number_size), bigbuf(rsa_number_size*2)
  [base]=[src], [dst]=1, pow8bit=01h                ;-init base, result, powbit
  for i=1 to num_exp_bits
    if [exp] AND pow8bit then rsa_mpi_mul_mod(dst,base)   ;-mul result
    rsa_mpi_mul_mod(base,base)                            ;-square base
    pow8bit=pow8bit ROL 1, exp=exp+carry                  ;-next exp bit
  next i
  return
```

This is the RSA main function. The exponent is applied by squaring the "src"
several times, and, if the corresponding exponent bit is set, multiplying the
result by the squared value. To avoid the numbers to become incredible large,
the modulus is applied after each multiplication (rather than applying it only
on the final result).

```
  For the Private Key formula: Use exp=prvkey, num_exp_bits=rsa_number_size*8
  For the Public Key formula:  Use exp=ptr_to_10001h, num_exp_bits=17
```

The parameters and result for "rsa\_mpi\_pow\_mod" must be in little-endian. Ie.
for DSi, reverse the byte order of the incoming/outgoing values. And, on DSi,
use rsa\_number\_size=80h (aka 128 bytes, aka for 1024bit RSA).



## rsa\_mpi\_mul\_mod(dst,src):


```
  rsa_mpi_mul(bigbuf,dst,src)           ;-multiply
  rsa_mpi_mod(bigbuf,pubkey)            ;-modulus
  [dst]=[bigbuf+0..rsa_number_size-1]   ;-copy to dst
  return
```



## rsa\_mpi\_mul(dst,src1,src2):    ;[dst]=[src1]\*[src2]


```
  [dst+0]=0, oldmsw=0                   ;-init first word and oldmsw
  for i=0 to rsa_number_size-4 step 4   ;\
    call @@inner_loop                   ; compute LSWs of destination
    src2=src2+4                         ;
  next i                                ;/
  src2=src2-4
  for i=rsa_number_size-8 to 0 step -4  ;\
    src1=src1+4                         ; compute MSWs of destination
    call @@inner_loop                   ;
  next i                                ;/
  return
 ;---
 @@inner_loop:
  [dst+4]=oldmsw, oldmsw=0
  for j=0 to i step 4
    msw:lsw = [src1+j]*[src2-j]
    [dst+0]=[dst+0]+lsw
    [dst+4]=[dst+4]+msw+cy
    oldmsw=oldmsw+cy
  next j
  dst=dst+4
  ret
```



## rsa\_mpi\_mod(dst,src):   ;[dst]=[dst] mod [src]  ;aka division remainder


;Double/Single -> Single modulo division (mpi/mpi)

;Divisor's MSW must be >= 80000000h

```
  ebx=rsa_number_size, dst=dst+ebx, i=ebx+4
 @@type0_lop:                                                           ;\
  if [dst+ebx-4]=0 then goto @@type0_next                               ;
  rsa_mpi_cmp(dst,src), if borrow then goto @@type1_next                ; type0
  rsa_mpi_sub(dst,src), if [dst+ebx-4]<>0 then goto @@type1_next        ; loop
 @@type0_next:                                                          ;
  dst=dst-4, i=i-4, if i>0 then goto @@type0_lop                        ;/
  goto @@done
 ;--- --- ---
 @@type1_lop:                                                           ;\
  lsw=[dst+ebx-4], msw=[dst+ebx-0]                                      ;
  if msw>=[src+ebx-4] then fac=FFFFFFFFh else fac=msw:lsw / [src+ebx-4] ;
  rsa_mpi_mulsub(dst,src,fac), if carry=0 then goto @@skip_add          ; type1
 @@add_more:                                                            ; loop
  rsa_mpi_add(dst,src)                                                  ;
  [dst+ebx]=[dst+ebx]+carry, if carry=0 then goto @@add_more            ;
 @@skip_add:                                                            ;
  if [dst+ebx-4]=0 then goto @@type0_next                               ;
 @@type1_next:                                                          ;
  dst=dst-4, i=i-4, if i>0 then goto @@type1_lop                        ;/
 @@done:
  return
```



## rsa\_mpi\_mulsub(dst,src,fac):    ;[dst]=[dst]-[src]\*fac


```
  oldborrow=0, oldmsw=0                                       ;\
  for i=0 to rsa_number_size-4 step 4                         ; process
    msw:lsw = [src+i]*fac, lsw=lsw+oldmsw, oldmsw=msw+carry   ; rsa_number_size
    [dst+i]=[dst+i]-lsw-oldborrow, oldborrow=borrow           ; bytes, plus...
  next i                                                      ;/
  [dst+rsa_number_size]=[dst+rsa_number_size]-oldmsw-oldborrow ;-one extra word
  return borrow   ;(unlike "rsa_embedded" which returns INVERTED borrow)
```



## rsa\_mpi\_add(dst,src):   ;out: [dst]=[dst]+[src], carry


```
  carry = 0
  for i=0 to rsa_number_size-4 step 4
    [dst+i]=[dst+i]+[src+i]+carry
  next i
  return carry
```



## rsa\_mpi\_sub(dst,src):   ;out: [dst]=[dst]-[src], borrow/unused


```
  borrow = 0
  for i=0 to rsa_number_size-4 step 4
    [dst+i]=[dst+i]-[src+i]-borrow
  next i
  return borrow
```



## rsa\_mpi\_cmp[dst,src]:   ;compare [dst]-[src], out: borrow


```
  for i=rsa_number_size-4 to 0 step -4
    temp=[dst+i]-[src+i], if not equal then return borrow
  next i
  return borrow
```

This is about same as "sub", but faster (because it can abort the loop upon
first difference).




# <a name="bios3dsexceptionvectors"></a>BIOS 3DS Exception Vectors




## Exception Vectors


The 3DS bootroms do mostly contain bootcode, unlike GBA/NDS without any public
functions, apart from some small stubs for redirecting the exception vectors to
RAM locations:

```
  08000000h 8  arm9_irq                ldr r15,[$+4] // dd vector  ;\
  08000008h 8  arm9_fiq                ldr r15,[$+4] // dd vector  ;
  08000010h 8  arm9_svc                ldr r15,[$+4] // dd vector  ; ARM9
  08000018h 8  arm9_undef              ldr r15,[$+4] // dd vector  ; exceptions
  08000020h 8  arm9_prefetch_abort     ldr r15,[$+4] // dd vector  ;
  08000028h 8  arm9_data_abort         ldr r15,[$+4] // dd vector  ;/
  1FFFFFA0h 8  arm11_irq               ldr r15,[$+4] // dd vector  ;\
  1FFFFFA8h 8  arm11_fiq               ldr r15,[$+4] // dd vector  ;
  1FFFFFB0h 8  arm11_svc               ldr r15,[$+4] // dd vector  ; ARM11
  1FFFFFB8h 8  arm11_undef             ldr r15,[$+4] // dd vector  ; exceptions
  1FFFFFC0h 8  arm11_prefetch_abort    ldr r15,[$+4] // dd vector  ;
  1FFFFFC8h 8  arm11_data_abort        ldr r15,[$+4] // dd vector  ;/
  1FFFFFDCh 4  arm11_core1_entrypoint  dd vector                   ;-CPU1 entry
  (OVERLAY) 4  arm11_core23_entry      dd vector                   ;-CPU2/3
```

The ARM11 exception vectors are shared for all CPU cores (so one must manually
redirect them to core specific handlers).

Alternately, instead of using the above RAM vectors, one could use ARM11
virtual memory or ARM9 ITCM for custom vectors.

Moreover, the CFG11\_BOOTROM\_OVERLAY\_CNT/VAL feature allows to redirect ARM11
vectors on New3DS (mainly intended for booting CPU2/CPU3 cores).



## SWI/SVC Functions


There aren't any built-in functions in the bootroms, however, SVC opcodes can
be used to obtain entrypoints to OS functions. That is, once when the OS is
booted (FIRM files are started without any OS functions, but .code files can
use OS functions).

Note: ARM has renamed SWI opcodes to SVC opcodes.




# <a name="biosramusage"></a>BIOS RAM Usage



Below contains info about RAM contents at cartridge boot time (as initialized
by the BIOS/Firmware), plus info about RAM locations used by IRQ handlers and
SWI functions.



## GBA BIOS RAM Usage


Below memory at 3007Fxxh is often accessed directly, or via mirrors at
3FFFFxxh.

```
  3000000h 7F00h User Memory and User Stack              (sp_usr=3007F00h)
  3007F00h A0h   Default Interrupt Stack (6 words/time)  (sp_irq=3007FA0h)
  3007FA0h 40h   Default Supervisor Stack (4 words/time) (sp_svc=3007FE0h)
  3007FE0h 10h   Debug Exception Stack (4 words/time)    (sp_xxx=3007FF0h)
  3007FF0h 4     Pointer to Sound Buffer (for SWI Sound functions)
  3007FF4h 3     Reserved (unused)
  3007FF7h 1     Reserved (intro/nintendo logo related)
  3007FF8h 2     IRQ IF Check Flags (for SWI IntrWait/VBlankIntrWait functions)
  3007FFAh 1     Soft Reset Re-entry Flag (for SWI SoftReset function)
  3007FFBh 1     Reserved (intro/multiboot slave related)
  3007FFCh 4     Pointer to user IRQ handler (to 32bit ARM code)
```



## NDS BIOS RAM Usage


Below memory at 27FFxxxh is mirrored to 23FFxxxh (on retail consoles with 4MB
RAM), however, it should be accessed via address 27FFxxxh (for compatibility
with debug consoles with 8MB RAM). Accessing it via mirrors at 2FFFxxxh is also
valid (this is done by DSi enhanced games; even when running in non-DSi mode;
this allows DSi games to use the same memory addresses in NDS and DSi mode).

```
  2000000h ...   ARM7 and ARM9 bootcode can be loaded here (2000000h..23BFDFFh)
  2400000h ...   Debug bootcode can be loaded here (2400000h..27BFDFFh)
  23FEE00h 168h  Fragments of NDS9 firmware boot code
  27FF800h 4     NDS Gamecart Chip ID 1
  27FF804h 4     NDS Gamecart Chip ID 2
  27FF808h 2     NDS Cart Header CRC (verified)            ;hdr[15Eh]
  27FF80Ah 2     NDS Cart Secure Area CRC (not verified ?) ;hdr[06Ch]
  27FF80Ch 2     NDS Cart Missing/Bad CRC (0=Okay, 1=Missing/Bad)
  27FF80Eh 2     NDS Cart Secure Area Bad (0=Okay, 1=Bad)
  27FF810h 2     Boot handler task number (usually FFFFh at cart boot time)
  27FF812h 2     Secure disable (0=Normal, 1=Disable; Cart[078h]=BIOS[1088h])
  27FF814h 2     SIO Debug Connection Exists (0=No, 1=Yes)
  27FF816h 2     RTC Status?                 (0=Okay, 1=Bad)
  27FF818h 1     Random RTC    ;random LSB from SIO debug detect handshake
  27FF819h 37h   Zerofilled by firmware
  27FF850h 2     NDS7 BIOS CRC (5835h)
  27FF860h 4     Somewhat copy of Cart[038h], nds7 ram addr (?)
  27FF864h 4     Wifi FLASH User Settings Bad (0=Okay, 1=Bad)
  27FF868h 4     Wifi FLASH User Settings FLASH Address (fmw[20h]*8)
                   maybe recommended to use above RAM cell instead FLASH entry?
  27FF86Ch 4     Whatever (seems to be zero at cart boot time)
  27FF870h 4     Whatever (seems to be zero at cart boot time)
  27FF874h 2     Wifi FLASH firmware part5 crc16 (359Ah) (fmw[026h])
  27FF876h 2     Wifi FLASH firmware part3/part4 crc16 (fmw[004h] or ZERO)
                   Above is usually ZERO at cart boot (set to fmw[004h] only
                   when running pictochat, or maybe also when changing user
                   settings)
  27FF878h 08h   Not used
  27FF880h 4     Message from NDS9 to NDS7  (=7 at cart boot time)
  27FF884h 4     NDS7 Boot Task (also checked by NDS9) (=6 at cart boot time)
  27FF888h ..    Whatever (seems to be zero at cart boot time)
  27FF890h 4     Somewhat boot flags (somewhat B0002A22h)
                   bit10 part3/part4 loaded/decoded (bit3 set if bad crc)
                   bit28 part5 loaded/decoded with good crc
  27FF894h 36Ch  Not used (zero)
  27FFC00h 4     NDS Gamecart Chip ID 1   (copy of 27FF800h)
  27FFC04h 4     NDS Gamecart Chip ID 2   (copy of 27FF804h)
  27FFC08h 2     NDS Cart Header CRC      (copy of 27FF808h)
  27FFC0Ah 2     NDS Cart Secure Area CRC (copy of 27FF80Ah)
  27FFC0Ch 2     NDS Cart Missing/Bad CRC (copy of 27FF80Ch)
  27FFC0Eh 2     NDS Cart Secure Area Bad (copy of 27FF80Eh)
  27FFC10h 2     NDS7 BIOS CRC (5835h)    (copy of <27FF850h>)
  27FFC12h 2     Secure Disable           (copy of 27FF812h)
  27FFC14h 2     SIO Debug Exist          (copy of 27FF814h)
  27FFC16h 1     RTC Status?              (<8bit> copy of 27FF816h)
  27FFC17h 1     Random 8bit              (copy of <27FF818h>)
  27FFC18h 18h   Not used (zero)
  27FFC30h 2     GBA Cartridge Header[BEh], Reserved
  27FFC32h 3     GBA Cartridge Header[B5h..B7h], Reserved
  27FFC35h 1     Whatever flags ?
  27FFC36h 2     GBA Cartridge Header[B0h], Maker Code
  27FFC38h 4     GBA Cartridge Header[ACh], Gamecode
  27FFC3Ch 4     Frame Counter (eg. 00000332h in no$gba with original firmware)
  27FFC40h 2     Boot Indicator (1=normal; required for some NDS games, 2=wifi)
  27FFC42h 3Ch   Not used (zero) (or boot info if booted via DS Download Play)
  27FFC7Eh 2     Not used (zero)
  27FFC80h 70h   Wifi FLASH User Settings (fmw[newest_user_settings])
  27FFCF0h 10h   Not used (zero)
  27FFDxxh ..    NDS9 Debug Exception Stack (stacktop=27FFD9Ch)
  27FFD9Ch 4     NDS9 Debug Exception Vector (0=None)
  27FFDA0h ..    ...
  27FFE00h 170h  NDS Cart Header at 27FFE00h+0..16Fh
  27FFF70h ..    Not used (zerofilled at cart boot time)
  27FFFF8h 2     NDS9 Scratch addr for SWI IsDebugger check
  27FFFFAh 2     NDS7 Scratch addr for SWI IsDebugger check
  27FFFFCh ..    ...
  27FFFFEh 2     Main Memory Control (on-chip power-down I/O port)
  DTCM+3FF8h 4   NDS9 IRQ IF Check Bits (hardcoded RAM address)
  DTCM+3FFCh 4   NDS9 IRQ Handler (hardcoded RAM address)
  37F8000h FE00h ARM7 bootcode can be loaded here (37F8000h..3807DFFh)
  380F700h 1D4h  Fragments of NDS7 firmware boot code
  380F980h 4     Unknown/garbage (set to FBDD37BBh, purpose unknown)
                   NOTE: Cooking Coach is doing similar crap at 37FCF1Ch ?!?!
  380FFC0h 4     DSi7 IRQ IF2 Check Bits (hardcoded RAM address) (DSi only)
  380FFDCh ..    NDS7 Debug Stacktop / Debug Vector (0=None)
  380FFF8h 4     NDS7 IRQ IF Check Bits (hardcoded RAM address)
  380FFFCh 4     NDS7 IRQ Handler (hardcoded RAM address)
  ---
  summary of nds memory used at cartridge boot time:
  (all other memory zero-filled unless containing cartridge data)
  37F8000h..3807E00h  ;cartridge area (nds7 only)
  2000000h..23BFE00h  ;cartridge area (nds9 and nds7)
  2400000h..27BFE00h  ;cartridge area (debug ver)
  23FEE00h..23FEF68h  ;fragments of NDS9 firmware boot code
  27FF800h..27FF85Fh  ;various values (from BIOS boot code)
  27FF860h..27FF893h  ;various values (from Firmware boot code)
  27FFC00h..27FFC41h  ;various values (from Firmware boot code)
  27FFC80h..27FFCE6h  ;firmware user settings
  27FFE00h..27FFF6Fh  ;cart header
  380F700h..380F8D4h  ;fragments of NDS7 firmware boot code
  380F980h            ;set to FBDD37BBh
  ---
  register settings at cartridge boot time:
  nds9 r0..r11     = zero
  nds9 r12,r14,r15 = entrypoint
  nds9 r13         = 3002F7Ch (!)
  nds9 r13_irq     = 3003F80h
  nds9 r13_svc     = 3003FC0h
  nds9 r14/spsr_irq= zero
  nds9 r14/spsr_svc= zero
  ---
  nds7 r0..r11     = zero
  nds7 r12,r14,r15 = entrypoint
  nds7 r13         = 380FD80h
  nds7 r13_irq     = 380FF80h
  nds7 r13_svc     = 380FFC0h
  nds7 r14/spsr_irq= zero
  nds7 r14/spsr_svc= zero
  ---
  Observe that SWI SoftReset applies different stack pointers:
  Host  sp_svc    sp_irq    sp_sys    zerofilled area       return address
  NDS7  380FFDCh  380FFB0h  380FF00h  [380FE00h..380FFFFh]  Addr[27FFE34h]
  NDS9  0803FC0h  0803FA0h  0803EC0h  [DTCM+3E00h..3FFFh]   Addr[27FFE24h]
```



## DSi BIOS RAM


```
  2000000h 8     AutoParam Old Title ID (former title)    ;carthdr[230h]
  2000008h 1     AutoParam Unknown/Unused
  2000009h 1     AutoParam Flags (03h=Stuff is used?)
  200000Ah 2     AutoParam Old Maker code                 ;carthdr[010h]
  200000Ch 2     AutoParam Unknown (02ECh) ;\counter/length/indices/whatever?
  200000Eh 2     AutoParam Unknown (0000h) ;/
  2000010h 2     AutoParam CRC16 on [000h..2FFh], initial=FFFFh, [010h]=0000h
  2000012h 2     AutoParam Unknown/Unused (000Fh = want Internet Settings?)
  2000014h 2ECh  AutoParam Unknown... some buffer... string maybe?
  2000300h 4     AutoLoad ID ("TLNC") (also requires BPTWL[70h]=01h)
  2000304h 1     AutoLoad Unknown/unused (usually 01h)
  2000305h 1     AutoLoad Leng of data at 2000308h (01h..18h,for CRC,18h=norm)
  2000306h 2     AutoLoad CRC16 of data at 2000308h (with initial value FFFFh)
  2000308h 8     AutoLoad Old Title ID (former title) (can be 0=anonymous)
  2000310h 8     AutoLoad New Title ID (new title to be started, 0=none)
  2000318h 4     AutoLoad Flags (bit0,1-3,4,5,6,7) ;usually 16bit, once 32bit
  200031Ch 4     AutoLoad Unused (but within checksummed area when CRC len=18h)
  2000320h E0h   AutoLoad Unused (but zerofilled upon erasing autoload area)
  2000400h 128h  System Settings from TWLCFGn.dat file (bytes 088h..1AFh)
  20005E0h 1     WlFirm Type (1=DWM-W015, 2=DWM-W024) (as wifi_flash[1FDh])
  20005E1h 1     WlFirm Unknown (zero)
  20005E2h 2     WlFirm CRC16 with initial value FFFFh on [20005E4h..20005EFh]
  20005E4h 4     WlFirm RAM vars (500400h)  ;\
  20005E8h 4     WlFirm RAM base (500000h)  ; as from "Wifi Firmware" file
  20005ECh 4     WlFirm RAM size (02E000h)  ;/
  20005F0h 10h   WlFirm Unknown (zero)
  2000600h 14h   Hexvalues from HWINFO_N.dat
  2000800h ...   Unlaunch Auto-load feature (via "device:/Path/Filename.ext")
  23FEE00h 200h  DSi9 bootstrap relict
  ---
  2FEE120h 4     "nand"   <--- passed as so to launcher
  2FF80xxh
  2FF82xxh
  2FF83xxh
  2FF89xxh
  2FF8Axxh
  2FF8Bxxh
  2FF8Cxxh
  2FF8Dxxh       ... Wifi MAC address, channel mask, etc.
  2FF8Fxxh
  2FF90xxh
  2FF91xxh
  2FF9208h       FBDD37BBh (that odd "garbage" value occurs also on NDS)
  2FFA1xxh
  2FFA2xxh
  2FFA5xxh
  2FFA6xxh
  2FFA680h 12    02FD4D80h,00000000h,00001980h
  2FFA68Ch ..    Zerofilled
  ---
  2FFC000h 1000h Full Cart Header (as at 2FFE000h, but, FOR NDS ROM CARTRIDGE)
  2FFD000h 7B0h  Zerofilled
  2FFD7B0h 8+1   Version Data Filename (eg. 30,30,30,30,30,30,30,34,00)
  2FFD7B9h 1     Version Data Region   (eg. 50h="P"=Europe)
  2FFD7BAh 1     Unknown  (00)   ;bit0 = warmboot-flag-related
  2FFD7BBh 1     Unknown  (00)
  2FFD7BCh 15+1  eMMC CID (dd,ss,ss,ss,ss,03,4D,30,30,46,50,41,00,00,15), 00
  2FFD7CCh 15+1  eMMC CSD (40,40,96,E9,7F,DB,F6,DF,01,59,0F,2A,01,26,90), 00
  2FFD7DCh 4     eMMC OCR (80,80,FF,80)                                  ;20h
  2FFD7E0h 8     eMMC SCR (00,04,00,00,00,00,00,00) (for MMC: dummy/4bit);24h
  2FFD7E8h 2     eMMC RCA (01,00)                                        ;2Ch
  2FFD7EAh 2     eMMC Typ (01,00) (0=SD Card, 1=MMC Card)                ;2Eh
  2FFD7ECh 2     eMMC HCS (00,00) ;copy of OCR.bit30 (sector addressing) ;30h
  2FFD7EEh 2     eMMC ?   (00,00)                                        ;32h
  2FFD7F0h 4     eMMC ?   (00,00,00,00)                                  ;34h
  2FFD7F4h 4     eMMC CSR (00,09,00,00)   ;card status (state=tran)      ;38h
  2FFD7F8h 2     eMMC Port 4004824h setting  (00,01)  ;SD_CARD_CLK_CTL   ;3Ch
  2FFD7FAh 2     eMMC Port 4004828h setting  (E0,40)  ;SD_CARD_OPTION    ;3Eh
  2FFD7FCh 2     eMMC ?   (00,00)                                        ;40h
  2FFD7FEh 2     eMMC Device (usually 0001h=eMMC) (0000h=SD/MMC Slot?)   ;42h
  2FFD800h 1     Titles: Number of titles in below lists (max 76h)
  2FFD801h 0Fh   Titles: Zerofilled
  2FFD810h 10h   Titles: Pub Flags (1bit each) ;same maker plus public.sav
  2FFD820h 10h   Titles: Prv Flags (1bit each) ;same maker plus private.sav
  2FFD830h 10h   Titles: Jmp Flags (1bit each) ;jumpable or current-title
  2FFD840h 10h   Titles: Mkr Flags (1bit each) ;same maker
  2FFD850h 3B0h  Titles: Title IDs (8 bytes each)
  2FFDC00h 400h  Zerofilled
  2FFE000h 1000h DSi Full Cart Header (additionally to short headers)
  2FFF000h 0Ch   Zerofilled
  2FFF00Ch 4     ? 0000007Fh
  2FFF010h 4     ? 550E25B8h
  2FFF014h 4     ? 02FF4000h
  2FFF018h A68h  Zerofilled
  2FFFA80h 160h  Short Cart header (as at 2FFFE00h, but, FOR NDS ROM CARTRIDGE)
  2FFFBE0h 20h   Zerofilled
```

Below resembles NDS area at 27FFC00h (with added/removed stuff)...

```
  2FFFC00h 4     NDS Gamecart Chip ID
  2FFFC04h 20h   Zerofilled
  2FFFC24h 5     ? (04 00 73 01 03)
  2FFFC29h 7     Zerofilled
  2FFFC30h 12    GBA Cartridge Header (FF FF FF FF FF 00 FF FF FF FF FF FF)
  2FFFC3Ch 4     Frame Counter maybe? (eg. 1F 01 00 00 in cooking coach)
  2FFFC40h 2     Boot Indicator (1=ROM Cartridge,2=Wifi/tmp?,3=SD/MMC DSiware)
  2FFFC42h 3Ch   Not used (zero) (or boot info if booted via DS Download Play)
  2FFFC7Eh 2     Not used (zero)
  2FFFC80h 70h   Wifi FLASH User Settings (fmw[newest_user_settings])
  2FFFCF0h 4     ?           (3D 00 01 6E) (update counter and crc16 ?)
  2FFFCF4h 6     Wifi MAC Address (00 23 CC xx xx xx)              (fmw[036h])
  2FFFCFAh 2     Wifi Channels (usually 1041h = ch1+7+13) (based on fmw[03Ch])
  2FFFCFCh 4     Zero
  2FFFD00h 68h   Zerofilled
  2FFFD68h 4     Bitmask for Supported Languages (3Eh for Europe);\
  2FFFD6Ch 4     Unknown (00,00,00,00)                           ; from
  2FFFD70h 1     Console Region (0=JP,1=US,2=EU,3=AU,4=CHN,5=KOR); HWINFO_S.dat
  2FFFD71h 12    Serial/Barcode (ASCII, 11-12 characters)        ;
  2FFFD7Dh 3     ? (00 00 3C)                                    ;/
  2FFFD80h 0Ch   Zerofilled
  2FFFD8Ch 10h   ARM9 debug exception stack (stacktop 2FFFD9Ch)
  2FFFD9Ch 4     ARM9 debug exception vector (020D3E64h)
  2FFFDA0h 4     02F80000h                                ;\
  2FFFDA4h 4     02FFA674h                                ;
  2FFFDA8h 4     00000000h zero                           ; start addresses?
  2FFFDACh 4     01FF86E0h itcm?                          ;
  2FFFDB0h 4     027C00C0h                                ;
  2FFFDB4h 4     02FFF000h                                ;
  2FFFDB8h 4     03040000h wram?                          ;
  2FFFDBCh 4     03800000h wram?                          ;
  2FFFDC0h 4     0380C3B4h wram?                          ;/
  2FFFDC4h 4     02F80000h                                ;\
  2FFFDC8h 4     02FFC000h ptr to DSi Full Cart Header    ;
  2FFFDCCh 4     00000000h zero                           ; end addresses?
  2FFFDD0h 4     02000000h ram bottom?                    ; (for above nine
  2FFFDD4h 4     027C0780h                                ; start addresses)
  2FFFDD8h 4     02FFF680h                                ;
  2FFFDDCh 4     03040000h wram?                          ;
  2FFFDE0h 4     03800000h wram?                          ;
  2FFFDE4h 4     0380F780h wram?                          ;/
  2FFFDE8h 4     RTC Date at Boot (BCD) (yy,mm,dd,XX) (XX=maybe day-of-week?)
  2FFFDECh 4     RTC Time at Boot (BCD) (hh,ss,mm,0) (hh.bit6=maybe PM or 24h?)
  2FFFDF0h 4     Initial ARM7 Port 4004008h bits (13FBFB06h) (SCFG_EXT7)
  2FFFDF4h 1     Initial ARM7 Port 40040xxh bits (C4h)       (SCFG_xxx)
  2FFFDF5h 1     Initial ARM7 Port 400400xh bits (F0h)       (SCFG_xxx)
  2FFFDF6h 2+2   Zerofilled
  2FFFDFAh 1     Warmboot Flag (bptwl[70h] OR 80h, ie. 80h=cold or 81h=warm)
  2FFFDFBh 1     01h
  2FFFDFCh 4     Pointer to TWLCFGn.dat (usually 2000400h) (or 0=2000400h)
  2FFFE00h 160h  Short Cart header (unlike NDS, only 160h, not 170h)
  2FFFF60h A0h   Zerofilled
 37FA414h       "nand:/title/....app"  <-- [1D4h]+3C0h  (without Device List!)
 380C400h 22E4h BIOS Keys (as from Boot Stage 1, see there)
  380F010h 10h   AES key for dev.kp (E5,CC,5A,8B,...) (optional/for launcher)
  380F600h 200h  DSi7 bootstrap relict (at 3FFF600h aka mirrored to 380F600h)
  380FFC0h 4     DSi7 IRQ IF2 Check Bits (hardcoded RAM address) (DSi only)
  380FFC4h 4     DSi7 SCFG_EXT7 setting
  380FFC8h 2     DSi7 SCFG_misc bits
  380FFDCh ..    DSi7 Debug Stacktop / Debug Vector (0=None)
  380FFF8h 4     DSi7 IRQ IF Check Bits (hardcoded RAM address)
  380FFFCh 4     DSi7 IRQ Handler (hardcoded RAM address)
  xxxxxxxh ?     ARM7i and ARM9 bootcode can be loaded WHERE and WHERE?
  cart_header[1D4h] 400h SD/MMC Device List ARM7 RAM; initialized by firmware
```

Initial state after DSi BIOS ROM bootcode (when starting eMMC bootcode)
requires only a few memory blocks in ITCM, ARM7 WRAM, and AES keyslots:

```
  1FFC400h 400h  BIOS Keys from FFFF87F4h (C3 02 93 DE ..) RSA keys (8x80h)
  1FFC800h 80h   BIOS Keys from FFFF9920h (30 33 26 D5 ..) Whatever
  1FFC880h 14h   Whatever, should/may be zerofilled?
  1FFC894h 1048h BIOS Keys from FFFF99A0h (99 D5 20 5F ..) Blowfish/NDS-mode
  1FFD8DCh 1048h BIOS Keys from FFFFA9E8h (D8 18 FA BF ..) Blowfish/unused?
  3FFC400h 200h  BIOS Keys from 00008188h (CA 13 31 79 ..) Whatever, 32x10h AES?
  3FFC600h 40h   BIOS Keys from 0000B5D8h (AF 1B F5 16 ..) Whatever, AES?
  3FFC640h 14h   Whatever, must be zerofilled
  3FFC654h 1048h BIOS Keys from 0000C6D0h (59 AA 56 8E ..) Blowfish/DSi-mode
  3FFD69Ch 1048h BIOS Keys from 0000D718h (54 86 13 3B ..) Blowfish/unused?
  3FFE6E4h 44h   eMMC Info (to be relocated to 2FFD7BCh, see there for details)
  4004450h 8     AES Key0.X ("Nintendo") for modcrypt
  4004480h 10h   AES Key1.X (CPU/Console ID and constants) for dev.kp and Tad
  40044B0h 10h   AES Key2.X ("Nintendo DS",...)            for Tad
  40044E0h 1Ch   AES Key3.X/Y (CPU/Console ID and constants) for eMMC
  2000000h ...   Warmboot Param (optional, passed on to New Title)
  2000300h 20h   Warmboot Info  (optional, passed on to Launcher)
```




# <a name="biosdumping"></a>BIOS Dumping




## BIOSes


```
  GBA BIOS 16K  (fully dumpable, CRC32=81977335 on GBA with [3F0Ch]=00h)
  GBA BIOS 16K  (fully dumpable, CRC32=A6473709 on NDS/3DS with [3F0Ch]=01h)
  NDS7 BIOS 16K (fully dumpable, CRC32=1280F0D5)
  NDS9 BIOS 4K  (fully dumpable, CRC32=2AB23573)
  DSi7 BIOS 64K (about 41K dumpable) (new: fully dumped now)
  DSi9 BIOS 64K (about 41K dumpable)
  3DS9 BIOS 64K (fully dumpable)
  3DS11 BIOS 64K (fully dumpable)
  DSiWifi BIOS 80K on older DSi (fully dumpable)
  DSiWifi BIOS Unknown size on newer DSi (fully dumpable)
  3DSWifi BIOS Unknown size on 3DS (fully dumpable)
```



## GBA BIOS


Contains SWI Functions and Bootcode (for starting cartridges, or booting via
Serial Port). The GBA BIOS can be read only by opcodes executed in BIOS area,
for example, via the MidiKey2Freq function (most other SWI Functions (like
CpuSet) are refusing source addresses within BIOS area).



## NDS BIOSes


Contains SWI Functions and Bootcode (for booting from SPI Bus Firmware FLASH
memory). The NDS9 BIOS can be dumped without restrictions (eg. via CpuSet, or
via LDR opcodes in RAM). The NDS7 BIOS has same restrictions as GBA, ie.
reading works only by BIOS opcodes, and not by functions like CpuSet. The
GetCRC16 functions does work though (at least for memory at 1204h..3FFFh). As
an additional obstacle, memory at 0000h..1203h can be dumped only by opcodes
within 0000h..1203h (that memory does mainly contain data, but some of the data
values can serve as THUMB LDR opcodes). For details see:

- [DS Memory Control - BIOS](ds.html#dsmemorycontrolbios)
Note: DSi consoles are containing a copy of the NDS BIOSes, but with BIOSPROT
set to 0020h (even when running in NDS mode), so the first 20h bytes of the
DSi's NDS7 BIOS aren't dumpable (except via tracing, see below), that 20h bytes
should be just same as on original NDS7 though.



## DSi BIOSes - Lower 32K-halves (SWI Functions)


The lower 32K of DSi9 doesn't have any restricions. The lower 32K of DSi7 has
similar restrictions as NDS7, but with BIOSPROT set to 0020h (instead of
1204h), this is making it more easy to dump memory at 0020h..7FFFh (eg. via
GetCRC16), but makes it impossible to dump the exception vectors at
0000h..001Fh, however, they can be deduced by tracing (with timer IRQs):

```
  ROM:00000000h  EA000006  b 20h   ;dsi7_reset_vector
  ROM:00000004h  EA000006  b 24h   ;dsi7_undef_handler
  ROM:00000008h  EA00001F  b 8Ch   ;dsi7_swi_handler
  ROM:0000000Ch  EA000004  b 24h   ;dsi7_prefetch_abort_handler
  ROM:00000010h  EA000003  b 24h   ;dsi7_data_abort_handler
  ROM:00000014h  EAFFFFFE  b 14h   ;reserved_vector
  ROM:00000018h  EA000013  b 6Ch   ;dsi7_irq_handler
  ROM:0000001Ch  EA000000  b 24h   ;dsi7_fiq_handler
```

Aside from branch opcodes, above could theoretically contain ALU opcodes that
modify R15 (but that would be very unlikely, and would make no difference)
(and, the above 20h bytes are dumped/confirmed on 3DS in DSi mode).



## DSi BIOSes - Upper 32K-halves (Bootcode, for booting from eMMC memory)


The upper 32K of the DSi9 and DSi7 BIOSes are locked at some point during
booting, and there's no known way to dump them directly. However, portions of
that memory are relocated to RAM/TCM before locking, and that relocated copies
can be dumped.

On a DSi, the following DSi ROM data can be dumped (originally done via Main
Memory hacks, ie. with complex external hardware soldered to the mainboard, but
it's now also possible via Unlaunch.dsi exploit):

```
  ROM:FFFF87F4h / TCM:1FFC400h (400h)  (C3 02 93 DE ..) RSA keys (8x80h)
  ROM:FFFF9920h / TCM:1FFC800h (80h)   (30 33 26 D5 ..) Whatever
  ROM:FFFF99A0h / TCM:1FFC894h (1048h) (99 D5 20 5F ..) Blowfish/NDS-mode
  ROM:FFFFA9E8h / TCM:1FFD8DCh (1048h) (D8 18 FA BF ..) Blowfish/unused?
  ROM:00008188h / RAM:3FFC400h (200h)  (CA 13 31 79 ..) Whatever, 32x10h AES?
  ROM:0000B5D8h / RAM:3FFC600h (40h)   (AF 1B F5 16 ..) Whatever, "common key"?
  ROM:0000C6D0h / RAM:3FFC654h (1048h) (59 AA 56 8E ..) Blowfish/DSi-mode
  ROM:0000D718h / RAM:3FFD69Ch (1048h) (54 86 13 3B ..) Blowfish/unused?
```

On a 3DS, the following "DSi ROM data" can be dumped from the 2470h-byte DSi
key area in 3DS memory at ARM9 ITCM 01FFD000h..01FFF46F (via 3DS exploits that
are capable of executing code on ARM9 side):

```
  ROM:FFFF87F4h / 3DS:01FFD000h  200h  RSA keys 0..3 (4x80h)
  ROM:00008308h / 3DS:01FFD200h  80h   some AES keys
  ROM:FFFF9920h / 3DS:01FFD280h  80h   whatever
  ROM:0000B5D8h / 3DS:01FFD300h  40h   AES keys and values (common etc)
  ROM:?         / 3DS:01FFD340h  A0h   misc "Nintendo" string etc.
  ROM:0000C6D0h / 3DS:01FFD3E0h  1048h Blowfish for DSi-mode
  ROM:FFFF99A0h / 3DS:01FFE428h  1048h Blowfish for DS-mode
```

The 3DS does have only half of the DSi keys (the extra keys might be used for
DSi debug version, but aren't needed for normal DSi software).

The 40h-byte area for ROM:0000B5D8h can be fully dumped from 3DS ITCM, the same
vales should also exist in DSi ITCM, but the DSi zerofills a 10h-byte fraction
of that area after initialization, and it doesn't seem be possible to read that
values via Main Memory hacks (most of that erased values can be found in AES
keyslots though).

The A0h-byte area is found only in 3DS ITCM, it should also exist somewhere in
DSi ROM, but isn't relocated to DSi ITCM (however, the relevant values can be
found in AES keyslots, eg. the "Nintendo" string).



## Checksums for BiosDSi.rom (20000h bytes)


```
  Offset Size  CRC32
  00000h 8000h 5434691Dh                ;\
  08000h 188h  ?                        ;
  08188h 180h  E5632151h  (not 3ds)     ;
  08308h 80h   64515306h                ;
  08388h 3250h ?                        ;
  0B5D8h 20h   85BE2749h                ; ARM7
  0B5F8h 10h   25A46A54h  (3ds only)    ;
  0B608h 10h   E882B9A9h                ;
  0B618h 10B8h ?                        ;
  0C6D0h 1048h 3B5CDF06h                ;
  0D718h 1048h 5AC363F9h  (not 3ds)     ;
  0E860h 18A0h ?                        ;/
  10000h 8000h 11E7C1EAh                ;\
  18000h 7F4h  ?                        ;
  187F4h 200h  4405D4BAh                ;
  189F4h 200h  2A32F2E7h  (not 3ds)     ;
  18BF4h D2Ch  ?                        ; ARM9
  19920h 80h   2699A10Fh                ;
  199A0h 1048h A8F58AE7h                ;
  1A9E8h 1048h E94759ACh  (not 3ds)     ;
  1BA30h 45D0h ?                        ;/
  ?      A0h   180DF59Bh  (3ds only)    ;-whatever, "Nintendo" string etc.
  ?      80h   ........h  (TWL-FIRM)    ;-RSA key for eMMC boot info
```

Checksums for the 'whole' 20000h-byte file (with unknown/missing areas
zerofilled):

```
  180DF59Bh (tcm/ram dump)  (missing 10h bytes)
  03A21235h (3ds dump)      (missing 180h+200h+1048h+1048h bytes)
  CDAA8FF6h (combined dump) (missing only the unknown "?" areas)
```



## 3DS BIOS


Can be dumped by crashing the 3DS with wrong voltages, or by using sighax to
crash the bootrom before disabling the upper 32Kbyte halves of the ARM9/ARM11
ROMs.



## DSiWifi BIOS


The Wifi BIOS can be dumped by using the WINDOW\_DATA register via SDIO CMD53.



## Further DSi BIOSes


The DSi cameras and several other I2C/SPI devices are probably having BIOS
ROMs, too. Unknown if/how that ROMs are dumpable.



## DSi BIOS Dumping via voltage errors


Lowering VDD12 for a moment does work quite reliable for crashing the ARM9 and
trapping the 2FFFD9Ch vector in Main RAM. The problem is that Main RAM seems to
be disabled during bootstage 1 (it gets enabled at begin of bootstage 2 via
EXMEMCNT, that is, shortly after the upper BIOS 32Kbyte areas are disabled).
More on that here:

- [http://4dsdev.kuribo64.net/thread.php?id=130](http://4dsdev.kuribo64.net/thread.php?id=130)

One theory/idea (from dark\_samus) is that EXMEMCNT controls the CE2 pin on the
Main RAM chip, so one could try to rewire that pin to get Main RAM enabled
regardless of EXMEMCNT, if that's actually working, then trapping the 2FFFD9Ch
vector should work even while BIOS ROMs are fully readable.




# <a name="externalconnectors"></a>External Connectors




## External Connectors


- [AUX GBA Game Pak Bus](#auxgbagamepakbus)
- [AUX DS Game Card Slot](#auxdsgamecardslot)
- [AUX Link Port](#auxlinkport)
- [AUX Sound/Headphone Socket and Battery/Power Supply](#auxsoundheadphonesocketandbatterypowersupply)
- [AUX DSi SD/MMC Pin-Outs](#auxdsisdmmcpinouts)


## Getting access to Internal Pins


- [AUX Opening the GBA](#auxopeningthegba)
- [AUX Mainboard](#auxmainboard)
- [AUX DSi Component Lists](#auxdsicomponentlists)
- [AUX DSi Internal Connectors](#auxdsiinternalconnectors)
- [AUX DSi Chipset Pinouts](#auxdsichipsetpinouts)


## More Internal Stuff


- [Pinouts - CPU - Signal Summary](#pinoutscpusignalsummary)
- [Pinouts - CPU - Pinouts](#pinoutscpupinouts)
- [Pinouts - Audio Amplifiers](#pinoutsaudioamplifiers)
- [Pinouts - LCD Cables](#pinoutslcdcables)
- [Pinouts - Power Switches, DC/DC Converters, Reset Generators](#pinoutspowerswitchesdcdcconvertersresetgenerators)
- [Pinouts - Wifi](#pinoutswifi)
- [Pinouts - Various](#pinoutsvarious)


## Xboo Multiboot Cable


- [AUX Xboo PC-to-GBA Multiboot Cable](#auxxboopctogbamultibootcable)
- [AUX Xboo Flashcard Upload](#auxxbooflashcardupload)
- [AUX Xboo Burst Boot Backdoor](#auxxbooburstbootbackdoor)
- [DS Xboo](ds.html#dsxboo)



# <a name="auxgbagamepakbus"></a>AUX GBA Game Pak Bus




## Game Pak Bus - 32pin cartridge slot


The cartridge bus may be used for both CGB and GBA game paks. In GBA mode, it
is used as follows:

```
 Pin    Name    Dir  Expl.
 1      VDD     O    Power Supply 3.3V DC
 2      PHI     O    System Clock (selectable none, 4.19MHz, 8.38MHz, 16.78MHz)
 3      /WR     O    Write Select    ;\latched address to be incremented on
 4      /RD     O    Read Select     ;/rising edges of /RD or /WR signals
 5      /CS     O    ROM Chip Select ;-A0..A15 to be latched on falling edge
 6-21   AD0-15  I/O  lower 16bit Address    and/or  16bit ROM-data (see below)
 22-29  A16-23  I/O  upper 8bit ROM-Address   or    8bit SRAM-data (see below)
 30     /CS2    O    SRAM Chip Select
 31     /REQ    I    Interrupt request (/IREQ) or DMA request (/DREQ)
 32     GND     O    Ground 0V
```

When accessing game pak SRAM, a 16bit address is output through AD0-AD15, then
8bit of data are transferred through A16-A23.

When accessing game pak ROM, a 24bit address is output through AD0-AD15 and
A16-A23, then 16bit of data are transferred through AD0-AD15.

The 24bit address is formed from the actual 25bit memory address (byte-steps),
divided by two (halfword-steps).

Pin Pitch is 1.5mm.



## 8bit-Gamepak-Switch (GBA, GBA SP only) (not DS)


A small switch is located inside of the cartridge slot, the switch is pushed
down when an 8bit cartridge is inserted, it is released when a GBA cartridge is
inserted (or if no cartridge is inserted).

The switch mechanically controls whether VDD3 or VDD5 are output at VDD35; ie.
in GBA mode 3V power supply/signals are used for the cartridge slot and link
port, while in 8bit mode 5V are used.

The switch additionally drags IN35 to 3V when an 8bit cart is inserted, the
current state of IN35 can be determined in GBA mode via Port 4000204h
(WAITCNT), if the switch is pushed, then CGB mode can be activated via Port
4000000h (DISPCNT.3), this bit can be set ONLY by opcodes in BIOS region (eg.
via CpuSet SWI function).

In 8bit mode, the cartridge bus works much like for GBA SRAM, however, the 8bit
/CS signal is expected at Pin 5, while GBA SRAM /CS2 at Pin 30 is interpreted
as /RESET signal by the 8bit MBC chip (if any). In practice, this appears to
result in 00h being received as data when attempting to read-out 8bit
cartridges from inside of GBA mode.




# <a name="auxdsgamecardslot"></a>AUX DS Game Card Slot



```
  Pin    Dir  Name  Connection in cartridge
  1   >  -    GND   (ROM all unused Pins, EEPROM Pin 4 = VSS)
  2      Out  CLK   (4MB/s, ROM Pin 5, EEPROM Pin 6 = CLK)
  3   N  -    ?     (ROM Pin 17) (Seems to be not connected in console)
  4   i  Out  /CS1  (ROM Pin 44) ROM Chipselect
  5   n  Out  /RES  (ROM Pin 42) Reset, switches ROM to unencrypted mode
  6   t  Out  /CS2  (EEPROM Pin 1) EEPROM Chipselect
  7   e  In   IRQ   (GND)
  8   n  -    3.3V  (ROM Pins 2, 23, EEPROM Pins 3,7,8 = /W,/HOLD,VCC)
  9   d  I/O  D0    (ROM Pin 18)
  10  o  I/O  D1    (ROM Pin 19)
  11     I/O  D2    (ROM Pin 20)
  12  C  I/O  D3    (ROM Pin 21)
  13  0  I/O  D4    (ROM Pin 24)
  14  1  I/O  D5    (ROM Pin 25)
  15  -  I/O  D6    (ROM Pin 26, EEPROM Pin 2 = Q = Data EEPROM to NDS)
  16  0  I/O  D7    (ROM Pin 27, EEPROM Pin 5 = D = Data NDS to EEPROM)
  17  1  -    GND   (ROM all unused Pins, EEPROM Pin 4 = VSS)
```


Chipselect High-to-Low transitions are invoking commands, which are transmitted
through data lines during next following eight CLK pulses, after the command
transmission, further CLK pulses are used to transfer data, the data transfer
ends at chipselect Low-to-High transition.

Data should be stable during CLK=LOW period throughout CLK rising edge.

Note: Supply Pins (1,8,17) are slightly longer than other pins. Pin pitch is
1.5mm.


The DS does also have a 32pin cartridge slot, that slot is used to run GBA
carts in GBA mode, it can be also used as expansion port in DS mode.




# <a name="auxlinkport"></a>AUX Link Port




## Serial Link Port Pin-Out (GBA:"EXT" - GBA SP:"EXT.1")


```
  Pin  Name  Cable
  1    VDD35 N/A       GBA Socket     GBA Plug   Old "8bit" Plug
  2    SO    Red       ___________    _________    ___________
  3    SI    Orange   |  2  4  6  |  / 2  4  6 \  |  2  4  6  |
  4    SD    Brown     \_1_ 3 _5_/   \_1_ 3 _5_/   \_1__3__5_/
  5    SC    Green         '-'           '-'
  6    GND   Blue      Socket Outside View / Plug Inside View
  Shield     Shield
```

Note: The pin numbers and names are printed on the GBA mainboard, colors as
used in Nintendo's AGB-005 and older 8bit cables.



## Serial Link/Power Supply Port (GBA-Micro: "EXT.")


```
  1  In  DC (Supply 5.2VDC)  ___________________
  2  Out V3 (SIO 3.3VDC)    |  1 2 3 4 5 6 7 8  |
  3  I/O SO (SIO RCNT.3)    | ================= |
  4  I/O SI (SIO RCNT.2)     \_________________/
  5  I/O SD (SIO RCNT.1)
  6  I/O SC (SIO RCNT.0)
  7  OUT DG (SIO GROUND)
  8  In  DG (Supply GROUND)
  -  -   -  (Shield not connected)
```



## Cable Diagrams (Left: GBA Cable, Right: 8bit Gameboy Cable)


```
  Big Plug  Middle Socket  Small Plug    Plug 1         Plug 2
   SI _________________     ____ SI       SI ______  ______SI
   SO ____________SO   |__ | ___ SO       SO ______><______SO
   GND____________GND______|____GND       GND_____________GND
   SD ____________SD____________ SD       SD               SD
   SC ____________SC____________ SC       SC _____________ SC
   Shield_______Shield_______Shield       Shield_______Shield
```



## Normal Connection


Just connect the plugs to the two GBAs and leave the Middle Socket
disconnected, in this mode both GBAs may behave as master or slave, regardless
of whether using big or small plugs.

The GBA is (NOT ???) able to communicate in Normal mode with MultiPlay cables
which do not have crossed SI/SO lines.



## Multi-Play Connection


Connect two GBAs as normal, for each further GBAs connect an additional cable
to the Middle socket of the first (or further) cable(s), up to four GBAs may be
connected by using up to three cables.

The GBA which is connected to a Small Plug is master, the slaves are all
connected to Large Plugs. (Only small plugs fit into the Middle Socket, so it's
not possible to mess up something here).



## Multi-Boot Connection


MultiBoot (SingleGamepak) is typically using Multi-Play communication, in this
case it is important that the Small plug is connected to the master/sender (ie.
to the GBA that contains the cartridge).



## Non-GBA Mode Connection


First of all, it is not possible to link between 32bit GBA games and 8bit
games, parts because of different cable protocol, and parts because of
different signal voltages.

However, when a 8bit cartridge is inserted (the GBA is switched into 8bit
compatibility mode) it may be connected to other 8bit games (monochrome
gameboys, CGBs, or to other GBAs which are in 8bit mode also, but not to GBAs
in 32bit mode).

When using 8bit link mode, an 8bit link cable must be used. The GBA link cables
won't work, see below modification though.



## Using a GBA 32bit cable for 8bit communication


Open the middle socket, and disconnect Small Plugs SI from GND, and connect SI
to Large Plugs SO instead. You may also want to install a switch that allows to
switch between SO and GND, the GND signal should be required for MultiPlay
communication only though.

Also, cut off the plastic ledge from the plugs so that they fit into 8bit
gameboy sockets.



## Using a GBA 8bit cable for 32bit communication


The cable should theoretically work as is, as the grounded SI would be required
for MultiPlay communication only. However, software that uses SD for
Slave-Ready detection won't work unless when adding a SD-to-SD connection (the
8bit plugs probably do not even contain SD pins though).




# <a name="auxsoundheadphonesocketandbatterypowersupply"></a>AUX Sound/Headphone Socket and Battery/Power Supply




## GBA, GBA-Micro, NDS, and NDS-Lite: Stereo Sound Connector (3.5mm, female)


```
  Tip     Audio Left         ___ ___ _____.-----------.
  Middle  Audio Right       (___|___|_____|           |
  Base    Ground              L   R   GND '-----------'
```

The NDS socket doesn't fully match regular 3.5mm plugs, one needs to cut-off a
portion of the DS case to be able to fully insert the plug, which still
requires a lot of pressure, furthermore, when fully inserted, left/right become
shortcut to mono, so one needs to pull-back the plug a bit to gain stereo
output.



## GBA SP and NDS - Power/Headphone Socket (EXT.2)


```
  Pin SP   NDS  Expl.
  1   P31  SL   Audio LOUT                          _____________
  2   P32  VIN  Supply Input (DC 5.2V)           SW| 5   ___   1 |SL
  3   P33  SR   Audio ROUT                         | ----   ---- |
  4   P34  SG   Audio GND (via 100uF to GND)       |_6__4   3__2_|
  5   P35  SW   Audio Speaker Disable (GND=Dis)    GND SG\_/SR VIN
  6        GND  Supply GND
  Shield        GND
```

External power input is used to charge the built-in battery, it cannot be used
to run the SP without that battery.



## NDS-Lite - Power Socket


```
  Pin  Expl.                                          __________
  1    Supply Input (DC 5.2V)                        /  ======  \
  2    Supply GND                                GND |___2__1___| VIN
```



## GBA-Micro - Power Socket


Uses an 8pin socket (which combines SIO and Power), for pin-outs, see

- [AUX Link Port](#auxlinkport)


## External Power Supply


GBA: DC 3.3V (no separate power socket, requires 2xAA-battery-shaped adapter)

GBA-SP/NDS: DC 5.2V (or DC 5V) (special connector on power/headphone socket)

NDS-Lite: DC 5.2V (or DC 5V) (another special connector on power socket)



## Internal Battery Supply


GBA: 2xAA (3V)

GBA-SP: Li-ion 3.7V, 600mAh (built-in, recharge-able)

GBA-Micro: Li-ion 3.8V, 460mAh (built-in, recharge-able)

NDS: Li-ion 3.7V, 850mAh (built-in, recharge-able)

NDS-Lite: Li-ion 3.7V, 1000mAh (built-in, recharge-able)



## Using PC +5V DC as Power Supply


Developers whom are using a PC for GBA programming will probably want to use
the PC power supply (gained from disk drive power supply cable) for the GBA as
well rather than dealing with batteries or external power supplies.

GBA: To lower the voltage to approximately 3 Volts use two diodes, type 1N 4004
or similar, the ring printed onto the diodes points towards the GBA side,
connected as such:

```
  PC +5V (red)   --------|>|---|>|--------  GBA BT+
  PC GND (black) -------------------------  GBA BT-
```

GBA SP, GBA Micro, NDS, and NDS-Lite: Works directly at +5V connected to EXT.2
socket (not to the internal battery pins), without any diodes.




# <a name="auxdsisdmmcpinouts"></a>AUX DSi SD/MMC Pin-Outs




## SD/MMC Transfer Modes


```
  Transfer Modes        SPI-Mode    1-bit-Bus  4-bit-Bus   SDIO
  MMC Cards             Optional    Yes        MMCplus     No
  SD Cards              Yes         Yes        Optional??  Optional
```

Note: SDIO is an extension to the SD protocol, allowing to access other
non-memory-card hardware (such like cameras or network adaptors) via SD
connectors.

Note: Original MMC cards don't support 4-bit bus, but there are revisions like
MMCplus and MMCmobile (with extra pin rows) which do support 4-bit and 8bit
bus.



## SD/MMC Pin-Outs


```
  MMC  MMCplus SD  miniSD microSD SPI-Mode    1-bit-Bus   4-bit/8bit-Bus
  1    1       1   1      2       /CS         CardDetect  Data3
  2    2       2   2      3       DataIn      CMD/REPLY   CMD/REPLY
  3    3       3   3      --      GND         GND         GND
  4    4       4   4      4       VDD         VDD         VDD
  5    5       5   5      5       CLK         CLK         CLK
  6    6       6   6      6       GND         GND         GND
  7    7       7   7      7       DataOut     Data        Data0
  --   8       8   8      8       /IRQ (SDIO) /IRQ (SDIO) Data1 or /IRQ (SDIO)
  --   9       9   9      1       NC          NC          Data2
  --   10      --  --     --      NC          NC          Data4  ;\
  --   11      --  --     --      NC          NC          Data5  ; MMCplus
  --   12      --  --     --      NC          NC          Data6  ; 8bit
  --   13      --  --     --      NC          NC          Data7  ;/
  --   --      --  10     --      Reserved    Reserved    Reserved
  --   --      --  11     --      Reserved    Reserved    Reserved
```

Moreover, the card sockets (not the cards themselves) are usually containing a
Card Detect switch, and, for SD card sockets, also a write protect switch:

```
  --   --      CD  CD     CD      Card Detect (senses if card is inserted)
  --   ---     WP  --     --      Write Protect (senses position of LOCK tab)
```

Note that the LOCK tab on SD cards is just a small piece of plastic without any
electronics attached to it, the actual switch/sensor is located in the SD card
socket (ie. the LOCK works much like the write-protect tabs on audio tapes,
video tapes, and floppy discs).

Card detect can be an actual switch (however, some sockets are simply having
dual contacts for Pin 3 (GND), one being GND, and the other becoming GNDed when
a cartridge is inserted).



## SD/MMC Card Shapes


```
     ______________________________
    /    __ __ __ __ __ __ __      |
   /    |  |  |  |  |  |  |  |     |
  |     | 1| 2| 3| 4| 5| 6| 7|     |
  | MMC |__|__|__|__|__|__|__|     |
  |    ______________________________
  |   /    __ __ __ __ __ __ __ _    |
  |  /  __|  |  |  |  |  |  |  | |   |
  | |  |  | 1| 2| 3| 4| 5| 6| 7|8|   | MMCplus:
  | |  | 9|__|__|__|__|__|__|__| |   | pinout is same as 9pin SD cards,
  | |  |_ |_ __ __       __ __ | |   | with extra DAT4-7 on pin10-13
  | |    |  | 1| 1|     | 1| 1|  |   |
  | |MMC | 9| 0| 1|     | 2| 3| 8|   |
  | |plus|__|__|__|     |__|__|__|   |
  | |    ______________________________
  | |   /    __ __ __ __ __ __ __ _    |
  | |  /  __|  |  |  |  |  |  |  | |   |
  | | |  |  | 1| 2| 3| 4| 5| 6| 7|8|   |
  | | |  | 9|__|__|__|__|__|__|__|_|   |
  | | '. |__| SD                      .'      SD Write Protect Tab
  | |  |  _________________________   |   <-- Unlock position
  | | .' |  _ _ _ _ _ _ _ _ _ _ _  |  |#  <-- LOCK position
  | | |  | | | | | |1|1| | | | | | |  '.
  | | |  | |9|1|2|3|0|1|4|5|6|7|8| |   |
  |_| |  | |_|_|_|_|_|_|_|_|_|_|_| |   |
    | |  |   miniSD                 \  |
    | |  |     _________________     | |
    | |  |    | _ _ _ _ _ _ _ _ |    | |
    | |  |    || | | | | | | | ||    | |
    |_|  |    ||1|2|3|4|5|6|7|8||    | |
      |  |    ||_|_|_|_|_|_|_|_||    | |
      |  |   /                  |    | |
      |  |  |_  microSD         |    | |
      |  |    |                 |    | |
      |  |   /                  |    | |
      |  |  |                   |    | |
      |  |  |                   |    | |
      |  |_ |                   | ___| |
      |____ |___________________| _____|
```



## SD/MMC Signals for on-board eMMC chip on DSi Mainboard "C/TWL-CPU-01"


Below are the required eMMC signals. Low-end hardware may get away with using
Data0 as single data line (eg. small microprocessors with few I/O pins), but
higher quality hardware should support 4bit data mode (eg. off-the-shelve SD
card interfaces may insist on all four data lines being connected). Data3 (aka
CardDetect) might be also needed even in 1bit data mode.

```
                         _______ CLK (SPI: CLK)    _______ Data3 (SPI: /CS)
                        |                         | ______ Data0 (SPI: DataOut)
                 <#>  <#>  <#>                    || _____ Data1
                EM14  R113 C130                   ||| ____ Data2
        .------------------------.                ||||
        |                        |          <#>  <####> #  #
        |                        |     U5   C57   RA4  C54 C55
        |  Shielding-plate       '---.  o .------------------.
        |                            |    |o                 |
        |                            |    |                  |
        |                            |    |  Samsung     834 |
        |                            |    |  KMAPF0000M-S998 |
        |  CPU              RAM      |    |                  |
        |                            |    |                  |
        |                            |    '------------------'
        '----------------------------'     R94 R54  C50 C51
             |                             <#> <#>  <#> <#>
             |                               |
             |___ shield = GND               |___ CMD/REPLY (SPI: DataIn)
```

For other DSi mainboards, see:

- [http://www.dsibrew.org/wiki/Hardware](http://www.dsibrew.org/wiki/Hardware)

The KMAPF0000M chip does probably NOT support SPI mode, and it does probably
support only MMC protocol (not SD protocol). That, assuming that the chip does
have similar capabilities as in KMCEN0000M datasheet (there's no KMAPF0000M
datasheet online).



## SD/MMC Signals and 3DS Hardmodding


Pictures with eMMC solder pads for 3DS mainboards boards can be found at:

- [https://www.3dbrew.org/wiki/Hardware](https://www.3dbrew.org/wiki/Hardware)

However, hardmodding is much more difficult for 3DS as than for DSi. Three
3DS-specific problems:


## CLK resistor

  - The 3DS tends to hold CLK low, and there is no resistor installed between
  - 3DS CPU and eMMC chip, so the card reader may be unable to pull CLK high.
  - As workaround, install a resistor in the CLK line (the mainboard has square
  - solder pads just for that purpose) (330..660 ohms have worked for me, I am
  - currently using 470 ohms; smaller resistors like 0..120 ohm won't work with
  - the card reader, and much larger resistors won't work with the 3DS itself).

## Incompatible Card readers

  - Newer 3DS/New3DS models seem to contain eMMC chips that are incompatible with
  - older card readers, maybe because their firmware/driver treats the CSD
  - version number as unknown, despite of the eMMC chip being nothing special.
  - As workaround, try to use some newer card readers, or use a DSi console as
  - card reader (ie. write you software that can happily ignore CSD version).

## Mechanical problems

  - Most solder points are on the wrong PCB side (unlike as on DSi, you will
  - need to remove the 3DS mainboard). Whereas, the connector for the top screen
  - backlight is rated to survive max 10 mating cycles (mine died after 5-7).
  - Part of the problem was that I wasn't aware of the other problems mentioned
  - above (so I had removed the mainboard several times to check my soldering),
  - and, the connector is 'underneath' of the PCB, making it difficult to insert
  - the cable straight and smoothly, causing pins in the connector may get bent,
  - making it impossible to insert the ribbon cable (maybe it will help if you
  - take time, and don't impatiently try to push the cable into the socket).



## Soldering Notes


Connect CLK/CMD to the pins on right side of R113/R94 (as shown in the
drawing). Connect Data3/0/1/2 to the LOWER pins of RA4 (unlike as shown in the
drawing, ie. NOT to the upper pins), or alternately, connect them to the four
vias below of RA4. Connect GND somewhere to shielding plate, for example.

My own setup is: A 8pin ribbon cable soldered to a spare SD-to-SDmicro adapter
(used as connector for SD/MMC slots), the ribbon cable is wired to a small
circuit board, which is soldered to the shielding of the DSi's game cartridge
slot (just for mechanical stability). Next, some fragile wires are forwarded
from the circuit board to the actual mainboard pins.



## Software Notes


Remove the DSi wifiboard (not absolutely required, but doing so will hang the
DSi before accessing the eMMC, which ensures that the eMMC won't be accessed
simultaneously by the DSi and PC). Switch on the DSi. Connect it to SD/MMC card
reader. Under Windows, the eMMC should show up as MMC-storagedevice in Windows
Explorer (alongsides with your HDD drives), due to the encryption it isn't
possible to access the filesystem or logical partitions of the chip. However,
the physical sectors can be accessed.

For example, using HxD hex editor: Click Extras, Open Disk, and select the MMC
(in HxD it shows up under Physical Discs: as Removeable Disk). Click Edit,
Select All, Copy. Click File, New. Then Edit, Paste. And finally File, Save As
for saving an image of the whole 240MByte FLASH chip.

I've tried accessing the eMMC on two PCs, one worked, the other didn't:

```
  Win98 with External Card reader: Windows didn't recognize the MMC chip
  Win7  with External Card reader: Okay (recognized as "unformatted" disk)
  Win7  with Internal Card reader: Okay (recognized as "unformatted" disk)
```

For testing the Operating System/Card Reader side: Connect a normal SD card to
the card reader. If HxD is showing it as both Logical Disc and Physical Disc,
then you are fine. If it shows up as Logical Disc only, then your setup won't
work for accessing the eMMC chip.




# <a name="auxopeningthegba"></a>AUX Opening the GBA



Since Nintendo uses special screws with Y-shaped heads to seal the GBA (as well
as older 8bit gameboys), it's always a bit difficult to loosen these screws.



## Using Screwdrivers


One possible method is to use a small flat screwdriver, which might work, even
though it'll most likely damage the screwdriver.

Reportedly, special Y-shaped screwdrivers for gameboys are available for sale
somewhere (probably not at your local dealer, but you might find some in the
internet or elsewhere).



## Destroying the Screws


A more violent method is to take an electric drill, and drill-off the screw
heads, this might also slightly damage the GBA plastic chase, also take care
that the metal spoons from the destroyed screws don't produce shortcuts on the
GBA mainboard.



## Using a selfmade Screwdriver


A possible method is to take a larger screw (with a normal I-shaped, or
X-shaped head), and to cut the screw-tip into Y-shape, you'll then end up with
an "adapter" which can be placed in the middle between a normal screwdriver and
gameboy screws.

Preferably, first cut the screw-tip into a shape like a "sharp three sided
pyramid", next cut notches into each side. Access to a grinding-machine will be
a great benefit, but you might get it working by using a normal metal-file as
well.



## Opening the GBA Micro


- open the case with appropriate screwdriver or drilling machine or whatever

- remove the plastic front-plate (there are two snap-ins inside at ONE side)

- remove the mainboard and screen and plastic skeleton from the metal case

- remove the start/select daughter-board from the plastic skeleton

- remove the plastic skeleton (move the screen through the skeleton)

- remove the screen (lift lcd socket front-side, backlight socket rear-side)



## Opening the NDS-Lite


- open the case with appropriate screwdriver or drilling machine or whatever

- remove the RFU unit, and the 4-pin touch-screen cable (under the RFU unit)

- remove the mainboard together with the lower screen

- remove the upper/lower screen cables (on the rear-side of the mainboard)




# <a name="auxmainboard"></a>AUX Mainboard



Other possibly useful signals on the mainboard...



## FIQ Signal


The FIQ (Fast Interrupt) signal (labeled FIQ on the mainboard) could be used as
external interrupt (or debugging break) signal.

Caution: By default, the FIQ input is directly shortcut to VDD35 (+3V or +5V
power supply voltage), this can be healed by scratching off the CL1 connection
located close to the FIQ pin (FIQ still appears to have an internal pull-up, so
that an external resistor is not required).

The GBA BIOS rejects FIQs if using normal ROM cartridge headers (or when no
cartridge is inserted). When using a FIQ-compatible ROM header, Fast Interrupts
can be then requested by pulling FIQ to ground, either by a push button, or by
remote controlled signals.



## RESET Signal


The RESET signal (found on the mainboard) could be used to reset the GBA by
pulling the signal to ground for a few microseconds (or longer). The signal can
be directly used (it is not shortcut to VDD35, unlike FIQ).

Note: A reset always launches Nintendo's time-consuming and annoying boot/logo
procedure, so that it'd be recommend to avoid this "feature" when possible.



## Joypad Signals


The 10 direction/button signals are each directly shortcut to ground when
pressed, and pulled up high otherwise (unlike 8bit gameboys which used a 2x4
keyboard matrix), it'd be thus easy to connect a remote keyboard, keypad,
joypad, or read-only 12bit parallel port.




# <a name="auxdsicomponentlists"></a>AUX DSi Component Lists




## DSi Mainboard "C/TWL-CPU-01" Components


```
  U1 352pin   CPU TWL       (under shielding plate)                    ;\under
  U2   ?pin   RAM 8Mx16, Fujitsu MB82DBS08164D-70L, NEC uPD46128512AF1 ;/shield
  U3  56pin   "TexasIns 72071B0" or "Mitsumi 3317A" (powerman?) (right of NAND)
  U4  48pin   "AIC3000D, TI 89K, EXDK G4" (PAIC3 codec? above headphone socket)
  U5   ?pin   Samsung KMAPF0000M-S998 (eMMC, 256Mbyte NAND FLASH)
  U6  36pin   "BPTWL, K007K, 0902KM00D" (small/square, left of cartridge slot)
  U7   8pin   "AOK, S8BXS" (ISL95810, I2C potentiometer)         ;\on PCB
  U8   8pin   "7BDS" (PCA9306, I2C voltage translator)           ;/backside
  U9  12pin   "199A, 01IU" (Seiko S-35199A01) (RTC) ;under shielding plate (A)
  U10  4pin   "6800" or "688F" Hinge Magnet Sensor (PCB backside, near A/B/X/Y)
  U11 10pin   ",\\ 908, 335A" or "2005D, 8350" (right of cartridge slot)
  U12  5pin   "L8NX" or "C7JHN" (upper-right of PCB back-side) ;text layer (B)
  U13  5pin   Backlight 1, "U01" or "KER"  ;\lower-right board edge
  U14  5pin   Backlight 2, "U01" or "KER"  ;/see text-layer (B)
  U15  4pin   ",\\ T34" (near external power input)
  U16     -   N/A
  U17  6pin   "VY" or "Z198" (in lower-right, on PCB backside)
  U18  6pin   "YJ" (above headphone socket)
  U19  5pin   "E30H6" or "L2SX" (at lower right of cartridge slot)
  Q1   6pin   external power supply related
  Q2    pin   N/A ?
  Q3   6pin   ... above battery plug
  Q4   3pin   maybe MUTE for SR  ;\old TWL-CPU-01 mainboard only
  Q5   3pin   maybe MUTE for SL  ;/(replaced by Q17?/Q18? on newer boards)
  Q6   6pin   MC1_VDD power ON (supply)
  Q7   3pin   MC1_VDD power OFF (pulldown)
  Q8    pin   N/A ?
  Q9    pin   N/A ?
  Q10   pin   N/A ?
  Q11  3pin   BLUE (LED)   ;\LEDs (note: the other LEDs, ORANGE
  Q12  3pin   YELLOW (LED) ;      and YELLOW, are driven directly)
  Q13  3pin   CAM_LED      ;/
  Q14  3pin   not installed (above powerman chip)
  Q15  3pin   not installed (above powerman chip)
  Q16  3pin   VDD-5 related, near DPAD socket
  Q17? 6pin   maybe MUTE  ;\  ;\new TWL-CPU-10 mainboard only
  Q18? 6pin   maybe MUTE  ;/  ;/(formerly Q4/Q5 on older boards)
  X1   4pin   16.756  (rectangular oscillator)        ;\under shielding plate
  X2   4pin   CB837 or CB822 (long slim osc) for RTC? ;/text layer: see (A)
  F1   2pin   Fuse for external power input
  SW1  2pin   Button A (right)
  SW2  2pin   Button B (lower)
  SW3  2pin   Button X (upper)
  SW4  2pin   Button Y (left)
  SW5  2pin   Button Select (lower)
  SW6  2pin   Button Start  (upper)
  P1  19pin   NDS/DSi cartridge slot (17pin slot + 2pin switch at right side)
  P2      -   N/A
  P3      -   N/A
  P4   8pin   External microphone/headphone combo socket
  P5  50pin   Wifi-Daughterboard
  P6      -   N/A
  P7  47pin   To UPPER lcd screen (video+backlight+speakers) (on PCB backside)
  P8  37pin   To LOWER lcd screen (video signals)
  P9  25pin   To UPPER lcd screen (signals for both cameras, and camera led)
  P10  4pin   To LOWER lcd screen (touchpad X-,Y-,X+,Y+)
  P11  2pin   External Power Supply input (4.6V DC IN)
  P12     -   N/A
  P13     -   N/A
  P14     -   N/A
  P15 15pin   To battery/DPAD/PowerButton board (and onwards to 3xLEDs)
  P16 26pin   To bottom cover (SD Slot and L/R/VOL+/- buttons)
  P17  2pin   Battery cable (lower-right) ;see text-layer (B)
  P18  4pin   To LOWER lcd screen (backlight cathode/anode)
  P19  1pin   Shielding-Plate for CPU (lower clip)
  P20  1pin   Shielding-Plate for CPU (upper clip)
  P21  1pin   Shielding-Plate for CPU (right clip)
  P22     -   N/A
  P23  2pin   To Internal Microphone (via orange shielded wire)
```

DSi Front/bottom-Side Text Layer sections (in upper left of mainboard)

```
  (A)  For components underneath of shielding plate
  (B)  For components in lower-right board edge (near battery connector)
  (C)  For components at middle/right of cartridge slot
  (D)  For components left of U4 (left board edge)
  (E)  For components right of U4 (above headphone socket)
  (F)  For components at lower/right of cartridge slot
```

DSi Back/top-Side Text Layer sections (at various places)

```
  (A)  at top/middle,  for components at upper right edge
  (B)  at middle/left, for components near upper right edge
  (C)  at lower/left,  for components left of Y-button
  (D)  at lower/righz, for components at right edge
```



## DSi Wifi Daughterboard (DWM-W015) (older DSi version)


PCB Text: "RU (S)-717V 01 ,\\" or "RU (S)-717V 03 ,\\" or "FK RU 06 ,\\"

```
  U   56pin "Mitsumi, Japan, 844L, MM3218" (same as in DS Lite)
  U  132pin "ROCm, Atheros, AR6002G-AC1B, E19077.1B, 0844, Taiwan"
  U    8pin I2C EEPROM "408F, B837" (HN58X2408F; 1Kx8 for atheros calibration)
  U    8pin SPI FLASH big chip "45PE10V6, HPASC VS, KOR 8364, ST"  ;\either one
  U    8pin SPI FLASH tiny chip "5A32, 8936?"                      ;/installed
  U    8pin "4P, K" or "S6, K" (odd 3+1+3+1 pin package, near antenna)
  U    4pin "3VP, OT" or "3VB, OS" (at board edge, near 50pin connector)
  X    4pin "26.000, 9848" (bigger oscillator, for atheros chip)
  X    4pin "22.000, xxxx" (smaller oscillator, for mitsumi chip)
  P   50pin Connector to Mainboard
  P    2pin Connector for Antenna (shielded white cable)
```

The "3VP/3VP" thing is some 1.2V voltage regulator (sth like LP3983 or TPS799xx
or similar).

White PCB sticker (underneath of the black isolation sticker): "DWM-W015,
IC:4250A-DWMW015, FCC ID:EW4DWMW015, [R]003WWA080444, [T]D080261003, MADE IN
PHILIPINES, MITSUMI ELEC. CO., LTD."



## DSi Wifi Daughterboard (DWM-W024) (newer DSi version)


PCB Text: "FB RU 06 ,\\"

```
  U   76pin "ROCm, Atheros, AR6013G-AL1C" (or 80pin, with 4pins at edges?)
  U    8pin I2C EEPROM? "4DA?, D940?"   ;maybe I2C eeprom for atheros
  U    8pin SPI FLASH "5A32, 8937?"   ;FLASH (small solder pads)
  U    8pin SPI FLASH not installed (alternate bigger solder pads for FLASH?)
  U    4pin "?" (at board edge, near 50pin connector)
  X    4pin "??" (oscillator, near ROCm chip)
  P   50pin Connector to Mainboard
  P    2pin Connector for Antenna (shielded white cable)
```



## DSi Wifi Daughterboard (J27H020) (alternate newer DSi version)


This seems to be functionally same as DWM-W024, but the PCB is different, and
the circuit seems to use a different voltage regulator, and includes solder
pads for some additional uninstalled components. And the shielding is difficult
to remove because it's soldered all way round (rather than just at some solder
points).

- Sticker 1:
  - HON HAI PRECISION IND.CO.,LTD.        ;aka Foxconn
  - MODEL: J27H020
  - [R] 003WWA100195
  - [T] D100196003
  - FCC ID: MCLJ27H020
  - IC: 2878D-27H020
- Sticker 2:
  - (barcode)
  - \<mac.address> J27H020.00 LF, 4xxxxxx-xxx
- Board:
  - U1   76pin atheros ... "ATHEROS, AR6013G-AL1C, N2U586.00C, 1035, KOREA"
  - U2    -    -
  - U3    -    -
  - U4    8pin I2C EEPROM "G80, 8, G02"
  - U5    8pin SPI FLASH big chip "26FV032T, OGK01"  (installed)
  - U6    -    -
  - U7    8pin SPI FLASH small chip (not installed)
  - U?    5pin voltage regulator or so "IG19P"
  - U?    6pin whatever near antenna (not installed)
  - Y1    4pin crystal "H400K"
  - J3    2pin Connector for Antenna (shielded white cable)
  - J6   50pin Connector to Mainboard



## 3DS Wifi Daughterboard (DWM-W028)


Component list is unknown. The thing is said to use a "Atheros AR6014" chip.

Later 3DS models have the Wifi unit (with AR6014G chip) on the mainboard
(instead of using a removeable DWM board).



## DSi Battery/DPAD Daughterboard "C/TWL-SUB-01"


```
  TH1  2pin  Battery Thermal Sensor maybe? (about 10kOhm at room temperature)
  F1   2pin  Battery Fuse
  SW1  2pin  DPAD Up Button
  SW2  2pin  DPAD Down Button
  SW3  2pin  DPAD Left Button
  SW4  2pin  DPAD Right Button
  SW5  2pin  Power/Reset Button
  P1  15pin  To Mainboard (P15) (button/led signals) (wire "15P-01")
  P2   6pin  To 3xLEDs
  P3   3pin  To battery (TWL-003 3.6V 840mAh 3Wh C/TWL-A-BP, Li-ion 00"
  Wire 2pin  To Mainboard (P17) (battery supply) (red=vcc, black=gnd)
```



## DSi LED Board/Foil "LED-01, (DF)"


```
  D    2pin  Left LED      ;-wifi
  D    2pin  Middle LED    ;-charge
  D    2pin  Right LED 1   ;\power "two-color-LED"
  D    2pin  Right LED 2   ;/composed of 2 single LEDs
  Wire 6pin  To Battery/DPAD Daughterboard
```



## DSi Lower Screen with Touchpad


```
  Wire 4pin  Touchpad
  Wire 4pin  Backlight (actually 2pins, each 2 pins are same)
  Wire xxpin Video Signals
  LCD  "LS033A1DG48R, 8X16Q U0003986"
```



## DSi Upper Screen with Speakers & Cameras & LED & Microphone


```
  Orange Ribbon Cable: Video Signals, Backlight, and Speakers
  Black Ribbon Cable: Cameras and Camera LED
  Shielded Orange 2pin Wire: Microphone
  Shielded White 2pin Wire: Wifi PCB Antenna
  LCD  "LS033A1DG38R, BX16Q L0005532"
  The speakers use red/black wires, which connect to the orange ribbon cable
```



## DSi Upper Screen Area Extra Components: Speakers & Cameras & LED & Microphone




## DSi Lower Case (SD Slot, L/R and VOL+/- Buttons, and screen calibration)


```
  Whatever, not checked yet
```



## DSi Disassembly Notes


Bottom Cover Screws:

```
  7 screws (two are under battery cover)
```

Remove bottom cover, and:

```
  P16: To bottom cover (SD Slot and L/R/VOL+/-) --> pull (away from board)
```

Remove Wifi Daughterboard:

```
  P5:  Wifi-board (without cable)               --> pull (away from board)
  WHITE: Wifi-Antenna (shielded 2pin)           --> pull (away from wifi-board)
```

Remove mainboard:

```
  ORANGE P24 (shielded 2pin)  --> pull (away from board)
  WHITE SUPPLY                --> lift (use screwdriver & push away from board)
  3x bigger white/black connectors --> lift black lid (at cable-side)
  2x smaller black connectors      --> lift black lid (at cable-end) (!!!)
```

Turn mainboard over, then unlock the connector at back side:

```
  1x bigger white/black connector  --> lift black lid (at cable-side)
```

Remove Battery board:

```
  1x smaller black connector       --> lift black lid (at cable-end) (!!!)
  1x bigger white/black connectors --> lift black lid (at cable-side)
  (don't disconnect bigger connector if the other cable end is already
  disconnected from mainboard) (or if you did do, reassemble as follows:
  longer cable end to battery board, short cable end to mainboard)
  1x battery cable (disconnect at mainboard side, see there)
```

Top Cover Disassembly:

```
  Disconnect upper LCD and mic/antenna from mainboard (see above)
  Remove 4 screws (all hidden under square rubber pieces)
  slide rear bezel upwards by two millimeters?
  push metal hinge inwards by three millimeters (under LED unit)
```




# <a name="auxdsiinternalconnectors"></a>AUX DSi Internal Connectors




## P1 - 19pin - NDS/DSi cartridge slot (17pin slot + 2pin switch at right side)


```
  1   GND
  2   MC1_CLK
  3   -
  4   MC1_CS
  5   MC1_RES
  6   MC1_CS2
  7   MC1_IREQ
  8   MC1_VDD via Q6 to VDD33 (cpu signal preamplified from Q7)
  9   MC1_IO0
  10  MC1_IO1
  11  MC1_IO2
  12  MC1_IO3
  13  MC1_IO4
  14  MC1_IO5
  15  MC1_IO6
  16  MC1_IO7
  17  GND
  18  MC1_DET           ;\switch closed when cart inserted
  19  GND               ;/
  Shield GND
```



## P4 - 8pin - External microphone/headphone combo socket


```
  1  GND    ;\      ;\
  2  SL     ; head- ; headphone gnd/left/right
  3  SR     ; phone ;/
  4  GND    ;       ;\headphone/speaker switch (pin 4+5 shortcut with each
  5  HP#SP  ;/      ;/other when no headphone connected)
  6  MIC    ;\    ;\microphone switch (pin6+7 shortcut when no mic connected)
  7  Switch ; mic ;/(internal mic from P23 is then passed from pin7 to pin6)
  8  GND    ;/
```



## P5 - 50pin - DSi Wifi-Daughterboard (DWM-W015, DWM-W024, or J27H020)


```
                           GND   2  1   SDIO.CLK       ;\
                         VDD18   4  3   GND            ; SDIO for
                         VDD18   6  5   SDIO.DAT0      ; Atheros Wifi
                           GND   8  7   SDIO.DAT3      ; (CLK, CMD, DATA0-3)
                         VDD33  10  9   SDIO.DAT1      ;
                         VDD33  12  11  SDIO.CMD       ;
                           GND  14  13  SDIO.DAT2      ;/
                      ATH_TX_H  16  15  DSi: NC (DWM: JTAG_TDO)
                     /WIFI_RST  18  17  DSi: NC (DWM: JTAG_TMS)
     (DWM:JTAG_TDI)    DSi: NC  20  19  GND
     (DWM:JTAG_TCK)    DSi: NC  22  21  RTC_FOUT (or RTC_F32K?)  ;for Atheros?
     (DWM:JTAG_TRST_L) DSi: NC  24  23  GND
 (near CPU irq pins) SEL_ATH_L  26  25  DSi: NC (wifi: via 0 ohm MM3218.pin47)
               /FLASH_WP (R122) 28  27  SPI_CS2 (wifi FLASH memory)
                       SPI_SCK  30  29  BBP_SLEEP    to MM3218.pin42
                      SPI_MISO  32  31  RF_SLEEP     to MM3218.pin41
                      SPI_MOSI  34  33  RF_SCS       to MM3218.pin38
       to MM3218.pin15     CCA  36  35  BBP_SCS      to MM3218.pin37
                       WL_RXPE  38  37  BB_RF_SDO    to MM3218.pin36
       to MM3218.pin19  TRDATA  40  39  BB_RF_SDI    to MM3218.pin35
                           GND  42  41  BB_RF_SCLK   to MM3218.pin34
       to MM3218.pin21   TRCLK  44  43  NC(VDD18_TP) to MM3218.pin28 (0ohm+cap)
       to MM3218.pin18   TRRDY  46  45  GND
                       WL_TXPE  48  47  MCLK    to MM3218.pin23 (via XX & CLxx)
                         RESET  50  49  GND
```

- [https://fccid.io/EW4DWMW024/Label/Label-format-and-location-1137926.pdf](https://fccid.io/EW4DWMW024/Label/Label-format-and-location-1137926.pdf)
- [https://fccid.io/EW4DWMW015/Label/Label-Location-1031953.pdf](https://fccid.io/EW4DWMW015/Label/Label-Location-1031953.pdf)
Pin 25 and 43 are VDD test points on DWM-W015 wifiboard (but are NC on DSi
mainboard & DWM-W024 wifiboard).



## P7 - 47pin - To UPPER lcd screen (video+backlight+speakers) (on PCB backside)


```
                          BLA2   1  2   BLC2    ;-backlight
                          SPLN   3  4   SPLN    ;\left speaker
                          SPLP   5  6   SPLP    ;/
                          SPRN   7  8   SPRN    ;\right speaker
                          SPRP   9  10  SPRP    ;/
                         VDD-5  11  12  VDD10
                          VDD5  13  14  GND
                          VSHD  15  16  VSHD
                           INI  17  18  GSP
                           GCK  19  20  LDB20
                         LDB21  21  22  LDB22
                         LDB23  23  24  LDB24
                         LDB25  25  26  LDG20
                         LDG21  27  28  LDG22
                           GND  29  30  LDG23
                         LDG24  31  32  LDG25
                         LDR20  33  34  LDR21
                         LDR22  35  36  LDR23
                         LDR24  37  38  LDR25
                           GND  39  40  DCLK
                           SPL  41  42  LS
                           GND  43  44  via C79 to COM2
                           REV  45  46  GND
                          COM2  47
```



## P8 - 37pin - To LOWER lcd screen (video signals)


```
                         VDD-5   1  2   VDD10
                          VDD5   3  4   GND
                          VSHD   5  6   VSHD
                           INI   7  8   GSP
                           GCK   9  10  LDB10
                         LDB11  11  12  LDB12
                         LDB13  13  14  LDB14
                         LDB15  15  16  LDG10
                         LDG11  17  18  LDG12
                           GND  19  20  LDG13
                         LDG14  21  22  LDG15
                         LDR10  23  24  LDR11
                         LDR12  25  26  LDR13
                         LDR14  27  28  LDR15
                           GND  29  30  DCLK
                           SPL  31  32  LS
                           GND  33  34  via C93 to COM1
                           REV  35  36  GND
                          COM1  37
```



## P9 - 25pin - To UPPER lcd screen (signals for both cameras, and camera led)


```
                           GND   1  2   CAM_LED
                         VDD42   3  4   GND
                  R100    RCLK   5  6   GND
                           GND   7  8   HSYNC
                         VSYNC   9  10  CAM_D5  RA7
                   RA7  CAM_D6  11  12  CAM_D4  RA7
                       CAM_RST  13  14  SCL
                           SDA  15  16  CAM_D7  RA7
                   RA6  CAM_D0  17  18  CAM_D3  RA6
                   RA6  CAM_D1  19  20  CAM_D2  RA6
                         VDD28  21  22  GND
                           CKI  23  24  GND
                         VDD18  25
```



## P10 - 4pin - To LOWER lcd screen (touchpad X-,Y-,X+,Y+)


```
  1 X-
  2 Y-
  3 X+
  4 Y+
```



## P11  2pin   External Power Supply input (4.6V DC IN)


```
  1 VIN  (+4.6V)
  2 VGND (GND)
  Shield (GND)
```



## P15 - 15pin - To battery/DPAD/PowerButton board (and onwards to 3xLEDs)


```
  dpad up button      P06  1  2  ORANGE (LED) Battery Charge
  dpad right button   P04  3  4  BLUE   (LED) Power On/Good
  dpad left button    P05  5  6  YELLOW (LED) Wifi
  dpad down button    P07  7  8  RED    (LED) Power On/Low
                      GND  9  10 VDD42 (to LEDs)
                      GND 11  12 TH on DPAD board (via R102 to TH on main)
  middle battery pin  DET 13  14 GND
  power button       PWSW 15
```

Note: On Daughterboard, pins are mirrored (eg. PWSW=Pin1 instead Pin15)



## P16 - 26pin - To bottom cover (SD Slot and L/R/VOL+/- buttons)


```
                      GND  2  1  SD10_CLK                   ;\
               SD10_DATA0  4  3  SD10_VDD (aka VDD33)       ;
               SD10_DATA1  6  5  SD10_VDD (aka VDD33)       ; pin 1..18
                  SD10_WP  8  7  GND                        ; to RIGHT side:
                      GND 10  9  SD10_CMD                   ; R-button, and
  shoulder button R   P08 12  11 GND                        ; SD-card slot
                      GND 14  13 SD10_DATA3                 ;
                  SD10_CD 16  15 SD10_DATA2                 ;
                      GND 18  17 GND                        ;/
                      GND 20  19 GND                        ;\pin 19..20
  maybe display ;\   VDD5 22  21 VOLP (aka volume plus?)    ; to LEFT side:
  calibration?  ;    COM1 24  23 VOLN (aka volume minus?)   ; L-button, VOL +/-
  (at battery)  ;/   COM2 26  25 P09   shoulder button L    ;/and calibration
```



## P17 - 2pin - Battery cable (lower-right) ;see text-layer (B)


```
  + BT+ (plus) (red wire)
  - BT- (GND)  (black wire)
```



## P18 - 4pin - To LOWER lcd screen (backlight cathode/anode)


```
  1 BLC1  ;\both same
  2 BLC1  ;/
  3 BLA1  ;\both same
  4 BLA1  ;/
```



## P19 - 1pin - Shielding-Plate for CPU (lower clip)



## P20 - 1pin - Shielding-Plate for CPU (upper clip)



## P21 - 1pin - Shielding-Plate for CPU (right clip)


```
  Shield GND
```



## P23 - 2pin - To Internal Microphone (via orange shielded wire)


```
  Pin  MIC (from P4.Pin7, disconnected when external microphone connected)
  Shield GND
```



## DPAD-BOARD - P2 - 6pin - To LEDs


```
  1  YELLOW  Wifi
  2  BLUE    Power On/Good
  3  ORANGE  Battery Charge
  4  GND   (for red+orange)
  5  RED     Power On/Low
  6  VDD42 (for yellow+blue)
```




# <a name="auxdsichipsetpinouts"></a>AUX DSi Chipset Pinouts



A photo of the DSi mainboard (with extra text layer on vias and solderpads) can
be found at:

- [http://problemkaputt.de/twl-core.jpg](http://problemkaputt.de/twl-core.jpg)



## DSi U1 - TWL-CPU (19x19 pin grid) (352 pins, aka 19x19 minus middle 3x3 pins)


```
      Wifi    MC2 maybe      MC1           SD/MMC  eMMC  SPI     RTC   IRQs
  .---.---.---------------.---------------.-------.---.-------.-------.---.---.
  |NC |wif|NC  NC  NC  NC |D7  D3  IRQ CLK|D0  CLK|CLK|CS3 SCK|CS  SCK|R7 |NC |
  +---'   |               |               |       |   |       |   .---'   '---+
  |wif wif|NC  NC  NC  NC |D6  D2  DET CS |D1  CMD|D0 |CS2 MIS|SIO|PEN NC  WIF|
  |       |               |               |       |   |       +---+---.   .---+
  |wif wif|NC  NC  NC  NC |D5  D1  PWR CS2|D2  CD |D1 |CS1 MOS|R00 R01|RTC|P09|
  |       '---.       .---+           .---'   .---'   '---.---+       '---'   |
  |wif wif wif|NC  NC |V33|D4  D0  RES|D3  WP |D3  D2  CMD| ? |P08 P07 P06 P05|
  |           '---+---'   '-----------'-------'-----------'---+               |
  |wif wif RXP TXP|GND V12 V33 GND V12 V33 G?  V12 V33 GND V33|P04 P03 P02 P01|
  | . .           |                                           +-----------.   |
  |DT3|wif wif ?  |GND V33 V12 GND GND GND V33 G?  GND V33 V12| ?  RES NC |P00|
  |   '. . . . . .|                                           |           '---+
  |CLK DT2 DT1 DT0|V33 GND V12 V33 GND V12 G?  V12 GND GND V33|PMO VC5 PMS X  |
  +-----------.   |                                           '-----------.   |
  |V33 NC  GND|CMD|V12 GND V33 GND V12 V33 GND V33 V12 V12 V33 GND GND GND|X  |
  |           '---'               .-----------.               .-----------'   |
  |V33 NC  V33 V33 GND V33 GND V33|-   -   -  |GND GND GND GND|HP# IRQ ?   GND|
  +---.   .---.                   |           |               |               |
  |B15|V33|NC |V33 V12 GND V12 V12|-   -   -  |V12 V18 GND V12|NC  NC  NC  GP |
  |   '---'---'---.               |           |               +---------------+
  |B14 B13 B12 B11|V33 GND V33 GND|-   -   -  |V18 GND V18 GND|A1  D1  A0  D0 |
  |               |               '-----------'               |               |
  |B10 G15 G14 G13|GND V33 V12 GND V18 V12 V18 GND V18 V12 V18|A3  D3  A2  D2 |
  |               |                                           |               |
  |G12 G11 G10 R15|V33 V12 GND V12 GND V18 GND V12 GND V18 GND|A5  D5  A4  D4 |
  |               |                                           |               |
  |R14 R13 R12 R11|GND V33 V18 GND V18 V12 V18 GND V18 V12 V18|A7  D7  A6  D6 |
  +-----------.   |                                           |               |
  |DCK GSP SPL|R10|V33 V12 GND V18 GND V18 GND V12 GND V18 GND|A9  D9  A8  D8 |
  |       .---'---'-------.-------.---.---.-------.-----------'               |
  |LS  REV|B22 G24 G20 R22|D7  D3 |NC |RST|SCK WS |CE1 /OE A20 A11 D11 A10 D10|
  |   .---'               |       |   |   |       |                           |
  |GCK|B25 B21 G23 R25 R21|D6  D2 |NC |VSY|MCK SDO|NC  CE2 A19 A13 D13 A12 D12|
  |   |                   |       |   |   +---.   |                           |
  |INI|B24 B20 G22 R24 R20|D5  D1 |NC |HSY|SDA|SDI|/LB CLK A18 A21 A14 D15 D14|
  +---+               .---+       '---'   |   +---'                       .---+
  |NC |B23 G25 G21 R23|NC |D4  D0  CKI RCK|SCL|/UB ADV /WE A15 A17 A22 A16|NC |
  '---'---------------'---'---------------'---'---------------------------'---'
          LCD                  CAM         I2C SND          RAM               o
```



## DSi U2 - Main RAM (8Mx16) (Fujitsu MB82DBS08164, or NEC uPD46128512)


DSi mainboard solder pads (12x8 grid, within 14x10 grid):

```
       A    B    C    D    E    F    G    H    J    K    L    M    N    P
  10   -    -    -    -    -    -    -    -    -    -    -    -    -    -
  9    -    NC   NC   -    A15  A21  A22  A16  NC   VSS  -    NC   NC   -
  8    -    NC   NC   A11  A12  A13  A14  NC   DQ15 DQ7  DQ14 NC   NC   -
  7    -    -    -    A8   A19  A9   A10  DQ6  DQ13 DQ12 DQ5  -    -    -
  6    -    -    -    /WE  CE2  A20  -    -    DQ4  VDD  NC   -    -    -
  5    -    -    -    CLK  /ADV (W)  -    -    DQ3  VDD  DQ11 -    -    -
  4    -    -    -    /LB  /UB  A18  A17  DQ1  DQ9  DQ10 DQ2  -    -    -
  3    -    NC   -    A7   A6   A5   A4   VSS  /OE  DQ0  DQ8  NC   NC   -
  2    -    NC   NC   -    A3   A2   A1   A0   NC   /CE1 -    NC   NC   -
  1 o  -    -    -    -    -    -    -    -    -    -    -    -    -    -
```

DSi RAM - Fujitsu MB82DBS08164 (14x10 grid):

```
       A    B    C    D    E    F    G    H    J    K    L    M    N    P
  10   NC   NC   NC   NC   NC   NC   VDD  VSS  NC   NC   NC   NC   NC   NC
  9    NC   NC   NC   NC   A15  A21  A22  A16  NC   VSS  NC   NC   NC   NC
  8    -    -    NC   A11  A12  A13  A14  NC   DQ15 DQ7  DQ14 NC   -    -
  7    -    -    NC   A8   A19  A9   A10  DQ6  DQ13 DQ12 DQ5  NC   -    -
  6    -    -    NC   /WE  CE2  A20  NC   NC   DQ4  VDD  NC   NC   -    -
  5    -    -    NC   CLK  /ADV /WAI NC   VDD  DQ3  VDD  DQ11 VDD  -    -
  4    -    -    NC   /LB  /UB  A18  A17  DQ1  DQ9  DQ10 DQ2  VSS  -    -
  3    -    -    VSS  A7   A6   A5   A4   VSS  /OE  DQ0  DQ8  NC   -    -
  2    NC   NC   NC   NC   A3   A2   A1   A0   NC   /CE1 NC   NC   NC   NC
  1 o  NC   NC   -    NC   NC   NC   VDD  VSS  NC   NC   NC   NC   NC   NC
```

DSi RAM - NEC uPD46128512 (14x10 grid):

```
       A    B    C    D    E    F    G    H    J    K    L    M    N    P
  10   NC   NC   NC   -    -    -    NC   NC   -    -    -    NC   NC   NC
  9    -    NC   NC   -    A15  A21  A22  A16  NC   VSS  -    NC   NC   -
  8    -    -    NC   A11  A12  A13  A14  NC   DQ15 DQ7  DQ14 NC   -    -
  7    -    -    -    A8   A19  A9   A10  DQ6  DQ13 DQ12 DQ5  -    -    -
  6    -    -    NC   /WE  CE2  A20  NC   NC   DQ4  VCC  NC   NC   -    -
  5    -    -    NC   CLK  /ADV /WAI NC   NC   DQ3  VCC  DQ11 NC   -    -
  4    -    -    -    /LB  /UB  A18  A17  DQ1  DQ9  DQ10 DQ2  -    -    -
  3    -    -    NC   A7   A6   A5   A4   GND  /OE  DQ0  DQ8  NC   -    -
  2    -    NC   NC   NC   A3   A2   A1   A0   NC   /CE1 -    NC   NC   -
  1 o  NC   NC   NC   -    -    -    NC   NC   -    -    -    NC   NC   NC
```

The Fujitsu & NEC datasheets are specifing 14x10 grid (the chips are
essentially pin-compatible, except that: NEC has removed some NC pins, changed
some supply pins to NC, and (attempted to) rename VSS to GND).

However, the DSi mainboard has 12x8 grid solder pads (and the installed
NEC/Fujitsu chip/packages are actually only 12x8, too).

The DSi debug version is said to have 32Mbyte RAM, there is no provision for
that feature on DSi retail boards; dev boards are probably somewhere having an
extra address line (or an extra chip select for a 2nd RAM chip).



## DSi U3 - Power Managment (Texas Instruments 72071B0, or Mitsumi 3317A)


```
  1   GND (via CL9)
  2   ADPO
  3   EXTB+
  4   VDD33
  5   RESET         ;\
  6   SPI_SCK       ; main cpu bus
  7   SPI_MOSI      ; (reset and spi)
  8   SPI_MISO      ;
  9   SPI_CS1       ;/  <-- powerman (this does ALSO connect to U4)
  10  GND
  11  PMOFF
  12  PWSWO
  13  VCNT5
  14  PM_SLP
  ---
  15  B+
  16  VDD12 via L1
  17  VDD12
  18  GND
  19  BLC1          ;\
  20  BLA1 via U13  ; backlight 1+2
  21  BLA2 via U14  ; anode/cathode
  22  BLC2          ;/
  23  GND
  24  B+
  25  B+
  26  VDD18 via L2
  27  VDD18 via L2
  28  VDD18
  ---
  29  DET     ;\battery contacts
  30  BT+     ;/    ;\these are almost shortcut
  31  VDET-         ;/with each other (via 0 ohm R71)
  32  PVDD
  33  PWSW (when off: very few ohms to PVDD)
  34        ... via R104 (100K) to Q3 (B+ enable or so?)
  35  B+
  36        ... via to C18 to GND (seems to have no other connection)
  37  GND
  38  AOUT  ;\to U6
  39  GND   ;
  40  SCL1  ;   ;\secondary IC2 bus (to U6)
  41  SDA1  ;/  ;/
  42  VDD33
  ---
  43  GND via CL10
  44  VDD5 input (sense if VDD5/C16 has reached voltage)
  45  charge-pump for VDD5 (L7 and via DA3 to VDD5/C16)
  46  charge-pump for VDD5 (L5 and C14)
  47  VDD33 (via CL5)
  48  VDD33 (via L3)
  49  VDD33
  50  VDD33
  51  B+
  52  B+
  53  B+
  54  charge-pump for VDD42 (L7 and C23)
  55  charge-pump for VDD42 (L7 and via D3 to VDD42/C22)
  56  VDD42 input (sense if VDD42/C22 has reached voltage)
```



## DSi U4 - Sound and Touchscreen controller (AIC3000D)


AIC3000D pinout is same as in TSC2117 datasheet (aside from GPIx/GPIOx pins).

```
  Pin TSC2117 AIC3000D
  1   MISO    SPI_MISO
  2   MOSI    SPI_MOSI
  3   /SS     SPI_CS1 (powerman, this does ALSO connect to U3)
  4   SCLK    SPI_SCLK
  5   GPIO1   SPI_CS3 (touchscreen)
  6   GPIO2   PENIRQ
  7   IOVSS   GND
  8   IOVDD   VDD33
  9   DVDD    VDD18
  10  SDOUT   SND_SDI              ;\
  11  SDIN    SND_SDO              ;
  12  WLCK    SND_WS               ; serial sound input from main cpu
  ---                              ; (and serial output? microphone maybe?)
  13  BCLK    SND_SCLK             ;
  14  MCLK    SND_MCLK             ;/
  15  SDA       ... via R107 to VDD18  ;\unused I2C bus (?)
  16  SCL       ... via R106 to VDD18  ;/
  17  VOL/M   wiper (sound volume, from I2C potentiometer) "VOL/MICDET?"
  18  MICBIAS   LIN-related-1 ... to 6pin U18
  19  MIC     LIN (aka MIC via C31)
  20  AUX1      LIN-related-2   ;\via 0ohm R108 to ... something on U18
  21  AUX2      LIN-related-2   ;/                     that is almost GND
  22  AVSS    GND
  23  AVDD    VDD33
  24  VBAT    GND
  ---
  25  VREF    VDD33
  26  TSVSS   GND
  27  YN      Y-                   ;\
  28  XN      X-                   ;
  29  DVSS    GND                  ; touchscreen input
  30  YP      Y+                   ;
  31  XP      X+                   ;/
  32  TSVDD   VDD33
  33  SPLN    SPLN                 ;\
  34  SLVSS   GND                  ;
  35  SLVDD   B+                   ; speaker output
  36  SPLP    SPLP                 ;
  ---                              ;
  37  SPRN    SPRN                 ;
  38  SRVDD   B+                   ;
  39  SRVSS   GND                  ;
  40  SPRP    SPRP                 ;/
  41  HPL     SL via CP2 and R88      ;\
  42  HVDD    VDD33                   ;
  43  HVSS    GND                     ; headphone output
  44  HPR     SR via CP3 and R89      ;
  45  GPI3    MUTE via Q4/Q5 to SR/SL ;
  46  GPI2    HP#SP switch            ;/
  47  GPI1    VCNT5
  48  /RESET  RESET
```



## DSi U5 - 256Mbyte eMMC NAND (14x14 grid)


```
       1    2    3    4    5    6    7    8    9    10   11   12   13   14
  o A  NC   NC   DAT0 DAT1 DAT2 NC   NC   NC   NC   NC   NC   NC   NC   NC
    B  NC   DAT3 DAT4 DAT5 DAT6 DAT7 NC   NC   NC   NC   NC   NC   NC   NC
    C  NC   VDDI NC   VSSQ NC   VCCQ NC   NC   NC   NC   NC   NC   NC   NC
    D  NC   NC   NC   NC   -    -    -    -    -    -    -    NC   NC   NC
    E  NC   NC   NC   -    NC   VCC  VSS  NC   NC   NC   -    NC   NC   NC
    F  NC   NC   NC   -    VCC  -    -    -    -    NC   -    NC   NC   NC
    G  NC   NC   NC   -    VSS  -    -    -    -    NC   -    NC   NC   NC
    H  NC   NC   NC   -    NC   -    -    -    -    VSS  -    NC   NC   NC
    J  NC   NC   NC   -    NC   -    -    -    -    VCC  -    NC   NC   NC
    K  NC   NC   NC   -    NC   NC   NC   VSS  VCC  NC   -    NC   NC   NC
    L  NC   NC   NC   -    -    -    -    -    -    -    -    NC   NC   NC
    M  NC   NC   NC   VCCQ CMD  CLK  NC   NC   NC   NC   NC   NC   NC   NC
    N  NC   VSSQ NC   VCCQ VSSQ NC   NC   NC   NC   NC   NC   NC   NC   NC
    P  NC   NC   VCCQ VSSQ VCCQ VSSQ NC   NC   NC   NC   NC   NC   NC   NC
```

Note: The pinout follows JEDEC's eMMC standard. The "NC" pins are GNDed in DSi,
the "DAT4..DAT7" pins are not connected in DSi. The "VDDI" pin isn't wired to
VDD, instead it goes to a capacitor (0.1uF min) "for internal power stability".



## DSi U6 - "BPTWL" - I2C bus(ses), LEDs, volume, power, wifi (6x6 grid)


```
       GND         WL_TXPE     P02(button) SDA'33      ADPO        GND       o
       ATH_TX_H    BLUE(LED)   RED(LED)    SCL'33      V33         GND
       YELLOW(LED) VOLP button VOLN button PM_SLP      V33'        /WIFI_RST
       SDA1        RESET       SCL1        to C46      GND         to U17
       VDD28       GND         CAM_LED     PWSWO       mFE         /mRST
       GND         AOUT        mFE'(R79)   WL_RXPE     /IRQ_O      GND
```



## DSi U7 - I2C bus potentiometer (ISL95810) (Device 50h)


```
  1  /WP (DSi: VDD33)  writeprotect
  2  SCL (DSi: SCL1)   i2c bus   ;\from U6
  3  SDA (DSi: SDA1)   i2c bus   ;/
  4  GND (DSi: GND)    ground
  5  RW  (DSi: wiper)  pot.wiper ;-to U4
  6  RL  (DSi: VDD18)  pot.L
  7  RH  (DSi: GND)    pot.H
  8  VCC (DSi: VDD33)  supply
```



## DSi U8 - bidirectional I2C voltage translator (PCA9306)


```
  1  GND   (DSi: GND)
  2  VREF1 (DSi: VDD18)
  3  SCL1  (DSi: SCL)     ;\to U1 (CPU)
  4  SDA1  (DSi: SDA)     ;/
  5  SDA2  (DSi: SDA'33)  ;\to U6 (LED/stuff)
  6  SCL2  (DSi: SCL'33)  ;/
  7  VREF2 (DSi: VDD33)
  8  EN    (DSi: VDD33)
```



## DSi U9 - RTC - Seiko S-35199A01 (4x3 grid)


```
       A    B    C    D
  3    CS   /SCK VDD  F32K
  2    SIO  CTRL /INT FOUT
  1 o  VSS  XIN  XOUT VDDL
```



## DSi U10 - Magnet Sensor (for hinge, aka shell opened/closed)


```
  1  VDD33
  2  R7 (HINGE)  ;to U1
  3  GND
  4  GND
```



## DSi U11 - charge


```
  1  EXTB+
  2  Rosc
  3  ORANGE (via R2)              ;-charge LED
  4  GND
  5  TH' (via R76 to TH)          ;\thermal sensor
  6  TH  (via R102 to DPAD board) ;/for battery?
  7  B+  (?)
  8  RICHG
  9  BT+
  10 BT+
```

Note: Seems to resemble Mitsumi MM3358 datasheet.



## DSi U12 - 5pin, VDD33 to VDD28 converter? (near upper screen socket)



## DSi U13 - 5pin, Backlight 1, near power managment chip



## DSi U14 - 5pin, Backlight 2, near power managment chip



## DSi U15 - 4pin, something near external power input



## DSi U16 - N/A



## DSi U17 - 6pin, something near headphone socket, connects to U6, and MUTE



## DSi U18 - 6pin, something near headphone socket, MIC/LIN related



## DSi U19 - 5pin, something near dpad socket


Smaller misc chips.



## DSi LEDs:


```
  CAM_LED (via R68 and Q13)  ;\
  BLUE    (via R21 and Q11)  ; from U6
  YELLOW  (via R22 and Q12)  ;/
  RED     (via R20)          ;-from U6 (or to U6 ?)
  ORANGE  (via R2)           ;-from U11
```



## DSi Wifi Daughterboard - MM3218 chip (same chip as in DS Lite)


```
  1  VDD18
  2  GND
  3  VDD18
  4  Antenna signal
  5  Antenna shield
  6  VDD18
  7  VDD18
  8  GND
  9  NC
  10 GND
  11 GND
  12 GND
  13 NC
  14 /RESET
  ---
  15 CCA    ... to DSi mainboard connector pin 36
  16 WL_TXPE
  17 WL_RXPE
  18 TRRDY  ... to DSi mainboard connector pin 46 !!!
  19 TRDATA ... to DSi mainboard connector pin 40
  20 VDD33
  21 TRCLK  ... to DSi mainboard connector pin 44
  22 GND
  23 MCLK   ... via nearby big component ... to DSi mainboard connector pin 47
  24 VDD18
  25 NC
  26 22MHz
  27 22MHz'
  28 ... to DSi mainboard connector pin 43 NC? (with cap to GND and via 0 ohm)
  ---
  29 VDD33
  30 via capacitor to VDD33
  31 via 1K2 + 120K to GND (aka via 121.2K to GND)
  32 VDD18
  33 VDD18
  34 BB_RF_SCLK   ... to DSi mainboard connector pin 41
  35 BB_RF_SDI    ... to DSi mainboard connector pin 39
  36 BB_RF_SDO    ... to DSi mainboard connector pin 37
  37 BBP_SCS      ... to DSi mainboard connector pin 35
  38 RF_SCS       ... to DSi mainboard connector pin 33
  39 GND
  40 VDD33
  41 RF_SLEEP     ... to DSi mainboard connector pin 31
  42 BBP_SLEEP    ... to DSi mainboard connector pin 29
  ---
  43 VDD18
  44 ... shortcut to MM3218.pin50, and via resistor to MM3218.pin46
  45 VDD33
  46 ... via resistor to MM3218.pin44+50
  47 ... to DSi mainboard connector pin 25 (via 0 ohm) (+cap) (NC in DSi)
  48 VDD33
  49 GND
  50 ... shortcut to MM3218.pin44, and via resistor to MM3218.pin46
  51 ... via resistor to GND
  52 VDD18
  53 NC
  54 NC
  55 NC
  56 NC
```



## DSi DWM-W015 Wifi Daughterboard - ROCm Atheros AR6002G-AC1B chip


```
   1     2     3     4     5     6     7    8    9     10    11    12    13
 A AGND  RF2   RF2   RF2   RF2   PDET  NC   NC   VDD18 VDD12 XTAL  XTAL  BT_CLK
         OUTN  OUTP  INP   INN                   BIAS  XTAL  I     O     OUT
 B RF5   AGND  VDD18 VDD12 VDD12 BIAS  NC   NC   VDD12 VDD12 VDD18 BT_   DVDD12
   INP         FE    LNA   BIAS  REF             D_SYN BB    XTAL  CLKEN
 C RF5   VDD12 -     -     AGND  AGND  AGND AGND AGND  -     -     GPIO  GPIO
   INN   FE                                                        17    16
 D PA5   NC    -     -     -     -     -    -    -     -     -     GPIO  GPIO
   BIAS                                                            14    15
 E RF5   VDD18 AGND  -     AGND  AGND  AGND AGND DVSS  -     -     DVDD  DVDD
   OUT   VCO                                                       GPIO1 GPIO0
 F VDD12 VDD12 AGND  -     AGND  AGND  AGND AGND DVSS  -     DVSS  GPIO  GPIO
   TX5   SYNTH                                                     12    13
 G XPA   XPA   AGND  -     AGND  AGND  AGND AGND DVSS  -     DVSS  GPIO  GPIIO
   BIAS2 BIAS5                                                     10    11
 H VCCFE LDO_  AGND  -     AGND  AGND  AGND AGND DVSS  -     DVSS  GPIO  DVDD
   M     OUT                                                       9     12
 J ANTA  VDDIO AGND  -     DVSS  DVSS  DVSS DVSS DVSS  -     DVSS  CLK_  DVDD
         ANT                                                       REQ   12
 K ANTC  ANTB  -     -     -     -     -    -    -     -     -     SYS_  CHIP_
                                                                   RST_L PWD_L
 L ANTD  ANTE  -     -     DVSS  DVSS  DVSS  DVSS DVSS -     -     DVDD  DVDD_
                                                                   12    SDIO
 M AGND  GPIO0 GPIO2 DVDD  GPIO4 GPIO6 GPIO8 JTAG JTAG JTAG  SDIO_ SDIO_ SDIO_
                     12                      TMS  TCK  TDO   DATA3 DATA2 CLK
 N DVDD  GPIO1 GPIO3 DVDD_ GPIO5 GPIO7 DVDD_ DVDD JTAG DVDD_ SDIO_ SDIO_ SDIO_
   12                BT                SDIO  12   TDI  SDIO  CMD   DATA1 DATA0
```



## DSi DWM-W024 Wifi Daughterboard - Atheros AR6013 chip


```
  1  1.2V
  2  VDD18
  3  NC
  4  NC
  5  VDD18
  6  NC
  7  1.2V
  8  VDD18
  9  1.2V
  10 NC
  11 NC (except, wired to tespoint)
  12 VDD33
  13 via 0 ohm to ATH_TX_H  ;<--with 0 ohm connection
  14 via (N/A) to ATH_TX_H  ;<--connection not installed
  15 to a dead-end-via
  16 to a dead-end-via
  17 1.2V
  18 P5.pin24       JTAG_TRST_L     (plus testpoint)
  19 NC (except, wired to tespoint)
  ---
  20 VDD18
  21 1.2V
  22 I2C.SCL
  23 I2C.SDA
  24 P5.pin21 RTC 32KHZ via 0 ohm
  25 /WIFI_RST
  26 ATH_TX_H
  27 SDKI.CMD
  28 SDIO.CLK
  29 VDD33
  30 SDIO.DAT0
  31 SDIO.DAT2
  32 SDIO.DAT1
  33 SDIO.DAT3
  34 P5.pin22       JTAG_TCK
  35 P5.pin20       JTAG_TDI
  36 P5.pin17       JTAG_TMS
  37 1.2V
  38 P5.pin15       JTAG_TDO
  ---
  39 P5.pin36       CCA
  40 VDD33
  41 1.2V
  42 P5.pin46       TRRDY
  43 P5.pin44       TRCLK
  44 P5.pin40       TRDATA
  45 WL_TXPE
  46 WL_RXPE
  47 P5.pin47       MCLK
  48 P5.pin33       RF_SCS      ... and 6.9ohm to P5.47 ?
  49 P5.pin35       BBP_SCS
  50 P5.pin39       BB_RF_SDI
  51 VDD33
  52 P5.pin37       BB_RF_SDO
  53 P5.pin41       BB_RF_SCLK
  54 P5.pin29       BBP_SLEEP
  55 P5.pin31       RF_SLEEP
  56 P5.pin26       SEL_ATH_L   ... IRQ?
  57 1.2V
  ---
  58 VDD18
  59 XTALx
  60 XTALx
  61 1.2V
  62 1.2V
  63 VDD18
  64 NC (except, wired to tespoint)
  65 NC (except, wired to tespoint)
  66 NC (except, wired to tespoint)
  67 NC (except, wired to tespoint)
  68 NC
  69 via 6.1K to GND
  70 1.2V
  71 NC
  72 NC
  73 VDD18
  74 RF2.OUTx
  75 RF2.OUTx
  76 VDD18
  ---
  GND center plates
```

Note: /RESET connects to Wifi FLASH only, ie. NOT to the MM3218 clone within
AR6013G (that's unlike as real MM3218).



## 3DS DWM-W028 Wifi Daughterboard - Atheros AR6014 chip


Pinouts unknown.


There is a 3rd part number, J27H020, made by hon hai (Foxconn) instead of
Mitsumi.




# <a name="pinoutscpusignalsummary"></a>Pinouts - CPU - Signal Summary




## Advance Gameboy CPU Signal Summary


Cart Bus: D0-D7, A0-A15, /CS, /RD, /WR (different usage in GBA/DMG mode)

WRAM Bus: WA0-WA16, WD0-WD15, /WLB, /WUB, /WWE, /WOE (used in GBA mode only)

LCD Bus : LDR1-5, LDG1-5, LDB1-5, DCK, LP, PS, SPL, CLS, SPS, MOD, REVC

Joypad: TP0-3 (Buttons), TP4-7 (Directions), TP8-9 (L/R-Buttons, via R43/R44)

Serial Link: SC, SD (aka P14?), SI, SO - Audio: SO1-2, Vin

Other: CK1-2, PHI, IN35, VCNT5, /FIQ (via CL1 to VDD3), /RESET (IN), /RES (OUT)

Supply: VDD35, VDD3, VDD2, GND (some are probably undoc inputs)

GBA SP: Same as GBA, plus VDD1, plus duplicated supply pins, plus pin 152.




# <a name="pinoutscpupinouts"></a>Pinouts - CPU - Pinouts




## Advance Gameboy CPU Pinouts (CPU AGB)


```
  1 VDD3  17 D0   33 A0    49 WA4   65 VDD2  81 WD9   97 LDB5   113 CK1
  2 IN35  18 A15  34 /CS   50 WA5   66 WD5   82 WD1   98 LDB4   114 CK2
  3 TP8   19 A14  35 /RD   51 WA6   67 WD13  83 /WOE  99 LDB3   115 VDD2
  4 TP0   20 A13  36 /WR   52 WA7   68 WD6   84 DCK   100 LDB2  116 GND
  5 TP1   21 A12  37 PHI   53 /WLB  69 WD14  85 LP    101 LDB1  117 VDD2
  6 SO1   22 A11  38 VDD35 54 /WUB  70 WD7   86 PS    102 GND   118 VCNT5
  7 SO2   23 A10  39 GND   55 /WWE  71 WD15  87 LDR5  103 VDD3  119 TP9
  8 Vin   24 A9   40 SC    56 WA8   72 WD8   88 LDR4  104 SPL   120 TP6
  9 /RES  25 A8   41 SD    57 WA9   73 WD16  89 LDR3  105 CLS   121 TP5
  10 D7   26 A7   42 SI    58 WA10  74 WA16  90 LDR2  106 SPS   122 TP7
  11 D6   27 A6   43 SO    59 WA11  75 WD12  91 LDR1  107 MOD   123 TP4
  12 D5   28 A5   44 VDD2  60 WA12  76 WD4   92 LDG5  108 REVC  124 /FIQ
  13 D4   29 A4   45 WA0   61 WA13  77 WD11  93 LDG4  109 GNDed 125 /RESET
  14 D3   30 A3   46 WA1   62 WA14  78 WD3   94 LDG3  110 GNDed 126 TP2
  15 D2   31 A2   47 WA2   63 WA15  79 WD10  95 LDG2  111 GNDed 127 TP3
  16 D1   32 A1   48 WA3   64 GND   80 WD2   96 LDG1  112 GNDed 128 GND
```



## GBA SP CPU Pinouts (CPU AGB B)


```
  1 IN35   21 D0    41 A0    61 WA4   81 WD13  101 GND   121 LDB4  141 GND
  2 TP8    22 A15   42 /CS   62 WA5   82 WD6   102 VDD1  122 LDB3  142 VDD3
  3 TP0    23 A14   43 /RD   63 WA6   83 WD14  103 GND   123 LDB2  143 GND
  4 TP1    24 A13   44 /WR   64 WA7   84 WD7   104 VDD3  124 LDB1  144 VCNT5
  5 SO1    25 A12   45 PHI   65 /WLB  85 WD15  105 DCK   125 GND   145 TP9
  6 SO2    26 A11   46 VDD35 66 /WUB  86 WD8   106 LP    126 VDD3  146 TP6
  7 Vin    27 GND   47 GND   67 GND   87 WD16  107 PS    127 SPL   147 TP5
  8 VDD1   28 VDD35 48 SC    68 VDD2  88 WA16  108 LDR5  128 CLS   148 TP7
  9 GND    29 A10   49 SD    69 /WWE  89 VDD2  109 LDR4  129 SPS   149 TP4
  10 VDD35 30 A9    50 SI    70 WA8   90 GND   110 LDR3  130 MOD   150 /FIQ
  11 /RES  31 A8    51 SO    71 WA9   91 WD12  111 LDR2  131 REVC  151 /RESET
  12 D7    32 A7    52 VDD35 72 WA10  92 WD4   112 LDR1  132 GND   152 ?
  13 D6    33 A6    53 GND   73 WA11  93 WD11  113 LDG5  133 GND   153 TP3
  14 D5    34 A5    54 VDD1  74 WA12  94 WD3   114 LDG4  134 GND   154 TP2
  15 D4    35 A4    55 GND   75 WA13  95 WD10  115 LDG3  135 GND   155 VDD3
  16 D3    36 GND   56 VDD2  76 WA14  96 WD2   116 LDG2  136 VDD1  156 GND
  17 D2    37 VDD35 57 WA0   77 WA15  97 WD9   117 LDG1  137 GND
  18 GND   38 A3    58 WA1   78 GND   98 WD1   118 GND   138 CK1
  19 VDD35 39 A2    59 WA2   79 VDD2  99 /WOE  119 VDD3  139 CK2
  20 D1    40 A1    60 WA3   80 WD5   100 VDD2 120 LDB5  140 VDD2
```

Pin 152 seems to be not connected on the mainboard, maybe an undoc output.



## GBA-Micro, NDS, NDS-Lite, and DSi CPU Pinouts


Unknown. The CPU Pins are hidden underneath of the CPU. And, in NDS and
NDS-Lite, the CPU itself hides underneath of the DS Cartridge Slot. In the DSi
it's hidden underneath of a shielding plate (which is itself underneath of the
removeable wifi daughterboard).




# <a name="pinoutsaudioamplifiers"></a>Pinouts - Audio Amplifiers




## Advance Gameboy Audio Amplifier (AMP AGB IR3R60N) (U6)


```
  1   2   3   4   5   6   7   8   9   10  11  12   13   14   15   16   17  18
  C38 FR1 FR2 FL1 FL2 GND RIN LIN C39 VOL SW  VDD5 LOUT VCC3 ROUT VCC3 SP  GND
```

SW=Headphone Switch (grounded when none connected).



## GBA SP Audio Amplifier (uses AMB AGB IR3R60N, too) (U3)


Same connection as in GBA, except that pin14/16 connect to VR21 (instead VCC3),
and pin1/9 connect to different capacitors.



## NDS - National Semiconductor LM4880M Dual 250mW Audio Power Amplifier (U12)


```
  1-OUT A  2-IN A  3-BYPASS  4-GND  5-SHUTDOWN  6-IN B  7-OUT A  8-VDD.VQ5
```

NDS-Lite: No external amplifier (Mitsumi 3205B Powermanagment Device contains
internal amplifier).




# <a name="pinoutslcdcables"></a>Pinouts - LCD Cables




## Advance Gameboy Display Socket


```
  1 ?     6 GND    11 LDR2   16 LDG2   21 LDB3   26 SPS     31 P2-VSS  36 V4
  2 VSHD  7 VSHD   12 LDR1   17 LDG1   22 LDB2   27 ?       32 P2-VCC  37 V3
  3 DCK   8 LDR5   13 LDG5   18 GND    23 LDB1   28 MOD     33 ?       38 V2
  4 LP    9 LDR4   14 LDG4   19 LDB5   24 SPL    29 VCOM    34 VDD5    39 V1
  5 PS    10 LDR3  15 LDG3   20 LDB4   25 CLS    30 P2-VEE  35 GND     40 V0
```



## GBA SP Display Socket


```
  1 VSHD 5 VSHD  9 LDR3   13 LDG4  17 GND   21 LDB2  25 SPS   29 P2VSS 33 U83
  2 DCK  6 GND   10 LDR2  14 LDG3  18 LDB5  22 LDB1  26 MOD   30 COM   34 VDD5
  3 LP   7 LDR5  11 LDR1  15 LDG2  19 LDB4  23 SPL   27 REVC  31 VDD5
  4 PS   8 LDR4  12 LDG5  16 LDG1  20 LDB3  24 CLS   28 P2VDD 32 GND
```



## GBA Micro Display Sockets


```
  __GBA Mirco display socket (P1)____________________________________
  1-PS    6-5bit  11-MD    16-5bit  21-5bit  26-CL             31-GND
  2-RV    7-5bit  12-SL    17-5bit  22-5bit  27-SS             32-GND
  3-GND   8-5bit  13-CK    18-5bit  23-5bit  28-via C5 to VR1  33-V10
  4-5bit  9-LP    14-GND   19-5bit  24-5bit  29-V5             34-V-5
  5-5bit  10-VD   15-5bit  20-GND   25-5bit  30-to VR1
  __GBA Mirco backlight socket (P3)__________________________________
  1-LC  2-LC  3-LA  4-LA
```



## NDS Upper/Lower Display Sockets


```
  ___NDS upper screen/upper backlight/speakers socket (P3)_____________________
  1-SPLO 7-PS2   13-LDR2  19-GND   25-LDG2  31-LDB2  37-MOD2  43-VDD15  49-SPRO
  2-SPLO 8-REV2  14-LDR1  20-DCLK2 26-LDG1  32-LDB1  38-GND   44-VDD-5  50-GND
  3-SSC2 9-GND   15-LDR0  21-GND   27-LDG0  33-LDB0  39-VDD5  45-VDD-10 51-GND
  4-ASC2 10-LDR5 16-LS2   22-LDG5  28-LDB5  34-GCK2  40-VDD10 46-LEDC2
  5-GND  11-LDR4 17-VSHD  23-LDG4  29-LDB4  35-GSP2  41-COM2  47-LEDA2
  6-SPL2 12-LDR3 18-DISP1 24-LDG3  30-LDB3  36-GND   42-GND   48-SPRO
  ___NDS lower screen socket (P4)______________________________________________
  1-SSC1 6-REV1  11-LDR2  16-DISP0 21-LDG4  26-LDB5  31-LDB0  36-GND  41-VDD15
  2-ASC1 7-GND   12-LDR1  17-SPL1  22-LDG3  27-LDB4  32-GCK1  37-?    42-VDD10
  3-GND  8-LDR5  13-LDR0  18-DCLK1 23-LDG2  28-LDB3  33-GSP1  38-VDD5 43-GND
  4-?    9-LDR4  14-LS1   19-GND   24-LDG1  29-LDB2  34-VSHD  39-COM1 44-VDD-5
  5-PS1  10-LDR3 15-VSHD  20-LDG5  25-LDG0  30-LDB1  35-MOD1  40-GND  45-VDD-10
  ___NDS lower backlight socket (P5)____   ___NDS touchscreen socket (P6)______
  1:LEDA1  2:LEDA1  3:LEDC1  4:LEDC1       1:Y-    2:X-    3:Y+    4:X+
```



## NDS-Lite Upper/Lower Display Sockets


```
  ___NDS-Lite upper screen/upper backlight/speakers socket (P3)________________
  1-VDD-5 6-MOD    11-LD2xx 16-LD2xx 21-LD2xx 26-LD2xx 31-LS   36-GND   41-SPRO
  2-VDD10 7-GSP    12-LD2xx 17-LD2xx 22-LD2xx 27-LD2xx 32-VSHD 37-COM2  42-SG
  3-VDD5  8-GCK    13-LD2xx 18-GND   23-LD2xx 28-GND   33-GND  38-LEDA2 43-SG
  4-GND   9-LD2xx  14-LD2xx 19-LD2xx 24-LD2xx 29-DCLK  34-xx2? 39-LEDC2 44-SPLO
  5-VSHD  10-LD2xx 15-LD2xx 20-LD2xx 25-LD2xx 30-SPL   35-REV  40-SPRO  45-SPLO
  ___NDS-Lite lower screen/lower backlight (P4)________________________________
  1-VDD-5 6-MOD    11-LD1xx 16-LD1xx 21-LD1xx 26-LD1xx 31-LS   36-GND
  2-VDD10 7-GSP    12-LD1xx 17-LD1xx 22-LD1xx 27-LD1xx 32-VSHD 37-COM1
  3-VDD5  8-GCK    13-LD1xx 18-GND   23-LD1xx 28-GND   33-GND  38-LEDA1
  4-GND   9-LD1xx  14-LD1xx 19-LD1xx 24-LD1xx 29-DCLK  34-xx1? 39-LEDC1
  5-VSHD  10-LD1xx 15-LD1xx 20-LD1xx 25-LD1xx 30-SPL   35-REV
  ___NDS-Lite touchscreen socket (P6)______   ___NDS-Lite white coax (P12)_____
  1:X-  2:Y-  3:X+  4:Y+                      Center:MICIN  Shield:GND
```




# <a name="pinoutspowerswitchesdcdcconvertersresetgenerators"></a>Pinouts - Power Switches, DC/DC Converters, Reset Generators




## Advance Gameboy Power Switch (2-position slider, with two common pins)



## GBA SP Power Switch (same as GBA)


```
  1 via resistor to GND (OFF)
  2 VS (BT+) (ON)
  C VCC (to board)
```



## GBA Micro Power Switch


Same as GBA and GBA SP, but Pin 1 and 2 exchanged.



## Advance Gameboy Cartridge Slot Switch (integrated 4pin micro switch)



## GBA SP Cartridge Slot Switch (separate 4pin micro switch)


```
  C1 VDD35  (to S2 when PRESSED, to S1 when RELEASED)
  S1 VDD3   (to C2 when PRESSED, to C1 when RELEASED)
  C2 IN35   (to S1 when PRESSED)
  S2 VDD5   (to C1 when PRESSED)
```

Pressed=8bit DMG/MGB/CGB cart, Released=32bit GBA cart (or no cart inserted)

GBA: switch integrated in cart socket, GBA-SP: separate switch next to socket.



## Advance Gameboy Power Controller (M 121 514X) (U4)


```
  1-VIN    2-VOUT5  3-CSS5    4-VDRV5  5-GND    6-VDRV3    7-CSS3    8-VOUT3
  9-VCNT5  10-CSCP  11-REGEXT 12-VDD3  13-VDD2  14-/RESET  15-LOWBAT 16-VDD13
```

/RESET is passed to the CPU, and then forwarded to /RES pin on cart slot.



## Advance Gameboy LCD Regulator (AGB-REG IR3E09N) (U3)


```
  1  2  3    4      5   6   7   8   9   10   11  12  13  14  15  16   17     18
  ?  ?  REVC U3-COM V0  V1  ?   ?   ?   GND  ?   V2  ?   V3  V4  VDD5 U3-VDD ?
```



## GBA SP Power Controller 1 (S6403 AU227 9276) (U4)


```
  1-VCC    2-SCP1   3-SCP2 4-VDRV3 5-VOUT3/VDD3 6-VDD2  7-VOUT1/VDD1  8-VDRV1
  9-LOWBAT 10-VCNT5 11-LS5 12-?    13-GND       14-?    15-VOUT5/VDD5 16-VDRV5
```



## GBA SP Power Controller 2 (2253B 2808) (U5)


```
  1-TIN     2-U5C3     3-ADJ  4-U5VDD  5-VIN   6-?    7-U57  8-?
  9-to-C29  10-to-C30  11-?   12-GND   13-VS   14-S-  15-S+  16-U5OUT
```



## GBA Micro - Power Managment Device (U2)


- 1 via C43 to GND
- 2 via R24 to C34 to R25 back to U2.2
- 3 via C35 to GND
- 4 via C36 to GND
- 5
- 6 audio.in ? (see BP)
- 7   via C48 to GND
- 8   via R21 to C46 to C47 to C38 to R23 to phones
- 9  VL (to U4)
- 10  via R27 to C33 to C44 to C49 to R22 to phones
- 11  via C45 to GND
- 12 audio.in ? (see BP)
- 13  via C41 to GND
- 14 phones (switch)
- 15 phones (tip via R22)
- 16 phones (mid via R23)
- 17 VCS
- 18 SP
- 19 GND
- 20 LB
- 21 via C52 to GND
- 22 via C53 to GND
- 23 RS         (looks like RESET output)
- 24 to R37/C56 (looks like RESET input)
- 25
- 26
- 27 via C54 to V3
- 28 V3
- 29 GND
- 30 V3
- 31 VC
- 32 to C58
- 33 to R41/C58
- 34 GND
- 35
- 36 VC
- 37 VC
- 38
- 39 V5
- 40 GND
- 41 GND
- 42
- 43
- 44
- 45 B+
- 46 S-
- 47 S+
- 48



## GBA Micro - Volume/Backlight Level Up/Down Controller (U5)


```
  1-     5-GND  9-      13-XD      17-     21-     25-    29-
  2-     6-GND  10-     14-to U4.7 18-XR   22-CN   26-    30-
  3-     7-     11-XC   15-        19-V+   23-CNS  27-    31-BP
  4-LN   8-     12-GND  16-        20-V-   24-     28-V3  32-
```



## NDS Powermanagment Device (Mitsumi 3152A) (U3)


```
  1 R50-EXTB+        17               33 LEDC1           49 VCNT5
  2 R39-ORANGE       18               34 GND             50
  3 GND              19 VQ5           35 LEDC2           51 RST
  4                  20               36                 52
  5 Rxx-Q4           21               37 U10-LEDA2       53
  6 INS+             22 GND           38                 54
  7 INS-             23 VQ5           39 MIC.C53-AIN     55 VQ5
  8                  24               40 MIC.TSC.AUX     56 R24-SR
  9 VDET             25 VDD3.3        41 GND             57
  10 PVDD            26 GND           42 R38-RED         58 R22-SL
  11                 27 CL60-VDD3.3   43 R37-GREEN       59 GND
  12 PWSW            28 VSHD          44 VDD3.3          60 VR3.PIN2
  13                 29               45 PWM.SPI.CLK     61
  14 GND             30 VDD5          46 PWM.SPI.D       62
  15 GND             31 U9-LEDA1      47 PWM.SPI.Q       63
  16 VQ5             32               48 PWM.SPI.SEL     64 GND
```



## NDS-LITE Powermanagment Device (Mitsumi 3205B) (U3)


```
  1 SW               17               33 LEDC1           49 VCNT5
  2 R50-EXTB+        18               34 GND             50
  3 R39-ORANGE       19 VQ5           35 LEDC2           51 RST
  4 GND              20               36                 52
  5                  21               37 U10-LEDA2       53
  6 R30-Q4           22 GND           38                 54
  7 INS+             23 VQ5           39 MIC.C53-AIN     55 CL63-VQ5
  8 INS-             24               40 MIC.TSC.AUX     56 R24-SR
  9 VDET             25 VDD3.3        41 GND             57 SPRO
  10 PVDD            26 GND           42 R38-RED         58 SPLO
  11                 27 CL60-VDD3.3   43 R37-GREEN       59 R22-SL
  12 PWSW            28 VSHD          44 VDD3.3          60 GND
  13 GND             29               45 PWM.SPI.CLK     61 R79-VR3.PIN2
  14 GND             30 VDD5          46 PWM.SPI.D       62
  15 GND             31 U9-LEDA1      47 PWM.SPI.Q       63
  16 VQ5             32               48 PWM.SPI.SEL     64
```



## NDS-LITE Power Switch


```
  1 PWSW (grounded when switch is pulled)
  2 GND
  3 GND
  4 NC? (grounded when switch is not pulled)
```




# <a name="pinoutswifi"></a>Pinouts - Wifi




## NDS RFU Daughter Board (Firmware FLASH, Wifi BB/RF Chips)


```
  1 N/A      6 FMW.CLK    11 ENABLE 16 RX.DTA? 21 BB./CS     26 22MHz   31 GND
  2 GND      7 FMW./SEL   12 GND    17 TX.MAIN 22 RF./CS     27 GND     32 GND
  3 high?    8 FMW.DTA.Q  13 GND    18 GND     23 BB.RF.CLK  28 VDD3.3  33 GND
  4 RXTX.ON  9 FMW.DTA.D  14 TX.ON  19 TX.CLK  24 BB.RF.RD   29 VDD1.8
  5 FMW./WP  10 FMW./RES  15 RX.ON  20 TX.DTA  25 BB.RF.WR   30 GND
```



## NDS-Lite RFU Daughter Board DWM-W006 (Firmware FLASH, Wifi BB/RF Chip)


```
  1 GND      6 GND       11 BB.RF.WR  16 VDD3.3   21 RF.SLEEP  26 FMW.Q
  2 TXPE     7 TRCLK     12 BB.RF.CLK 17 GND      22 FMW./RES  27 FMW./WP
  3 RXPE     8 TRDATA    13 GND       18 RF./CS   23 GND       28 FMW./CS
  4 CCA      9 GND       14 MCLK      19 BB.SLEEP 24 FMW.CLK   29 LD  ;hi?
  5 TRRDY    10 BB.RF.RD 15 GND       20 BB./CS   25 FMW.D     30 GND
```

- [https://fccid.io/EW4DWMW006/Label/ID-label-format-and-location-706511.pdf](https://fccid.io/EW4DWMW006/Label/ID-label-format-and-location-706511.pdf)


## Wifi RF Chip: RF9008, 0441, E0121Q (32 pin)


```
  1       5       9       13      17         21 RF.CLK  25        29
  2       6       10      14 GND  18         22         26        30
  3       7       11      15      19 RF.RD   23         27        31
  4       8       12      16      20 RF./CS  24         28        32
```

Pin19 RF.RD (oops, should be WR, maybe I've exchanged RD-WR?)

Pin20 RF./CS (via 10ohm)

Pin21 RF.CLK (via 10ohm)

Resembles RF2958 datasheet...?



## Wifi BB Chip: Mitsumi, Japan, 4418, MM3155 (48 pins)


```
  1 GND   7       13 GND     19      25       31         37 TX.MAIN 43
  2       8       14         20      26       32 BB./CS  38 RX.DTA? 44
  3       9       15 BB.CLK  21      27       33 TX.DTA  39 RX.ON   45 GND
  4       10      16 BB.WR   22      28 RST   34 RXTX.ON 40 TX.ON   46
  5       11      17 BB.RD   23      29       35 TX.CLK  41         47
  6       12      18 22MHz   24      30       36         42         48
```

Pin15 BB.CLK (via 10ohm to RFU.23)

Pin16 BB.WR (RFU.25)

Pin17 BB.RD (RFU.24)

Pin18 22MHz (via 50ohm)

Pin28 RST (same as FMW./RES)

Pin32 BB./CS (RFU.21)

The chip is roughly resembling HSP3824/HFA3824A/HFA3860A/HFA3860B (though
pinout and registers aren't compatible).



## NDS-LITE BB/RF-Chip Mitsumi MM3218 (56 pins)


```
  1-VDD18 8-GND   15-CCA    22-GND   29-VDD33     36-BBRF_SDO 43-VDD18 50-
  2-GND   9-NC    16-TXPE   23-MCLK  30-          37-BB_SCS   44-...   51-
  3-VDD18 10-GND  17-RXPE   24-VDD18 31-          38-RF_SCS   45-VDD33 52-VDD18
  4-Ant   11-GND  18-TRRDY  25-NC    32-VDD18     39-GND      46-...   53-NC
  5-Ant'  12-GND  19-TRDATA 26-22MHz 33-VDD18     40-VDD33    47-...   54-NC
  6-VDD18 13-NC   20-VDD33  27-22MHz 34-BBRF_SCLK 41-RF_SLEEP 48-VDD33 55-NC
  7-VDD18 14-/RES 21-TRCLK  28-      35-BBRF_SDI  42-BB_SLEEP 49-GND   56-NC
```

Note: Pinout should be same as in DSi (see DSi pinout for details).



## TX Signal/Timing Chart (Host Game)


```
  RX.DTA?  __________________________________________________________
  RXTX.ON  __-----------------------_________________________________
  RX.ON    __---_______-------------_________________________________
  TX.ON    _____-------______________________________________________
  TX.MAIN  ________----______________________________________________
  TX.CLK   _____#__####______________________________________________
  TX.DTA   _____#__####______________________________________________
```

This example shows a host sending beacons. The pre-beacon receive period is
probably to sense conflicts with other transmitters. The post-beacon receive
period is to get responses from other players. The two transmit parts are: The
hardware header, followed by inactivity on the tx pins during the rest of the
preamble period, then followed by the actual IEEE frame. The rest of the time
is spent in idle mode to reduce power consumption.



## RX Signal/Timing Chart (Join Game)


```
  RX.DTA?  __________________________________________________________
  RXTX.ON  -----------------------------------------------______-----
  RX.ON    -----------------------------------------------_________--
  TX.ON    __________________________________________________________
  TX.MAIN  __________________________________________________________
  TX.CLK   __________________________________________________________
  TX.DTA   _______________________________________________---________
```

This example shows a client trying to receive beacons, so most of the time is
spent in receive mode (the short idle periods are probably occuring when it is
switching to another channel). Once when it has associated with a host, the
client may spend more time in idle mode, and needs to be in receive mode only
when expecting to receive beacons or other data.




# <a name="pinoutsvarious"></a>Pinouts - Various




## Advance Gameboy 256Kbytes RAM 128Kx16bit (NEC D442012LGY-B85x-MJH) (wide)



## GBA SP 256Kbytes RAM 128Kx16bit (F 82D12160-10FN) (square)


```
  1 A15   7 A9    13 IC    19 A6   25 A0   31 D2   37 VCC  43 D15
  2 A14   8 A8    14 /UB   20 A5   26 /CE1 32 D10  38 D5   44 D8
  3 A13   9 NC    15 /LB   21 A4   27 GND  33 D3   39 D13  45 D16
  4 A12   10 NC   16 NC    22 A3   28 /OE  34 D11  40 D6   46 GND
  5 A11   11 /WE  17 NC    23 A2   29 D1   35 D4   41 D14  47 NC
  6 A10   12 CE2  18 A7    24 A1   30 D9   36 D12  42 D7   48 A16
```

Connection in GBA and GBA SP: IC-GND, /CE1-GND, CE2-VDD2, VCC-VDD2, Pin16-VDD2,
the other NC pins seem to be actually not connected, all other pins connect to
the corresponding Wxx CPU pins. Note: Both GBA and GBA SP have soldering points
for wide (12x18mm) and square (12x14mm) RAMs, so either could be used.

The GBA additionally contains 32K built-in WRAM, and built-in VRAM, so the
above 256K RAM chip is probably not used in 8bit classic/color gameboy mode.

Note: In the GBA Micro, the 256K RAM are contained on-chip in the CPU.



## Advance Gameboy Schematic Fragments


P2-VSS = VDD-15

VIN = VCC3 via R33

REGEXT (on my modified board, REGEXT underneath of my diodes)

/RES (OUT) (via R40)

/CS (via R39)

/WR (via R38)

SC (via Rxx)

SD (via Rxx)

SI (via Rxx)

SO (via Rxx)

DCK (via R36)

A-GND via CP4 (100uF) to GND (used speaker, and on headphone socket)



## GBA SP Schematic Fragments


P2VDD = VDD13

P2VSS = VDD15

/RES via R46

/CS via R45

/WR via R44

DCK via R20

VS=BT+

In my repaired GBA-SP: CK1 test-point is disconnected (instead GND'ed).

In my repaired GBA-SP: broken oscillator replaced

In my repaired GBA-SP: broken r1 1mOhm replaced (near oscillator)

In my repaired GBA-SP: broken EXT2 socket metal-spring/snapper removed

CL1 FIQ (near SW4)

CL2 ?

CL3 ?

CL4 VOUT1/VDD1 (near U4)

CL5 VOUT3/VDD3 (near U4)

CL6 VOUT5/VDD5 (near U4)

DL1-red (power low) ---R32--Q4--R6--

DL2-green (power good) ---Q6--LOWBAT/R34-VDD3

DL3-orange (charge) --R24--Q2--VIN/U57

P2VDD--VDD13

P2VSS--VDD15

S+ and S- are (almost) shortcut by R23 (1.0 ohm)

S+ via Q1 to VIN

VS via D1 to S-

A-GND via CP1 (100uF) to GND

U4 pin 12 to r6 (towards red led)

U4 pin 14 to D6---to U7

SC (CPU pin48) with R7 100K ohm pullup to VDD35

P35 via Q11 to SW (speaker disable)



## GBA SP Backlight-Button Schematic (U6,U8,Q12)


```
        ______                _____
  GND--|1 U8 6|-- U85        |     |--VDD5
  U82--|2    5|-- U85    U61-| Q12 |         U83  ------> to display
  U83--|3____4|-- U82        |_____|--Q12B   Q12B <------ from button
  U61--|1 U6 8|--VDD5    (X)---R51--VDD5    (X)---C70--GND
  U62--|2    7|--VDD5    U62---R49--VDD5    U61---R40--GND
  U62--|3    6|--(X)     Q12B--R39--VDD5    U82---R38--GND
  GND--|4____5|--NC?     Q12B--C69--VDD5    U85---R50--U62
```




# <a name="auxxboopctogbamultibootcable"></a>AUX Xboo PC-to-GBA Multiboot Cable



Below describes how to connect a PC parallel port to the GBA link port,
allowing to upload small programs (max 256 KBytes) from no$gba's Utility menu
into real GBAs.


This is possible because the GBA BIOS includes a built-in function for
downloading & executing program code even when no cartridge is inserted.
The program is loaded to 2000000h and up in GBA memory, and must contain
cartridge header information just as for normal ROM cartridges (nintendo logo,
checksum, etc., plus some additional multiboot info).



## Basic Cable Connection


The general connection is very simple (only needs four wires), the only problem
is that you need a special GBA plug or otherwise need to solder wires directly
to the GBA mainboard (see Examples below).

```
  GBA  Name  Color                 SUBD CNTR Name
  2    SO    Red     ------------- 10   10   /ACK
  3    SI    Orange  ------------- 14   14   /AUTOLF
  5    SC    Green   ------------- 1    1    /STROBE
  6    GND   Blue    ------------- 19   19   GND
```

Optionally, also connect the following signals (see notes below):

```
  4    SD    Brown   ------------- 17   36   /SELECT  (double speed burst)
  3    SI    Orange  ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  5    SC    Green   ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  4    SD    Brown   ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  START  (mainboard) -----|>|----- 16   31   /INIT    (auto-reset, 1N4148)
  SELECT (mainboard) -----|>|----- 16   31   /INIT    (auto-reset, 1N4148)
  RESET  (mainboard) -----||------ 16   31   /INIT    (auto-reset, 300nF)
```

Notes: The GBA Pins are arranged from left to right as 2,4,6 in upper row, and
1,3,5 in lower row; outside view of GBA socket; flat side of socket upside. The
above "Colors" are as used in most or all standard Nintendo link cables, note
that Red/Orange will be exchanged at one end in cables with crossed SO/SI
lines. At the PC side, use the SUBD pin numbers when connecting to a 25-pin
SUBD plug, or CNTR pin numbers for 36-pin Centronics plug.



## Optional SD Connection (Double Speed Burst)


The SD line is used for Double Speed Burst transfers only, in case that you are
using a gameboy link plug for the connection, and if that plug does not have a
SD-pin (such like from older 8bit gameboy cables), then you may leave out this
connection. Burst Boot will then only work half as fast though.



## Optional Pull-Ups (Improves Low-to-High Transition Speed)


If your parallel port works only with medium or slow delay settings, try to
connect 560 Ohm resistors to SI/SC/SD inputs each, and the other resistor pin
to any or all of the parallel port data lines (no$gba outputs high to pins
2..9).



## Optional Reset Connection (CAUTION: Connection changed September 2004)


The Reset connection allows to automatically reset & upload data even if a
program in the GBA has locked up (or if you've loaded a program that does not
support nocash burst boot), without having to reset the GBA manually by
switching it off and on (and without having to press Start+Select if a
cartridge is inserted).

The two diodes should be 1N4148 or similar, the capacitor should be 300nF (eg.
three 100nF capacitors in parallel). The signals are labeled on the mainboard,
and can be found at following names / CPU pin numbers: RESET/CPU.125,
SELECT/TP2/CPU.126, START/TP3/CPU.127.



## Optional Power Supply Connection


Also, you may want to connect the power supply to parallel port data lines, see
chapter Power Supply for details.



## Transmission Speed


The first transfer will be very slow, and the GBA BIOS will display the boot
logo for at least 4 seconds, even if the transfer has completed in less time.
Once when you have uploaded a program with burst boot backdoor, further
transfers will be ways faster. The table below shows transfer times for 0KByte
- 256KByte files:

```
  Boot Mode_____Delay 0_______Delay 1_______Delay 2_____
  Double Burst  0.1s - 1.8s   0.1s - 3.7s   0.1s - 5.3s
  Single Burst  0.1s - 3.6s   0.1s - 7.1s   0.1s - 10.6s
  Normal Bios   4.0s - 9.0s   4.0s - 12.7s  4.0s - 16.3s
```

All timings measured on a 66MHz computer, best possible transmission speed
should be 150KBytes/second. Timings might slightly vary depending on the CPU
speed and/or operating system. Synchronization is done by I/O waitstates, that
should work even on faster computers. Non-zero delays are eventually required
for cables without pull-ups.



## Requirements


Beside for the cable and plugs, no special requirements.

The cable should work with all parallel ports, including old-fashioned
one-directional printer ports, as well as modern bi-directional EPP ports.
Transfer timings should work stable regardless of the PCs CPU speed (see above
though), and regardless of multitasking interruptions.

Both no$gba and the actual transmission procedure are using some 32bit code, so
that either one currently requires 80386SX CPUs or above.



## Connection Examples


As far as I can imagine, there are four possible methods how to connect the
cable to the GBA. The first two methods don't require to open the GBA, and the
other methods also allow to connect optional power supply and reset signal.

```
  1) Connect it to the GBA link port. Advantage: No need to
     open/modify the GBA. Disadvantage: You need a special plug,
     (typically gained by removing it from a gameboy link cable).
  2) Solder the cable directly to the GBA link port pins. Advantages:
     No plug required & no need to open the GBA. Disadvantages:
     You can't remove the cable, and the link port becomes unusable.
  3) Solder the cable directly to the GBA mainboard. Advantage: No
     plug required at the GBA side. Disadvantage: You'll always
     have a cable leaping out of the GBA even when not using it,
     unless you put a small standard plug between GBA and cable.
  4) Install a Centronics socket in the GBA (between power switch
     and headphone socket). Advantage: You can use a standard
     printer cable. Disadvantages: You need to cut a big hole into
     the GBAs battery box (which cannot be used anymore), the big
     cable might be a bit uncomfortable when holding the GBA.
```

Personally, I've decided to use the lastmost method as I don't like ending up
with hundreds of special cables for different purposes, and asides, it's been
fun to damage the GAB as much as possible.



## Note


The above used PC parallel port signals are typically using 5V=HIGH while GBA
link ports deal with 3V=HIGH. From my experiences, the different voltages do
not cause communication problems (and do not damage the GBA and/or PC
hardware), and after all real men don't care about a handful of volts, however,
use at own risk.




# <a name="auxxbooflashcardupload"></a>AUX Xboo Flashcard Upload




## Flashcard Upload


Allows to write data to flashcards which are plugged into GBA cartridge slot,
cartridge is automatically started after writing. On initial power-up, hold
down START+SELECT to prevent the GBA from booting the old program in the
flashcard.

The Upload function in Utility menu uses flashcard mode for files bigger than
256KB (otherwise uses multiboot mode automatically). Also, there's a separate
Upload to Flashcard function in Remote Access submenu, allowing to write files
of 256KB or less to flashcard if that should be desired.



## Supported Flashcards


Function currently tested with Visoly Flash Advance (FA) 256Mbit (32MB) Turbo
cartridge. Should also work with older FA versions. Please let me know if you
are using other flashcards which aren't yet supported.



## Flashcard Performance


Writing to flashcards may become potentially slow because of chip erase/write
times, cable transmission time, and the sheer size of larger ROM-images.
However, developers whom are testing different builts of their project usually
won't need to rewrite the complete flashcard, Xboo uses a highspeed checksum
mechanism (16MB/sec) to determine which flashcard sector(s) have changed, and
does then re-write only these sector(s).

To eliminate transmission time, data transfer takes place in the erase phases.
Erase/write time depends on the flashcard type, should be circa 1-2 seconds per
256KB sector. Because the cartridge is programmed directly in the GBA there's
no need to remove it from the GBA when writing to it.



## Developers Advice


Locate your program fragments at fixed addresses, for example, code and data
blocks each aligned to 64K memory boundaries, so that data remains at the same
location even when the size of code changes. Fill any blank spaces by value FFh
for faster write time. Reduce the size of your ROM-image by efficient memory
use (except for above alignment trick). Include the burst boot backdoor in your
program, allowing to re-write the flashcard directly without resetting the GBA.



## Lamers Advice


Xboo Flashcard support does not mean to get lame & to drop normal multiboot
support, if your program fits into 256KB then make it \<both> flashcard
\<and> multiboot compatible - multiboot reduces upload time, increases
your flashcard lifetime, and will also work for people whom don't own
flashcards.




# <a name="auxxbooburstbootbackdoor"></a>AUX Xboo Burst Boot Backdoor



When writing Xboo compatible programs, always include a burst boot "backdoor",
this will allow yourself (and other people) to upload programs much faster as
when using the normal GBA BIOS multiboot function. Aside from the improved
transmission speed, there's no need to reset the GBA each time (eventually
manually if you do not have reset connect), without having to press
Start+Select (if cartridge inserted), and, most important, the time-consuming
nintendo-logo intro is bypassed.



## The Burst Boot Protocol


In your programs IRQ handler, add some code that watches out for burst boot IRQ
requests. When sensing a burst boot request, download the actual boot
procedure, and pass control to that procedure.

```
  Send (PC)    Reply (GBA)
  "BRST"       "BOOT"        ;request burst, and reply <prepared> for boot
  <wait 1/16s> <process IRQ> ;long delay, allow slave to enter IRQ handler
  llllllll     "OKAY"        ;send length in bytes, reply <ready> to boot
  dddddddd     --------      ;send data in 32bit units, reply don't care
  cccccccc     cccccccc      ;exchange crc (all data units added together)
```

Use normal mode, 32bit, external clock for all transfers. The received
highspeed loader (currently approx. 180h bytes) is to be loaded to and started
at 3000000h, which will then handle the actual download operation.


Below is an example program which works with multiboot, burstboot, and as
normal rom/flashcard. The source can be assembled with a22i (the no$gba
built-in assembler, see no$gba utility menu). When using other/mainstream
assemblers, you'll eventually have to change some directives, convert numbers
from NNNh into 0xNNN format, and define the origin somewhere in linker/makefile
instead of in source code.


```
 .arm            ;select 32bit ARM instruction set
 .gba            ;indicate that it's a gameboy advance program
 .fix            ;automatically fix the cartridge header checksum
 org 2000000h    ;origin in RAM for multiboot-cable/no$gba-cutdown programs
 ;------------------
 ;cartridge header/multiboot header
  b     rom_start                ;-rom entry point
  dcb   ...insert logo here...   ;-nintento logo (156 bytes)
  dcb   'XBOO SAMPLE '           ;-title (12 bytes)
  dcb   0,0,0,0,  0,0            ;-game code (4 bytes), maker code (2 bytes)
  dcb   96h,0,0                  ;-fixed value 96h, main unit code, device type
  dcb   0,0,0,0,0,0,0            ;-reserved (7 bytes)
  dcb   0                        ;-software version number
  dcb   0                        ;-header checksum (set by .fix)
  dcb   0,0                      ;-reserved (2 bytes)
  b     ram_start                ;-multiboot ram entry point
  dcb   0,0                      ;-multiboot reserved bytes (destroyed by BIOS)
  dcb   0,0                      ;-blank padded (32bit alignment)
 ;------------------
 irq_handler:  ;interrupt handler (note: r0-r3 are pushed by BIOS)
  mov    r1,4000000h             ;\get I/O base address,
  ldr    r0,[r1,200h] ;IE/IF     ; read IE and IF,
  and    r0,r0,r0,lsr 16         ; isolate occurred AND enabled irqs,
  add    r3,r1,200h   ;IF        ; and acknowledge these in IF
  strh   r0,[r3,2]               ;/
  ldrh   r3,[r1,-8]              ;\mix up with BIOS irq flags at 3007FF8h,
  orr    r3,r3,r0                ; aka mirrored at 3FFFFF8h, this is required
  strh   r3,[r1,-8]              ;/when using the (VBlank-)IntrWait functions
  and    r3,r0,80h ;IE/IF.7 SIO  ;\
  cmp    r3,80h                  ; check if it's a burst boot interrupt
  ldreq  r2,[r1,120h] ;SIODATA32 ; (if interrupt caused by serial transfer,
  ldreq  r3,[msg_brst]           ; and if received data is "BRST",
  cmpeq  r2,r3                   ; then jump to burst boot)
  beq    burst_boot              ;/
  ;... insert your own interrupt handler code here ...
  bx     lr                      ;-return to the BIOS interrupt handler
 ;------------------
 burst_boot:     ;requires incoming r1=4000000h
  ;... if your program uses DMA, disable any active DMA transfers here ...
  ldr   r4,[msg_okay]            ;\
  bl    sio_transfer             ; receive transfer length/bytes & reply "OKAY"
  mov   r2,r0 ;len               ;/
  mov   r3,3000000h   ;dst       ;\
  mov   r4,0  ;crc               ;
 @@lop:                          ;
  bl    sio_transfer             ; download burst loader to 3000000h and up
  stmia [r3]!,r0      ;dst       ;
  add   r4,r4,r0      ;crc       ;
  subs  r2,r2,4       ;len       ;
  bhi   @@lop                    ;/
  bl    sio_transfer             ;-send crc value to master
  b     3000000h  ;ARM state!    ;-launch actual transfer / start the loader
 ;------------------
 sio_transfer:  ;serial transfer subroutine, 32bit normal mode, external clock
  str   r4,[r1,120h]  ;siodata32 ;-set reply/send data
  ldr   r0,[r1,128h]  ;siocnt    ;\
  orr   r0,r0,80h                ; activate slave transfer
  str   r0,[r1,128h]  ;siocnt    ;/
 @@wait:                         ;\
  ldr   r0,[r1,128h]  ;siocnt    ; wait until transfer completed
  tst   r0,80h                   ;
  bne   @@wait                   ;/
  ldr   r0,[r1,120h]  ;siodata32 ;-get received data
  bx    lr
 ;---
 msg_boot dcb 'BOOT'     ;\
 msg_okay dcb "OKAY"     ; ID codes for the burstboot protocol
 msg_brst dcb "BRST"     ;/
 ;------------------
 download_rom_to_ram:
  mov  r0,8000000h  ;src/rom     ;\
  mov  r1,2000000h  ;dst/ram     ;
  mov  r2,40000h/16 ;length      ; transfer the ROM content
 @@lop:                          ; into RAM (done in units of 4 words/16 bytes)
  ldmia [r0]!,r4,r5,r6,r7        ; currently fills whole 256K of RAM,
  stmia [r1]!,r4,r5,r6,r7        ; even though the proggy is smaller
  subs  r2,r2,1                  ;
  bne   @@lop                    ;/
  sub   r15,lr,8000000h-2000000h ;-return (retadr rom/8000XXXh -> ram/2000XXXh)
 ;------------------
 init_interrupts:
  mov  r4,4000000h               ;-base address for below I/O registers
  ldr  r0,=irq_handler           ;\install IRQ handler address
  str  r0,[r4,-4]   ;IRQ HANDLER ;/at 3FFFFFC aka 3007FFC
  mov  r0,0008h                  ;\enable generating vblank irqs
  strh r0,[r4,4h]   ;DISPSTAT    ;/
  mrs  r0,cpsr                   ;\
  bic  r0,r0,80h                 ; cpu interrupt enable (clear i-flag)
  msr  cpsr,r0                   ;/
  mov  r0,0                      ;\
  str  r0,[r4,134h] ;RCNT        ; init SIO normal mode, external clock,
  ldr  r0,=5080h                 ; 32bit, IRQ enable, transfer started
  str  r0,[r4,128h] ;SIOCNT      ; output "BOOT" (indicate burst boot prepared)
  ldr  r0,[msg_boot]             ;
  str  r0,[r4,120h] ;SIODATA32   ;/
  mov  r0,1                      ;\interrupt master enable
  str  r0,[r4,208h] ;IME=1       ;/
  mov  r0,81h                    ;\enable execution of vblank IRQs,
  str  r0,[r4,200h] ;IE=81h      ;/and of SIO IRQs (burst boot)
  bx   lr
 ;------------------
 rom_start:   ;entry point when booted from flashcart/rom
  bl   download_rom_to_ram       ;-download ROM to RAM (returns to ram_start)
 ram_start:   ;entry point for multiboot/burstboot
  mov  r0,0feh                   ;\reset all registers, and clear all memory
  swi  10000h ;RegisterRamReset  ;/(except program code in wram at 2000000h)
  bl   init_interrupts           ;-install burst boot irq handler
  mov  r4,4000000h               ;\enable video,
  strh r4,[r4,000h] ;DISPCNT     ;/by clearing the forced blank bit
 @@mainloop:
  swi  50000h ;VBlankIntrWait    ;-wait one frame (cpu in low power mode)
  mov  r5,5000000h               ;\increment the backdrop palette color
  str  r8,[r5]                   ; (ie. display a blinking screen)
  add  r8,r8,1                   ;/
  b    @@mainloop
 ;------------------
 .pool
 end
```




# <a name="aboutthisdocument"></a>About this Document




## About


GBATEK written 2001-2014 by Martin Korth, programming specs for the GBA and NDS
hardware, I've been trying to keep the specs both as short as possible, and as
complete as possible. The document is part of the no$gba debuggers built-in
help text.



## Updates


The standalone docs in TXT and HTM format are updated when having added any
major changes to the document. The no$gba built-in version will be updated more
regularly, including for minor changes, along with all no$gba updates.



## Homepage


- [http://problemkaputt.de/gba.htm](http://problemkaputt.de/gba.htm) - no$gba emulator homepage (freeware)

- [http://problemkaputt.de/gba-dev.htm](http://problemkaputt.de/gba-dev.htm) - no$gba debugger homepage

- [http://problemkaputt.de/gbapics.htm](http://problemkaputt.de/gbapics.htm) - no$gba debugger screenshots

- [http://problemkaputt.de/gbatek.htm](http://problemkaputt.de/gbatek.htm) - gbatek html version

- [http://problemkaputt.de/gbatek.txt](http://problemkaputt.de/gbatek.txt) - gbatek text version



## Feedback


If you find any information in this document to be misleading, incomplete, or
incorrect, please say something! My spam-shielded email address is found at:

- [http://problemkaputt.de/email.htm](http://problemkaputt.de/email.htm) - contact

Mail from programmers only, please. No gaming questions, thanks.



## Credits


Thanks for GBATEK fixes, and for info about GBA and NDS hardware,

- Jasper Vijn

- Remi Veilleux (DS video details)

- Randy Linden

- Sebastian Rasmussen

- Stephen Stair (DS Wifi)

- Cue (DS Firmware bits and bytes)

- Tim Seidel (DS Wifi RF2958 datasheet)

- Damien Good (DS Bios Dumping, and lots of e-Reader info)

- Kenobi and Dualscreenman (lots of ARDS/CBDS cheat info)

- Flubba (GBA X/Y-Axis tilt sensor, and GBA Gameboy Player info)

- DarkFader (DS Key2)

- Dstek by neimod (DS Sound)

- Christian Auby

- Jeff Frohwein

- NDSTech Wiki, 
- [http://www.bottledlight.com/ds/](http://www.bottledlight.com/ds/) (lots of DS info)

- wwylele (xpertteak cpu and mmio findings)



## Formatting


TXT is 80 columns, TXT is 80 columns, TXT is 80 columns.

Don't trust anything else. Never.





